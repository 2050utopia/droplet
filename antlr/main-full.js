(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.antlr = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated from C.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\2s\u04e7\b\1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t",
    "\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20",
    "\t\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4",
    "\27\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35",
    "\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'",
    "\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61",
    "\t\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\4",
    "8\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C",
    "\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\t",
    "N\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY",
    "\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\t",
    "d\4e\te\4f\tf\4g\tg\4h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to",
    "\4p\tp\4q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4z\tz\4",
    "{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080\4\u0081\t\u0081\4",
    "\u0082\t\u0082\4\u0083\t\u0083\4\u0084\t\u0084\4\u0085\t\u0085\4\u0086",
    "\t\u0086\4\u0087\t\u0087\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a",
    "\4\u008b\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e\4\u008f",
    "\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092\t\u0092\4\u0093\t\u0093",
    "\4\u0094\t\u0094\4\u0095\t\u0095\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098",
    "\t\u0098\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\3",
    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\4",
    "\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4",
    "\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\7",
    "\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b",
    "\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n",
    "\3\n\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3",
    "\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r",
    "\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\17\3",
    "\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20",
    "\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3",
    "\22\3\23\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\25\3\25",
    "\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3\26\3\26\3",
    "\26\3\26\3\27\3\27\3\27\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\31\3\31",
    "\3\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\33\3\33\3\33\3\33\3\33\3",
    "\33\3\33\3\34\3\34\3\34\3\34\3\34\3\34\3\35\3\35\3\35\3\35\3\36\3\36",
    "\3\36\3\36\3\36\3\37\3\37\3\37\3 \3 \3 \3 \3 \3 \3 \3!\3!\3!\3!\3\"",
    "\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3$\3$\3$\3$\3$\3$\3$\3$",
    "\3$\3%\3%\3%\3%\3%\3%\3%\3&\3&\3&\3&\3&\3&\3\'\3\'\3\'\3\'\3\'\3\'\3",
    "\'\3(\3(\3(\3(\3(\3(\3(\3)\3)\3)\3)\3)\3)\3)\3*\3*\3*\3*\3*\3*\3*\3",
    "+\3+\3+\3+\3+\3+\3+\3,\3,\3,\3,\3,\3,\3,\3,\3-\3-\3-\3-\3-\3-\3.\3.",
    "\3.\3.\3.\3.\3.\3.\3.\3/\3/\3/\3/\3/\3\60\3\60\3\60\3\60\3\60\3\60\3",
    "\60\3\60\3\60\3\61\3\61\3\61\3\61\3\61\3\61\3\62\3\62\3\62\3\62\3\62",
    "\3\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3",
    "\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\65\3\65\3\65\3\65\3\65\3\65",
    "\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\67\3\67\3\67\3\67\3",
    "\67\3\67\3\67\3\67\3\67\38\38\38\38\38\38\38\38\38\38\38\39\39\39\3",
    "9\39\39\39\39\39\39\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3:\3;",
    "\3;\3;\3;\3;\3;\3;\3;\3;\3;\3;\3;\3;\3;\3<\3<\3=\3=\3>\3>\3?\3?\3@\3",
    "@\3A\3A\3B\3B\3C\3C\3C\3D\3D\3E\3E\3E\3F\3F\3F\3G\3G\3G\3H\3H\3I\3I",
    "\3I\3J\3J\3K\3K\3K\3L\3L\3M\3M\3N\3N\3O\3O\3P\3P\3Q\3Q\3Q\3R\3R\3R\3",
    "S\3S\3T\3T\3U\3U\3V\3V\3W\3W\3X\3X\3Y\3Y\3Z\3Z\3[\3[\3[\3\\\3\\\3\\",
    "\3]\3]\3]\3^\3^\3^\3_\3_\3_\3`\3`\3`\3`\3a\3a\3a\3a\3b\3b\3b\3c\3c\3",
    "c\3d\3d\3d\3e\3e\3e\3f\3f\3f\3g\3g\3g\3h\3h\3i\3i\3i\3i\3j\3j\3j\7j",
    "\u0381\nj\fj\16j\u0384\13j\3k\3k\5k\u0388\nk\3l\3l\3m\3m\3n\3n\3n\3",
    "n\3n\3n\3n\3n\3n\3n\5n\u0398\nn\3o\3o\3o\3o\3o\3p\3p\3p\5p\u03a2\np",
    "\3q\3q\5q\u03a6\nq\3q\3q\5q\u03aa\nq\3q\3q\5q\u03ae\nq\5q\u03b0\nq\3",
    "r\3r\7r\u03b4\nr\fr\16r\u03b7\13r\3s\3s\7s\u03bb\ns\fs\16s\u03be\13",
    "s\3t\3t\6t\u03c2\nt\rt\16t\u03c3\3u\3u\3u\3v\3v\3w\3w\3x\3x\3y\3y\5",
    "y\u03d1\ny\3y\3y\3y\3y\3y\5y\u03d8\ny\3y\3y\5y\u03dc\ny\5y\u03de\ny",
    "\3z\3z\3{\3{\3|\3|\3|\3|\5|\u03e8\n|\3}\3}\5}\u03ec\n}\3~\3~\5~\u03f0",
    "\n~\3~\5~\u03f3\n~\3~\3~\3~\5~\u03f8\n~\5~\u03fa\n~\3\177\3\177\3\177",
    "\3\177\5\177\u0400\n\177\3\177\3\177\3\177\3\177\5\177\u0406\n\177\5",
    "\177\u0408\n\177\3\u0080\5\u0080\u040b\n\u0080\3\u0080\3\u0080\3\u0080",
    "\3\u0080\3\u0080\5\u0080\u0412\n\u0080\3\u0081\3\u0081\5\u0081\u0416",
    "\n\u0081\3\u0081\3\u0081\3\u0081\5\u0081\u041b\n\u0081\3\u0081\5\u0081",
    "\u041e\n\u0081\3\u0082\3\u0082\3\u0083\6\u0083\u0423\n\u0083\r\u0083",
    "\16\u0083\u0424\3\u0084\5\u0084\u0428\n\u0084\3\u0084\3\u0084\3\u0084",
    "\3\u0084\3\u0084\5\u0084\u042f\n\u0084\3\u0085\3\u0085\5\u0085\u0433",
    "\n\u0085\3\u0085\3\u0085\3\u0085\5\u0085\u0438\n\u0085\3\u0085\5\u0085",
    "\u043b\n\u0085\3\u0086\6\u0086\u043e\n\u0086\r\u0086\16\u0086\u043f",
    "\3\u0087\3\u0087\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088",
    "\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088",
    "\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\5\u0088\u045a\n\u0088",
    "\3\u0089\6\u0089\u045d\n\u0089\r\u0089\16\u0089\u045e\3\u008a\3\u008a",
    "\5\u008a\u0463\n\u008a\3\u008b\3\u008b\3\u008b\3\u008b\5\u008b\u0469",
    "\n\u008b\3\u008c\3\u008c\3\u008c\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d",
    "\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d\5\u008d\u0479\n\u008d",
    "\3\u008e\3\u008e\3\u008e\3\u008e\6\u008e\u047f\n\u008e\r\u008e\16\u008e",
    "\u0480\3\u008f\5\u008f\u0484\n\u008f\3\u008f\3\u008f\5\u008f\u0488\n",
    "\u008f\3\u008f\3\u008f\3\u0090\3\u0090\3\u0090\5\u0090\u048f\n\u0090",
    "\3\u0091\6\u0091\u0492\n\u0091\r\u0091\16\u0091\u0493\3\u0092\3\u0092",
    "\5\u0092\u0498\n\u0092\3\u0093\3\u0093\5\u0093\u049c\n\u0093\3\u0093",
    "\3\u0093\5\u0093\u04a0\n\u0093\3\u0093\3\u0093\7\u0093\u04a4\n\u0093",
    "\f\u0093\16\u0093\u04a7\13\u0093\3\u0093\3\u0093\3\u0094\3\u0094\5\u0094",
    "\u04ad\n\u0094\3\u0094\3\u0094\3\u0094\3\u0094\3\u0094\3\u0094\3\u0094",
    "\3\u0094\3\u0094\7\u0094\u04b8\n\u0094\f\u0094\16\u0094\u04bb\13\u0094",
    "\3\u0094\3\u0094\3\u0095\6\u0095\u04c0\n\u0095\r\u0095\16\u0095\u04c1",
    "\3\u0095\3\u0095\3\u0096\3\u0096\5\u0096\u04c8\n\u0096\3\u0096\5\u0096",
    "\u04cb\n\u0096\3\u0096\3\u0096\3\u0097\3\u0097\3\u0097\3\u0097\7\u0097",
    "\u04d3\n\u0097\f\u0097\16\u0097\u04d6\13\u0097\3\u0097\3\u0097\3\u0097",
    "\3\u0097\3\u0097\3\u0098\3\u0098\3\u0098\3\u0098\7\u0098\u04e1\n\u0098",
    "\f\u0098\16\u0098\u04e4\13\u0098\3\u0098\3\u0098\3\u04d4\2\u0099\3\3",
    "\5\4\7\5\t\6\13\7\r\b\17\t\21\n\23\13\25\f\27\r\31\16\33\17\35\20\37",
    "\21!\22#\23%\24\'\25)\26+\27-\30/\31\61\32\63\33\65\34\67\359\36;\37",
    "= ?!A\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]\60_\61a\62c\63e\64g\65i\66k\67m",
    "8o9q:s;u<w=y>{?}@\177A\u0081B\u0083C\u0085D\u0087E\u0089F\u008bG\u008d",
    "H\u008fI\u0091J\u0093K\u0095L\u0097M\u0099N\u009bO\u009dP\u009fQ\u00a1",
    "R\u00a3S\u00a5T\u00a7U\u00a9V\u00abW\u00adX\u00afY\u00b1Z\u00b3[\u00b5",
    "\\\u00b7]\u00b9^\u00bb_\u00bd`\u00bfa\u00c1b\u00c3c\u00c5d\u00c7e\u00c9",
    "f\u00cbg\u00cdh\u00cfi\u00d1j\u00d3k\u00d5\2\u00d7\2\u00d9\2\u00db\2",
    "\u00dd\2\u00dfl\u00e1\2\u00e3\2\u00e5\2\u00e7\2\u00e9\2\u00eb\2\u00ed",
    "\2\u00ef\2\u00f1\2\u00f3\2\u00f5\2\u00f7\2\u00f9\2\u00fb\2\u00fd\2\u00ff",
    "\2\u0101\2\u0103\2\u0105\2\u0107\2\u0109\2\u010b\2\u010d\2\u010f\2\u0111",
    "\2\u0113\2\u0115\2\u0117\2\u0119\2\u011b\2\u011dm\u011f\2\u0121\2\u0123",
    "\2\u0125n\u0127o\u0129p\u012bq\u012dr\u012fs\3\2\22\5\2C\\aac|\3\2\62",
    ";\4\2ZZzz\3\2\63;\3\2\629\5\2\62;CHch\4\2WWww\4\2NNnn\4\2--//\6\2HH",
    "NNhhnn\6\2\f\f\17\17))^^\f\2$$))AA^^cdhhppttvvxx\5\2NNWWww\6\2\f\f\17",
    "\17$$^^\4\2\f\f\17\17\4\2\13\13\"\"\u0503\2\3\3\2\2\2\2\5\3\2\2\2\2",
    "\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2\2\2\17\3\2\2\2\2\21\3",
    "\2\2\2\2\23\3\2\2\2\2\25\3\2\2\2\2\27\3\2\2\2\2\31\3\2\2\2\2\33\3\2",
    "\2\2\2\35\3\2\2\2\2\37\3\2\2\2\2!\3\2\2\2\2#\3\2\2\2\2%\3\2\2\2\2\'",
    "\3\2\2\2\2)\3\2\2\2\2+\3\2\2\2\2-\3\2\2\2\2/\3\2\2\2\2\61\3\2\2\2\2",
    "\63\3\2\2\2\2\65\3\2\2\2\2\67\3\2\2\2\29\3\2\2\2\2;\3\2\2\2\2=\3\2\2",
    "\2\2?\3\2\2\2\2A\3\2\2\2\2C\3\2\2\2\2E\3\2\2\2\2G\3\2\2\2\2I\3\2\2\2",
    "\2K\3\2\2\2\2M\3\2\2\2\2O\3\2\2\2\2Q\3\2\2\2\2S\3\2\2\2\2U\3\2\2\2\2",
    "W\3\2\2\2\2Y\3\2\2\2\2[\3\2\2\2\2]\3\2\2\2\2_\3\2\2\2\2a\3\2\2\2\2c",
    "\3\2\2\2\2e\3\2\2\2\2g\3\2\2\2\2i\3\2\2\2\2k\3\2\2\2\2m\3\2\2\2\2o\3",
    "\2\2\2\2q\3\2\2\2\2s\3\2\2\2\2u\3\2\2\2\2w\3\2\2\2\2y\3\2\2\2\2{\3\2",
    "\2\2\2}\3\2\2\2\2\177\3\2\2\2\2\u0081\3\2\2\2\2\u0083\3\2\2\2\2\u0085",
    "\3\2\2\2\2\u0087\3\2\2\2\2\u0089\3\2\2\2\2\u008b\3\2\2\2\2\u008d\3\2",
    "\2\2\2\u008f\3\2\2\2\2\u0091\3\2\2\2\2\u0093\3\2\2\2\2\u0095\3\2\2\2",
    "\2\u0097\3\2\2\2\2\u0099\3\2\2\2\2\u009b\3\2\2\2\2\u009d\3\2\2\2\2\u009f",
    "\3\2\2\2\2\u00a1\3\2\2\2\2\u00a3\3\2\2\2\2\u00a5\3\2\2\2\2\u00a7\3\2",
    "\2\2\2\u00a9\3\2\2\2\2\u00ab\3\2\2\2\2\u00ad\3\2\2\2\2\u00af\3\2\2\2",
    "\2\u00b1\3\2\2\2\2\u00b3\3\2\2\2\2\u00b5\3\2\2\2\2\u00b7\3\2\2\2\2\u00b9",
    "\3\2\2\2\2\u00bb\3\2\2\2\2\u00bd\3\2\2\2\2\u00bf\3\2\2\2\2\u00c1\3\2",
    "\2\2\2\u00c3\3\2\2\2\2\u00c5\3\2\2\2\2\u00c7\3\2\2\2\2\u00c9\3\2\2\2",
    "\2\u00cb\3\2\2\2\2\u00cd\3\2\2\2\2\u00cf\3\2\2\2\2\u00d1\3\2\2\2\2\u00d3",
    "\3\2\2\2\2\u00df\3\2\2\2\2\u011d\3\2\2\2\2\u0125\3\2\2\2\2\u0127\3\2",
    "\2\2\2\u0129\3\2\2\2\2\u012b\3\2\2\2\2\u012d\3\2\2\2\2\u012f\3\2\2\2",
    "\3\u0131\3\2\2\2\5\u013f\3\2\2\2\7\u0150\3\2\2\2\t\u0163\3\2\2\2\13",
    "\u016a\3\2\2\2\r\u0172\3\2\2\2\17\u017a\3\2\2\2\21\u0185\3\2\2\2\23",
    "\u0190\3\2\2\2\25\u019a\3\2\2\2\27\u01a5\3\2\2\2\31\u01ab\3\2\2\2\33",
    "\u01b9\3\2\2\2\35\u01c1\3\2\2\2\37\u01ce\3\2\2\2!\u01d3\3\2\2\2#\u01d9",
    "\3\2\2\2%\u01de\3\2\2\2\'\u01e3\3\2\2\2)\u01e9\3\2\2\2+\u01f2\3\2\2",
    "\2-\u01fa\3\2\2\2/\u01fd\3\2\2\2\61\u0204\3\2\2\2\63\u0209\3\2\2\2\65",
    "\u020e\3\2\2\2\67\u0215\3\2\2\29\u021b\3\2\2\2;\u021f\3\2\2\2=\u0224",
    "\3\2\2\2?\u0227\3\2\2\2A\u022e\3\2\2\2C\u0232\3\2\2\2E\u0237\3\2\2\2",
    "G\u0240\3\2\2\2I\u0249\3\2\2\2K\u0250\3\2\2\2M\u0256\3\2\2\2O\u025d",
    "\3\2\2\2Q\u0264\3\2\2\2S\u026b\3\2\2\2U\u0272\3\2\2\2W\u0279\3\2\2\2",
    "Y\u0281\3\2\2\2[\u0287\3\2\2\2]\u0290\3\2\2\2_\u0295\3\2\2\2a\u029e",
    "\3\2\2\2c\u02a4\3\2\2\2e\u02ad\3\2\2\2g\u02b6\3\2\2\2i\u02be\3\2\2\2",
    "k\u02c4\3\2\2\2m\u02cd\3\2\2\2o\u02d6\3\2\2\2q\u02e1\3\2\2\2s\u02eb",
    "\3\2\2\2u\u02fa\3\2\2\2w\u0308\3\2\2\2y\u030a\3\2\2\2{\u030c\3\2\2\2",
    "}\u030e\3\2\2\2\177\u0310\3\2\2\2\u0081\u0312\3\2\2\2\u0083\u0314\3",
    "\2\2\2\u0085\u0316\3\2\2\2\u0087\u0319\3\2\2\2\u0089\u031b\3\2\2\2\u008b",
    "\u031e\3\2\2\2\u008d\u0321\3\2\2\2\u008f\u0324\3\2\2\2\u0091\u0326\3",
    "\2\2\2\u0093\u0329\3\2\2\2\u0095\u032b\3\2\2\2\u0097\u032e\3\2\2\2\u0099",
    "\u0330\3\2\2\2\u009b\u0332\3\2\2\2\u009d\u0334\3\2\2\2\u009f\u0336\3",
    "\2\2\2\u00a1\u0338\3\2\2\2\u00a3\u033b\3\2\2\2\u00a5\u033e\3\2\2\2\u00a7",
    "\u0340\3\2\2\2\u00a9\u0342\3\2\2\2\u00ab\u0344\3\2\2\2\u00ad\u0346\3",
    "\2\2\2\u00af\u0348\3\2\2\2\u00b1\u034a\3\2\2\2\u00b3\u034c\3\2\2\2\u00b5",
    "\u034e\3\2\2\2\u00b7\u0351\3\2\2\2\u00b9\u0354\3\2\2\2\u00bb\u0357\3",
    "\2\2\2\u00bd\u035a\3\2\2\2\u00bf\u035d\3\2\2\2\u00c1\u0361\3\2\2\2\u00c3",
    "\u0365\3\2\2\2\u00c5\u0368\3\2\2\2\u00c7\u036b\3\2\2\2\u00c9\u036e\3",
    "\2\2\2\u00cb\u0371\3\2\2\2\u00cd\u0374\3\2\2\2\u00cf\u0377\3\2\2\2\u00d1",
    "\u0379\3\2\2\2\u00d3\u037d\3\2\2\2\u00d5\u0387\3\2\2\2\u00d7\u0389\3",
    "\2\2\2\u00d9\u038b\3\2\2\2\u00db\u0397\3\2\2\2\u00dd\u0399\3\2\2\2\u00df",
    "\u03a1\3\2\2\2\u00e1\u03af\3\2\2\2\u00e3\u03b1\3\2\2\2\u00e5\u03b8\3",
    "\2\2\2\u00e7\u03bf\3\2\2\2\u00e9\u03c5\3\2\2\2\u00eb\u03c8\3\2\2\2\u00ed",
    "\u03ca\3\2\2\2\u00ef\u03cc\3\2\2\2\u00f1\u03dd\3\2\2\2\u00f3\u03df\3",
    "\2\2\2\u00f5\u03e1\3\2\2\2\u00f7\u03e7\3\2\2\2\u00f9\u03eb\3\2\2\2\u00fb",
    "\u03f9\3\2\2\2\u00fd\u0407\3\2\2\2\u00ff\u0411\3\2\2\2\u0101\u041d\3",
    "\2\2\2\u0103\u041f\3\2\2\2\u0105\u0422\3\2\2\2\u0107\u042e\3\2\2\2\u0109",
    "\u043a\3\2\2\2\u010b\u043d\3\2\2\2\u010d\u0441\3\2\2\2\u010f\u0459\3",
    "\2\2\2\u0111\u045c\3\2\2\2\u0113\u0462\3\2\2\2\u0115\u0468\3\2\2\2\u0117",
    "\u046a\3\2\2\2\u0119\u0478\3\2\2\2\u011b\u047a\3\2\2\2\u011d\u0483\3",
    "\2\2\2\u011f\u048e\3\2\2\2\u0121\u0491\3\2\2\2\u0123\u0497\3\2\2\2\u0125",
    "\u0499\3\2\2\2\u0127\u04aa\3\2\2\2\u0129\u04bf\3\2\2\2\u012b\u04ca\3",
    "\2\2\2\u012d\u04ce\3\2\2\2\u012f\u04dc\3\2\2\2\u0131\u0132\7a\2\2\u0132",
    "\u0133\7a\2\2\u0133\u0134\7g\2\2\u0134\u0135\7z\2\2\u0135\u0136\7v\2",
    "\2\u0136\u0137\7g\2\2\u0137\u0138\7p\2\2\u0138\u0139\7u\2\2\u0139\u013a",
    "\7k\2\2\u013a\u013b\7q\2\2\u013b\u013c\7p\2\2\u013c\u013d\7a\2\2\u013d",
    "\u013e\7a\2\2\u013e\4\3\2\2\2\u013f\u0140\7a\2\2\u0140\u0141\7a\2\2",
    "\u0141\u0142\7d\2\2\u0142\u0143\7w\2\2\u0143\u0144\7k\2\2\u0144\u0145",
    "\7n\2\2\u0145\u0146\7v\2\2\u0146\u0147\7k\2\2\u0147\u0148\7p\2\2\u0148",
    "\u0149\7a\2\2\u0149\u014a\7x\2\2\u014a\u014b\7c\2\2\u014b\u014c\7a\2",
    "\2\u014c\u014d\7c\2\2\u014d\u014e\7t\2\2\u014e\u014f\7i\2\2\u014f\6",
    "\3\2\2\2\u0150\u0151\7a\2\2\u0151\u0152\7a\2\2\u0152\u0153\7d\2\2\u0153",
    "\u0154\7w\2\2\u0154\u0155\7k\2\2\u0155\u0156\7n\2\2\u0156\u0157\7v\2",
    "\2\u0157\u0158\7k\2\2\u0158\u0159\7p\2\2\u0159\u015a\7a\2\2\u015a\u015b",
    "\7q\2\2\u015b\u015c\7h\2\2\u015c\u015d\7h\2\2\u015d\u015e\7u\2\2\u015e",
    "\u015f\7g\2\2\u015f\u0160\7v\2\2\u0160\u0161\7q\2\2\u0161\u0162\7h\2",
    "\2\u0162\b\3\2\2\2\u0163\u0164\7a\2\2\u0164\u0165\7a\2\2\u0165\u0166",
    "\7o\2\2\u0166\u0167\7\63\2\2\u0167\u0168\7\64\2\2\u0168\u0169\7:\2\2",
    "\u0169\n\3\2\2\2\u016a\u016b\7a\2\2\u016b\u016c\7a\2\2\u016c\u016d\7",
    "o\2\2\u016d\u016e\7\63\2\2\u016e\u016f\7\64\2\2\u016f\u0170\7:\2\2\u0170",
    "\u0171\7f\2\2\u0171\f\3\2\2\2\u0172\u0173\7a\2\2\u0173\u0174\7a\2\2",
    "\u0174\u0175\7o\2\2\u0175\u0176\7\63\2\2\u0176\u0177\7\64\2\2\u0177",
    "\u0178\7:\2\2\u0178\u0179\7k\2\2\u0179\16\3\2\2\2\u017a\u017b\7a\2\2",
    "\u017b\u017c\7a\2\2\u017c\u017d\7v\2\2\u017d\u017e\7{\2\2\u017e\u017f",
    "\7r\2\2\u017f\u0180\7g\2\2\u0180\u0181\7q\2\2\u0181\u0182\7h\2\2\u0182",
    "\u0183\7a\2\2\u0183\u0184\7a\2\2\u0184\20\3\2\2\2\u0185\u0186\7a\2\2",
    "\u0186\u0187\7a\2\2\u0187\u0188\7k\2\2\u0188\u0189\7p\2\2\u0189\u018a",
    "\7n\2\2\u018a\u018b\7k\2\2\u018b\u018c\7p\2\2\u018c\u018d\7g\2\2\u018d",
    "\u018e\7a\2\2\u018e\u018f\7a\2\2\u018f\22\3\2\2\2\u0190\u0191\7a\2\2",
    "\u0191\u0192\7a\2\2\u0192\u0193\7u\2\2\u0193\u0194\7v\2\2\u0194\u0195",
    "\7f\2\2\u0195\u0196\7e\2\2\u0196\u0197\7c\2\2\u0197\u0198\7n\2\2\u0198",
    "\u0199\7n\2\2\u0199\24\3\2\2\2\u019a\u019b\7a\2\2\u019b\u019c\7a\2\2",
    "\u019c\u019d\7f\2\2\u019d\u019e\7g\2\2\u019e\u019f\7e\2\2\u019f\u01a0",
    "\7n\2\2\u01a0\u01a1\7u\2\2\u01a1\u01a2\7r\2\2\u01a2\u01a3\7g\2\2\u01a3",
    "\u01a4\7e\2\2\u01a4\26\3\2\2\2\u01a5\u01a6\7a\2\2\u01a6\u01a7\7a\2\2",
    "\u01a7\u01a8\7c\2\2\u01a8\u01a9\7u\2\2\u01a9\u01aa\7o\2\2\u01aa\30\3",
    "\2\2\2\u01ab\u01ac\7a\2\2\u01ac\u01ad\7a\2\2\u01ad\u01ae\7c\2\2\u01ae",
    "\u01af\7v\2\2\u01af\u01b0\7v\2\2\u01b0\u01b1\7t\2\2\u01b1\u01b2\7k\2",
    "\2\u01b2\u01b3\7d\2\2\u01b3\u01b4\7w\2\2\u01b4\u01b5\7v\2\2\u01b5\u01b6",
    "\7g\2\2\u01b6\u01b7\7a\2\2\u01b7\u01b8\7a\2\2\u01b8\32\3\2\2\2\u01b9",
    "\u01ba\7a\2\2\u01ba\u01bb\7a\2\2\u01bb\u01bc\7c\2\2\u01bc\u01bd\7u\2",
    "\2\u01bd\u01be\7o\2\2\u01be\u01bf\7a\2\2\u01bf\u01c0\7a\2\2\u01c0\34",
    "\3\2\2\2\u01c1\u01c2\7a\2\2\u01c2\u01c3\7a\2\2\u01c3\u01c4\7x\2\2\u01c4",
    "\u01c5\7q\2\2\u01c5\u01c6\7n\2\2\u01c6\u01c7\7c\2\2\u01c7\u01c8\7v\2",
    "\2\u01c8\u01c9\7k\2\2\u01c9\u01ca\7n\2\2\u01ca\u01cb\7g\2\2\u01cb\u01cc",
    "\7a\2\2\u01cc\u01cd\7a\2\2\u01cd\36\3\2\2\2\u01ce\u01cf\7c\2\2\u01cf",
    "\u01d0\7w\2\2\u01d0\u01d1\7v\2\2\u01d1\u01d2\7q\2\2\u01d2 \3\2\2\2\u01d3",
    "\u01d4\7d\2\2\u01d4\u01d5\7t\2\2\u01d5\u01d6\7g\2\2\u01d6\u01d7\7c\2",
    "\2\u01d7\u01d8\7m\2\2\u01d8\"\3\2\2\2\u01d9\u01da\7e\2\2\u01da\u01db",
    "\7c\2\2\u01db\u01dc\7u\2\2\u01dc\u01dd\7g\2\2\u01dd$\3\2\2\2\u01de\u01df",
    "\7e\2\2\u01df\u01e0\7j\2\2\u01e0\u01e1\7c\2\2\u01e1\u01e2\7t\2\2\u01e2",
    "&\3\2\2\2\u01e3\u01e4\7e\2\2\u01e4\u01e5\7q\2\2\u01e5\u01e6\7p\2\2\u01e6",
    "\u01e7\7u\2\2\u01e7\u01e8\7v\2\2\u01e8(\3\2\2\2\u01e9\u01ea\7e\2\2\u01ea",
    "\u01eb\7q\2\2\u01eb\u01ec\7p\2\2\u01ec\u01ed\7v\2\2\u01ed\u01ee\7k\2",
    "\2\u01ee\u01ef\7p\2\2\u01ef\u01f0\7w\2\2\u01f0\u01f1\7g\2\2\u01f1*\3",
    "\2\2\2\u01f2\u01f3\7f\2\2\u01f3\u01f4\7g\2\2\u01f4\u01f5\7h\2\2\u01f5",
    "\u01f6\7c\2\2\u01f6\u01f7\7w\2\2\u01f7\u01f8\7n\2\2\u01f8\u01f9\7v\2",
    "\2\u01f9,\3\2\2\2\u01fa\u01fb\7f\2\2\u01fb\u01fc\7q\2\2\u01fc.\3\2\2",
    "\2\u01fd\u01fe\7f\2\2\u01fe\u01ff\7q\2\2\u01ff\u0200\7w\2\2\u0200\u0201",
    "\7d\2\2\u0201\u0202\7n\2\2\u0202\u0203\7g\2\2\u0203\60\3\2\2\2\u0204",
    "\u0205\7g\2\2\u0205\u0206\7n\2\2\u0206\u0207\7u\2\2\u0207\u0208\7g\2",
    "\2\u0208\62\3\2\2\2\u0209\u020a\7g\2\2\u020a\u020b\7p\2\2\u020b\u020c",
    "\7w\2\2\u020c\u020d\7o\2\2\u020d\64\3\2\2\2\u020e\u020f\7g\2\2\u020f",
    "\u0210\7z\2\2\u0210\u0211\7v\2\2\u0211\u0212\7g\2\2\u0212\u0213\7t\2",
    "\2\u0213\u0214\7p\2\2\u0214\66\3\2\2\2\u0215\u0216\7h\2\2\u0216\u0217",
    "\7n\2\2\u0217\u0218\7q\2\2\u0218\u0219\7c\2\2\u0219\u021a\7v\2\2\u021a",
    "8\3\2\2\2\u021b\u021c\7h\2\2\u021c\u021d\7q\2\2\u021d\u021e\7t\2\2\u021e",
    ":\3\2\2\2\u021f\u0220\7i\2\2\u0220\u0221\7q\2\2\u0221\u0222\7v\2\2\u0222",
    "\u0223\7q\2\2\u0223<\3\2\2\2\u0224\u0225\7k\2\2\u0225\u0226\7h\2\2\u0226",
    ">\3\2\2\2\u0227\u0228\7k\2\2\u0228\u0229\7p\2\2\u0229\u022a\7n\2\2\u022a",
    "\u022b\7k\2\2\u022b\u022c\7p\2\2\u022c\u022d\7g\2\2\u022d@\3\2\2\2\u022e",
    "\u022f\7k\2\2\u022f\u0230\7p\2\2\u0230\u0231\7v\2\2\u0231B\3\2\2\2\u0232",
    "\u0233\7n\2\2\u0233\u0234\7q\2\2\u0234\u0235\7p\2\2\u0235\u0236\7i\2",
    "\2\u0236D\3\2\2\2\u0237\u0238\7t\2\2\u0238\u0239\7g\2\2\u0239\u023a",
    "\7i\2\2\u023a\u023b\7k\2\2\u023b\u023c\7u\2\2\u023c\u023d\7v\2\2\u023d",
    "\u023e\7g\2\2\u023e\u023f\7t\2\2\u023fF\3\2\2\2\u0240\u0241\7t\2\2\u0241",
    "\u0242\7g\2\2\u0242\u0243\7u\2\2\u0243\u0244\7v\2\2\u0244\u0245\7t\2",
    "\2\u0245\u0246\7k\2\2\u0246\u0247\7e\2\2\u0247\u0248\7v\2\2\u0248H\3",
    "\2\2\2\u0249\u024a\7t\2\2\u024a\u024b\7g\2\2\u024b\u024c\7v\2\2\u024c",
    "\u024d\7w\2\2\u024d\u024e\7t\2\2\u024e\u024f\7p\2\2\u024fJ\3\2\2\2\u0250",
    "\u0251\7u\2\2\u0251\u0252\7j\2\2\u0252\u0253\7q\2\2\u0253\u0254\7t\2",
    "\2\u0254\u0255\7v\2\2\u0255L\3\2\2\2\u0256\u0257\7u\2\2\u0257\u0258",
    "\7k\2\2\u0258\u0259\7i\2\2\u0259\u025a\7p\2\2\u025a\u025b\7g\2\2\u025b",
    "\u025c\7f\2\2\u025cN\3\2\2\2\u025d\u025e\7u\2\2\u025e\u025f\7k\2\2\u025f",
    "\u0260\7|\2\2\u0260\u0261\7g\2\2\u0261\u0262\7q\2\2\u0262\u0263\7h\2",
    "\2\u0263P\3\2\2\2\u0264\u0265\7u\2\2\u0265\u0266\7v\2\2\u0266\u0267",
    "\7c\2\2\u0267\u0268\7v\2\2\u0268\u0269\7k\2\2\u0269\u026a\7e\2\2\u026a",
    "R\3\2\2\2\u026b\u026c\7u\2\2\u026c\u026d\7v\2\2\u026d\u026e\7t\2\2\u026e",
    "\u026f\7w\2\2\u026f\u0270\7e\2\2\u0270\u0271\7v\2\2\u0271T\3\2\2\2\u0272",
    "\u0273\7u\2\2\u0273\u0274\7y\2\2\u0274\u0275\7k\2\2\u0275\u0276\7v\2",
    "\2\u0276\u0277\7e\2\2\u0277\u0278\7j\2\2\u0278V\3\2\2\2\u0279\u027a",
    "\7v\2\2\u027a\u027b\7{\2\2\u027b\u027c\7r\2\2\u027c\u027d\7g\2\2\u027d",
    "\u027e\7f\2\2\u027e\u027f\7g\2\2\u027f\u0280\7h\2\2\u0280X\3\2\2\2\u0281",
    "\u0282\7w\2\2\u0282\u0283\7p\2\2\u0283\u0284\7k\2\2\u0284\u0285\7q\2",
    "\2\u0285\u0286\7p\2\2\u0286Z\3\2\2\2\u0287\u0288\7w\2\2\u0288\u0289",
    "\7p\2\2\u0289\u028a\7u\2\2\u028a\u028b\7k\2\2\u028b\u028c\7i\2\2\u028c",
    "\u028d\7p\2\2\u028d\u028e\7g\2\2\u028e\u028f\7f\2\2\u028f\\\3\2\2\2",
    "\u0290\u0291\7x\2\2\u0291\u0292\7q\2\2\u0292\u0293\7k\2\2\u0293\u0294",
    "\7f\2\2\u0294^\3\2\2\2\u0295\u0296\7x\2\2\u0296\u0297\7q\2\2\u0297\u0298",
    "\7n\2\2\u0298\u0299\7c\2\2\u0299\u029a\7v\2\2\u029a\u029b\7k\2\2\u029b",
    "\u029c\7n\2\2\u029c\u029d\7g\2\2\u029d`\3\2\2\2\u029e\u029f\7y\2\2\u029f",
    "\u02a0\7j\2\2\u02a0\u02a1\7k\2\2\u02a1\u02a2\7n\2\2\u02a2\u02a3\7g\2",
    "\2\u02a3b\3\2\2\2\u02a4\u02a5\7a\2\2\u02a5\u02a6\7C\2\2\u02a6\u02a7",
    "\7n\2\2\u02a7\u02a8\7k\2\2\u02a8\u02a9\7i\2\2\u02a9\u02aa\7p\2\2\u02aa",
    "\u02ab\7c\2\2\u02ab\u02ac\7u\2\2\u02acd\3\2\2\2\u02ad\u02ae\7a\2\2\u02ae",
    "\u02af\7C\2\2\u02af\u02b0\7n\2\2\u02b0\u02b1\7k\2\2\u02b1\u02b2\7i\2",
    "\2\u02b2\u02b3\7p\2\2\u02b3\u02b4\7q\2\2\u02b4\u02b5\7h\2\2\u02b5f\3",
    "\2\2\2\u02b6\u02b7\7a\2\2\u02b7\u02b8\7C\2\2\u02b8\u02b9\7v\2\2\u02b9",
    "\u02ba\7q\2\2\u02ba\u02bb\7o\2\2\u02bb\u02bc\7k\2\2\u02bc\u02bd\7e\2",
    "\2\u02bdh\3\2\2\2\u02be\u02bf\7a\2\2\u02bf\u02c0\7D\2\2\u02c0\u02c1",
    "\7q\2\2\u02c1\u02c2\7q\2\2\u02c2\u02c3\7n\2\2\u02c3j\3\2\2\2\u02c4\u02c5",
    "\7a\2\2\u02c5\u02c6\7E\2\2\u02c6\u02c7\7q\2\2\u02c7\u02c8\7o\2\2\u02c8",
    "\u02c9\7r\2\2\u02c9\u02ca\7n\2\2\u02ca\u02cb\7g\2\2\u02cb\u02cc\7z\2",
    "\2\u02ccl\3\2\2\2\u02cd\u02ce\7a\2\2\u02ce\u02cf\7I\2\2\u02cf\u02d0",
    "\7g\2\2\u02d0\u02d1\7p\2\2\u02d1\u02d2\7g\2\2\u02d2\u02d3\7t\2\2\u02d3",
    "\u02d4\7k\2\2\u02d4\u02d5\7e\2\2\u02d5n\3\2\2\2\u02d6\u02d7\7a\2\2\u02d7",
    "\u02d8\7K\2\2\u02d8\u02d9\7o\2\2\u02d9\u02da\7c\2\2\u02da\u02db\7i\2",
    "\2\u02db\u02dc\7k\2\2\u02dc\u02dd\7p\2\2\u02dd\u02de\7c\2\2\u02de\u02df",
    "\7t\2\2\u02df\u02e0\7{\2\2\u02e0p\3\2\2\2\u02e1\u02e2\7a\2\2\u02e2\u02e3",
    "\7P\2\2\u02e3\u02e4\7q\2\2\u02e4\u02e5\7t\2\2\u02e5\u02e6\7g\2\2\u02e6",
    "\u02e7\7v\2\2\u02e7\u02e8\7w\2\2\u02e8\u02e9\7t\2\2\u02e9\u02ea\7p\2",
    "\2\u02ear\3\2\2\2\u02eb\u02ec\7a\2\2\u02ec\u02ed\7U\2\2\u02ed\u02ee",
    "\7v\2\2\u02ee\u02ef\7c\2\2\u02ef\u02f0\7v\2\2\u02f0\u02f1\7k\2\2\u02f1",
    "\u02f2\7e\2\2\u02f2\u02f3\7a\2\2\u02f3\u02f4\7c\2\2\u02f4\u02f5\7u\2",
    "\2\u02f5\u02f6\7u\2\2\u02f6\u02f7\7g\2\2\u02f7\u02f8\7t\2\2\u02f8\u02f9",
    "\7v\2\2\u02f9t\3\2\2\2\u02fa\u02fb\7a\2\2\u02fb\u02fc\7V\2\2\u02fc\u02fd",
    "\7j\2\2\u02fd\u02fe\7t\2\2\u02fe\u02ff\7g\2\2\u02ff\u0300\7c\2\2\u0300",
    "\u0301\7f\2\2\u0301\u0302\7a\2\2\u0302\u0303\7n\2\2\u0303\u0304\7q\2",
    "\2\u0304\u0305\7e\2\2\u0305\u0306\7c\2\2\u0306\u0307\7n\2\2\u0307v\3",
    "\2\2\2\u0308\u0309\7*\2\2\u0309x\3\2\2\2\u030a\u030b\7+\2\2\u030bz\3",
    "\2\2\2\u030c\u030d\7]\2\2\u030d|\3\2\2\2\u030e\u030f\7_\2\2\u030f~\3",
    "\2\2\2\u0310\u0311\7}\2\2\u0311\u0080\3\2\2\2\u0312\u0313\7\177\2\2",
    "\u0313\u0082\3\2\2\2\u0314\u0315\7>\2\2\u0315\u0084\3\2\2\2\u0316\u0317",
    "\7>\2\2\u0317\u0318\7?\2\2\u0318\u0086\3\2\2\2\u0319\u031a\7@\2\2\u031a",
    "\u0088\3\2\2\2\u031b\u031c\7@\2\2\u031c\u031d\7?\2\2\u031d\u008a\3\2",
    "\2\2\u031e\u031f\7>\2\2\u031f\u0320\7>\2\2\u0320\u008c\3\2\2\2\u0321",
    "\u0322\7@\2\2\u0322\u0323\7@\2\2\u0323\u008e\3\2\2\2\u0324\u0325\7-",
    "\2\2\u0325\u0090\3\2\2\2\u0326\u0327\7-\2\2\u0327\u0328\7-\2\2\u0328",
    "\u0092\3\2\2\2\u0329\u032a\7/\2\2\u032a\u0094\3\2\2\2\u032b\u032c\7",
    "/\2\2\u032c\u032d\7/\2\2\u032d\u0096\3\2\2\2\u032e\u032f\7,\2\2\u032f",
    "\u0098\3\2\2\2\u0330\u0331\7\61\2\2\u0331\u009a\3\2\2\2\u0332\u0333",
    "\7\'\2\2\u0333\u009c\3\2\2\2\u0334\u0335\7(\2\2\u0335\u009e\3\2\2\2",
    "\u0336\u0337\7~\2\2\u0337\u00a0\3\2\2\2\u0338\u0339\7(\2\2\u0339\u033a",
    "\7(\2\2\u033a\u00a2\3\2\2\2\u033b\u033c\7~\2\2\u033c\u033d\7~\2\2\u033d",
    "\u00a4\3\2\2\2\u033e\u033f\7`\2\2\u033f\u00a6\3\2\2\2\u0340\u0341\7",
    "#\2\2\u0341\u00a8\3\2\2\2\u0342\u0343\7\u0080\2\2\u0343\u00aa\3\2\2",
    "\2\u0344\u0345\7A\2\2\u0345\u00ac\3\2\2\2\u0346\u0347\7<\2\2\u0347\u00ae",
    "\3\2\2\2\u0348\u0349\7=\2\2\u0349\u00b0\3\2\2\2\u034a\u034b\7.\2\2\u034b",
    "\u00b2\3\2\2\2\u034c\u034d\7?\2\2\u034d\u00b4\3\2\2\2\u034e\u034f\7",
    ",\2\2\u034f\u0350\7?\2\2\u0350\u00b6\3\2\2\2\u0351\u0352\7\61\2\2\u0352",
    "\u0353\7?\2\2\u0353\u00b8\3\2\2\2\u0354\u0355\7\'\2\2\u0355\u0356\7",
    "?\2\2\u0356\u00ba\3\2\2\2\u0357\u0358\7-\2\2\u0358\u0359\7?\2\2\u0359",
    "\u00bc\3\2\2\2\u035a\u035b\7/\2\2\u035b\u035c\7?\2\2\u035c\u00be\3\2",
    "\2\2\u035d\u035e\7>\2\2\u035e\u035f\7>\2\2\u035f\u0360\7?\2\2\u0360",
    "\u00c0\3\2\2\2\u0361\u0362\7@\2\2\u0362\u0363\7@\2\2\u0363\u0364\7?",
    "\2\2\u0364\u00c2\3\2\2\2\u0365\u0366\7(\2\2\u0366\u0367\7?\2\2\u0367",
    "\u00c4\3\2\2\2\u0368\u0369\7`\2\2\u0369\u036a\7?\2\2\u036a\u00c6\3\2",
    "\2\2\u036b\u036c\7~\2\2\u036c\u036d\7?\2\2\u036d\u00c8\3\2\2\2\u036e",
    "\u036f\7?\2\2\u036f\u0370\7?\2\2\u0370\u00ca\3\2\2\2\u0371\u0372\7#",
    "\2\2\u0372\u0373\7?\2\2\u0373\u00cc\3\2\2\2\u0374\u0375\7/\2\2\u0375",
    "\u0376\7@\2\2\u0376\u00ce\3\2\2\2\u0377\u0378\7\60\2\2\u0378\u00d0\3",
    "\2\2\2\u0379\u037a\7\60\2\2\u037a\u037b\7\60\2\2\u037b\u037c\7\60\2",
    "\2\u037c\u00d2\3\2\2\2\u037d\u0382\5\u00d5k\2\u037e\u0381\5\u00d5k\2",
    "\u037f\u0381\5\u00d9m\2\u0380\u037e\3\2\2\2\u0380\u037f\3\2\2\2\u0381",
    "\u0384\3\2\2\2\u0382\u0380\3\2\2\2\u0382\u0383\3\2\2\2\u0383\u00d4\3",
    "\2\2\2\u0384\u0382\3\2\2\2\u0385\u0388\5\u00d7l\2\u0386\u0388\5\u00db",
    "n\2\u0387\u0385\3\2\2\2\u0387\u0386\3\2\2\2\u0388\u00d6\3\2\2\2\u0389",
    "\u038a\t\2\2\2\u038a\u00d8\3\2\2\2\u038b\u038c\t\3\2\2\u038c\u00da\3",
    "\2\2\2\u038d\u038e\7^\2\2\u038e\u038f\7w\2\2\u038f\u0390\3\2\2\2\u0390",
    "\u0398\5\u00ddo\2\u0391\u0392\7^\2\2\u0392\u0393\7W\2\2\u0393\u0394",
    "\3\2\2\2\u0394\u0395\5\u00ddo\2\u0395\u0396\5\u00ddo\2\u0396\u0398\3",
    "\2\2\2\u0397\u038d\3\2\2\2\u0397\u0391\3\2\2\2\u0398\u00dc\3\2\2\2\u0399",
    "\u039a\5\u00efx\2\u039a\u039b\5\u00efx\2\u039b\u039c\5\u00efx\2\u039c",
    "\u039d\5\u00efx\2\u039d\u00de\3\2\2\2\u039e\u03a2\5\u00e1q\2\u039f\u03a2",
    "\5\u00f9}\2\u03a0\u03a2\5\u010f\u0088\2\u03a1\u039e\3\2\2\2\u03a1\u039f",
    "\3\2\2\2\u03a1\u03a0\3\2\2\2\u03a2\u00e0\3\2\2\2\u03a3\u03a5\5\u00e3",
    "r\2\u03a4\u03a6\5\u00f1y\2\u03a5\u03a4\3\2\2\2\u03a5\u03a6\3\2\2\2\u03a6",
    "\u03b0\3\2\2\2\u03a7\u03a9\5\u00e5s\2\u03a8\u03aa\5\u00f1y\2\u03a9\u03a8",
    "\3\2\2\2\u03a9\u03aa\3\2\2\2\u03aa\u03b0\3\2\2\2\u03ab\u03ad\5\u00e7",
    "t\2\u03ac\u03ae\5\u00f1y\2\u03ad\u03ac\3\2\2\2\u03ad\u03ae\3\2\2\2\u03ae",
    "\u03b0\3\2\2\2\u03af\u03a3\3\2\2\2\u03af\u03a7\3\2\2\2\u03af\u03ab\3",
    "\2\2\2\u03b0\u00e2\3\2\2\2\u03b1\u03b5\5\u00ebv\2\u03b2\u03b4\5\u00d9",
    "m\2\u03b3\u03b2\3\2\2\2\u03b4\u03b7\3\2\2\2\u03b5\u03b3\3\2\2\2\u03b5",
    "\u03b6\3\2\2\2\u03b6\u00e4\3\2\2\2\u03b7\u03b5\3\2\2\2\u03b8\u03bc\7",
    "\62\2\2\u03b9\u03bb\5\u00edw\2\u03ba\u03b9\3\2\2\2\u03bb\u03be\3\2\2",
    "\2\u03bc\u03ba\3\2\2\2\u03bc\u03bd\3\2\2\2\u03bd\u00e6\3\2\2\2\u03be",
    "\u03bc\3\2\2\2\u03bf\u03c1\5\u00e9u\2\u03c0\u03c2\5\u00efx\2\u03c1\u03c0",
    "\3\2\2\2\u03c2\u03c3\3\2\2\2\u03c3\u03c1\3\2\2\2\u03c3\u03c4\3\2\2\2",
    "\u03c4\u00e8\3\2\2\2\u03c5\u03c6\7\62\2\2\u03c6\u03c7\t\4\2\2\u03c7",
    "\u00ea\3\2\2\2\u03c8\u03c9\t\5\2\2\u03c9\u00ec\3\2\2\2\u03ca\u03cb\t",
    "\6\2\2\u03cb\u00ee\3\2\2\2\u03cc\u03cd\t\7\2\2\u03cd\u00f0\3\2\2\2\u03ce",
    "\u03d0\5\u00f3z\2\u03cf\u03d1\5\u00f5{\2\u03d0\u03cf\3\2\2\2\u03d0\u03d1",
    "\3\2\2\2\u03d1\u03de\3\2\2\2\u03d2\u03d3\5\u00f3z\2\u03d3\u03d4\5\u00f7",
    "|\2\u03d4\u03de\3\2\2\2\u03d5\u03d7\5\u00f5{\2\u03d6\u03d8\5\u00f3z",
    "\2\u03d7\u03d6\3\2\2\2\u03d7\u03d8\3\2\2\2\u03d8\u03de\3\2\2\2\u03d9",
    "\u03db\5\u00f7|\2\u03da\u03dc\5\u00f3z\2\u03db\u03da\3\2\2\2\u03db\u03dc",
    "\3\2\2\2\u03dc\u03de\3\2\2\2\u03dd\u03ce\3\2\2\2\u03dd\u03d2\3\2\2\2",
    "\u03dd\u03d5\3\2\2\2\u03dd\u03d9\3\2\2\2\u03de\u00f2\3\2\2\2\u03df\u03e0",
    "\t\b\2\2\u03e0\u00f4\3\2\2\2\u03e1\u03e2\t\t\2\2\u03e2\u00f6\3\2\2\2",
    "\u03e3\u03e4\7n\2\2\u03e4\u03e8\7n\2\2\u03e5\u03e6\7N\2\2\u03e6\u03e8",
    "\7N\2\2\u03e7\u03e3\3\2\2\2\u03e7\u03e5\3\2\2\2\u03e8\u00f8\3\2\2\2",
    "\u03e9\u03ec\5\u00fb~\2\u03ea\u03ec\5\u00fd\177\2\u03eb\u03e9\3\2\2",
    "\2\u03eb\u03ea\3\2\2\2\u03ec\u00fa\3\2\2\2\u03ed\u03ef\5\u00ff\u0080",
    "\2\u03ee\u03f0\5\u0101\u0081\2\u03ef\u03ee\3\2\2\2\u03ef\u03f0\3\2\2",
    "\2\u03f0\u03f2\3\2\2\2\u03f1\u03f3\5\u010d\u0087\2\u03f2\u03f1\3\2\2",
    "\2\u03f2\u03f3\3\2\2\2\u03f3\u03fa\3\2\2\2\u03f4\u03f5\5\u0105\u0083",
    "\2\u03f5\u03f7\5\u0101\u0081\2\u03f6\u03f8\5\u010d\u0087\2\u03f7\u03f6",
    "\3\2\2\2\u03f7\u03f8\3\2\2\2\u03f8\u03fa\3\2\2\2\u03f9\u03ed\3\2\2\2",
    "\u03f9\u03f4\3\2\2\2\u03fa\u00fc\3\2\2\2\u03fb\u03fc\5\u00e9u\2\u03fc",
    "\u03fd\5\u0107\u0084\2\u03fd\u03ff\5\u0109\u0085\2\u03fe\u0400\5\u010d",
    "\u0087\2\u03ff\u03fe\3\2\2\2\u03ff\u0400\3\2\2\2\u0400\u0408\3\2\2\2",
    "\u0401\u0402\5\u00e9u\2\u0402\u0403\5\u010b\u0086\2\u0403\u0405\5\u0109",
    "\u0085\2\u0404\u0406\5\u010d\u0087\2\u0405\u0404\3\2\2\2\u0405\u0406",
    "\3\2\2\2\u0406\u0408\3\2\2\2\u0407\u03fb\3\2\2\2\u0407\u0401\3\2\2\2",
    "\u0408\u00fe\3\2\2\2\u0409\u040b\5\u0105\u0083\2\u040a\u0409\3\2\2\2",
    "\u040a\u040b\3\2\2\2\u040b\u040c\3\2\2\2\u040c\u040d\7\60\2\2\u040d",
    "\u0412\5\u0105\u0083\2\u040e\u040f\5\u0105\u0083\2\u040f\u0410\7\60",
    "\2\2\u0410\u0412\3\2\2\2\u0411\u040a\3\2\2\2\u0411\u040e\3\2\2\2\u0412",
    "\u0100\3\2\2\2\u0413\u0415\7g\2\2\u0414\u0416\5\u0103\u0082\2\u0415",
    "\u0414\3\2\2\2\u0415\u0416\3\2\2\2\u0416\u0417\3\2\2\2\u0417\u041e\5",
    "\u0105\u0083\2\u0418\u041a\7G\2\2\u0419\u041b\5\u0103\u0082\2\u041a",
    "\u0419\3\2\2\2\u041a\u041b\3\2\2\2\u041b\u041c\3\2\2\2\u041c\u041e\5",
    "\u0105\u0083\2\u041d\u0413\3\2\2\2\u041d\u0418\3\2\2\2\u041e\u0102\3",
    "\2\2\2\u041f\u0420\t\n\2\2\u0420\u0104\3\2\2\2\u0421\u0423\5\u00d9m",
    "\2\u0422\u0421\3\2\2\2\u0423\u0424\3\2\2\2\u0424\u0422\3\2\2\2\u0424",
    "\u0425\3\2\2\2\u0425\u0106\3\2\2\2\u0426\u0428\5\u010b\u0086\2\u0427",
    "\u0426\3\2\2\2\u0427\u0428\3\2\2\2\u0428\u0429\3\2\2\2\u0429\u042a\7",
    "\60\2\2\u042a\u042f\5\u010b\u0086\2\u042b\u042c\5\u010b\u0086\2\u042c",
    "\u042d\7\60\2\2\u042d\u042f\3\2\2\2\u042e\u0427\3\2\2\2\u042e\u042b",
    "\3\2\2\2\u042f\u0108\3\2\2\2\u0430\u0432\7r\2\2\u0431\u0433\5\u0103",
    "\u0082\2\u0432\u0431\3\2\2\2\u0432\u0433\3\2\2\2\u0433\u0434\3\2\2\2",
    "\u0434\u043b\5\u0105\u0083\2\u0435\u0437\7R\2\2\u0436\u0438\5\u0103",
    "\u0082\2\u0437\u0436\3\2\2\2\u0437\u0438\3\2\2\2\u0438\u0439\3\2\2\2",
    "\u0439\u043b\5\u0105\u0083\2\u043a\u0430\3\2\2\2\u043a\u0435\3\2\2\2",
    "\u043b\u010a\3\2\2\2\u043c\u043e\5\u00efx\2\u043d\u043c\3\2\2\2\u043e",
    "\u043f\3\2\2\2\u043f\u043d\3\2\2\2\u043f\u0440\3\2\2\2\u0440\u010c\3",
    "\2\2\2\u0441\u0442\t\13\2\2\u0442\u010e\3\2\2\2\u0443\u0444\7)\2\2\u0444",
    "\u0445\5\u0111\u0089\2\u0445\u0446\7)\2\2\u0446\u045a\3\2\2\2\u0447",
    "\u0448\7N\2\2\u0448\u0449\7)\2\2\u0449\u044a\3\2\2\2\u044a\u044b\5\u0111",
    "\u0089\2\u044b\u044c\7)\2\2\u044c\u045a\3\2\2\2\u044d\u044e\7w\2\2\u044e",
    "\u044f\7)\2\2\u044f\u0450\3\2\2\2\u0450\u0451\5\u0111\u0089\2\u0451",
    "\u0452\7)\2\2\u0452\u045a\3\2\2\2\u0453\u0454\7W\2\2\u0454\u0455\7)",
    "\2\2\u0455\u0456\3\2\2\2\u0456\u0457\5\u0111\u0089\2\u0457\u0458\7)",
    "\2\2\u0458\u045a\3\2\2\2\u0459\u0443\3\2\2\2\u0459\u0447\3\2\2\2\u0459",
    "\u044d\3\2\2\2\u0459\u0453\3\2\2\2\u045a\u0110\3\2\2\2\u045b\u045d\5",
    "\u0113\u008a\2\u045c\u045b\3\2\2\2\u045d\u045e\3\2\2\2\u045e\u045c\3",
    "\2\2\2\u045e\u045f\3\2\2\2\u045f\u0112\3\2\2\2\u0460\u0463\n\f\2\2\u0461",
    "\u0463\5\u0115\u008b\2\u0462\u0460\3\2\2\2\u0462\u0461\3\2\2\2\u0463",
    "\u0114\3\2\2\2\u0464\u0469\5\u0117\u008c\2\u0465\u0469\5\u0119\u008d",
    "\2\u0466\u0469\5\u011b\u008e\2\u0467\u0469\5\u00dbn\2\u0468\u0464\3",
    "\2\2\2\u0468\u0465\3\2\2\2\u0468\u0466\3\2\2\2\u0468\u0467\3\2\2\2\u0469",
    "\u0116\3\2\2\2\u046a\u046b\7^\2\2\u046b\u046c\t\r\2\2\u046c\u0118\3",
    "\2\2\2\u046d\u046e\7^\2\2\u046e\u0479\5\u00edw\2\u046f\u0470\7^\2\2",
    "\u0470\u0471\5\u00edw\2\u0471\u0472\5\u00edw\2\u0472\u0479\3\2\2\2\u0473",
    "\u0474\7^\2\2\u0474\u0475\5\u00edw\2\u0475\u0476\5\u00edw\2\u0476\u0477",
    "\5\u00edw\2\u0477\u0479\3\2\2\2\u0478\u046d\3\2\2\2\u0478\u046f\3\2",
    "\2\2\u0478\u0473\3\2\2\2\u0479\u011a\3\2\2\2\u047a\u047b\7^\2\2\u047b",
    "\u047c\7z\2\2\u047c\u047e\3\2\2\2\u047d\u047f\5\u00efx\2\u047e\u047d",
    "\3\2\2\2\u047f\u0480\3\2\2\2\u0480\u047e\3\2\2\2\u0480\u0481\3\2\2\2",
    "\u0481\u011c\3\2\2\2\u0482\u0484\5\u011f\u0090\2\u0483\u0482\3\2\2\2",
    "\u0483\u0484\3\2\2\2\u0484\u0485\3\2\2\2\u0485\u0487\7$\2\2\u0486\u0488",
    "\5\u0121\u0091\2\u0487\u0486\3\2\2\2\u0487\u0488\3\2\2\2\u0488\u0489",
    "\3\2\2\2\u0489\u048a\7$\2\2\u048a\u011e\3\2\2\2\u048b\u048c\7w\2\2\u048c",
    "\u048f\7:\2\2\u048d\u048f\t\16\2\2\u048e\u048b\3\2\2\2\u048e\u048d\3",
    "\2\2\2\u048f\u0120\3\2\2\2\u0490\u0492\5\u0123\u0092\2\u0491\u0490\3",
    "\2\2\2\u0492\u0493\3\2\2\2\u0493\u0491\3\2\2\2\u0493\u0494\3\2\2\2\u0494",
    "\u0122\3\2\2\2\u0495\u0498\n\17\2\2\u0496\u0498\5\u0115\u008b\2\u0497",
    "\u0495\3\2\2\2\u0497\u0496\3\2\2\2\u0498\u0124\3\2\2\2\u0499\u049b\7",
    "%\2\2\u049a\u049c\5\u0129\u0095\2\u049b\u049a\3\2\2\2\u049b\u049c\3",
    "\2\2\2\u049c\u049d\3\2\2\2\u049d\u049f\5\u00e3r\2\u049e\u04a0\5\u0129",
    "\u0095\2\u049f\u049e\3\2\2\2\u049f\u04a0\3\2\2\2\u04a0\u04a1\3\2\2\2",
    "\u04a1\u04a5\5\u011d\u008f\2\u04a2\u04a4\n\20\2\2\u04a3\u04a2\3\2\2",
    "\2\u04a4\u04a7\3\2\2\2\u04a5\u04a3\3\2\2\2\u04a5\u04a6\3\2\2\2\u04a6",
    "\u04a8\3\2\2\2\u04a7\u04a5\3\2\2\2\u04a8\u04a9\b\u0093\2\2\u04a9\u0126",
    "\3\2\2\2\u04aa\u04ac\7%\2\2\u04ab\u04ad\5\u0129\u0095\2\u04ac\u04ab",
    "\3\2\2\2\u04ac\u04ad\3\2\2\2\u04ad\u04ae\3\2\2\2\u04ae\u04af\7r\2\2",
    "\u04af\u04b0\7t\2\2\u04b0\u04b1\7c\2\2\u04b1\u04b2\7i\2\2\u04b2\u04b3",
    "\7o\2\2\u04b3\u04b4\7c\2\2\u04b4\u04b5\3\2\2\2\u04b5\u04b9\5\u0129\u0095",
    "\2\u04b6\u04b8\n\20\2\2\u04b7\u04b6\3\2\2\2\u04b8\u04bb\3\2\2\2\u04b9",
    "\u04b7\3\2\2\2\u04b9\u04ba\3\2\2\2\u04ba\u04bc\3\2\2\2\u04bb\u04b9\3",
    "\2\2\2\u04bc\u04bd\b\u0094\2\2\u04bd\u0128\3\2\2\2\u04be\u04c0\t\21",
    "\2\2\u04bf\u04be\3\2\2\2\u04c0\u04c1\3\2\2\2\u04c1\u04bf\3\2\2\2\u04c1",
    "\u04c2\3\2\2\2\u04c2\u04c3\3\2\2\2\u04c3\u04c4\b\u0095\2\2\u04c4\u012a",
    "\3\2\2\2\u04c5\u04c7\7\17\2\2\u04c6\u04c8\7\f\2\2\u04c7\u04c6\3\2\2",
    "\2\u04c7\u04c8\3\2\2\2\u04c8\u04cb\3\2\2\2\u04c9\u04cb\7\f\2\2\u04ca",
    "\u04c5\3\2\2\2\u04ca\u04c9\3\2\2\2\u04cb\u04cc\3\2\2\2\u04cc\u04cd\b",
    "\u0096\2\2\u04cd\u012c\3\2\2\2\u04ce\u04cf\7\61\2\2\u04cf\u04d0\7,\2",
    "\2\u04d0\u04d4\3\2\2\2\u04d1\u04d3\13\2\2\2\u04d2\u04d1\3\2\2\2\u04d3",
    "\u04d6\3\2\2\2\u04d4\u04d5\3\2\2\2\u04d4\u04d2\3\2\2\2\u04d5\u04d7\3",
    "\2\2\2\u04d6\u04d4\3\2\2\2\u04d7\u04d8\7,\2\2\u04d8\u04d9\7\61\2\2\u04d9",
    "\u04da\3\2\2\2\u04da\u04db\b\u0097\2\2\u04db\u012e\3\2\2\2\u04dc\u04dd",
    "\7\61\2\2\u04dd\u04de\7\61\2\2\u04de\u04e2\3\2\2\2\u04df\u04e1\n\20",
    "\2\2\u04e0\u04df\3\2\2\2\u04e1\u04e4\3\2\2\2\u04e2\u04e0\3\2\2\2\u04e2",
    "\u04e3\3\2\2\2\u04e3\u04e5\3\2\2\2\u04e4\u04e2\3\2\2\2\u04e5\u04e6\b",
    "\u0098\2\2\u04e6\u0130\3\2\2\2=\2\u0380\u0382\u0387\u0397\u03a1\u03a5",
    "\u03a9\u03ad\u03af\u03b5\u03bc\u03c3\u03d0\u03d7\u03db\u03dd\u03e7\u03eb",
    "\u03ef\u03f2\u03f7\u03f9\u03ff\u0405\u0407\u040a\u0411\u0415\u041a\u041d",
    "\u0424\u0427\u042e\u0432\u0437\u043a\u043f\u0459\u045e\u0462\u0468\u0478",
    "\u0480\u0483\u0487\u048e\u0493\u0497\u049b\u049f\u04a5\u04ac\u04b9\u04c1",
    "\u04c7\u04ca\u04d4\u04e2\3\b\2\2"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function CLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

CLexer.prototype = Object.create(antlr4.Lexer.prototype);
CLexer.prototype.constructor = CLexer;

CLexer.EOF = antlr4.Token.EOF;
CLexer.T__0 = 1;
CLexer.T__1 = 2;
CLexer.T__2 = 3;
CLexer.T__3 = 4;
CLexer.T__4 = 5;
CLexer.T__5 = 6;
CLexer.T__6 = 7;
CLexer.T__7 = 8;
CLexer.T__8 = 9;
CLexer.T__9 = 10;
CLexer.T__10 = 11;
CLexer.T__11 = 12;
CLexer.T__12 = 13;
CLexer.T__13 = 14;
CLexer.Auto = 15;
CLexer.Break = 16;
CLexer.Case = 17;
CLexer.Char = 18;
CLexer.Const = 19;
CLexer.Continue = 20;
CLexer.Default = 21;
CLexer.Do = 22;
CLexer.Double = 23;
CLexer.Else = 24;
CLexer.Enum = 25;
CLexer.Extern = 26;
CLexer.Float = 27;
CLexer.For = 28;
CLexer.Goto = 29;
CLexer.If = 30;
CLexer.Inline = 31;
CLexer.Int = 32;
CLexer.Long = 33;
CLexer.Register = 34;
CLexer.Restrict = 35;
CLexer.Return = 36;
CLexer.Short = 37;
CLexer.Signed = 38;
CLexer.Sizeof = 39;
CLexer.Static = 40;
CLexer.Struct = 41;
CLexer.Switch = 42;
CLexer.Typedef = 43;
CLexer.Union = 44;
CLexer.Unsigned = 45;
CLexer.Void = 46;
CLexer.Volatile = 47;
CLexer.While = 48;
CLexer.Alignas = 49;
CLexer.Alignof = 50;
CLexer.Atomic = 51;
CLexer.Bool = 52;
CLexer.Complex = 53;
CLexer.Generic = 54;
CLexer.Imaginary = 55;
CLexer.Noreturn = 56;
CLexer.StaticAssert = 57;
CLexer.ThreadLocal = 58;
CLexer.LeftParen = 59;
CLexer.RightParen = 60;
CLexer.LeftBracket = 61;
CLexer.RightBracket = 62;
CLexer.LeftBrace = 63;
CLexer.RightBrace = 64;
CLexer.Less = 65;
CLexer.LessEqual = 66;
CLexer.Greater = 67;
CLexer.GreaterEqual = 68;
CLexer.LeftShift = 69;
CLexer.RightShift = 70;
CLexer.Plus = 71;
CLexer.PlusPlus = 72;
CLexer.Minus = 73;
CLexer.MinusMinus = 74;
CLexer.Star = 75;
CLexer.Div = 76;
CLexer.Mod = 77;
CLexer.And = 78;
CLexer.Or = 79;
CLexer.AndAnd = 80;
CLexer.OrOr = 81;
CLexer.Caret = 82;
CLexer.Not = 83;
CLexer.Tilde = 84;
CLexer.Question = 85;
CLexer.Colon = 86;
CLexer.Semi = 87;
CLexer.Comma = 88;
CLexer.Assign = 89;
CLexer.StarAssign = 90;
CLexer.DivAssign = 91;
CLexer.ModAssign = 92;
CLexer.PlusAssign = 93;
CLexer.MinusAssign = 94;
CLexer.LeftShiftAssign = 95;
CLexer.RightShiftAssign = 96;
CLexer.AndAssign = 97;
CLexer.XorAssign = 98;
CLexer.OrAssign = 99;
CLexer.Equal = 100;
CLexer.NotEqual = 101;
CLexer.Arrow = 102;
CLexer.Dot = 103;
CLexer.Ellipsis = 104;
CLexer.Identifier = 105;
CLexer.Constant = 106;
CLexer.StringLiteral = 107;
CLexer.LineDirective = 108;
CLexer.PragmaDirective = 109;
CLexer.Whitespace = 110;
CLexer.Newline = 111;
CLexer.BlockComment = 112;
CLexer.LineComment = 113;


CLexer.modeNames = [ "DEFAULT_MODE" ];

CLexer.literalNames = [ 'null', "'__extension__'", "'__builtin_va_arg'", 
                        "'__builtin_offsetof'", "'__m128'", "'__m128d'", 
                        "'__m128i'", "'__typeof__'", "'__inline__'", "'__stdcall'", 
                        "'__declspec'", "'__asm'", "'__attribute__'", "'__asm__'", 
                        "'__volatile__'", "'auto'", "'break'", "'case'", 
                        "'char'", "'const'", "'continue'", "'default'", 
                        "'do'", "'double'", "'else'", "'enum'", "'extern'", 
                        "'float'", "'for'", "'goto'", "'if'", "'inline'", 
                        "'int'", "'long'", "'register'", "'restrict'", "'return'", 
                        "'short'", "'signed'", "'sizeof'", "'static'", "'struct'", 
                        "'switch'", "'typedef'", "'union'", "'unsigned'", 
                        "'void'", "'volatile'", "'while'", "'_Alignas'", 
                        "'_Alignof'", "'_Atomic'", "'_Bool'", "'_Complex'", 
                        "'_Generic'", "'_Imaginary'", "'_Noreturn'", "'_Static_assert'", 
                        "'_Thread_local'", "'('", "')'", "'['", "']'", "'{'", 
                        "'}'", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'", 
                        "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", 
                        "'&'", "'|'", "'&&'", "'||'", "'^'", "'!'", "'~'", 
                        "'?'", "':'", "';'", "','", "'='", "'*='", "'/='", 
                        "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", 
                        "'^='", "'|='", "'=='", "'!='", "'->'", "'.'", "'...'" ];

CLexer.symbolicNames = [ 'null', 'null', 'null', 'null', 'null', 'null', 
                         'null', 'null', 'null', 'null', 'null', 'null', 
                         'null', 'null', 'null', "Auto", "Break", "Case", 
                         "Char", "Const", "Continue", "Default", "Do", "Double", 
                         "Else", "Enum", "Extern", "Float", "For", "Goto", 
                         "If", "Inline", "Int", "Long", "Register", "Restrict", 
                         "Return", "Short", "Signed", "Sizeof", "Static", 
                         "Struct", "Switch", "Typedef", "Union", "Unsigned", 
                         "Void", "Volatile", "While", "Alignas", "Alignof", 
                         "Atomic", "Bool", "Complex", "Generic", "Imaginary", 
                         "Noreturn", "StaticAssert", "ThreadLocal", "LeftParen", 
                         "RightParen", "LeftBracket", "RightBracket", "LeftBrace", 
                         "RightBrace", "Less", "LessEqual", "Greater", "GreaterEqual", 
                         "LeftShift", "RightShift", "Plus", "PlusPlus", 
                         "Minus", "MinusMinus", "Star", "Div", "Mod", "And", 
                         "Or", "AndAnd", "OrOr", "Caret", "Not", "Tilde", 
                         "Question", "Colon", "Semi", "Comma", "Assign", 
                         "StarAssign", "DivAssign", "ModAssign", "PlusAssign", 
                         "MinusAssign", "LeftShiftAssign", "RightShiftAssign", 
                         "AndAssign", "XorAssign", "OrAssign", "Equal", 
                         "NotEqual", "Arrow", "Dot", "Ellipsis", "Identifier", 
                         "Constant", "StringLiteral", "LineDirective", "PragmaDirective", 
                         "Whitespace", "Newline", "BlockComment", "LineComment" ];

CLexer.ruleNames = [ "T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", 
                     "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", 
                     "T__13", "Auto", "Break", "Case", "Char", "Const", 
                     "Continue", "Default", "Do", "Double", "Else", "Enum", 
                     "Extern", "Float", "For", "Goto", "If", "Inline", "Int", 
                     "Long", "Register", "Restrict", "Return", "Short", 
                     "Signed", "Sizeof", "Static", "Struct", "Switch", "Typedef", 
                     "Union", "Unsigned", "Void", "Volatile", "While", "Alignas", 
                     "Alignof", "Atomic", "Bool", "Complex", "Generic", 
                     "Imaginary", "Noreturn", "StaticAssert", "ThreadLocal", 
                     "LeftParen", "RightParen", "LeftBracket", "RightBracket", 
                     "LeftBrace", "RightBrace", "Less", "LessEqual", "Greater", 
                     "GreaterEqual", "LeftShift", "RightShift", "Plus", 
                     "PlusPlus", "Minus", "MinusMinus", "Star", "Div", "Mod", 
                     "And", "Or", "AndAnd", "OrOr", "Caret", "Not", "Tilde", 
                     "Question", "Colon", "Semi", "Comma", "Assign", "StarAssign", 
                     "DivAssign", "ModAssign", "PlusAssign", "MinusAssign", 
                     "LeftShiftAssign", "RightShiftAssign", "AndAssign", 
                     "XorAssign", "OrAssign", "Equal", "NotEqual", "Arrow", 
                     "Dot", "Ellipsis", "Identifier", "IdentifierNondigit", 
                     "Nondigit", "Digit", "UniversalCharacterName", "HexQuad", 
                     "Constant", "IntegerConstant", "DecimalConstant", "OctalConstant", 
                     "HexadecimalConstant", "HexadecimalPrefix", "NonzeroDigit", 
                     "OctalDigit", "HexadecimalDigit", "IntegerSuffix", 
                     "UnsignedSuffix", "LongSuffix", "LongLongSuffix", "FloatingConstant", 
                     "DecimalFloatingConstant", "HexadecimalFloatingConstant", 
                     "FractionalConstant", "ExponentPart", "Sign", "DigitSequence", 
                     "HexadecimalFractionalConstant", "BinaryExponentPart", 
                     "HexadecimalDigitSequence", "FloatingSuffix", "CharacterConstant", 
                     "CCharSequence", "CChar", "EscapeSequence", "SimpleEscapeSequence", 
                     "OctalEscapeSequence", "HexadecimalEscapeSequence", 
                     "StringLiteral", "EncodingPrefix", "SCharSequence", 
                     "SChar", "LineDirective", "PragmaDirective", "Whitespace", 
                     "Newline", "BlockComment", "LineComment" ];

CLexer.grammarFileName = "C.g4";



exports.CLexer = CLexer;


},{"antlr4/index":54}],2:[function(require,module,exports){
// Generated from C.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by CParser.
function CListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

CListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
CListener.prototype.constructor = CListener;

// Enter a parse tree produced by CParser#primaryExpression.
CListener.prototype.enterPrimaryExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#primaryExpression.
CListener.prototype.exitPrimaryExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#genericSelection.
CListener.prototype.enterGenericSelection = function(ctx) {
};

// Exit a parse tree produced by CParser#genericSelection.
CListener.prototype.exitGenericSelection = function(ctx) {
};


// Enter a parse tree produced by CParser#genericAssocList.
CListener.prototype.enterGenericAssocList = function(ctx) {
};

// Exit a parse tree produced by CParser#genericAssocList.
CListener.prototype.exitGenericAssocList = function(ctx) {
};


// Enter a parse tree produced by CParser#genericAssociation.
CListener.prototype.enterGenericAssociation = function(ctx) {
};

// Exit a parse tree produced by CParser#genericAssociation.
CListener.prototype.exitGenericAssociation = function(ctx) {
};


// Enter a parse tree produced by CParser#postfixExpression.
CListener.prototype.enterPostfixExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#postfixExpression.
CListener.prototype.exitPostfixExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#argumentExpressionList.
CListener.prototype.enterArgumentExpressionList = function(ctx) {
};

// Exit a parse tree produced by CParser#argumentExpressionList.
CListener.prototype.exitArgumentExpressionList = function(ctx) {
};


// Enter a parse tree produced by CParser#unaryExpression.
CListener.prototype.enterUnaryExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#unaryExpression.
CListener.prototype.exitUnaryExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#unaryOperator.
CListener.prototype.enterUnaryOperator = function(ctx) {
};

// Exit a parse tree produced by CParser#unaryOperator.
CListener.prototype.exitUnaryOperator = function(ctx) {
};


// Enter a parse tree produced by CParser#castExpression.
CListener.prototype.enterCastExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#castExpression.
CListener.prototype.exitCastExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#multiplicativeExpression.
CListener.prototype.enterMultiplicativeExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#multiplicativeExpression.
CListener.prototype.exitMultiplicativeExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#additiveExpression.
CListener.prototype.enterAdditiveExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#additiveExpression.
CListener.prototype.exitAdditiveExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#shiftExpression.
CListener.prototype.enterShiftExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#shiftExpression.
CListener.prototype.exitShiftExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#relationalExpression.
CListener.prototype.enterRelationalExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#relationalExpression.
CListener.prototype.exitRelationalExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#equalityExpression.
CListener.prototype.enterEqualityExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#equalityExpression.
CListener.prototype.exitEqualityExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#andExpression.
CListener.prototype.enterAndExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#andExpression.
CListener.prototype.exitAndExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#exclusiveOrExpression.
CListener.prototype.enterExclusiveOrExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#exclusiveOrExpression.
CListener.prototype.exitExclusiveOrExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#inclusiveOrExpression.
CListener.prototype.enterInclusiveOrExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#inclusiveOrExpression.
CListener.prototype.exitInclusiveOrExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#logicalAndExpression.
CListener.prototype.enterLogicalAndExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#logicalAndExpression.
CListener.prototype.exitLogicalAndExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#logicalOrExpression.
CListener.prototype.enterLogicalOrExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#logicalOrExpression.
CListener.prototype.exitLogicalOrExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#conditionalExpression.
CListener.prototype.enterConditionalExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#conditionalExpression.
CListener.prototype.exitConditionalExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#assignmentExpression.
CListener.prototype.enterAssignmentExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#assignmentExpression.
CListener.prototype.exitAssignmentExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#assignmentOperator.
CListener.prototype.enterAssignmentOperator = function(ctx) {
};

// Exit a parse tree produced by CParser#assignmentOperator.
CListener.prototype.exitAssignmentOperator = function(ctx) {
};


// Enter a parse tree produced by CParser#expression.
CListener.prototype.enterExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#expression.
CListener.prototype.exitExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#constantExpression.
CListener.prototype.enterConstantExpression = function(ctx) {
};

// Exit a parse tree produced by CParser#constantExpression.
CListener.prototype.exitConstantExpression = function(ctx) {
};


// Enter a parse tree produced by CParser#declaration.
CListener.prototype.enterDeclaration = function(ctx) {
};

// Exit a parse tree produced by CParser#declaration.
CListener.prototype.exitDeclaration = function(ctx) {
};


// Enter a parse tree produced by CParser#declarationSpecifiers.
CListener.prototype.enterDeclarationSpecifiers = function(ctx) {
};

// Exit a parse tree produced by CParser#declarationSpecifiers.
CListener.prototype.exitDeclarationSpecifiers = function(ctx) {
};


// Enter a parse tree produced by CParser#declarationSpecifiers2.
CListener.prototype.enterDeclarationSpecifiers2 = function(ctx) {
};

// Exit a parse tree produced by CParser#declarationSpecifiers2.
CListener.prototype.exitDeclarationSpecifiers2 = function(ctx) {
};


// Enter a parse tree produced by CParser#declarationSpecifier.
CListener.prototype.enterDeclarationSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#declarationSpecifier.
CListener.prototype.exitDeclarationSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#initDeclaratorList.
CListener.prototype.enterInitDeclaratorList = function(ctx) {
};

// Exit a parse tree produced by CParser#initDeclaratorList.
CListener.prototype.exitInitDeclaratorList = function(ctx) {
};


// Enter a parse tree produced by CParser#initDeclarator.
CListener.prototype.enterInitDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#initDeclarator.
CListener.prototype.exitInitDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#storageClassSpecifier.
CListener.prototype.enterStorageClassSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#storageClassSpecifier.
CListener.prototype.exitStorageClassSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#typeSpecifier.
CListener.prototype.enterTypeSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#typeSpecifier.
CListener.prototype.exitTypeSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#structOrUnionSpecifier.
CListener.prototype.enterStructOrUnionSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#structOrUnionSpecifier.
CListener.prototype.exitStructOrUnionSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#structOrUnion.
CListener.prototype.enterStructOrUnion = function(ctx) {
};

// Exit a parse tree produced by CParser#structOrUnion.
CListener.prototype.exitStructOrUnion = function(ctx) {
};


// Enter a parse tree produced by CParser#structDeclarationList.
CListener.prototype.enterStructDeclarationList = function(ctx) {
};

// Exit a parse tree produced by CParser#structDeclarationList.
CListener.prototype.exitStructDeclarationList = function(ctx) {
};


// Enter a parse tree produced by CParser#structDeclaration.
CListener.prototype.enterStructDeclaration = function(ctx) {
};

// Exit a parse tree produced by CParser#structDeclaration.
CListener.prototype.exitStructDeclaration = function(ctx) {
};


// Enter a parse tree produced by CParser#specifierQualifierList.
CListener.prototype.enterSpecifierQualifierList = function(ctx) {
};

// Exit a parse tree produced by CParser#specifierQualifierList.
CListener.prototype.exitSpecifierQualifierList = function(ctx) {
};


// Enter a parse tree produced by CParser#structDeclaratorList.
CListener.prototype.enterStructDeclaratorList = function(ctx) {
};

// Exit a parse tree produced by CParser#structDeclaratorList.
CListener.prototype.exitStructDeclaratorList = function(ctx) {
};


// Enter a parse tree produced by CParser#structDeclarator.
CListener.prototype.enterStructDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#structDeclarator.
CListener.prototype.exitStructDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#enumSpecifier.
CListener.prototype.enterEnumSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#enumSpecifier.
CListener.prototype.exitEnumSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#enumeratorList.
CListener.prototype.enterEnumeratorList = function(ctx) {
};

// Exit a parse tree produced by CParser#enumeratorList.
CListener.prototype.exitEnumeratorList = function(ctx) {
};


// Enter a parse tree produced by CParser#enumerator.
CListener.prototype.enterEnumerator = function(ctx) {
};

// Exit a parse tree produced by CParser#enumerator.
CListener.prototype.exitEnumerator = function(ctx) {
};


// Enter a parse tree produced by CParser#enumerationConstant.
CListener.prototype.enterEnumerationConstant = function(ctx) {
};

// Exit a parse tree produced by CParser#enumerationConstant.
CListener.prototype.exitEnumerationConstant = function(ctx) {
};


// Enter a parse tree produced by CParser#atomicTypeSpecifier.
CListener.prototype.enterAtomicTypeSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#atomicTypeSpecifier.
CListener.prototype.exitAtomicTypeSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#typeQualifier.
CListener.prototype.enterTypeQualifier = function(ctx) {
};

// Exit a parse tree produced by CParser#typeQualifier.
CListener.prototype.exitTypeQualifier = function(ctx) {
};


// Enter a parse tree produced by CParser#functionSpecifier.
CListener.prototype.enterFunctionSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#functionSpecifier.
CListener.prototype.exitFunctionSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#alignmentSpecifier.
CListener.prototype.enterAlignmentSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#alignmentSpecifier.
CListener.prototype.exitAlignmentSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#declarator.
CListener.prototype.enterDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#declarator.
CListener.prototype.exitDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#directDeclarator.
CListener.prototype.enterDirectDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#directDeclarator.
CListener.prototype.exitDirectDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#gccDeclaratorExtension.
CListener.prototype.enterGccDeclaratorExtension = function(ctx) {
};

// Exit a parse tree produced by CParser#gccDeclaratorExtension.
CListener.prototype.exitGccDeclaratorExtension = function(ctx) {
};


// Enter a parse tree produced by CParser#gccAttributeSpecifier.
CListener.prototype.enterGccAttributeSpecifier = function(ctx) {
};

// Exit a parse tree produced by CParser#gccAttributeSpecifier.
CListener.prototype.exitGccAttributeSpecifier = function(ctx) {
};


// Enter a parse tree produced by CParser#gccAttributeList.
CListener.prototype.enterGccAttributeList = function(ctx) {
};

// Exit a parse tree produced by CParser#gccAttributeList.
CListener.prototype.exitGccAttributeList = function(ctx) {
};


// Enter a parse tree produced by CParser#gccAttribute.
CListener.prototype.enterGccAttribute = function(ctx) {
};

// Exit a parse tree produced by CParser#gccAttribute.
CListener.prototype.exitGccAttribute = function(ctx) {
};


// Enter a parse tree produced by CParser#nestedParenthesesBlock.
CListener.prototype.enterNestedParenthesesBlock = function(ctx) {
};

// Exit a parse tree produced by CParser#nestedParenthesesBlock.
CListener.prototype.exitNestedParenthesesBlock = function(ctx) {
};


// Enter a parse tree produced by CParser#pointer.
CListener.prototype.enterPointer = function(ctx) {
};

// Exit a parse tree produced by CParser#pointer.
CListener.prototype.exitPointer = function(ctx) {
};


// Enter a parse tree produced by CParser#typeQualifierList.
CListener.prototype.enterTypeQualifierList = function(ctx) {
};

// Exit a parse tree produced by CParser#typeQualifierList.
CListener.prototype.exitTypeQualifierList = function(ctx) {
};


// Enter a parse tree produced by CParser#parameterTypeList.
CListener.prototype.enterParameterTypeList = function(ctx) {
};

// Exit a parse tree produced by CParser#parameterTypeList.
CListener.prototype.exitParameterTypeList = function(ctx) {
};


// Enter a parse tree produced by CParser#parameterList.
CListener.prototype.enterParameterList = function(ctx) {
};

// Exit a parse tree produced by CParser#parameterList.
CListener.prototype.exitParameterList = function(ctx) {
};


// Enter a parse tree produced by CParser#parameterDeclaration.
CListener.prototype.enterParameterDeclaration = function(ctx) {
};

// Exit a parse tree produced by CParser#parameterDeclaration.
CListener.prototype.exitParameterDeclaration = function(ctx) {
};


// Enter a parse tree produced by CParser#identifierList.
CListener.prototype.enterIdentifierList = function(ctx) {
};

// Exit a parse tree produced by CParser#identifierList.
CListener.prototype.exitIdentifierList = function(ctx) {
};


// Enter a parse tree produced by CParser#typeName.
CListener.prototype.enterTypeName = function(ctx) {
};

// Exit a parse tree produced by CParser#typeName.
CListener.prototype.exitTypeName = function(ctx) {
};


// Enter a parse tree produced by CParser#abstractDeclarator.
CListener.prototype.enterAbstractDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#abstractDeclarator.
CListener.prototype.exitAbstractDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#directAbstractDeclarator.
CListener.prototype.enterDirectAbstractDeclarator = function(ctx) {
};

// Exit a parse tree produced by CParser#directAbstractDeclarator.
CListener.prototype.exitDirectAbstractDeclarator = function(ctx) {
};


// Enter a parse tree produced by CParser#typedefName.
CListener.prototype.enterTypedefName = function(ctx) {
};

// Exit a parse tree produced by CParser#typedefName.
CListener.prototype.exitTypedefName = function(ctx) {
};


// Enter a parse tree produced by CParser#initializer.
CListener.prototype.enterInitializer = function(ctx) {
};

// Exit a parse tree produced by CParser#initializer.
CListener.prototype.exitInitializer = function(ctx) {
};


// Enter a parse tree produced by CParser#initializerList.
CListener.prototype.enterInitializerList = function(ctx) {
};

// Exit a parse tree produced by CParser#initializerList.
CListener.prototype.exitInitializerList = function(ctx) {
};


// Enter a parse tree produced by CParser#designation.
CListener.prototype.enterDesignation = function(ctx) {
};

// Exit a parse tree produced by CParser#designation.
CListener.prototype.exitDesignation = function(ctx) {
};


// Enter a parse tree produced by CParser#designatorList.
CListener.prototype.enterDesignatorList = function(ctx) {
};

// Exit a parse tree produced by CParser#designatorList.
CListener.prototype.exitDesignatorList = function(ctx) {
};


// Enter a parse tree produced by CParser#designator.
CListener.prototype.enterDesignator = function(ctx) {
};

// Exit a parse tree produced by CParser#designator.
CListener.prototype.exitDesignator = function(ctx) {
};


// Enter a parse tree produced by CParser#staticAssertDeclaration.
CListener.prototype.enterStaticAssertDeclaration = function(ctx) {
};

// Exit a parse tree produced by CParser#staticAssertDeclaration.
CListener.prototype.exitStaticAssertDeclaration = function(ctx) {
};


// Enter a parse tree produced by CParser#statement.
CListener.prototype.enterStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#statement.
CListener.prototype.exitStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#labeledStatement.
CListener.prototype.enterLabeledStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#labeledStatement.
CListener.prototype.exitLabeledStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#compoundStatement.
CListener.prototype.enterCompoundStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#compoundStatement.
CListener.prototype.exitCompoundStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#blockItemList.
CListener.prototype.enterBlockItemList = function(ctx) {
};

// Exit a parse tree produced by CParser#blockItemList.
CListener.prototype.exitBlockItemList = function(ctx) {
};


// Enter a parse tree produced by CParser#blockItem.
CListener.prototype.enterBlockItem = function(ctx) {
};

// Exit a parse tree produced by CParser#blockItem.
CListener.prototype.exitBlockItem = function(ctx) {
};


// Enter a parse tree produced by CParser#expressionStatement.
CListener.prototype.enterExpressionStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#expressionStatement.
CListener.prototype.exitExpressionStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#selectionStatement.
CListener.prototype.enterSelectionStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#selectionStatement.
CListener.prototype.exitSelectionStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#iterationStatement.
CListener.prototype.enterIterationStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#iterationStatement.
CListener.prototype.exitIterationStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#jumpStatement.
CListener.prototype.enterJumpStatement = function(ctx) {
};

// Exit a parse tree produced by CParser#jumpStatement.
CListener.prototype.exitJumpStatement = function(ctx) {
};


// Enter a parse tree produced by CParser#compilationUnit.
CListener.prototype.enterCompilationUnit = function(ctx) {
};

// Exit a parse tree produced by CParser#compilationUnit.
CListener.prototype.exitCompilationUnit = function(ctx) {
};


// Enter a parse tree produced by CParser#translationUnit.
CListener.prototype.enterTranslationUnit = function(ctx) {
};

// Exit a parse tree produced by CParser#translationUnit.
CListener.prototype.exitTranslationUnit = function(ctx) {
};


// Enter a parse tree produced by CParser#externalDeclaration.
CListener.prototype.enterExternalDeclaration = function(ctx) {
};

// Exit a parse tree produced by CParser#externalDeclaration.
CListener.prototype.exitExternalDeclaration = function(ctx) {
};


// Enter a parse tree produced by CParser#functionDefinition.
CListener.prototype.enterFunctionDefinition = function(ctx) {
};

// Exit a parse tree produced by CParser#functionDefinition.
CListener.prototype.exitFunctionDefinition = function(ctx) {
};


// Enter a parse tree produced by CParser#declarationList.
CListener.prototype.enterDeclarationList = function(ctx) {
};

// Exit a parse tree produced by CParser#declarationList.
CListener.prototype.exitDeclarationList = function(ctx) {
};



exports.CListener = CListener;
},{"antlr4/index":54}],3:[function(require,module,exports){
// Generated from C.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');
var CListener = require('./CListener').CListener;
var grammarFileName = "C.g4";

var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\3s\u04e9\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4",
    "\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t",
    "\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27",
    "\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4",
    "\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'\t",
    "\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t",
    "\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t",
    "8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC",
    "\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\tN\4",
    "O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\3\2\3\2\3\2\6\2\u00ae\n\2\r",
    "\2\16\2\u00af\3\2\3\2\3\2\3\2\3\2\3\2\5\2\u00b8\n\2\3\2\3\2\3\2\3\2",
    "\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\5\2\u00cc\n",
    "\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\7\4\u00db\n\4",
    "\f\4\16\4\u00de\13\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5\u00e7\n\5\3\6\3",
    "\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3",
    "\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u010b",
    "\n\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\5\6\u0115\n\6\3\6\3\6\3\6\3\6\3",
    "\6\3\6\3\6\3\6\3\6\3\6\3\6\7\6\u0122\n\6\f\6\16\6\u0125\13\6\3\7\3\7",
    "\3\7\3\7\3\7\3\7\7\7\u012d\n\7\f\7\16\7\u0130\13\7\3\b\3\b\3\b\3\b\3",
    "\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3",
    "\b\5\b\u0148\n\b\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n",
    "\3\n\5\n\u0158\n\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13",
    "\3\13\3\13\7\13\u0166\n\13\f\13\16\13\u0169\13\13\3\f\3\f\3\f\3\f\3",
    "\f\3\f\3\f\3\f\3\f\7\f\u0174\n\f\f\f\16\f\u0177\13\f\3\r\3\r\3\r\3\r",
    "\3\r\3\r\3\r\3\r\3\r\7\r\u0182\n\r\f\r\16\r\u0185\13\r\3\16\3\16\3\16",
    "\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\7\16\u0196",
    "\n\16\f\16\16\16\u0199\13\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17",
    "\3\17\7\17\u01a4\n\17\f\17\16\17\u01a7\13\17\3\20\3\20\3\20\3\20\3\20",
    "\3\20\7\20\u01af\n\20\f\20\16\20\u01b2\13\20\3\21\3\21\3\21\3\21\3\21",
    "\3\21\7\21\u01ba\n\21\f\21\16\21\u01bd\13\21\3\22\3\22\3\22\3\22\3\22",
    "\3\22\7\22\u01c5\n\22\f\22\16\22\u01c8\13\22\3\23\3\23\3\23\3\23\3\23",
    "\3\23\7\23\u01d0\n\23\f\23\16\23\u01d3\13\23\3\24\3\24\3\24\3\24\3\24",
    "\3\24\7\24\u01db\n\24\f\24\16\24\u01de\13\24\3\25\3\25\3\25\3\25\3\25",
    "\3\25\5\25\u01e6\n\25\3\26\3\26\3\26\3\26\3\26\5\26\u01ed\n\26\3\27",
    "\3\27\3\30\3\30\3\30\3\30\3\30\3\30\7\30\u01f7\n\30\f\30\16\30\u01fa",
    "\13\30\3\31\3\31\3\32\3\32\5\32\u0200\n\32\3\32\3\32\3\32\5\32\u0205",
    "\n\32\3\33\6\33\u0208\n\33\r\33\16\33\u0209\3\34\6\34\u020d\n\34\r\34",
    "\16\34\u020e\3\35\3\35\3\35\3\35\3\35\5\35\u0216\n\35\3\36\3\36\3\36",
    "\3\36\3\36\3\36\7\36\u021e\n\36\f\36\16\36\u0221\13\36\3\37\3\37\3\37",
    "\3\37\3\37\5\37\u0228\n\37\3 \3 \3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3",
    "!\3!\3!\5!\u023a\n!\3\"\3\"\5\"\u023e\n\"\3\"\3\"\3\"\3\"\3\"\3\"\3",
    "\"\5\"\u0247\n\"\3#\3#\3$\3$\3$\3$\3$\7$\u0250\n$\f$\16$\u0253\13$\3",
    "%\3%\5%\u0257\n%\3%\3%\3%\5%\u025c\n%\3&\3&\5&\u0260\n&\3&\3&\5&\u0264",
    "\n&\5&\u0266\n&\3\'\3\'\3\'\3\'\3\'\3\'\7\'\u026e\n\'\f\'\16\'\u0271",
    "\13\'\3(\3(\5(\u0275\n(\3(\3(\5(\u0279\n(\3)\3)\5)\u027d\n)\3)\3)\3",
    ")\3)\3)\3)\5)\u0285\n)\3)\3)\3)\3)\3)\3)\3)\5)\u028e\n)\3*\3*\3*\3*",
    "\3*\3*\7*\u0296\n*\f*\16*\u0299\13*\3+\3+\3+\3+\3+\5+\u02a0\n+\3,\3",
    ",\3-\3-\3-\3-\3-\3.\3.\3/\3/\3/\3/\3/\3/\5/\u02b1\n/\3\60\3\60\3\60",
    "\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u02bd\n\60\3\61\5\61\u02c0",
    "\n\61\3\61\3\61\7\61\u02c4\n\61\f\61\16\61\u02c7\13\61\3\62\3\62\3\62",
    "\3\62\3\62\3\62\5\62\u02cf\n\62\3\62\3\62\3\62\5\62\u02d4\n\62\3\62",
    "\5\62\u02d7\n\62\3\62\3\62\3\62\3\62\3\62\5\62\u02de\n\62\3\62\3\62",
    "\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u02ed\n",
    "\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\3\62\5\62\u02f9\n\62",
    "\3\62\7\62\u02fc\n\62\f\62\16\62\u02ff\13\62\3\63\3\63\3\63\6\63\u0304",
    "\n\63\r\63\16\63\u0305\3\63\3\63\5\63\u030a\n\63\3\64\3\64\3\64\3\64",
    "\3\64\3\64\3\64\3\65\3\65\3\65\7\65\u0316\n\65\f\65\16\65\u0319\13\65",
    "\3\65\5\65\u031c\n\65\3\66\3\66\3\66\5\66\u0321\n\66\3\66\5\66\u0324",
    "\n\66\3\66\5\66\u0327\n\66\3\67\3\67\3\67\3\67\3\67\7\67\u032e\n\67",
    "\f\67\16\67\u0331\13\67\38\38\58\u0335\n8\38\38\58\u0339\n8\38\38\3",
    "8\58\u033e\n8\38\38\58\u0342\n8\38\58\u0345\n8\39\39\39\39\39\79\u034c",
    "\n9\f9\169\u034f\139\3:\3:\3:\3:\3:\5:\u0356\n:\3;\3;\3;\3;\3;\3;\7",
    ";\u035e\n;\f;\16;\u0361\13;\3<\3<\3<\3<\3<\5<\u0368\n<\5<\u036a\n<\3",
    "=\3=\3=\3=\3=\3=\7=\u0372\n=\f=\16=\u0375\13=\3>\3>\5>\u0379\n>\3?\3",
    "?\5?\u037d\n?\3?\3?\7?\u0381\n?\f?\16?\u0384\13?\5?\u0386\n?\3@\3@\3",
    "@\3@\3@\7@\u038d\n@\f@\16@\u0390\13@\3@\3@\5@\u0394\n@\3@\5@\u0397\n",
    "@\3@\3@\3@\3@\5@\u039d\n@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@",
    "\5@\u03ad\n@\3@\3@\7@\u03b1\n@\f@\16@\u03b4\13@\5@\u03b6\n@\3@\3@\3",
    "@\5@\u03bb\n@\3@\5@\u03be\n@\3@\3@\3@\3@\3@\5@\u03c5\n@\3@\3@\3@\3@",
    "\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\3@\5@\u03d8\n@\3@\3@\7@\u03dc\n",
    "@\f@\16@\u03df\13@\7@\u03e1\n@\f@\16@\u03e4\13@\3A\3A\3B\3B\3B\3B\3",
    "B\3B\3B\3B\3B\3B\5B\u03f2\nB\3C\3C\5C\u03f6\nC\3C\3C\3C\3C\3C\5C\u03fd",
    "\nC\3C\7C\u0400\nC\fC\16C\u0403\13C\3D\3D\3D\3E\3E\3E\3E\3E\7E\u040d",
    "\nE\fE\16E\u0410\13E\3F\3F\3F\3F\3F\3F\5F\u0418\nF\3G\3G\3G\3G\3G\6",
    "G\u041f\nG\rG\16G\u0420\3G\3G\3G\3H\3H\3H\3H\3H\3H\3H\3H\3H\3H\3H\3",
    "H\7H\u0432\nH\fH\16H\u0435\13H\5H\u0437\nH\3H\3H\3H\3H\7H\u043d\nH\f",
    "H\16H\u0440\13H\5H\u0442\nH\7H\u0444\nH\fH\16H\u0447\13H\3H\3H\5H\u044b",
    "\nH\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u0458\nI\3J\3J\5J\u045c\nJ\3",
    "J\3J\3K\3K\3K\3K\3K\7K\u0465\nK\fK\16K\u0468\13K\3L\3L\5L\u046c\nL\3",
    "M\5M\u046f\nM\3M\3M\3N\3N\3N\3N\3N\3N\3N\5N\u047a\nN\3N\3N\3N\3N\3N",
    "\3N\5N\u0482\nN\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\5",
    "O\u0495\nO\3O\3O\5O\u0499\nO\3O\3O\5O\u049d\nO\3O\3O\3O\3O\3O\3O\5O",
    "\u04a5\nO\3O\3O\5O\u04a9\nO\3O\3O\3O\5O\u04ae\nO\3P\3P\3P\3P\3P\3P\3",
    "P\3P\3P\5P\u04b9\nP\3P\3P\3P\3P\3P\5P\u04c0\nP\3Q\5Q\u04c3\nQ\3Q\3Q",
    "\3R\3R\3R\3R\3R\7R\u04cc\nR\fR\16R\u04cf\13R\3S\3S\3S\5S\u04d4\nS\3",
    "T\5T\u04d7\nT\3T\3T\5T\u04db\nT\3T\3T\3U\3U\3U\3U\3U\7U\u04e4\nU\fU",
    "\16U\u04e7\13U\3U\2\36\6\n\f\24\26\30\32\34\36 \"$&.:FLRbptx~\u0084",
    "\u0088\u0094\u00a2\u00a8V\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"",
    "$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082",
    "\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a",
    "\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\2\16\7\2IIKKMMPPUV\3\2[e",
    "\b\2\21\21\34\34$$**--<<\n\2\6\b\24\24\31\31\35\35\"#\'(/\60\66\67\3",
    "\2\6\b\4\2++..\6\2\25\25%%\61\61\65\65\5\2\n\13!!::\4\2=>ZZ\3\2=>\4",
    "\2\r\r\17\17\4\2\20\20\61\61\u0559\2\u00cb\3\2\2\2\4\u00cd\3\2\2\2\6",
    "\u00d4\3\2\2\2\b\u00e6\3\2\2\2\n\u010a\3\2\2\2\f\u0126\3\2\2\2\16\u0147",
    "\3\2\2\2\20\u0149\3\2\2\2\22\u0157\3\2\2\2\24\u0159\3\2\2\2\26\u016a",
    "\3\2\2\2\30\u0178\3\2\2\2\32\u0186\3\2\2\2\34\u019a\3\2\2\2\36\u01a8",
    "\3\2\2\2 \u01b3\3\2\2\2\"\u01be\3\2\2\2$\u01c9\3\2\2\2&\u01d4\3\2\2",
    "\2(\u01df\3\2\2\2*\u01ec\3\2\2\2,\u01ee\3\2\2\2.\u01f0\3\2\2\2\60\u01fb",
    "\3\2\2\2\62\u0204\3\2\2\2\64\u0207\3\2\2\2\66\u020c\3\2\2\28\u0215\3",
    "\2\2\2:\u0217\3\2\2\2<\u0227\3\2\2\2>\u0229\3\2\2\2@\u0239\3\2\2\2B",
    "\u0246\3\2\2\2D\u0248\3\2\2\2F\u024a\3\2\2\2H\u025b\3\2\2\2J\u0265\3",
    "\2\2\2L\u0267\3\2\2\2N\u0278\3\2\2\2P\u028d\3\2\2\2R\u028f\3\2\2\2T",
    "\u029f\3\2\2\2V\u02a1\3\2\2\2X\u02a3\3\2\2\2Z\u02a8\3\2\2\2\\\u02b0",
    "\3\2\2\2^\u02bc\3\2\2\2`\u02bf\3\2\2\2b\u02ce\3\2\2\2d\u0309\3\2\2\2",
    "f\u030b\3\2\2\2h\u031b\3\2\2\2j\u0326\3\2\2\2l\u032f\3\2\2\2n\u0344",
    "\3\2\2\2p\u0346\3\2\2\2r\u0355\3\2\2\2t\u0357\3\2\2\2v\u0369\3\2\2\2",
    "x\u036b\3\2\2\2z\u0376\3\2\2\2|\u0385\3\2\2\2~\u03b5\3\2\2\2\u0080\u03e5",
    "\3\2\2\2\u0082\u03f1\3\2\2\2\u0084\u03f3\3\2\2\2\u0086\u0404\3\2\2\2",
    "\u0088\u0407\3\2\2\2\u008a\u0417\3\2\2\2\u008c\u0419\3\2\2\2\u008e\u044a",
    "\3\2\2\2\u0090\u0457\3\2\2\2\u0092\u0459\3\2\2\2\u0094\u045f\3\2\2\2",
    "\u0096\u046b\3\2\2\2\u0098\u046e\3\2\2\2\u009a\u0481\3\2\2\2\u009c\u04ad",
    "\3\2\2\2\u009e\u04bf\3\2\2\2\u00a0\u04c2\3\2\2\2\u00a2\u04c6\3\2\2\2",
    "\u00a4\u04d3\3\2\2\2\u00a6\u04d6\3\2\2\2\u00a8\u04de\3\2\2\2\u00aa\u00cc",
    "\7k\2\2\u00ab\u00cc\7l\2\2\u00ac\u00ae\7m\2\2\u00ad\u00ac\3\2\2\2\u00ae",
    "\u00af\3\2\2\2\u00af\u00ad\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00cc\3",
    "\2\2\2\u00b1\u00b2\7=\2\2\u00b2\u00b3\5.\30\2\u00b3\u00b4\7>\2\2\u00b4",
    "\u00cc\3\2\2\2\u00b5\u00cc\5\4\3\2\u00b6\u00b8\7\3\2\2\u00b7\u00b6\3",
    "\2\2\2\u00b7\u00b8\3\2\2\2\u00b8\u00b9\3\2\2\2\u00b9\u00ba\7=\2\2\u00ba",
    "\u00bb\5\u0092J\2\u00bb\u00bc\7>\2\2\u00bc\u00cc\3\2\2\2\u00bd\u00be",
    "\7\4\2\2\u00be\u00bf\7=\2\2\u00bf\u00c0\5\16\b\2\u00c0\u00c1\7Z\2\2",
    "\u00c1\u00c2\5z>\2\u00c2\u00c3\7>\2\2\u00c3\u00cc\3\2\2\2\u00c4\u00c5",
    "\7\5\2\2\u00c5\u00c6\7=\2\2\u00c6\u00c7\5z>\2\u00c7\u00c8\7Z\2\2\u00c8",
    "\u00c9\5\16\b\2\u00c9\u00ca\7>\2\2\u00ca\u00cc\3\2\2\2\u00cb\u00aa\3",
    "\2\2\2\u00cb\u00ab\3\2\2\2\u00cb\u00ad\3\2\2\2\u00cb\u00b1\3\2\2\2\u00cb",
    "\u00b5\3\2\2\2\u00cb\u00b7\3\2\2\2\u00cb\u00bd\3\2\2\2\u00cb\u00c4\3",
    "\2\2\2\u00cc\3\3\2\2\2\u00cd\u00ce\78\2\2\u00ce\u00cf\7=\2\2\u00cf\u00d0",
    "\5*\26\2\u00d0\u00d1\7Z\2\2\u00d1\u00d2\5\6\4\2\u00d2\u00d3\7>\2\2\u00d3",
    "\5\3\2\2\2\u00d4\u00d5\b\4\1\2\u00d5\u00d6\5\b\5\2\u00d6\u00dc\3\2\2",
    "\2\u00d7\u00d8\f\3\2\2\u00d8\u00d9\7Z\2\2\u00d9\u00db\5\b\5\2\u00da",
    "\u00d7\3\2\2\2\u00db\u00de\3\2\2\2\u00dc\u00da\3\2\2\2\u00dc\u00dd\3",
    "\2\2\2\u00dd\7\3\2\2\2\u00de\u00dc\3\2\2\2\u00df\u00e0\5z>\2\u00e0\u00e1",
    "\7X\2\2\u00e1\u00e2\5*\26\2\u00e2\u00e7\3\2\2\2\u00e3\u00e4\7\27\2\2",
    "\u00e4\u00e5\7X\2\2\u00e5\u00e7\5*\26\2\u00e6\u00df\3\2\2\2\u00e6\u00e3",
    "\3\2\2\2\u00e7\t\3\2\2\2\u00e8\u00e9\b\6\1\2\u00e9\u010b\5\2\2\2\u00ea",
    "\u00eb\7=\2\2\u00eb\u00ec\5z>\2\u00ec\u00ed\7>\2\2\u00ed\u00ee\7A\2",
    "\2\u00ee\u00ef\5\u0084C\2\u00ef\u00f0\7B\2\2\u00f0\u010b\3\2\2\2\u00f1",
    "\u00f2\7=\2\2\u00f2\u00f3\5z>\2\u00f3\u00f4\7>\2\2\u00f4\u00f5\7A\2",
    "\2\u00f5\u00f6\5\u0084C\2\u00f6\u00f7\7Z\2\2\u00f7\u00f8\7B\2\2\u00f8",
    "\u010b\3\2\2\2\u00f9\u00fa\7\3\2\2\u00fa\u00fb\7=\2\2\u00fb\u00fc\5",
    "z>\2\u00fc\u00fd\7>\2\2\u00fd\u00fe\7A\2\2\u00fe\u00ff\5\u0084C\2\u00ff",
    "\u0100\7B\2\2\u0100\u010b\3\2\2\2\u0101\u0102\7\3\2\2\u0102\u0103\7",
    "=\2\2\u0103\u0104\5z>\2\u0104\u0105\7>\2\2\u0105\u0106\7A\2\2\u0106",
    "\u0107\5\u0084C\2\u0107\u0108\7Z\2\2\u0108\u0109\7B\2\2\u0109\u010b",
    "\3\2\2\2\u010a\u00e8\3\2\2\2\u010a\u00ea\3\2\2\2\u010a\u00f1\3\2\2\2",
    "\u010a\u00f9\3\2\2\2\u010a\u0101\3\2\2\2\u010b\u0123\3\2\2\2\u010c\u010d",
    "\f\f\2\2\u010d\u010e\7?\2\2\u010e\u010f\5.\30\2\u010f\u0110\7@\2\2\u0110",
    "\u0122\3\2\2\2\u0111\u0112\f\13\2\2\u0112\u0114\7=\2\2\u0113\u0115\5",
    "\f\7\2\u0114\u0113\3\2\2\2\u0114\u0115\3\2\2\2\u0115\u0116\3\2\2\2\u0116",
    "\u0122\7>\2\2\u0117\u0118\f\n\2\2\u0118\u0119\7i\2\2\u0119\u0122\7k",
    "\2\2\u011a\u011b\f\t\2\2\u011b\u011c\7h\2\2\u011c\u0122\7k\2\2\u011d",
    "\u011e\f\b\2\2\u011e\u0122\7J\2\2\u011f\u0120\f\7\2\2\u0120\u0122\7",
    "L\2\2\u0121\u010c\3\2\2\2\u0121\u0111\3\2\2\2\u0121\u0117\3\2\2\2\u0121",
    "\u011a\3\2\2\2\u0121\u011d\3\2\2\2\u0121\u011f\3\2\2\2\u0122\u0125\3",
    "\2\2\2\u0123\u0121\3\2\2\2\u0123\u0124\3\2\2\2\u0124\13\3\2\2\2\u0125",
    "\u0123\3\2\2\2\u0126\u0127\b\7\1\2\u0127\u0128\5*\26\2\u0128\u012e\3",
    "\2\2\2\u0129\u012a\f\3\2\2\u012a\u012b\7Z\2\2\u012b\u012d\5*\26\2\u012c",
    "\u0129\3\2\2\2\u012d\u0130\3\2\2\2\u012e\u012c\3\2\2\2\u012e\u012f\3",
    "\2\2\2\u012f\r\3\2\2\2\u0130\u012e\3\2\2\2\u0131\u0148\5\n\6\2\u0132",
    "\u0133\7J\2\2\u0133\u0148\5\16\b\2\u0134\u0135\7L\2\2\u0135\u0148\5",
    "\16\b\2\u0136\u0137\5\20\t\2\u0137\u0138\5\22\n\2\u0138\u0148\3\2\2",
    "\2\u0139\u013a\7)\2\2\u013a\u0148\5\16\b\2\u013b\u013c\7)\2\2\u013c",
    "\u013d\7=\2\2\u013d\u013e\5z>\2\u013e\u013f\7>\2\2\u013f\u0148\3\2\2",
    "\2\u0140\u0141\7\64\2\2\u0141\u0142\7=\2\2\u0142\u0143\5z>\2\u0143\u0144",
    "\7>\2\2\u0144\u0148\3\2\2\2\u0145\u0146\7R\2\2\u0146\u0148\7k\2\2\u0147",
    "\u0131\3\2\2\2\u0147\u0132\3\2\2\2\u0147\u0134\3\2\2\2\u0147\u0136\3",
    "\2\2\2\u0147\u0139\3\2\2\2\u0147\u013b\3\2\2\2\u0147\u0140\3\2\2\2\u0147",
    "\u0145\3\2\2\2\u0148\17\3\2\2\2\u0149\u014a\t\2\2\2\u014a\21\3\2\2\2",
    "\u014b\u0158\5\16\b\2\u014c\u014d\7=\2\2\u014d\u014e\5z>\2\u014e\u014f",
    "\7>\2\2\u014f\u0150\5\22\n\2\u0150\u0158\3\2\2\2\u0151\u0152\7\3\2\2",
    "\u0152\u0153\7=\2\2\u0153\u0154\5z>\2\u0154\u0155\7>\2\2\u0155\u0156",
    "\5\22\n\2\u0156\u0158\3\2\2\2\u0157\u014b\3\2\2\2\u0157\u014c\3\2\2",
    "\2\u0157\u0151\3\2\2\2\u0158\23\3\2\2\2\u0159\u015a\b\13\1\2\u015a\u015b",
    "\5\22\n\2\u015b\u0167\3\2\2\2\u015c\u015d\f\5\2\2\u015d\u015e\7M\2\2",
    "\u015e\u0166\5\22\n\2\u015f\u0160\f\4\2\2\u0160\u0161\7N\2\2\u0161\u0166",
    "\5\22\n\2\u0162\u0163\f\3\2\2\u0163\u0164\7O\2\2\u0164\u0166\5\22\n",
    "\2\u0165\u015c\3\2\2\2\u0165\u015f\3\2\2\2\u0165\u0162\3\2\2\2\u0166",
    "\u0169\3\2\2\2\u0167\u0165\3\2\2\2\u0167\u0168\3\2\2\2\u0168\25\3\2",
    "\2\2\u0169\u0167\3\2\2\2\u016a\u016b\b\f\1\2\u016b\u016c\5\24\13\2\u016c",
    "\u0175\3\2\2\2\u016d\u016e\f\4\2\2\u016e\u016f\7I\2\2\u016f\u0174\5",
    "\24\13\2\u0170\u0171\f\3\2\2\u0171\u0172\7K\2\2\u0172\u0174\5\24\13",
    "\2\u0173\u016d\3\2\2\2\u0173\u0170\3\2\2\2\u0174\u0177\3\2\2\2\u0175",
    "\u0173\3\2\2\2\u0175\u0176\3\2\2\2\u0176\27\3\2\2\2\u0177\u0175\3\2",
    "\2\2\u0178\u0179\b\r\1\2\u0179\u017a\5\26\f\2\u017a\u0183\3\2\2\2\u017b",
    "\u017c\f\4\2\2\u017c\u017d\7G\2\2\u017d\u0182\5\26\f\2\u017e\u017f\f",
    "\3\2\2\u017f\u0180\7H\2\2\u0180\u0182\5\26\f\2\u0181\u017b\3\2\2\2\u0181",
    "\u017e\3\2\2\2\u0182\u0185\3\2\2\2\u0183\u0181\3\2\2\2\u0183\u0184\3",
    "\2\2\2\u0184\31\3\2\2\2\u0185\u0183\3\2\2\2\u0186\u0187\b\16\1\2\u0187",
    "\u0188\5\30\r\2\u0188\u0197\3\2\2\2\u0189\u018a\f\6\2\2\u018a\u018b",
    "\7C\2\2\u018b\u0196\5\30\r\2\u018c\u018d\f\5\2\2\u018d\u018e\7E\2\2",
    "\u018e\u0196\5\30\r\2\u018f\u0190\f\4\2\2\u0190\u0191\7D\2\2\u0191\u0196",
    "\5\30\r\2\u0192\u0193\f\3\2\2\u0193\u0194\7F\2\2\u0194\u0196\5\30\r",
    "\2\u0195\u0189\3\2\2\2\u0195\u018c\3\2\2\2\u0195\u018f\3\2\2\2\u0195",
    "\u0192\3\2\2\2\u0196\u0199\3\2\2\2\u0197\u0195\3\2\2\2\u0197\u0198\3",
    "\2\2\2\u0198\33\3\2\2\2\u0199\u0197\3\2\2\2\u019a\u019b\b\17\1\2\u019b",
    "\u019c\5\32\16\2\u019c\u01a5\3\2\2\2\u019d\u019e\f\4\2\2\u019e\u019f",
    "\7f\2\2\u019f\u01a4\5\32\16\2\u01a0\u01a1\f\3\2\2\u01a1\u01a2\7g\2\2",
    "\u01a2\u01a4\5\32\16\2\u01a3\u019d\3\2\2\2\u01a3\u01a0\3\2\2\2\u01a4",
    "\u01a7\3\2\2\2\u01a5\u01a3\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\35\3\2",
    "\2\2\u01a7\u01a5\3\2\2\2\u01a8\u01a9\b\20\1\2\u01a9\u01aa\5\34\17\2",
    "\u01aa\u01b0\3\2\2\2\u01ab\u01ac\f\3\2\2\u01ac\u01ad\7P\2\2\u01ad\u01af",
    "\5\34\17\2\u01ae\u01ab\3\2\2\2\u01af\u01b2\3\2\2\2\u01b0\u01ae\3\2\2",
    "\2\u01b0\u01b1\3\2\2\2\u01b1\37\3\2\2\2\u01b2\u01b0\3\2\2\2\u01b3\u01b4",
    "\b\21\1\2\u01b4\u01b5\5\36\20\2\u01b5\u01bb\3\2\2\2\u01b6\u01b7\f\3",
    "\2\2\u01b7\u01b8\7T\2\2\u01b8\u01ba\5\36\20\2\u01b9\u01b6\3\2\2\2\u01ba",
    "\u01bd\3\2\2\2\u01bb\u01b9\3\2\2\2\u01bb\u01bc\3\2\2\2\u01bc!\3\2\2",
    "\2\u01bd\u01bb\3\2\2\2\u01be\u01bf\b\22\1\2\u01bf\u01c0\5 \21\2\u01c0",
    "\u01c6\3\2\2\2\u01c1\u01c2\f\3\2\2\u01c2\u01c3\7Q\2\2\u01c3\u01c5\5",
    " \21\2\u01c4\u01c1\3\2\2\2\u01c5\u01c8\3\2\2\2\u01c6\u01c4\3\2\2\2\u01c6",
    "\u01c7\3\2\2\2\u01c7#\3\2\2\2\u01c8\u01c6\3\2\2\2\u01c9\u01ca\b\23\1",
    "\2\u01ca\u01cb\5\"\22\2\u01cb\u01d1\3\2\2\2\u01cc\u01cd\f\3\2\2\u01cd",
    "\u01ce\7R\2\2\u01ce\u01d0\5\"\22\2\u01cf\u01cc\3\2\2\2\u01d0\u01d3\3",
    "\2\2\2\u01d1\u01cf\3\2\2\2\u01d1\u01d2\3\2\2\2\u01d2%\3\2\2\2\u01d3",
    "\u01d1\3\2\2\2\u01d4\u01d5\b\24\1\2\u01d5\u01d6\5$\23\2\u01d6\u01dc",
    "\3\2\2\2\u01d7\u01d8\f\3\2\2\u01d8\u01d9\7S\2\2\u01d9\u01db\5$\23\2",
    "\u01da\u01d7\3\2\2\2\u01db\u01de\3\2\2\2\u01dc\u01da\3\2\2\2\u01dc\u01dd",
    "\3\2\2\2\u01dd\'\3\2\2\2\u01de\u01dc\3\2\2\2\u01df\u01e5\5&\24\2\u01e0",
    "\u01e1\7W\2\2\u01e1\u01e2\5.\30\2\u01e2\u01e3\7X\2\2\u01e3\u01e4\5(",
    "\25\2\u01e4\u01e6\3\2\2\2\u01e5\u01e0\3\2\2\2\u01e5\u01e6\3\2\2\2\u01e6",
    ")\3\2\2\2\u01e7\u01ed\5(\25\2\u01e8\u01e9\5\16\b\2\u01e9\u01ea\5,\27",
    "\2\u01ea\u01eb\5*\26\2\u01eb\u01ed\3\2\2\2\u01ec\u01e7\3\2\2\2\u01ec",
    "\u01e8\3\2\2\2\u01ed+\3\2\2\2\u01ee\u01ef\t\3\2\2\u01ef-\3\2\2\2\u01f0",
    "\u01f1\b\30\1\2\u01f1\u01f2\5*\26\2\u01f2\u01f8\3\2\2\2\u01f3\u01f4",
    "\f\3\2\2\u01f4\u01f5\7Z\2\2\u01f5\u01f7\5*\26\2\u01f6\u01f3\3\2\2\2",
    "\u01f7\u01fa\3\2\2\2\u01f8\u01f6\3\2\2\2\u01f8\u01f9\3\2\2\2\u01f9/",
    "\3\2\2\2\u01fa\u01f8\3\2\2\2\u01fb\u01fc\5(\25\2\u01fc\61\3\2\2\2\u01fd",
    "\u01ff\5\64\33\2\u01fe\u0200\5:\36\2\u01ff\u01fe\3\2\2\2\u01ff\u0200",
    "\3\2\2\2\u0200\u0201\3\2\2\2\u0201\u0202\7Y\2\2\u0202\u0205\3\2\2\2",
    "\u0203\u0205\5\u008cG\2\u0204\u01fd\3\2\2\2\u0204\u0203\3\2\2\2\u0205",
    "\63\3\2\2\2\u0206\u0208\58\35\2\u0207\u0206\3\2\2\2\u0208\u0209\3\2",
    "\2\2\u0209\u0207\3\2\2\2\u0209\u020a\3\2\2\2\u020a\65\3\2\2\2\u020b",
    "\u020d\58\35\2\u020c\u020b\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u020c\3",
    "\2\2\2\u020e\u020f\3\2\2\2\u020f\67\3\2\2\2\u0210\u0216\5> \2\u0211",
    "\u0216\5@!\2\u0212\u0216\5Z.\2\u0213\u0216\5\\/\2\u0214\u0216\5^\60",
    "\2\u0215\u0210\3\2\2\2\u0215\u0211\3\2\2\2\u0215\u0212\3\2\2\2\u0215",
    "\u0213\3\2\2\2\u0215\u0214\3\2\2\2\u02169\3\2\2\2\u0217\u0218\b\36\1",
    "\2\u0218\u0219\5<\37\2\u0219\u021f\3\2\2\2\u021a\u021b\f\3\2\2\u021b",
    "\u021c\7Z\2\2\u021c\u021e\5<\37\2\u021d\u021a\3\2\2\2\u021e\u0221\3",
    "\2\2\2\u021f\u021d\3\2\2\2\u021f\u0220\3\2\2\2\u0220;\3\2\2\2\u0221",
    "\u021f\3\2\2\2\u0222\u0228\5`\61\2\u0223\u0224\5`\61\2\u0224\u0225\7",
    "[\2\2\u0225\u0226\5\u0082B\2\u0226\u0228\3\2\2\2\u0227\u0222\3\2\2\2",
    "\u0227\u0223\3\2\2\2\u0228=\3\2\2\2\u0229\u022a\t\4\2\2\u022a?\3\2\2",
    "\2\u022b\u023a\t\5\2\2\u022c\u022d\7\3\2\2\u022d\u022e\7=\2\2\u022e",
    "\u022f\t\6\2\2\u022f\u023a\7>\2\2\u0230\u023a\5X-\2\u0231\u023a\5B\"",
    "\2\u0232\u023a\5P)\2\u0233\u023a\5\u0080A\2\u0234\u0235\7\t\2\2\u0235",
    "\u0236\7=\2\2\u0236\u0237\5\60\31\2\u0237\u0238\7>\2\2\u0238\u023a\3",
    "\2\2\2\u0239\u022b\3\2\2\2\u0239\u022c\3\2\2\2\u0239\u0230\3\2\2\2\u0239",
    "\u0231\3\2\2\2\u0239\u0232\3\2\2\2\u0239\u0233\3\2\2\2\u0239\u0234\3",
    "\2\2\2\u023aA\3\2\2\2\u023b\u023d\5D#\2\u023c\u023e\7k\2\2\u023d\u023c",
    "\3\2\2\2\u023d\u023e\3\2\2\2\u023e\u023f\3\2\2\2\u023f\u0240\7A\2\2",
    "\u0240\u0241\5F$\2\u0241\u0242\7B\2\2\u0242\u0247\3\2\2\2\u0243\u0244",
    "\5D#\2\u0244\u0245\7k\2\2\u0245\u0247\3\2\2\2\u0246\u023b\3\2\2\2\u0246",
    "\u0243\3\2\2\2\u0247C\3\2\2\2\u0248\u0249\t\7\2\2\u0249E\3\2\2\2\u024a",
    "\u024b\b$\1\2\u024b\u024c\5H%\2\u024c\u0251\3\2\2\2\u024d\u024e\f\3",
    "\2\2\u024e\u0250\5H%\2\u024f\u024d\3\2\2\2\u0250\u0253\3\2\2\2\u0251",
    "\u024f\3\2\2\2\u0251\u0252\3\2\2\2\u0252G\3\2\2\2\u0253\u0251\3\2\2",
    "\2\u0254\u0256\5J&\2\u0255\u0257\5L\'\2\u0256\u0255\3\2\2\2\u0256\u0257",
    "\3\2\2\2\u0257\u0258\3\2\2\2\u0258\u0259\7Y\2\2\u0259\u025c\3\2\2\2",
    "\u025a\u025c\5\u008cG\2\u025b\u0254\3\2\2\2\u025b\u025a\3\2\2\2\u025c",
    "I\3\2\2\2\u025d\u025f\5@!\2\u025e\u0260\5J&\2\u025f\u025e\3\2\2\2\u025f",
    "\u0260\3\2\2\2\u0260\u0266\3\2\2\2\u0261\u0263\5Z.\2\u0262\u0264\5J",
    "&\2\u0263\u0262\3\2\2\2\u0263\u0264\3\2\2\2\u0264\u0266\3\2\2\2\u0265",
    "\u025d\3\2\2\2\u0265\u0261\3\2\2\2\u0266K\3\2\2\2\u0267\u0268\b\'\1",
    "\2\u0268\u0269\5N(\2\u0269\u026f\3\2\2\2\u026a\u026b\f\3\2\2\u026b\u026c",
    "\7Z\2\2\u026c\u026e\5N(\2\u026d\u026a\3\2\2\2\u026e\u0271\3\2\2\2\u026f",
    "\u026d\3\2\2\2\u026f\u0270\3\2\2\2\u0270M\3\2\2\2\u0271\u026f\3\2\2",
    "\2\u0272\u0279\5`\61\2\u0273\u0275\5`\61\2\u0274\u0273\3\2\2\2\u0274",
    "\u0275\3\2\2\2\u0275\u0276\3\2\2\2\u0276\u0277\7X\2\2\u0277\u0279\5",
    "\60\31\2\u0278\u0272\3\2\2\2\u0278\u0274\3\2\2\2\u0279O\3\2\2\2\u027a",
    "\u027c\7\33\2\2\u027b\u027d\7k\2\2\u027c\u027b\3\2\2\2\u027c\u027d\3",
    "\2\2\2\u027d\u027e\3\2\2\2\u027e\u027f\7A\2\2\u027f\u0280\5R*\2\u0280",
    "\u0281\7B\2\2\u0281\u028e\3\2\2\2\u0282\u0284\7\33\2\2\u0283\u0285\7",
    "k\2\2\u0284\u0283\3\2\2\2\u0284\u0285\3\2\2\2\u0285\u0286\3\2\2\2\u0286",
    "\u0287\7A\2\2\u0287\u0288\5R*\2\u0288\u0289\7Z\2\2\u0289\u028a\7B\2",
    "\2\u028a\u028e\3\2\2\2\u028b\u028c\7\33\2\2\u028c\u028e\7k\2\2\u028d",
    "\u027a\3\2\2\2\u028d\u0282\3\2\2\2\u028d\u028b\3\2\2\2\u028eQ\3\2\2",
    "\2\u028f\u0290\b*\1\2\u0290\u0291\5T+\2\u0291\u0297\3\2\2\2\u0292\u0293",
    "\f\3\2\2\u0293\u0294\7Z\2\2\u0294\u0296\5T+\2\u0295\u0292\3\2\2\2\u0296",
    "\u0299\3\2\2\2\u0297\u0295\3\2\2\2\u0297\u0298\3\2\2\2\u0298S\3\2\2",
    "\2\u0299\u0297\3\2\2\2\u029a\u02a0\5V,\2\u029b\u029c\5V,\2\u029c\u029d",
    "\7[\2\2\u029d\u029e\5\60\31\2\u029e\u02a0\3\2\2\2\u029f\u029a\3\2\2",
    "\2\u029f\u029b\3\2\2\2\u02a0U\3\2\2\2\u02a1\u02a2\7k\2\2\u02a2W\3\2",
    "\2\2\u02a3\u02a4\7\65\2\2\u02a4\u02a5\7=\2\2\u02a5\u02a6\5z>\2\u02a6",
    "\u02a7\7>\2\2\u02a7Y\3\2\2\2\u02a8\u02a9\t\b\2\2\u02a9[\3\2\2\2\u02aa",
    "\u02b1\t\t\2\2\u02ab\u02b1\5f\64\2\u02ac\u02ad\7\f\2\2\u02ad\u02ae\7",
    "=\2\2\u02ae\u02af\7k\2\2\u02af\u02b1\7>\2\2\u02b0\u02aa\3\2\2\2\u02b0",
    "\u02ab\3\2\2\2\u02b0\u02ac\3\2\2\2\u02b1]\3\2\2\2\u02b2\u02b3\7\63\2",
    "\2\u02b3\u02b4\7=\2\2\u02b4\u02b5\5z>\2\u02b5\u02b6\7>\2\2\u02b6\u02bd",
    "\3\2\2\2\u02b7\u02b8\7\63\2\2\u02b8\u02b9\7=\2\2\u02b9\u02ba\5\60\31",
    "\2\u02ba\u02bb\7>\2\2\u02bb\u02bd\3\2\2\2\u02bc\u02b2\3\2\2\2\u02bc",
    "\u02b7\3\2\2\2\u02bd_\3\2\2\2\u02be\u02c0\5n8\2\u02bf\u02be\3\2\2\2",
    "\u02bf\u02c0\3\2\2\2\u02c0\u02c1\3\2\2\2\u02c1\u02c5\5b\62\2\u02c2\u02c4",
    "\5d\63\2\u02c3\u02c2\3\2\2\2\u02c4\u02c7\3\2\2\2\u02c5\u02c3\3\2\2\2",
    "\u02c5\u02c6\3\2\2\2\u02c6a\3\2\2\2\u02c7\u02c5\3\2\2\2\u02c8\u02c9",
    "\b\62\1\2\u02c9\u02cf\7k\2\2\u02ca\u02cb\7=\2\2\u02cb\u02cc\5`\61\2",
    "\u02cc\u02cd\7>\2\2\u02cd\u02cf\3\2\2\2\u02ce\u02c8\3\2\2\2\u02ce\u02ca",
    "\3\2\2\2\u02cf\u02fd\3\2\2\2\u02d0\u02d1\f\b\2\2\u02d1\u02d3\7?\2\2",
    "\u02d2\u02d4\5p9\2\u02d3\u02d2\3\2\2\2\u02d3\u02d4\3\2\2\2\u02d4\u02d6",
    "\3\2\2\2\u02d5\u02d7\5*\26\2\u02d6\u02d5\3\2\2\2\u02d6\u02d7\3\2\2\2",
    "\u02d7\u02d8\3\2\2\2\u02d8\u02fc\7@\2\2\u02d9\u02da\f\7\2\2\u02da\u02db",
    "\7?\2\2\u02db\u02dd\7*\2\2\u02dc\u02de\5p9\2\u02dd\u02dc\3\2\2\2\u02dd",
    "\u02de\3\2\2\2\u02de\u02df\3\2\2\2\u02df\u02e0\5*\26\2\u02e0\u02e1\7",
    "@\2\2\u02e1\u02fc\3\2\2\2\u02e2\u02e3\f\6\2\2\u02e3\u02e4\7?\2\2\u02e4",
    "\u02e5\5p9\2\u02e5\u02e6\7*\2\2\u02e6\u02e7\5*\26\2\u02e7\u02e8\7@\2",
    "\2\u02e8\u02fc\3\2\2\2\u02e9\u02ea\f\5\2\2\u02ea\u02ec\7?\2\2\u02eb",
    "\u02ed\5p9\2\u02ec\u02eb\3\2\2\2\u02ec\u02ed\3\2\2\2\u02ed\u02ee\3\2",
    "\2\2\u02ee\u02ef\7M\2\2\u02ef\u02fc\7@\2\2\u02f0\u02f1\f\4\2\2\u02f1",
    "\u02f2\7=\2\2\u02f2\u02f3\5r:\2\u02f3\u02f4\7>\2\2\u02f4\u02fc\3\2\2",
    "\2\u02f5\u02f6\f\3\2\2\u02f6\u02f8\7=\2\2\u02f7\u02f9\5x=\2\u02f8\u02f7",
    "\3\2\2\2\u02f8\u02f9\3\2\2\2\u02f9\u02fa\3\2\2\2\u02fa\u02fc\7>\2\2",
    "\u02fb\u02d0\3\2\2\2\u02fb\u02d9\3\2\2\2\u02fb\u02e2\3\2\2\2\u02fb\u02e9",
    "\3\2\2\2\u02fb\u02f0\3\2\2\2\u02fb\u02f5\3\2\2\2\u02fc\u02ff\3\2\2\2",
    "\u02fd\u02fb\3\2\2\2\u02fd\u02fe\3\2\2\2\u02fec\3\2\2\2\u02ff\u02fd",
    "\3\2\2\2\u0300\u0301\7\r\2\2\u0301\u0303\7=\2\2\u0302\u0304\7m\2\2\u0303",
    "\u0302\3\2\2\2\u0304\u0305\3\2\2\2\u0305\u0303\3\2\2\2\u0305\u0306\3",
    "\2\2\2\u0306\u0307\3\2\2\2\u0307\u030a\7>\2\2\u0308\u030a\5f\64\2\u0309",
    "\u0300\3\2\2\2\u0309\u0308\3\2\2\2\u030ae\3\2\2\2\u030b\u030c\7\16\2",
    "\2\u030c\u030d\7=\2\2\u030d\u030e\7=\2\2\u030e\u030f\5h\65\2\u030f\u0310",
    "\7>\2\2\u0310\u0311\7>\2\2\u0311g\3\2\2\2\u0312\u0317\5j\66\2\u0313",
    "\u0314\7Z\2\2\u0314\u0316\5j\66\2\u0315\u0313\3\2\2\2\u0316\u0319\3",
    "\2\2\2\u0317\u0315\3\2\2\2\u0317\u0318\3\2\2\2\u0318\u031c\3\2\2\2\u0319",
    "\u0317\3\2\2\2\u031a\u031c\3\2\2\2\u031b\u0312\3\2\2\2\u031b\u031a\3",
    "\2\2\2\u031ci\3\2\2\2\u031d\u0323\n\n\2\2\u031e\u0320\7=\2\2\u031f\u0321",
    "\5\f\7\2\u0320\u031f\3\2\2\2\u0320\u0321\3\2\2\2\u0321\u0322\3\2\2\2",
    "\u0322\u0324\7>\2\2\u0323\u031e\3\2\2\2\u0323\u0324\3\2\2\2\u0324\u0327",
    "\3\2\2\2\u0325\u0327\3\2\2\2\u0326\u031d\3\2\2\2\u0326\u0325\3\2\2\2",
    "\u0327k\3\2\2\2\u0328\u032e\n\13\2\2\u0329\u032a\7=\2\2\u032a\u032b",
    "\5l\67\2\u032b\u032c\7>\2\2\u032c\u032e\3\2\2\2\u032d\u0328\3\2\2\2",
    "\u032d\u0329\3\2\2\2\u032e\u0331\3\2\2\2\u032f\u032d\3\2\2\2\u032f\u0330",
    "\3\2\2\2\u0330m\3\2\2\2\u0331\u032f\3\2\2\2\u0332\u0334\7M\2\2\u0333",
    "\u0335\5p9\2\u0334\u0333\3\2\2\2\u0334\u0335\3\2\2\2\u0335\u0345\3\2",
    "\2\2\u0336\u0338\7M\2\2\u0337\u0339\5p9\2\u0338\u0337\3\2\2\2\u0338",
    "\u0339\3\2\2\2\u0339\u033a\3\2\2\2\u033a\u0345\5n8\2\u033b\u033d\7T",
    "\2\2\u033c\u033e\5p9\2\u033d\u033c\3\2\2\2\u033d\u033e\3\2\2\2\u033e",
    "\u0345\3\2\2\2\u033f\u0341\7T\2\2\u0340\u0342\5p9\2\u0341\u0340\3\2",
    "\2\2\u0341\u0342\3\2\2\2\u0342\u0343\3\2\2\2\u0343\u0345\5n8\2\u0344",
    "\u0332\3\2\2\2\u0344\u0336\3\2\2\2\u0344\u033b\3\2\2\2\u0344\u033f\3",
    "\2\2\2\u0345o\3\2\2\2\u0346\u0347\b9\1\2\u0347\u0348\5Z.\2\u0348\u034d",
    "\3\2\2\2\u0349\u034a\f\3\2\2\u034a\u034c\5Z.\2\u034b\u0349\3\2\2\2\u034c",
    "\u034f\3\2\2\2\u034d\u034b\3\2\2\2\u034d\u034e\3\2\2\2\u034eq\3\2\2",
    "\2\u034f\u034d\3\2\2\2\u0350\u0356\5t;\2\u0351\u0352\5t;\2\u0352\u0353",
    "\7Z\2\2\u0353\u0354\7j\2\2\u0354\u0356\3\2\2\2\u0355\u0350\3\2\2\2\u0355",
    "\u0351\3\2\2\2\u0356s\3\2\2\2\u0357\u0358\b;\1\2\u0358\u0359\5v<\2\u0359",
    "\u035f\3\2\2\2\u035a\u035b\f\3\2\2\u035b\u035c\7Z\2\2\u035c\u035e\5",
    "v<\2\u035d\u035a\3\2\2\2\u035e\u0361\3\2\2\2\u035f\u035d\3\2\2\2\u035f",
    "\u0360\3\2\2\2\u0360u\3\2\2\2\u0361\u035f\3\2\2\2\u0362\u0363\5\64\33",
    "\2\u0363\u0364\5`\61\2\u0364\u036a\3\2\2\2\u0365\u0367\5\66\34\2\u0366",
    "\u0368\5|?\2\u0367\u0366\3\2\2\2\u0367\u0368\3\2\2\2\u0368\u036a\3\2",
    "\2\2\u0369\u0362\3\2\2\2\u0369\u0365\3\2\2\2\u036aw\3\2\2\2\u036b\u036c",
    "\b=\1\2\u036c\u036d\7k\2\2\u036d\u0373\3\2\2\2\u036e\u036f\f\3\2\2\u036f",
    "\u0370\7Z\2\2\u0370\u0372\7k\2\2\u0371\u036e\3\2\2\2\u0372\u0375\3\2",
    "\2\2\u0373\u0371\3\2\2\2\u0373\u0374\3\2\2\2\u0374y\3\2\2\2\u0375\u0373",
    "\3\2\2\2\u0376\u0378\5J&\2\u0377\u0379\5|?\2\u0378\u0377\3\2\2\2\u0378",
    "\u0379\3\2\2\2\u0379{\3\2\2\2\u037a\u0386\5n8\2\u037b\u037d\5n8\2\u037c",
    "\u037b\3\2\2\2\u037c\u037d\3\2\2\2\u037d\u037e\3\2\2\2\u037e\u0382\5",
    "~@\2\u037f\u0381\5d\63\2\u0380\u037f\3\2\2\2\u0381\u0384\3\2\2\2\u0382",
    "\u0380\3\2\2\2\u0382\u0383\3\2\2\2\u0383\u0386\3\2\2\2\u0384\u0382\3",
    "\2\2\2\u0385\u037a\3\2\2\2\u0385\u037c\3\2\2\2\u0386}\3\2\2\2\u0387",
    "\u0388\b@\1\2\u0388\u0389\7=\2\2\u0389\u038a\5|?\2\u038a\u038e\7>\2",
    "\2\u038b\u038d\5d\63\2\u038c\u038b\3\2\2\2\u038d\u0390\3\2\2\2\u038e",
    "\u038c\3\2\2\2\u038e\u038f\3\2\2\2\u038f\u03b6\3\2\2\2\u0390\u038e\3",
    "\2\2\2\u0391\u0393\7?\2\2\u0392\u0394\5p9\2\u0393\u0392\3\2\2\2\u0393",
    "\u0394\3\2\2\2\u0394\u0396\3\2\2\2\u0395\u0397\5*\26\2\u0396\u0395\3",
    "\2\2\2\u0396\u0397\3\2\2\2\u0397\u0398\3\2\2\2\u0398\u03b6\7@\2\2\u0399",
    "\u039a\7?\2\2\u039a\u039c\7*\2\2\u039b\u039d\5p9\2\u039c\u039b\3\2\2",
    "\2\u039c\u039d\3\2\2\2\u039d\u039e\3\2\2\2\u039e\u039f\5*\26\2\u039f",
    "\u03a0\7@\2\2\u03a0\u03b6\3\2\2\2\u03a1\u03a2\7?\2\2\u03a2\u03a3\5p",
    "9\2\u03a3\u03a4\7*\2\2\u03a4\u03a5\5*\26\2\u03a5\u03a6\7@\2\2\u03a6",
    "\u03b6\3\2\2\2\u03a7\u03a8\7?\2\2\u03a8\u03a9\7M\2\2\u03a9\u03b6\7@",
    "\2\2\u03aa\u03ac\7=\2\2\u03ab\u03ad\5r:\2\u03ac\u03ab\3\2\2\2\u03ac",
    "\u03ad\3\2\2\2\u03ad\u03ae\3\2\2\2\u03ae\u03b2\7>\2\2\u03af\u03b1\5",
    "d\63\2\u03b0\u03af\3\2\2\2\u03b1\u03b4\3\2\2\2\u03b2\u03b0\3\2\2\2\u03b2",
    "\u03b3\3\2\2\2\u03b3\u03b6\3\2\2\2\u03b4\u03b2\3\2\2\2\u03b5\u0387\3",
    "\2\2\2\u03b5\u0391\3\2\2\2\u03b5\u0399\3\2\2\2\u03b5\u03a1\3\2\2\2\u03b5",
    "\u03a7\3\2\2\2\u03b5\u03aa\3\2\2\2\u03b6\u03e2\3\2\2\2\u03b7\u03b8\f",
    "\7\2\2\u03b8\u03ba\7?\2\2\u03b9\u03bb\5p9\2\u03ba\u03b9\3\2\2\2\u03ba",
    "\u03bb\3\2\2\2\u03bb\u03bd\3\2\2\2\u03bc\u03be\5*\26\2\u03bd\u03bc\3",
    "\2\2\2\u03bd\u03be\3\2\2\2\u03be\u03bf\3\2\2\2\u03bf\u03e1\7@\2\2\u03c0",
    "\u03c1\f\6\2\2\u03c1\u03c2\7?\2\2\u03c2\u03c4\7*\2\2\u03c3\u03c5\5p",
    "9\2\u03c4\u03c3\3\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u03c6\3\2\2\2\u03c6",
    "\u03c7\5*\26\2\u03c7\u03c8\7@\2\2\u03c8\u03e1\3\2\2\2\u03c9\u03ca\f",
    "\5\2\2\u03ca\u03cb\7?\2\2\u03cb\u03cc\5p9\2\u03cc\u03cd\7*\2\2\u03cd",
    "\u03ce\5*\26\2\u03ce\u03cf\7@\2\2\u03cf\u03e1\3\2\2\2\u03d0\u03d1\f",
    "\4\2\2\u03d1\u03d2\7?\2\2\u03d2\u03d3\7M\2\2\u03d3\u03e1\7@\2\2\u03d4",
    "\u03d5\f\3\2\2\u03d5\u03d7\7=\2\2\u03d6\u03d8\5r:\2\u03d7\u03d6\3\2",
    "\2\2\u03d7\u03d8\3\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u03dd\7>\2\2\u03da",
    "\u03dc\5d\63\2\u03db\u03da\3\2\2\2\u03dc\u03df\3\2\2\2\u03dd\u03db\3",
    "\2\2\2\u03dd\u03de\3\2\2\2\u03de\u03e1\3\2\2\2\u03df\u03dd\3\2\2\2\u03e0",
    "\u03b7\3\2\2\2\u03e0\u03c0\3\2\2\2\u03e0\u03c9\3\2\2\2\u03e0\u03d0\3",
    "\2\2\2\u03e0\u03d4\3\2\2\2\u03e1\u03e4\3\2\2\2\u03e2\u03e0\3\2\2\2\u03e2",
    "\u03e3\3\2\2\2\u03e3\177\3\2\2\2\u03e4\u03e2\3\2\2\2\u03e5\u03e6\7k",
    "\2\2\u03e6\u0081\3\2\2\2\u03e7\u03f2\5*\26\2\u03e8\u03e9\7A\2\2\u03e9",
    "\u03ea\5\u0084C\2\u03ea\u03eb\7B\2\2\u03eb\u03f2\3\2\2\2\u03ec\u03ed",
    "\7A\2\2\u03ed\u03ee\5\u0084C\2\u03ee\u03ef\7Z\2\2\u03ef\u03f0\7B\2\2",
    "\u03f0\u03f2\3\2\2\2\u03f1\u03e7\3\2\2\2\u03f1\u03e8\3\2\2\2\u03f1\u03ec",
    "\3\2\2\2\u03f2\u0083\3\2\2\2\u03f3\u03f5\bC\1\2\u03f4\u03f6\5\u0086",
    "D\2\u03f5\u03f4\3\2\2\2\u03f5\u03f6\3\2\2\2\u03f6\u03f7\3\2\2\2\u03f7",
    "\u03f8\5\u0082B\2\u03f8\u0401\3\2\2\2\u03f9\u03fa\f\3\2\2\u03fa\u03fc",
    "\7Z\2\2\u03fb\u03fd\5\u0086D\2\u03fc\u03fb\3\2\2\2\u03fc\u03fd\3\2\2",
    "\2\u03fd\u03fe\3\2\2\2\u03fe\u0400\5\u0082B\2\u03ff\u03f9\3\2\2\2\u0400",
    "\u0403\3\2\2\2\u0401\u03ff\3\2\2\2\u0401\u0402\3\2\2\2\u0402\u0085\3",
    "\2\2\2\u0403\u0401\3\2\2\2\u0404\u0405\5\u0088E\2\u0405\u0406\7[\2\2",
    "\u0406\u0087\3\2\2\2\u0407\u0408\bE\1\2\u0408\u0409\5\u008aF\2\u0409",
    "\u040e\3\2\2\2\u040a\u040b\f\3\2\2\u040b\u040d\5\u008aF\2\u040c\u040a",
    "\3\2\2\2\u040d\u0410\3\2\2\2\u040e\u040c\3\2\2\2\u040e\u040f\3\2\2\2",
    "\u040f\u0089\3\2\2\2\u0410\u040e\3\2\2\2\u0411\u0412\7?\2\2\u0412\u0413",
    "\5\60\31\2\u0413\u0414\7@\2\2\u0414\u0418\3\2\2\2\u0415\u0416\7i\2\2",
    "\u0416\u0418\7k\2\2\u0417\u0411\3\2\2\2\u0417\u0415\3\2\2\2\u0418\u008b",
    "\3\2\2\2\u0419\u041a\7;\2\2\u041a\u041b\7=\2\2\u041b\u041c\5\60\31\2",
    "\u041c\u041e\7Z\2\2\u041d\u041f\7m\2\2\u041e\u041d\3\2\2\2\u041f\u0420",
    "\3\2\2\2\u0420\u041e\3\2\2\2\u0420\u0421\3\2\2\2\u0421\u0422\3\2\2\2",
    "\u0422\u0423\7>\2\2\u0423\u0424\7Y\2\2\u0424\u008d\3\2\2\2\u0425\u044b",
    "\5\u0090I\2\u0426\u044b\5\u0092J\2\u0427\u044b\5\u0098M\2\u0428\u044b",
    "\5\u009aN\2\u0429\u044b\5\u009cO\2\u042a\u044b\5\u009eP\2\u042b\u042c",
    "\t\f\2\2\u042c\u042d\t\r\2\2\u042d\u0436\7=\2\2\u042e\u0433\5&\24\2",
    "\u042f\u0430\7Z\2\2\u0430\u0432\5&\24\2\u0431\u042f\3\2\2\2\u0432\u0435",
    "\3\2\2\2\u0433\u0431\3\2\2\2\u0433\u0434\3\2\2\2\u0434\u0437\3\2\2\2",
    "\u0435\u0433\3\2\2\2\u0436\u042e\3\2\2\2\u0436\u0437\3\2\2\2\u0437\u0445",
    "\3\2\2\2\u0438\u0441\7X\2\2\u0439\u043e\5&\24\2\u043a\u043b\7Z\2\2\u043b",
    "\u043d\5&\24\2\u043c\u043a\3\2\2\2\u043d\u0440\3\2\2\2\u043e\u043c\3",
    "\2\2\2\u043e\u043f\3\2\2\2\u043f\u0442\3\2\2\2\u0440\u043e\3\2\2\2\u0441",
    "\u0439\3\2\2\2\u0441\u0442\3\2\2\2\u0442\u0444\3\2\2\2\u0443\u0438\3",
    "\2\2\2\u0444\u0447\3\2\2\2\u0445\u0443\3\2\2\2\u0445\u0446\3\2\2\2\u0446",
    "\u0448\3\2\2\2\u0447\u0445\3\2\2\2\u0448\u0449\7>\2\2\u0449\u044b\7",
    "Y\2\2\u044a\u0425\3\2\2\2\u044a\u0426\3\2\2\2\u044a\u0427\3\2\2\2\u044a",
    "\u0428\3\2\2\2\u044a\u0429\3\2\2\2\u044a\u042a\3\2\2\2\u044a\u042b\3",
    "\2\2\2\u044b\u008f\3\2\2\2\u044c\u044d\7k\2\2\u044d\u044e\7X\2\2\u044e",
    "\u0458\5\u008eH\2\u044f\u0450\7\23\2\2\u0450\u0451\5\60\31\2\u0451\u0452",
    "\7X\2\2\u0452\u0453\5\u008eH\2\u0453\u0458\3\2\2\2\u0454\u0455\7\27",
    "\2\2\u0455\u0456\7X\2\2\u0456\u0458\5\u008eH\2\u0457\u044c\3\2\2\2\u0457",
    "\u044f\3\2\2\2\u0457\u0454\3\2\2\2\u0458\u0091\3\2\2\2\u0459\u045b\7",
    "A\2\2\u045a\u045c\5\u0094K\2\u045b\u045a\3\2\2\2\u045b\u045c\3\2\2\2",
    "\u045c\u045d\3\2\2\2\u045d\u045e\7B\2\2\u045e\u0093\3\2\2\2\u045f\u0460",
    "\bK\1\2\u0460\u0461\5\u0096L\2\u0461\u0466\3\2\2\2\u0462\u0463\f\3\2",
    "\2\u0463\u0465\5\u0096L\2\u0464\u0462\3\2\2\2\u0465\u0468\3\2\2\2\u0466",
    "\u0464\3\2\2\2\u0466\u0467\3\2\2\2\u0467\u0095\3\2\2\2\u0468\u0466\3",
    "\2\2\2\u0469\u046c\5\62\32\2\u046a\u046c\5\u008eH\2\u046b\u0469\3\2",
    "\2\2\u046b\u046a\3\2\2\2\u046c\u0097\3\2\2\2\u046d\u046f\5.\30\2\u046e",
    "\u046d\3\2\2\2\u046e\u046f\3\2\2\2\u046f\u0470\3\2\2\2\u0470\u0471\7",
    "Y\2\2\u0471\u0099\3\2\2\2\u0472\u0473\7 \2\2\u0473\u0474\7=\2\2\u0474",
    "\u0475\5.\30\2\u0475\u0476\7>\2\2\u0476\u0479\5\u008eH\2\u0477\u0478",
    "\7\32\2\2\u0478\u047a\5\u008eH\2\u0479\u0477\3\2\2\2\u0479\u047a\3\2",
    "\2\2\u047a\u0482\3\2\2\2\u047b\u047c\7,\2\2\u047c\u047d\7=\2\2\u047d",
    "\u047e\5.\30\2\u047e\u047f\7>\2\2\u047f\u0480\5\u008eH\2\u0480\u0482",
    "\3\2\2\2\u0481\u0472\3\2\2\2\u0481\u047b\3\2\2\2\u0482\u009b\3\2\2\2",
    "\u0483\u0484\7\62\2\2\u0484\u0485\7=\2\2\u0485\u0486\5.\30\2\u0486\u0487",
    "\7>\2\2\u0487\u0488\5\u008eH\2\u0488\u04ae\3\2\2\2\u0489\u048a\7\30",
    "\2\2\u048a\u048b\5\u008eH\2\u048b\u048c\7\62\2\2\u048c\u048d\7=\2\2",
    "\u048d\u048e\5.\30\2\u048e\u048f\7>\2\2\u048f\u0490\7Y\2\2\u0490\u04ae",
    "\3\2\2\2\u0491\u0492\7\36\2\2\u0492\u0494\7=\2\2\u0493\u0495\5.\30\2",
    "\u0494\u0493\3\2\2\2\u0494\u0495\3\2\2\2\u0495\u0496\3\2\2\2\u0496\u0498",
    "\7Y\2\2\u0497\u0499\5.\30\2\u0498\u0497\3\2\2\2\u0498\u0499\3\2\2\2",
    "\u0499\u049a\3\2\2\2\u049a\u049c\7Y\2\2\u049b\u049d\5.\30\2\u049c\u049b",
    "\3\2\2\2\u049c\u049d\3\2\2\2\u049d\u049e\3\2\2\2\u049e\u049f\7>\2\2",
    "\u049f\u04ae\5\u008eH\2\u04a0\u04a1\7\36\2\2\u04a1\u04a2\7=\2\2\u04a2",
    "\u04a4\5\62\32\2\u04a3\u04a5\5.\30\2\u04a4\u04a3\3\2\2\2\u04a4\u04a5",
    "\3\2\2\2\u04a5\u04a6\3\2\2\2\u04a6\u04a8\7Y\2\2\u04a7\u04a9\5.\30\2",
    "\u04a8\u04a7\3\2\2\2\u04a8\u04a9\3\2\2\2\u04a9\u04aa\3\2\2\2\u04aa\u04ab",
    "\7>\2\2\u04ab\u04ac\5\u008eH\2\u04ac\u04ae\3\2\2\2\u04ad\u0483\3\2\2",
    "\2\u04ad\u0489\3\2\2\2\u04ad\u0491\3\2\2\2\u04ad\u04a0\3\2\2\2\u04ae",
    "\u009d\3\2\2\2\u04af\u04b0\7\37\2\2\u04b0\u04b1\7k\2\2\u04b1\u04c0\7",
    "Y\2\2\u04b2\u04b3\7\26\2\2\u04b3\u04c0\7Y\2\2\u04b4\u04b5\7\22\2\2\u04b5",
    "\u04c0\7Y\2\2\u04b6\u04b8\7&\2\2\u04b7\u04b9\5.\30\2\u04b8\u04b7\3\2",
    "\2\2\u04b8\u04b9\3\2\2\2\u04b9\u04ba\3\2\2\2\u04ba\u04c0\7Y\2\2\u04bb",
    "\u04bc\7\37\2\2\u04bc\u04bd\5\16\b\2\u04bd\u04be\7Y\2\2\u04be\u04c0",
    "\3\2\2\2\u04bf\u04af\3\2\2\2\u04bf\u04b2\3\2\2\2\u04bf\u04b4\3\2\2\2",
    "\u04bf\u04b6\3\2\2\2\u04bf\u04bb\3\2\2\2\u04c0\u009f\3\2\2\2\u04c1\u04c3",
    "\5\u00a2R\2\u04c2\u04c1\3\2\2\2\u04c2\u04c3\3\2\2\2\u04c3\u04c4\3\2",
    "\2\2\u04c4\u04c5\7\2\2\3\u04c5\u00a1\3\2\2\2\u04c6\u04c7\bR\1\2\u04c7",
    "\u04c8\5\u00a4S\2\u04c8\u04cd\3\2\2\2\u04c9\u04ca\f\3\2\2\u04ca\u04cc",
    "\5\u00a4S\2\u04cb\u04c9\3\2\2\2\u04cc\u04cf\3\2\2\2\u04cd\u04cb\3\2",
    "\2\2\u04cd\u04ce\3\2\2\2\u04ce\u00a3\3\2\2\2\u04cf\u04cd\3\2\2\2\u04d0",
    "\u04d4\5\u00a6T\2\u04d1\u04d4\5\62\32\2\u04d2\u04d4\7Y\2\2\u04d3\u04d0",
    "\3\2\2\2\u04d3\u04d1\3\2\2\2\u04d3\u04d2\3\2\2\2\u04d4\u00a5\3\2\2\2",
    "\u04d5\u04d7\5\64\33\2\u04d6\u04d5\3\2\2\2\u04d6\u04d7\3\2\2\2\u04d7",
    "\u04d8\3\2\2\2\u04d8\u04da\5`\61\2\u04d9\u04db\5\u00a8U\2\u04da\u04d9",
    "\3\2\2\2\u04da\u04db\3\2\2\2\u04db\u04dc\3\2\2\2\u04dc\u04dd\5\u0092",
    "J\2\u04dd\u00a7\3\2\2\2\u04de\u04df\bU\1\2\u04df\u04e0\5\62\32\2\u04e0",
    "\u04e5\3\2\2\2\u04e1\u04e2\f\3\2\2\u04e2\u04e4\5\62\32\2\u04e3\u04e1",
    "\3\2\2\2\u04e4\u04e7\3\2\2\2\u04e5\u04e3\3\2\2\2\u04e5\u04e6\3\2\2\2",
    "\u04e6\u00a9\3\2\2\2\u04e7\u04e5\3\2\2\2\u008c\u00af\u00b7\u00cb\u00dc",
    "\u00e6\u010a\u0114\u0121\u0123\u012e\u0147\u0157\u0165\u0167\u0173\u0175",
    "\u0181\u0183\u0195\u0197\u01a3\u01a5\u01b0\u01bb\u01c6\u01d1\u01dc\u01e5",
    "\u01ec\u01f8\u01ff\u0204\u0209\u020e\u0215\u021f\u0227\u0239\u023d\u0246",
    "\u0251\u0256\u025b\u025f\u0263\u0265\u026f\u0274\u0278\u027c\u0284\u028d",
    "\u0297\u029f\u02b0\u02bc\u02bf\u02c5\u02ce\u02d3\u02d6\u02dd\u02ec\u02f8",
    "\u02fb\u02fd\u0305\u0309\u0317\u031b\u0320\u0323\u0326\u032d\u032f\u0334",
    "\u0338\u033d\u0341\u0344\u034d\u0355\u035f\u0367\u0369\u0373\u0378\u037c",
    "\u0382\u0385\u038e\u0393\u0396\u039c\u03ac\u03b2\u03b5\u03ba\u03bd\u03c4",
    "\u03d7\u03dd\u03e0\u03e2\u03f1\u03f5\u03fc\u0401\u040e\u0417\u0420\u0433",
    "\u0436\u043e\u0441\u0445\u044a\u0457\u045b\u0466\u046b\u046e\u0479\u0481",
    "\u0494\u0498\u049c\u04a4\u04a8\u04ad\u04b8\u04bf\u04c2\u04cd\u04d3\u04d6",
    "\u04da\u04e5"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ 'null', "'__extension__'", "'__builtin_va_arg'", "'__builtin_offsetof'", 
                     "'__m128'", "'__m128d'", "'__m128i'", "'__typeof__'", 
                     "'__inline__'", "'__stdcall'", "'__declspec'", "'__asm'", 
                     "'__attribute__'", "'__asm__'", "'__volatile__'", "'auto'", 
                     "'break'", "'case'", "'char'", "'const'", "'continue'", 
                     "'default'", "'do'", "'double'", "'else'", "'enum'", 
                     "'extern'", "'float'", "'for'", "'goto'", "'if'", "'inline'", 
                     "'int'", "'long'", "'register'", "'restrict'", "'return'", 
                     "'short'", "'signed'", "'sizeof'", "'static'", "'struct'", 
                     "'switch'", "'typedef'", "'union'", "'unsigned'", "'void'", 
                     "'volatile'", "'while'", "'_Alignas'", "'_Alignof'", 
                     "'_Atomic'", "'_Bool'", "'_Complex'", "'_Generic'", 
                     "'_Imaginary'", "'_Noreturn'", "'_Static_assert'", 
                     "'_Thread_local'", "'('", "')'", "'['", "']'", "'{'", 
                     "'}'", "'<'", "'<='", "'>'", "'>='", "'<<'", "'>>'", 
                     "'+'", "'++'", "'-'", "'--'", "'*'", "'/'", "'%'", 
                     "'&'", "'|'", "'&&'", "'||'", "'^'", "'!'", "'~'", 
                     "'?'", "':'", "';'", "','", "'='", "'*='", "'/='", 
                     "'%='", "'+='", "'-='", "'<<='", "'>>='", "'&='", "'^='", 
                     "'|='", "'=='", "'!='", "'->'", "'.'", "'...'" ];

var symbolicNames = [ 'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', "Auto", "Break", "Case", "Char", "Const", 
                      "Continue", "Default", "Do", "Double", "Else", "Enum", 
                      "Extern", "Float", "For", "Goto", "If", "Inline", 
                      "Int", "Long", "Register", "Restrict", "Return", "Short", 
                      "Signed", "Sizeof", "Static", "Struct", "Switch", 
                      "Typedef", "Union", "Unsigned", "Void", "Volatile", 
                      "While", "Alignas", "Alignof", "Atomic", "Bool", "Complex", 
                      "Generic", "Imaginary", "Noreturn", "StaticAssert", 
                      "ThreadLocal", "LeftParen", "RightParen", "LeftBracket", 
                      "RightBracket", "LeftBrace", "RightBrace", "Less", 
                      "LessEqual", "Greater", "GreaterEqual", "LeftShift", 
                      "RightShift", "Plus", "PlusPlus", "Minus", "MinusMinus", 
                      "Star", "Div", "Mod", "And", "Or", "AndAnd", "OrOr", 
                      "Caret", "Not", "Tilde", "Question", "Colon", "Semi", 
                      "Comma", "Assign", "StarAssign", "DivAssign", "ModAssign", 
                      "PlusAssign", "MinusAssign", "LeftShiftAssign", "RightShiftAssign", 
                      "AndAssign", "XorAssign", "OrAssign", "Equal", "NotEqual", 
                      "Arrow", "Dot", "Ellipsis", "Identifier", "Constant", 
                      "StringLiteral", "LineDirective", "PragmaDirective", 
                      "Whitespace", "Newline", "BlockComment", "LineComment" ];

var ruleNames =  [ "primaryExpression", "genericSelection", "genericAssocList", 
                   "genericAssociation", "postfixExpression", "argumentExpressionList", 
                   "unaryExpression", "unaryOperator", "castExpression", 
                   "multiplicativeExpression", "additiveExpression", "shiftExpression", 
                   "relationalExpression", "equalityExpression", "andExpression", 
                   "exclusiveOrExpression", "inclusiveOrExpression", "logicalAndExpression", 
                   "logicalOrExpression", "conditionalExpression", "assignmentExpression", 
                   "assignmentOperator", "expression", "constantExpression", 
                   "declaration", "declarationSpecifiers", "declarationSpecifiers2", 
                   "declarationSpecifier", "initDeclaratorList", "initDeclarator", 
                   "storageClassSpecifier", "typeSpecifier", "structOrUnionSpecifier", 
                   "structOrUnion", "structDeclarationList", "structDeclaration", 
                   "specifierQualifierList", "structDeclaratorList", "structDeclarator", 
                   "enumSpecifier", "enumeratorList", "enumerator", "enumerationConstant", 
                   "atomicTypeSpecifier", "typeQualifier", "functionSpecifier", 
                   "alignmentSpecifier", "declarator", "directDeclarator", 
                   "gccDeclaratorExtension", "gccAttributeSpecifier", "gccAttributeList", 
                   "gccAttribute", "nestedParenthesesBlock", "pointer", 
                   "typeQualifierList", "parameterTypeList", "parameterList", 
                   "parameterDeclaration", "identifierList", "typeName", 
                   "abstractDeclarator", "directAbstractDeclarator", "typedefName", 
                   "initializer", "initializerList", "designation", "designatorList", 
                   "designator", "staticAssertDeclaration", "statement", 
                   "labeledStatement", "compoundStatement", "blockItemList", 
                   "blockItem", "expressionStatement", "selectionStatement", 
                   "iterationStatement", "jumpStatement", "compilationUnit", 
                   "translationUnit", "externalDeclaration", "functionDefinition", 
                   "declarationList" ];

function CParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

CParser.prototype = Object.create(antlr4.Parser.prototype);
CParser.prototype.constructor = CParser;

Object.defineProperty(CParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

CParser.EOF = antlr4.Token.EOF;
CParser.T__0 = 1;
CParser.T__1 = 2;
CParser.T__2 = 3;
CParser.T__3 = 4;
CParser.T__4 = 5;
CParser.T__5 = 6;
CParser.T__6 = 7;
CParser.T__7 = 8;
CParser.T__8 = 9;
CParser.T__9 = 10;
CParser.T__10 = 11;
CParser.T__11 = 12;
CParser.T__12 = 13;
CParser.T__13 = 14;
CParser.Auto = 15;
CParser.Break = 16;
CParser.Case = 17;
CParser.Char = 18;
CParser.Const = 19;
CParser.Continue = 20;
CParser.Default = 21;
CParser.Do = 22;
CParser.Double = 23;
CParser.Else = 24;
CParser.Enum = 25;
CParser.Extern = 26;
CParser.Float = 27;
CParser.For = 28;
CParser.Goto = 29;
CParser.If = 30;
CParser.Inline = 31;
CParser.Int = 32;
CParser.Long = 33;
CParser.Register = 34;
CParser.Restrict = 35;
CParser.Return = 36;
CParser.Short = 37;
CParser.Signed = 38;
CParser.Sizeof = 39;
CParser.Static = 40;
CParser.Struct = 41;
CParser.Switch = 42;
CParser.Typedef = 43;
CParser.Union = 44;
CParser.Unsigned = 45;
CParser.Void = 46;
CParser.Volatile = 47;
CParser.While = 48;
CParser.Alignas = 49;
CParser.Alignof = 50;
CParser.Atomic = 51;
CParser.Bool = 52;
CParser.Complex = 53;
CParser.Generic = 54;
CParser.Imaginary = 55;
CParser.Noreturn = 56;
CParser.StaticAssert = 57;
CParser.ThreadLocal = 58;
CParser.LeftParen = 59;
CParser.RightParen = 60;
CParser.LeftBracket = 61;
CParser.RightBracket = 62;
CParser.LeftBrace = 63;
CParser.RightBrace = 64;
CParser.Less = 65;
CParser.LessEqual = 66;
CParser.Greater = 67;
CParser.GreaterEqual = 68;
CParser.LeftShift = 69;
CParser.RightShift = 70;
CParser.Plus = 71;
CParser.PlusPlus = 72;
CParser.Minus = 73;
CParser.MinusMinus = 74;
CParser.Star = 75;
CParser.Div = 76;
CParser.Mod = 77;
CParser.And = 78;
CParser.Or = 79;
CParser.AndAnd = 80;
CParser.OrOr = 81;
CParser.Caret = 82;
CParser.Not = 83;
CParser.Tilde = 84;
CParser.Question = 85;
CParser.Colon = 86;
CParser.Semi = 87;
CParser.Comma = 88;
CParser.Assign = 89;
CParser.StarAssign = 90;
CParser.DivAssign = 91;
CParser.ModAssign = 92;
CParser.PlusAssign = 93;
CParser.MinusAssign = 94;
CParser.LeftShiftAssign = 95;
CParser.RightShiftAssign = 96;
CParser.AndAssign = 97;
CParser.XorAssign = 98;
CParser.OrAssign = 99;
CParser.Equal = 100;
CParser.NotEqual = 101;
CParser.Arrow = 102;
CParser.Dot = 103;
CParser.Ellipsis = 104;
CParser.Identifier = 105;
CParser.Constant = 106;
CParser.StringLiteral = 107;
CParser.LineDirective = 108;
CParser.PragmaDirective = 109;
CParser.Whitespace = 110;
CParser.Newline = 111;
CParser.BlockComment = 112;
CParser.LineComment = 113;

CParser.RULE_primaryExpression = 0;
CParser.RULE_genericSelection = 1;
CParser.RULE_genericAssocList = 2;
CParser.RULE_genericAssociation = 3;
CParser.RULE_postfixExpression = 4;
CParser.RULE_argumentExpressionList = 5;
CParser.RULE_unaryExpression = 6;
CParser.RULE_unaryOperator = 7;
CParser.RULE_castExpression = 8;
CParser.RULE_multiplicativeExpression = 9;
CParser.RULE_additiveExpression = 10;
CParser.RULE_shiftExpression = 11;
CParser.RULE_relationalExpression = 12;
CParser.RULE_equalityExpression = 13;
CParser.RULE_andExpression = 14;
CParser.RULE_exclusiveOrExpression = 15;
CParser.RULE_inclusiveOrExpression = 16;
CParser.RULE_logicalAndExpression = 17;
CParser.RULE_logicalOrExpression = 18;
CParser.RULE_conditionalExpression = 19;
CParser.RULE_assignmentExpression = 20;
CParser.RULE_assignmentOperator = 21;
CParser.RULE_expression = 22;
CParser.RULE_constantExpression = 23;
CParser.RULE_declaration = 24;
CParser.RULE_declarationSpecifiers = 25;
CParser.RULE_declarationSpecifiers2 = 26;
CParser.RULE_declarationSpecifier = 27;
CParser.RULE_initDeclaratorList = 28;
CParser.RULE_initDeclarator = 29;
CParser.RULE_storageClassSpecifier = 30;
CParser.RULE_typeSpecifier = 31;
CParser.RULE_structOrUnionSpecifier = 32;
CParser.RULE_structOrUnion = 33;
CParser.RULE_structDeclarationList = 34;
CParser.RULE_structDeclaration = 35;
CParser.RULE_specifierQualifierList = 36;
CParser.RULE_structDeclaratorList = 37;
CParser.RULE_structDeclarator = 38;
CParser.RULE_enumSpecifier = 39;
CParser.RULE_enumeratorList = 40;
CParser.RULE_enumerator = 41;
CParser.RULE_enumerationConstant = 42;
CParser.RULE_atomicTypeSpecifier = 43;
CParser.RULE_typeQualifier = 44;
CParser.RULE_functionSpecifier = 45;
CParser.RULE_alignmentSpecifier = 46;
CParser.RULE_declarator = 47;
CParser.RULE_directDeclarator = 48;
CParser.RULE_gccDeclaratorExtension = 49;
CParser.RULE_gccAttributeSpecifier = 50;
CParser.RULE_gccAttributeList = 51;
CParser.RULE_gccAttribute = 52;
CParser.RULE_nestedParenthesesBlock = 53;
CParser.RULE_pointer = 54;
CParser.RULE_typeQualifierList = 55;
CParser.RULE_parameterTypeList = 56;
CParser.RULE_parameterList = 57;
CParser.RULE_parameterDeclaration = 58;
CParser.RULE_identifierList = 59;
CParser.RULE_typeName = 60;
CParser.RULE_abstractDeclarator = 61;
CParser.RULE_directAbstractDeclarator = 62;
CParser.RULE_typedefName = 63;
CParser.RULE_initializer = 64;
CParser.RULE_initializerList = 65;
CParser.RULE_designation = 66;
CParser.RULE_designatorList = 67;
CParser.RULE_designator = 68;
CParser.RULE_staticAssertDeclaration = 69;
CParser.RULE_statement = 70;
CParser.RULE_labeledStatement = 71;
CParser.RULE_compoundStatement = 72;
CParser.RULE_blockItemList = 73;
CParser.RULE_blockItem = 74;
CParser.RULE_expressionStatement = 75;
CParser.RULE_selectionStatement = 76;
CParser.RULE_iterationStatement = 77;
CParser.RULE_jumpStatement = 78;
CParser.RULE_compilationUnit = 79;
CParser.RULE_translationUnit = 80;
CParser.RULE_externalDeclaration = 81;
CParser.RULE_functionDefinition = 82;
CParser.RULE_declarationList = 83;

function PrimaryExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_primaryExpression;
    return this;
}

PrimaryExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrimaryExpressionContext.prototype.constructor = PrimaryExpressionContext;

PrimaryExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

PrimaryExpressionContext.prototype.Constant = function() {
    return this.getToken(CParser.Constant, 0);
};

PrimaryExpressionContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


PrimaryExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

PrimaryExpressionContext.prototype.genericSelection = function() {
    return this.getTypedRuleContext(GenericSelectionContext,0);
};

PrimaryExpressionContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

PrimaryExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

PrimaryExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

PrimaryExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterPrimaryExpression(this);
	}
};

PrimaryExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitPrimaryExpression(this);
	}
};




CParser.PrimaryExpressionContext = PrimaryExpressionContext;

CParser.prototype.primaryExpression = function() {

    var localctx = new PrimaryExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, CParser.RULE_primaryExpression);
    var _la = 0; // Token type
    try {
        this.state = 201;
        var la_ = this._interp.adaptivePredict(this._input,2,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 168;
            this.match(CParser.Identifier);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 169;
            this.match(CParser.Constant);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 171; 
            this._errHandler.sync(this);
            var _alt = 1;
            do {
            	switch (_alt) {
            	case 1:
            		this.state = 170;
            		this.match(CParser.StringLiteral);
            		break;
            	default:
            		throw new antlr4.error.NoViableAltException(this);
            	}
            	this.state = 173; 
            	this._errHandler.sync(this);
            	_alt = this._interp.adaptivePredict(this._input,0, this._ctx);
            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 175;
            this.match(CParser.LeftParen);
            this.state = 176;
            this.expression(0);
            this.state = 177;
            this.match(CParser.RightParen);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 179;
            this.genericSelection();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 181;
            _la = this._input.LA(1);
            if(_la===CParser.T__0) {
                this.state = 180;
                this.match(CParser.T__0);
            }

            this.state = 183;
            this.match(CParser.LeftParen);
            this.state = 184;
            this.compoundStatement();
            this.state = 185;
            this.match(CParser.RightParen);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 187;
            this.match(CParser.T__1);
            this.state = 188;
            this.match(CParser.LeftParen);
            this.state = 189;
            this.unaryExpression();
            this.state = 190;
            this.match(CParser.Comma);
            this.state = 191;
            this.typeName();
            this.state = 192;
            this.match(CParser.RightParen);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 194;
            this.match(CParser.T__2);
            this.state = 195;
            this.match(CParser.LeftParen);
            this.state = 196;
            this.typeName();
            this.state = 197;
            this.match(CParser.Comma);
            this.state = 198;
            this.unaryExpression();
            this.state = 199;
            this.match(CParser.RightParen);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericSelectionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericSelection;
    return this;
}

GenericSelectionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericSelectionContext.prototype.constructor = GenericSelectionContext;

GenericSelectionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

GenericSelectionContext.prototype.genericAssocList = function() {
    return this.getTypedRuleContext(GenericAssocListContext,0);
};

GenericSelectionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGenericSelection(this);
	}
};

GenericSelectionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGenericSelection(this);
	}
};




CParser.GenericSelectionContext = GenericSelectionContext;

CParser.prototype.genericSelection = function() {

    var localctx = new GenericSelectionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, CParser.RULE_genericSelection);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 203;
        this.match(CParser.Generic);
        this.state = 204;
        this.match(CParser.LeftParen);
        this.state = 205;
        this.assignmentExpression();
        this.state = 206;
        this.match(CParser.Comma);
        this.state = 207;
        this.genericAssocList(0);
        this.state = 208;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericAssocListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericAssocList;
    return this;
}

GenericAssocListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericAssocListContext.prototype.constructor = GenericAssocListContext;

GenericAssocListContext.prototype.genericAssociation = function() {
    return this.getTypedRuleContext(GenericAssociationContext,0);
};

GenericAssocListContext.prototype.genericAssocList = function() {
    return this.getTypedRuleContext(GenericAssocListContext,0);
};

GenericAssocListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGenericAssocList(this);
	}
};

GenericAssocListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGenericAssocList(this);
	}
};



CParser.prototype.genericAssocList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new GenericAssocListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 4;
    this.enterRecursionRule(localctx, 4, CParser.RULE_genericAssocList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 211;
        this.genericAssociation();
        this._ctx.stop = this._input.LT(-1);
        this.state = 218;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,3,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new GenericAssocListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_genericAssocList);
                this.state = 213;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 214;
                this.match(CParser.Comma);
                this.state = 215;
                this.genericAssociation(); 
            }
            this.state = 220;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,3,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function GenericAssociationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_genericAssociation;
    return this;
}

GenericAssociationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericAssociationContext.prototype.constructor = GenericAssociationContext;

GenericAssociationContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

GenericAssociationContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

GenericAssociationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGenericAssociation(this);
	}
};

GenericAssociationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGenericAssociation(this);
	}
};




CParser.GenericAssociationContext = GenericAssociationContext;

CParser.prototype.genericAssociation = function() {

    var localctx = new GenericAssociationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, CParser.RULE_genericAssociation);
    try {
        this.state = 228;
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.Char:
        case CParser.Const:
        case CParser.Double:
        case CParser.Enum:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Restrict:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Struct:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 221;
            this.typeName();
            this.state = 222;
            this.match(CParser.Colon);
            this.state = 223;
            this.assignmentExpression();
            break;
        case CParser.Default:
            this.enterOuterAlt(localctx, 2);
            this.state = 225;
            this.match(CParser.Default);
            this.state = 226;
            this.match(CParser.Colon);
            this.state = 227;
            this.assignmentExpression();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PostfixExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_postfixExpression;
    return this;
}

PostfixExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PostfixExpressionContext.prototype.constructor = PostfixExpressionContext;

PostfixExpressionContext.prototype.primaryExpression = function() {
    return this.getTypedRuleContext(PrimaryExpressionContext,0);
};

PostfixExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

PostfixExpressionContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

PostfixExpressionContext.prototype.postfixExpression = function() {
    return this.getTypedRuleContext(PostfixExpressionContext,0);
};

PostfixExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

PostfixExpressionContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

PostfixExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

PostfixExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterPostfixExpression(this);
	}
};

PostfixExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitPostfixExpression(this);
	}
};



CParser.prototype.postfixExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new PostfixExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 8;
    this.enterRecursionRule(localctx, 8, CParser.RULE_postfixExpression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 264;
        var la_ = this._interp.adaptivePredict(this._input,5,this._ctx);
        switch(la_) {
        case 1:
            this.state = 231;
            this.primaryExpression();
            break;

        case 2:
            this.state = 232;
            this.match(CParser.LeftParen);
            this.state = 233;
            this.typeName();
            this.state = 234;
            this.match(CParser.RightParen);
            this.state = 235;
            this.match(CParser.LeftBrace);
            this.state = 236;
            this.initializerList(0);
            this.state = 237;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.state = 239;
            this.match(CParser.LeftParen);
            this.state = 240;
            this.typeName();
            this.state = 241;
            this.match(CParser.RightParen);
            this.state = 242;
            this.match(CParser.LeftBrace);
            this.state = 243;
            this.initializerList(0);
            this.state = 244;
            this.match(CParser.Comma);
            this.state = 245;
            this.match(CParser.RightBrace);
            break;

        case 4:
            this.state = 247;
            this.match(CParser.T__0);
            this.state = 248;
            this.match(CParser.LeftParen);
            this.state = 249;
            this.typeName();
            this.state = 250;
            this.match(CParser.RightParen);
            this.state = 251;
            this.match(CParser.LeftBrace);
            this.state = 252;
            this.initializerList(0);
            this.state = 253;
            this.match(CParser.RightBrace);
            break;

        case 5:
            this.state = 255;
            this.match(CParser.T__0);
            this.state = 256;
            this.match(CParser.LeftParen);
            this.state = 257;
            this.typeName();
            this.state = 258;
            this.match(CParser.RightParen);
            this.state = 259;
            this.match(CParser.LeftBrace);
            this.state = 260;
            this.initializerList(0);
            this.state = 261;
            this.match(CParser.Comma);
            this.state = 262;
            this.match(CParser.RightBrace);
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 289;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,8,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 287;
                var la_ = this._interp.adaptivePredict(this._input,7,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 266;
                    if (!( this.precpred(this._ctx, 10))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
                    }
                    this.state = 267;
                    this.match(CParser.LeftBracket);
                    this.state = 268;
                    this.expression(0);
                    this.state = 269;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 271;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 272;
                    this.match(CParser.LeftParen);
                    this.state = 274;
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 273;
                        this.argumentExpressionList(0);
                    }

                    this.state = 276;
                    this.match(CParser.RightParen);
                    break;

                case 3:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 277;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 278;
                    this.match(CParser.Dot);
                    this.state = 279;
                    this.match(CParser.Identifier);
                    break;

                case 4:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 280;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 281;
                    this.match(CParser.Arrow);
                    this.state = 282;
                    this.match(CParser.Identifier);
                    break;

                case 5:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 283;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 284;
                    this.match(CParser.PlusPlus);
                    break;

                case 6:
                    localctx = new PostfixExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_postfixExpression);
                    this.state = 285;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 286;
                    this.match(CParser.MinusMinus);
                    break;

                } 
            }
            this.state = 291;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,8,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ArgumentExpressionListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_argumentExpressionList;
    return this;
}

ArgumentExpressionListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentExpressionListContext.prototype.constructor = ArgumentExpressionListContext;

ArgumentExpressionListContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

ArgumentExpressionListContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

ArgumentExpressionListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterArgumentExpressionList(this);
	}
};

ArgumentExpressionListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitArgumentExpressionList(this);
	}
};



CParser.prototype.argumentExpressionList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ArgumentExpressionListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 10;
    this.enterRecursionRule(localctx, 10, CParser.RULE_argumentExpressionList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 293;
        this.assignmentExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 300;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,9,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ArgumentExpressionListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_argumentExpressionList);
                this.state = 295;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 296;
                this.match(CParser.Comma);
                this.state = 297;
                this.assignmentExpression(); 
            }
            this.state = 302;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,9,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function UnaryExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_unaryExpression;
    return this;
}

UnaryExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnaryExpressionContext.prototype.constructor = UnaryExpressionContext;

UnaryExpressionContext.prototype.postfixExpression = function() {
    return this.getTypedRuleContext(PostfixExpressionContext,0);
};

UnaryExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

UnaryExpressionContext.prototype.unaryOperator = function() {
    return this.getTypedRuleContext(UnaryOperatorContext,0);
};

UnaryExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

UnaryExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

UnaryExpressionContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

UnaryExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterUnaryExpression(this);
	}
};

UnaryExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitUnaryExpression(this);
	}
};




CParser.UnaryExpressionContext = UnaryExpressionContext;

CParser.prototype.unaryExpression = function() {

    var localctx = new UnaryExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, CParser.RULE_unaryExpression);
    try {
        this.state = 325;
        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 303;
            this.postfixExpression(0);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 304;
            this.match(CParser.PlusPlus);
            this.state = 305;
            this.unaryExpression();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 306;
            this.match(CParser.MinusMinus);
            this.state = 307;
            this.unaryExpression();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 308;
            this.unaryOperator();
            this.state = 309;
            this.castExpression();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 311;
            this.match(CParser.Sizeof);
            this.state = 312;
            this.unaryExpression();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 313;
            this.match(CParser.Sizeof);
            this.state = 314;
            this.match(CParser.LeftParen);
            this.state = 315;
            this.typeName();
            this.state = 316;
            this.match(CParser.RightParen);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 318;
            this.match(CParser.Alignof);
            this.state = 319;
            this.match(CParser.LeftParen);
            this.state = 320;
            this.typeName();
            this.state = 321;
            this.match(CParser.RightParen);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 323;
            this.match(CParser.AndAnd);
            this.state = 324;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function UnaryOperatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_unaryOperator;
    return this;
}

UnaryOperatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
UnaryOperatorContext.prototype.constructor = UnaryOperatorContext;


UnaryOperatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterUnaryOperator(this);
	}
};

UnaryOperatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitUnaryOperator(this);
	}
};




CParser.UnaryOperatorContext = UnaryOperatorContext;

CParser.prototype.unaryOperator = function() {

    var localctx = new UnaryOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, CParser.RULE_unaryOperator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 327;
        _la = this._input.LA(1);
        if(!(((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CastExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_castExpression;
    return this;
}

CastExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CastExpressionContext.prototype.constructor = CastExpressionContext;

CastExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

CastExpressionContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

CastExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

CastExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterCastExpression(this);
	}
};

CastExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitCastExpression(this);
	}
};




CParser.CastExpressionContext = CastExpressionContext;

CParser.prototype.castExpression = function() {

    var localctx = new CastExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, CParser.RULE_castExpression);
    try {
        this.state = 341;
        var la_ = this._interp.adaptivePredict(this._input,11,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 329;
            this.unaryExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 330;
            this.match(CParser.LeftParen);
            this.state = 331;
            this.typeName();
            this.state = 332;
            this.match(CParser.RightParen);
            this.state = 333;
            this.castExpression();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 335;
            this.match(CParser.T__0);
            this.state = 336;
            this.match(CParser.LeftParen);
            this.state = 337;
            this.typeName();
            this.state = 338;
            this.match(CParser.RightParen);
            this.state = 339;
            this.castExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MultiplicativeExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_multiplicativeExpression;
    return this;
}

MultiplicativeExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MultiplicativeExpressionContext.prototype.constructor = MultiplicativeExpressionContext;

MultiplicativeExpressionContext.prototype.castExpression = function() {
    return this.getTypedRuleContext(CastExpressionContext,0);
};

MultiplicativeExpressionContext.prototype.multiplicativeExpression = function() {
    return this.getTypedRuleContext(MultiplicativeExpressionContext,0);
};

MultiplicativeExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterMultiplicativeExpression(this);
	}
};

MultiplicativeExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitMultiplicativeExpression(this);
	}
};



CParser.prototype.multiplicativeExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new MultiplicativeExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 18;
    this.enterRecursionRule(localctx, 18, CParser.RULE_multiplicativeExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 344;
        this.castExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 357;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,13,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 355;
                var la_ = this._interp.adaptivePredict(this._input,12,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 346;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 347;
                    this.match(CParser.Star);
                    this.state = 348;
                    this.castExpression();
                    break;

                case 2:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 349;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 350;
                    this.match(CParser.Div);
                    this.state = 351;
                    this.castExpression();
                    break;

                case 3:
                    localctx = new MultiplicativeExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_multiplicativeExpression);
                    this.state = 352;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 353;
                    this.match(CParser.Mod);
                    this.state = 354;
                    this.castExpression();
                    break;

                } 
            }
            this.state = 359;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,13,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function AdditiveExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_additiveExpression;
    return this;
}

AdditiveExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AdditiveExpressionContext.prototype.constructor = AdditiveExpressionContext;

AdditiveExpressionContext.prototype.multiplicativeExpression = function() {
    return this.getTypedRuleContext(MultiplicativeExpressionContext,0);
};

AdditiveExpressionContext.prototype.additiveExpression = function() {
    return this.getTypedRuleContext(AdditiveExpressionContext,0);
};

AdditiveExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAdditiveExpression(this);
	}
};

AdditiveExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAdditiveExpression(this);
	}
};



CParser.prototype.additiveExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new AdditiveExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 20;
    this.enterRecursionRule(localctx, 20, CParser.RULE_additiveExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 361;
        this.multiplicativeExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 371;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,15,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 369;
                var la_ = this._interp.adaptivePredict(this._input,14,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new AdditiveExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_additiveExpression);
                    this.state = 363;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 364;
                    this.match(CParser.Plus);
                    this.state = 365;
                    this.multiplicativeExpression(0);
                    break;

                case 2:
                    localctx = new AdditiveExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_additiveExpression);
                    this.state = 366;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 367;
                    this.match(CParser.Minus);
                    this.state = 368;
                    this.multiplicativeExpression(0);
                    break;

                } 
            }
            this.state = 373;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,15,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ShiftExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_shiftExpression;
    return this;
}

ShiftExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ShiftExpressionContext.prototype.constructor = ShiftExpressionContext;

ShiftExpressionContext.prototype.additiveExpression = function() {
    return this.getTypedRuleContext(AdditiveExpressionContext,0);
};

ShiftExpressionContext.prototype.shiftExpression = function() {
    return this.getTypedRuleContext(ShiftExpressionContext,0);
};

ShiftExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterShiftExpression(this);
	}
};

ShiftExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitShiftExpression(this);
	}
};



CParser.prototype.shiftExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ShiftExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 22;
    this.enterRecursionRule(localctx, 22, CParser.RULE_shiftExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 375;
        this.additiveExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 385;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,17,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 383;
                var la_ = this._interp.adaptivePredict(this._input,16,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new ShiftExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_shiftExpression);
                    this.state = 377;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 378;
                    this.match(CParser.LeftShift);
                    this.state = 379;
                    this.additiveExpression(0);
                    break;

                case 2:
                    localctx = new ShiftExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_shiftExpression);
                    this.state = 380;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 381;
                    this.match(CParser.RightShift);
                    this.state = 382;
                    this.additiveExpression(0);
                    break;

                } 
            }
            this.state = 387;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,17,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function RelationalExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_relationalExpression;
    return this;
}

RelationalExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RelationalExpressionContext.prototype.constructor = RelationalExpressionContext;

RelationalExpressionContext.prototype.shiftExpression = function() {
    return this.getTypedRuleContext(ShiftExpressionContext,0);
};

RelationalExpressionContext.prototype.relationalExpression = function() {
    return this.getTypedRuleContext(RelationalExpressionContext,0);
};

RelationalExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterRelationalExpression(this);
	}
};

RelationalExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitRelationalExpression(this);
	}
};



CParser.prototype.relationalExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new RelationalExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 24;
    this.enterRecursionRule(localctx, 24, CParser.RULE_relationalExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 389;
        this.shiftExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 405;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,19,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 403;
                var la_ = this._interp.adaptivePredict(this._input,18,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 391;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 392;
                    this.match(CParser.Less);
                    this.state = 393;
                    this.shiftExpression(0);
                    break;

                case 2:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 394;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 395;
                    this.match(CParser.Greater);
                    this.state = 396;
                    this.shiftExpression(0);
                    break;

                case 3:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 397;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 398;
                    this.match(CParser.LessEqual);
                    this.state = 399;
                    this.shiftExpression(0);
                    break;

                case 4:
                    localctx = new RelationalExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_relationalExpression);
                    this.state = 400;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 401;
                    this.match(CParser.GreaterEqual);
                    this.state = 402;
                    this.shiftExpression(0);
                    break;

                } 
            }
            this.state = 407;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,19,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function EqualityExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_equalityExpression;
    return this;
}

EqualityExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EqualityExpressionContext.prototype.constructor = EqualityExpressionContext;

EqualityExpressionContext.prototype.relationalExpression = function() {
    return this.getTypedRuleContext(RelationalExpressionContext,0);
};

EqualityExpressionContext.prototype.equalityExpression = function() {
    return this.getTypedRuleContext(EqualityExpressionContext,0);
};

EqualityExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterEqualityExpression(this);
	}
};

EqualityExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitEqualityExpression(this);
	}
};



CParser.prototype.equalityExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new EqualityExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 26;
    this.enterRecursionRule(localctx, 26, CParser.RULE_equalityExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 409;
        this.relationalExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 419;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,21,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 417;
                var la_ = this._interp.adaptivePredict(this._input,20,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new EqualityExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_equalityExpression);
                    this.state = 411;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 412;
                    this.match(CParser.Equal);
                    this.state = 413;
                    this.relationalExpression(0);
                    break;

                case 2:
                    localctx = new EqualityExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_equalityExpression);
                    this.state = 414;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 415;
                    this.match(CParser.NotEqual);
                    this.state = 416;
                    this.relationalExpression(0);
                    break;

                } 
            }
            this.state = 421;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,21,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function AndExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_andExpression;
    return this;
}

AndExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AndExpressionContext.prototype.constructor = AndExpressionContext;

AndExpressionContext.prototype.equalityExpression = function() {
    return this.getTypedRuleContext(EqualityExpressionContext,0);
};

AndExpressionContext.prototype.andExpression = function() {
    return this.getTypedRuleContext(AndExpressionContext,0);
};

AndExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAndExpression(this);
	}
};

AndExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAndExpression(this);
	}
};



CParser.prototype.andExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new AndExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 28;
    this.enterRecursionRule(localctx, 28, CParser.RULE_andExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 423;
        this.equalityExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 430;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,22,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new AndExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_andExpression);
                this.state = 425;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 426;
                this.match(CParser.And);
                this.state = 427;
                this.equalityExpression(0); 
            }
            this.state = 432;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,22,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ExclusiveOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_exclusiveOrExpression;
    return this;
}

ExclusiveOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExclusiveOrExpressionContext.prototype.constructor = ExclusiveOrExpressionContext;

ExclusiveOrExpressionContext.prototype.andExpression = function() {
    return this.getTypedRuleContext(AndExpressionContext,0);
};

ExclusiveOrExpressionContext.prototype.exclusiveOrExpression = function() {
    return this.getTypedRuleContext(ExclusiveOrExpressionContext,0);
};

ExclusiveOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterExclusiveOrExpression(this);
	}
};

ExclusiveOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitExclusiveOrExpression(this);
	}
};



CParser.prototype.exclusiveOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExclusiveOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 30;
    this.enterRecursionRule(localctx, 30, CParser.RULE_exclusiveOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 434;
        this.andExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 441;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,23,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ExclusiveOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_exclusiveOrExpression);
                this.state = 436;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 437;
                this.match(CParser.Caret);
                this.state = 438;
                this.andExpression(0); 
            }
            this.state = 443;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,23,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function InclusiveOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_inclusiveOrExpression;
    return this;
}

InclusiveOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InclusiveOrExpressionContext.prototype.constructor = InclusiveOrExpressionContext;

InclusiveOrExpressionContext.prototype.exclusiveOrExpression = function() {
    return this.getTypedRuleContext(ExclusiveOrExpressionContext,0);
};

InclusiveOrExpressionContext.prototype.inclusiveOrExpression = function() {
    return this.getTypedRuleContext(InclusiveOrExpressionContext,0);
};

InclusiveOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterInclusiveOrExpression(this);
	}
};

InclusiveOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitInclusiveOrExpression(this);
	}
};



CParser.prototype.inclusiveOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InclusiveOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 32;
    this.enterRecursionRule(localctx, 32, CParser.RULE_inclusiveOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 445;
        this.exclusiveOrExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 452;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,24,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InclusiveOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_inclusiveOrExpression);
                this.state = 447;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 448;
                this.match(CParser.Or);
                this.state = 449;
                this.exclusiveOrExpression(0); 
            }
            this.state = 454;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,24,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function LogicalAndExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_logicalAndExpression;
    return this;
}

LogicalAndExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LogicalAndExpressionContext.prototype.constructor = LogicalAndExpressionContext;

LogicalAndExpressionContext.prototype.inclusiveOrExpression = function() {
    return this.getTypedRuleContext(InclusiveOrExpressionContext,0);
};

LogicalAndExpressionContext.prototype.logicalAndExpression = function() {
    return this.getTypedRuleContext(LogicalAndExpressionContext,0);
};

LogicalAndExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterLogicalAndExpression(this);
	}
};

LogicalAndExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitLogicalAndExpression(this);
	}
};



CParser.prototype.logicalAndExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new LogicalAndExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 34;
    this.enterRecursionRule(localctx, 34, CParser.RULE_logicalAndExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 456;
        this.inclusiveOrExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 463;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,25,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new LogicalAndExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_logicalAndExpression);
                this.state = 458;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 459;
                this.match(CParser.AndAnd);
                this.state = 460;
                this.inclusiveOrExpression(0); 
            }
            this.state = 465;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,25,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function LogicalOrExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_logicalOrExpression;
    return this;
}

LogicalOrExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LogicalOrExpressionContext.prototype.constructor = LogicalOrExpressionContext;

LogicalOrExpressionContext.prototype.logicalAndExpression = function() {
    return this.getTypedRuleContext(LogicalAndExpressionContext,0);
};

LogicalOrExpressionContext.prototype.logicalOrExpression = function() {
    return this.getTypedRuleContext(LogicalOrExpressionContext,0);
};

LogicalOrExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterLogicalOrExpression(this);
	}
};

LogicalOrExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitLogicalOrExpression(this);
	}
};



CParser.prototype.logicalOrExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new LogicalOrExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 36;
    this.enterRecursionRule(localctx, 36, CParser.RULE_logicalOrExpression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 467;
        this.logicalAndExpression(0);
        this._ctx.stop = this._input.LT(-1);
        this.state = 474;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,26,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new LogicalOrExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_logicalOrExpression);
                this.state = 469;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 470;
                this.match(CParser.OrOr);
                this.state = 471;
                this.logicalAndExpression(0); 
            }
            this.state = 476;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,26,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ConditionalExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_conditionalExpression;
    return this;
}

ConditionalExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConditionalExpressionContext.prototype.constructor = ConditionalExpressionContext;

ConditionalExpressionContext.prototype.logicalOrExpression = function() {
    return this.getTypedRuleContext(LogicalOrExpressionContext,0);
};

ConditionalExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ConditionalExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

ConditionalExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterConditionalExpression(this);
	}
};

ConditionalExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitConditionalExpression(this);
	}
};




CParser.ConditionalExpressionContext = ConditionalExpressionContext;

CParser.prototype.conditionalExpression = function() {

    var localctx = new ConditionalExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, CParser.RULE_conditionalExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 477;
        this.logicalOrExpression(0);
        this.state = 483;
        var la_ = this._interp.adaptivePredict(this._input,27,this._ctx);
        if(la_===1) {
            this.state = 478;
            this.match(CParser.Question);
            this.state = 479;
            this.expression(0);
            this.state = 480;
            this.match(CParser.Colon);
            this.state = 481;
            this.conditionalExpression();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AssignmentExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_assignmentExpression;
    return this;
}

AssignmentExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AssignmentExpressionContext.prototype.constructor = AssignmentExpressionContext;

AssignmentExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

AssignmentExpressionContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

AssignmentExpressionContext.prototype.assignmentOperator = function() {
    return this.getTypedRuleContext(AssignmentOperatorContext,0);
};

AssignmentExpressionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

AssignmentExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAssignmentExpression(this);
	}
};

AssignmentExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAssignmentExpression(this);
	}
};




CParser.AssignmentExpressionContext = AssignmentExpressionContext;

CParser.prototype.assignmentExpression = function() {

    var localctx = new AssignmentExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, CParser.RULE_assignmentExpression);
    try {
        this.state = 490;
        var la_ = this._interp.adaptivePredict(this._input,28,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 485;
            this.conditionalExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 486;
            this.unaryExpression();
            this.state = 487;
            this.assignmentOperator();
            this.state = 488;
            this.assignmentExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AssignmentOperatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_assignmentOperator;
    return this;
}

AssignmentOperatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AssignmentOperatorContext.prototype.constructor = AssignmentOperatorContext;


AssignmentOperatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAssignmentOperator(this);
	}
};

AssignmentOperatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAssignmentOperator(this);
	}
};




CParser.AssignmentOperatorContext = AssignmentOperatorContext;

CParser.prototype.assignmentOperator = function() {

    var localctx = new AssignmentOperatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, CParser.RULE_assignmentOperator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 492;
        _la = this._input.LA(1);
        if(!(((((_la - 89)) & ~0x1f) == 0 && ((1 << (_la - 89)) & ((1 << (CParser.Assign - 89)) | (1 << (CParser.StarAssign - 89)) | (1 << (CParser.DivAssign - 89)) | (1 << (CParser.ModAssign - 89)) | (1 << (CParser.PlusAssign - 89)) | (1 << (CParser.MinusAssign - 89)) | (1 << (CParser.LeftShiftAssign - 89)) | (1 << (CParser.RightShiftAssign - 89)) | (1 << (CParser.AndAssign - 89)) | (1 << (CParser.XorAssign - 89)) | (1 << (CParser.OrAssign - 89)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;

ExpressionContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

ExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterExpression(this);
	}
};

ExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitExpression(this);
	}
};



CParser.prototype.expression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 44;
    this.enterRecursionRule(localctx, 44, CParser.RULE_expression, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 495;
        this.assignmentExpression();
        this._ctx.stop = this._input.LT(-1);
        this.state = 502;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,29,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ExpressionContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_expression);
                this.state = 497;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 498;
                this.match(CParser.Comma);
                this.state = 499;
                this.assignmentExpression(); 
            }
            this.state = 504;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,29,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ConstantExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_constantExpression;
    return this;
}

ConstantExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantExpressionContext.prototype.constructor = ConstantExpressionContext;

ConstantExpressionContext.prototype.conditionalExpression = function() {
    return this.getTypedRuleContext(ConditionalExpressionContext,0);
};

ConstantExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterConstantExpression(this);
	}
};

ConstantExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitConstantExpression(this);
	}
};




CParser.ConstantExpressionContext = ConstantExpressionContext;

CParser.prototype.constantExpression = function() {

    var localctx = new ConstantExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, CParser.RULE_constantExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 505;
        this.conditionalExpression();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declaration;
    return this;
}

DeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationContext.prototype.constructor = DeclarationContext;

DeclarationContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

DeclarationContext.prototype.initDeclaratorList = function() {
    return this.getTypedRuleContext(InitDeclaratorListContext,0);
};

DeclarationContext.prototype.staticAssertDeclaration = function() {
    return this.getTypedRuleContext(StaticAssertDeclarationContext,0);
};

DeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclaration(this);
	}
};

DeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclaration(this);
	}
};




CParser.DeclarationContext = DeclarationContext;

CParser.prototype.declaration = function() {

    var localctx = new DeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, CParser.RULE_declaration);
    var _la = 0; // Token type
    try {
        this.state = 514;
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.T__7:
        case CParser.T__8:
        case CParser.T__9:
        case CParser.T__11:
        case CParser.Auto:
        case CParser.Char:
        case CParser.Const:
        case CParser.Double:
        case CParser.Enum:
        case CParser.Extern:
        case CParser.Float:
        case CParser.Inline:
        case CParser.Int:
        case CParser.Long:
        case CParser.Register:
        case CParser.Restrict:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Static:
        case CParser.Struct:
        case CParser.Typedef:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.Alignas:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Noreturn:
        case CParser.ThreadLocal:
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 507;
            this.declarationSpecifiers();
            this.state = 509;
            _la = this._input.LA(1);
            if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)))) !== 0) || _la===CParser.Identifier) {
                this.state = 508;
                this.initDeclaratorList(0);
            }

            this.state = 511;
            this.match(CParser.Semi);
            break;
        case CParser.StaticAssert:
            this.enterOuterAlt(localctx, 2);
            this.state = 513;
            this.staticAssertDeclaration();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifiersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifiers;
    return this;
}

DeclarationSpecifiersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifiersContext.prototype.constructor = DeclarationSpecifiersContext;

DeclarationSpecifiersContext.prototype.declarationSpecifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationSpecifierContext);
    } else {
        return this.getTypedRuleContext(DeclarationSpecifierContext,i);
    }
};

DeclarationSpecifiersContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclarationSpecifiers(this);
	}
};

DeclarationSpecifiersContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclarationSpecifiers(this);
	}
};




CParser.DeclarationSpecifiersContext = DeclarationSpecifiersContext;

CParser.prototype.declarationSpecifiers = function() {

    var localctx = new DeclarationSpecifiersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, CParser.RULE_declarationSpecifiers);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 517; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 516;
        		this.declarationSpecifier();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 519; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,32, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifiers2Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifiers2;
    return this;
}

DeclarationSpecifiers2Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifiers2Context.prototype.constructor = DeclarationSpecifiers2Context;

DeclarationSpecifiers2Context.prototype.declarationSpecifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationSpecifierContext);
    } else {
        return this.getTypedRuleContext(DeclarationSpecifierContext,i);
    }
};

DeclarationSpecifiers2Context.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclarationSpecifiers2(this);
	}
};

DeclarationSpecifiers2Context.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclarationSpecifiers2(this);
	}
};




CParser.DeclarationSpecifiers2Context = DeclarationSpecifiers2Context;

CParser.prototype.declarationSpecifiers2 = function() {

    var localctx = new DeclarationSpecifiers2Context(this, this._ctx, this.state);
    this.enterRule(localctx, 52, CParser.RULE_declarationSpecifiers2);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 522; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 521;
        		this.declarationSpecifier();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 524; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,33, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationSpecifier;
    return this;
}

DeclarationSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationSpecifierContext.prototype.constructor = DeclarationSpecifierContext;

DeclarationSpecifierContext.prototype.storageClassSpecifier = function() {
    return this.getTypedRuleContext(StorageClassSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.typeSpecifier = function() {
    return this.getTypedRuleContext(TypeSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

DeclarationSpecifierContext.prototype.functionSpecifier = function() {
    return this.getTypedRuleContext(FunctionSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.alignmentSpecifier = function() {
    return this.getTypedRuleContext(AlignmentSpecifierContext,0);
};

DeclarationSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclarationSpecifier(this);
	}
};

DeclarationSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclarationSpecifier(this);
	}
};




CParser.DeclarationSpecifierContext = DeclarationSpecifierContext;

CParser.prototype.declarationSpecifier = function() {

    var localctx = new DeclarationSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, CParser.RULE_declarationSpecifier);
    try {
        this.state = 531;
        var la_ = this._interp.adaptivePredict(this._input,34,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 526;
            this.storageClassSpecifier();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 527;
            this.typeSpecifier();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 528;
            this.typeQualifier();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 529;
            this.functionSpecifier();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 530;
            this.alignmentSpecifier();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitDeclaratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initDeclaratorList;
    return this;
}

InitDeclaratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitDeclaratorListContext.prototype.constructor = InitDeclaratorListContext;

InitDeclaratorListContext.prototype.initDeclarator = function() {
    return this.getTypedRuleContext(InitDeclaratorContext,0);
};

InitDeclaratorListContext.prototype.initDeclaratorList = function() {
    return this.getTypedRuleContext(InitDeclaratorListContext,0);
};

InitDeclaratorListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterInitDeclaratorList(this);
	}
};

InitDeclaratorListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitInitDeclaratorList(this);
	}
};



CParser.prototype.initDeclaratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InitDeclaratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 56;
    this.enterRecursionRule(localctx, 56, CParser.RULE_initDeclaratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 534;
        this.initDeclarator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 541;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,35,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InitDeclaratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_initDeclaratorList);
                this.state = 536;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 537;
                this.match(CParser.Comma);
                this.state = 538;
                this.initDeclarator(); 
            }
            this.state = 543;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,35,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function InitDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initDeclarator;
    return this;
}

InitDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitDeclaratorContext.prototype.constructor = InitDeclaratorContext;

InitDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

InitDeclaratorContext.prototype.initializer = function() {
    return this.getTypedRuleContext(InitializerContext,0);
};

InitDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterInitDeclarator(this);
	}
};

InitDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitInitDeclarator(this);
	}
};




CParser.InitDeclaratorContext = InitDeclaratorContext;

CParser.prototype.initDeclarator = function() {

    var localctx = new InitDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, CParser.RULE_initDeclarator);
    try {
        this.state = 549;
        var la_ = this._interp.adaptivePredict(this._input,36,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 544;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 545;
            this.declarator();
            this.state = 546;
            this.match(CParser.Assign);
            this.state = 547;
            this.initializer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StorageClassSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_storageClassSpecifier;
    return this;
}

StorageClassSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StorageClassSpecifierContext.prototype.constructor = StorageClassSpecifierContext;


StorageClassSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStorageClassSpecifier(this);
	}
};

StorageClassSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStorageClassSpecifier(this);
	}
};




CParser.StorageClassSpecifierContext = StorageClassSpecifierContext;

CParser.prototype.storageClassSpecifier = function() {

    var localctx = new StorageClassSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, CParser.RULE_storageClassSpecifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 551;
        _la = this._input.LA(1);
        if(!(_la===CParser.Auto || _la===CParser.Extern || ((((_la - 34)) & ~0x1f) == 0 && ((1 << (_la - 34)) & ((1 << (CParser.Register - 34)) | (1 << (CParser.Static - 34)) | (1 << (CParser.Typedef - 34)) | (1 << (CParser.ThreadLocal - 34)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeSpecifier;
    return this;
}

TypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeSpecifierContext.prototype.constructor = TypeSpecifierContext;

TypeSpecifierContext.prototype.atomicTypeSpecifier = function() {
    return this.getTypedRuleContext(AtomicTypeSpecifierContext,0);
};

TypeSpecifierContext.prototype.structOrUnionSpecifier = function() {
    return this.getTypedRuleContext(StructOrUnionSpecifierContext,0);
};

TypeSpecifierContext.prototype.enumSpecifier = function() {
    return this.getTypedRuleContext(EnumSpecifierContext,0);
};

TypeSpecifierContext.prototype.typedefName = function() {
    return this.getTypedRuleContext(TypedefNameContext,0);
};

TypeSpecifierContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

TypeSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTypeSpecifier(this);
	}
};

TypeSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTypeSpecifier(this);
	}
};




CParser.TypeSpecifierContext = TypeSpecifierContext;

CParser.prototype.typeSpecifier = function() {

    var localctx = new TypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, CParser.RULE_typeSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 567;
        switch(this._input.LA(1)) {
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.Char:
        case CParser.Double:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Bool:
        case CParser.Complex:
            this.enterOuterAlt(localctx, 1);
            this.state = 553;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.Char) | (1 << CParser.Double) | (1 << CParser.Float))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            break;
        case CParser.T__0:
            this.enterOuterAlt(localctx, 2);
            this.state = 554;
            this.match(CParser.T__0);
            this.state = 555;
            this.match(CParser.LeftParen);
            this.state = 556;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 557;
            this.match(CParser.RightParen);
            break;
        case CParser.Atomic:
            this.enterOuterAlt(localctx, 3);
            this.state = 558;
            this.atomicTypeSpecifier();
            break;
        case CParser.Struct:
        case CParser.Union:
            this.enterOuterAlt(localctx, 4);
            this.state = 559;
            this.structOrUnionSpecifier();
            break;
        case CParser.Enum:
            this.enterOuterAlt(localctx, 5);
            this.state = 560;
            this.enumSpecifier();
            break;
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 6);
            this.state = 561;
            this.typedefName();
            break;
        case CParser.T__6:
            this.enterOuterAlt(localctx, 7);
            this.state = 562;
            this.match(CParser.T__6);
            this.state = 563;
            this.match(CParser.LeftParen);
            this.state = 564;
            this.constantExpression();
            this.state = 565;
            this.match(CParser.RightParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructOrUnionSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structOrUnionSpecifier;
    return this;
}

StructOrUnionSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructOrUnionSpecifierContext.prototype.constructor = StructOrUnionSpecifierContext;

StructOrUnionSpecifierContext.prototype.structOrUnion = function() {
    return this.getTypedRuleContext(StructOrUnionContext,0);
};

StructOrUnionSpecifierContext.prototype.structDeclarationList = function() {
    return this.getTypedRuleContext(StructDeclarationListContext,0);
};

StructOrUnionSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

StructOrUnionSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructOrUnionSpecifier(this);
	}
};

StructOrUnionSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructOrUnionSpecifier(this);
	}
};




CParser.StructOrUnionSpecifierContext = StructOrUnionSpecifierContext;

CParser.prototype.structOrUnionSpecifier = function() {

    var localctx = new StructOrUnionSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, CParser.RULE_structOrUnionSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 580;
        var la_ = this._interp.adaptivePredict(this._input,39,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 569;
            this.structOrUnion();
            this.state = 571;
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 570;
                this.match(CParser.Identifier);
            }

            this.state = 573;
            this.match(CParser.LeftBrace);
            this.state = 574;
            this.structDeclarationList(0);
            this.state = 575;
            this.match(CParser.RightBrace);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 577;
            this.structOrUnion();
            this.state = 578;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructOrUnionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structOrUnion;
    return this;
}

StructOrUnionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructOrUnionContext.prototype.constructor = StructOrUnionContext;


StructOrUnionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructOrUnion(this);
	}
};

StructOrUnionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructOrUnion(this);
	}
};




CParser.StructOrUnionContext = StructOrUnionContext;

CParser.prototype.structOrUnion = function() {

    var localctx = new StructOrUnionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, CParser.RULE_structOrUnion);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 582;
        _la = this._input.LA(1);
        if(!(_la===CParser.Struct || _la===CParser.Union)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructDeclarationListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclarationList;
    return this;
}

StructDeclarationListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclarationListContext.prototype.constructor = StructDeclarationListContext;

StructDeclarationListContext.prototype.structDeclaration = function() {
    return this.getTypedRuleContext(StructDeclarationContext,0);
};

StructDeclarationListContext.prototype.structDeclarationList = function() {
    return this.getTypedRuleContext(StructDeclarationListContext,0);
};

StructDeclarationListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructDeclarationList(this);
	}
};

StructDeclarationListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructDeclarationList(this);
	}
};



CParser.prototype.structDeclarationList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new StructDeclarationListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 68;
    this.enterRecursionRule(localctx, 68, CParser.RULE_structDeclarationList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 585;
        this.structDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 591;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,40,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new StructDeclarationListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_structDeclarationList);
                this.state = 587;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 588;
                this.structDeclaration(); 
            }
            this.state = 593;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,40,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function StructDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclaration;
    return this;
}

StructDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclarationContext.prototype.constructor = StructDeclarationContext;

StructDeclarationContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

StructDeclarationContext.prototype.structDeclaratorList = function() {
    return this.getTypedRuleContext(StructDeclaratorListContext,0);
};

StructDeclarationContext.prototype.staticAssertDeclaration = function() {
    return this.getTypedRuleContext(StaticAssertDeclarationContext,0);
};

StructDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructDeclaration(this);
	}
};

StructDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructDeclaration(this);
	}
};




CParser.StructDeclarationContext = StructDeclarationContext;

CParser.prototype.structDeclaration = function() {

    var localctx = new StructDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, CParser.RULE_structDeclaration);
    var _la = 0; // Token type
    try {
        this.state = 601;
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.Char:
        case CParser.Const:
        case CParser.Double:
        case CParser.Enum:
        case CParser.Float:
        case CParser.Int:
        case CParser.Long:
        case CParser.Restrict:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Struct:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 594;
            this.specifierQualifierList();
            this.state = 596;
            _la = this._input.LA(1);
            if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)) | (1 << (CParser.Colon - 59)))) !== 0) || _la===CParser.Identifier) {
                this.state = 595;
                this.structDeclaratorList(0);
            }

            this.state = 598;
            this.match(CParser.Semi);
            break;
        case CParser.StaticAssert:
            this.enterOuterAlt(localctx, 2);
            this.state = 600;
            this.staticAssertDeclaration();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SpecifierQualifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_specifierQualifierList;
    return this;
}

SpecifierQualifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SpecifierQualifierListContext.prototype.constructor = SpecifierQualifierListContext;

SpecifierQualifierListContext.prototype.typeSpecifier = function() {
    return this.getTypedRuleContext(TypeSpecifierContext,0);
};

SpecifierQualifierListContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

SpecifierQualifierListContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

SpecifierQualifierListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterSpecifierQualifierList(this);
	}
};

SpecifierQualifierListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitSpecifierQualifierList(this);
	}
};




CParser.SpecifierQualifierListContext = SpecifierQualifierListContext;

CParser.prototype.specifierQualifierList = function() {

    var localctx = new SpecifierQualifierListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, CParser.RULE_specifierQualifierList);
    try {
        this.state = 611;
        var la_ = this._interp.adaptivePredict(this._input,45,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 603;
            this.typeSpecifier();
            this.state = 605;
            var la_ = this._interp.adaptivePredict(this._input,43,this._ctx);
            if(la_===1) {
                this.state = 604;
                this.specifierQualifierList();

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 607;
            this.typeQualifier();
            this.state = 609;
            var la_ = this._interp.adaptivePredict(this._input,44,this._ctx);
            if(la_===1) {
                this.state = 608;
                this.specifierQualifierList();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StructDeclaratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclaratorList;
    return this;
}

StructDeclaratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclaratorListContext.prototype.constructor = StructDeclaratorListContext;

StructDeclaratorListContext.prototype.structDeclarator = function() {
    return this.getTypedRuleContext(StructDeclaratorContext,0);
};

StructDeclaratorListContext.prototype.structDeclaratorList = function() {
    return this.getTypedRuleContext(StructDeclaratorListContext,0);
};

StructDeclaratorListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructDeclaratorList(this);
	}
};

StructDeclaratorListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructDeclaratorList(this);
	}
};



CParser.prototype.structDeclaratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new StructDeclaratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 74;
    this.enterRecursionRule(localctx, 74, CParser.RULE_structDeclaratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 614;
        this.structDeclarator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 621;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,46,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new StructDeclaratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_structDeclaratorList);
                this.state = 616;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 617;
                this.match(CParser.Comma);
                this.state = 618;
                this.structDeclarator(); 
            }
            this.state = 623;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,46,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function StructDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_structDeclarator;
    return this;
}

StructDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StructDeclaratorContext.prototype.constructor = StructDeclaratorContext;

StructDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

StructDeclaratorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

StructDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStructDeclarator(this);
	}
};

StructDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStructDeclarator(this);
	}
};




CParser.StructDeclaratorContext = StructDeclaratorContext;

CParser.prototype.structDeclarator = function() {

    var localctx = new StructDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, CParser.RULE_structDeclarator);
    var _la = 0; // Token type
    try {
        this.state = 630;
        var la_ = this._interp.adaptivePredict(this._input,48,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 624;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 626;
            _la = this._input.LA(1);
            if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)))) !== 0) || _la===CParser.Identifier) {
                this.state = 625;
                this.declarator();
            }

            this.state = 628;
            this.match(CParser.Colon);
            this.state = 629;
            this.constantExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumSpecifier;
    return this;
}

EnumSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumSpecifierContext.prototype.constructor = EnumSpecifierContext;

EnumSpecifierContext.prototype.enumeratorList = function() {
    return this.getTypedRuleContext(EnumeratorListContext,0);
};

EnumSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

EnumSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterEnumSpecifier(this);
	}
};

EnumSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitEnumSpecifier(this);
	}
};




CParser.EnumSpecifierContext = EnumSpecifierContext;

CParser.prototype.enumSpecifier = function() {

    var localctx = new EnumSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, CParser.RULE_enumSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 651;
        var la_ = this._interp.adaptivePredict(this._input,51,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 632;
            this.match(CParser.Enum);
            this.state = 634;
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 633;
                this.match(CParser.Identifier);
            }

            this.state = 636;
            this.match(CParser.LeftBrace);
            this.state = 637;
            this.enumeratorList(0);
            this.state = 638;
            this.match(CParser.RightBrace);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 640;
            this.match(CParser.Enum);
            this.state = 642;
            _la = this._input.LA(1);
            if(_la===CParser.Identifier) {
                this.state = 641;
                this.match(CParser.Identifier);
            }

            this.state = 644;
            this.match(CParser.LeftBrace);
            this.state = 645;
            this.enumeratorList(0);
            this.state = 646;
            this.match(CParser.Comma);
            this.state = 647;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 649;
            this.match(CParser.Enum);
            this.state = 650;
            this.match(CParser.Identifier);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumeratorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumeratorList;
    return this;
}

EnumeratorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorListContext.prototype.constructor = EnumeratorListContext;

EnumeratorListContext.prototype.enumerator = function() {
    return this.getTypedRuleContext(EnumeratorContext,0);
};

EnumeratorListContext.prototype.enumeratorList = function() {
    return this.getTypedRuleContext(EnumeratorListContext,0);
};

EnumeratorListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterEnumeratorList(this);
	}
};

EnumeratorListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitEnumeratorList(this);
	}
};



CParser.prototype.enumeratorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new EnumeratorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 80;
    this.enterRecursionRule(localctx, 80, CParser.RULE_enumeratorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 654;
        this.enumerator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 661;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,52,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new EnumeratorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_enumeratorList);
                this.state = 656;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 657;
                this.match(CParser.Comma);
                this.state = 658;
                this.enumerator(); 
            }
            this.state = 663;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,52,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function EnumeratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumerator;
    return this;
}

EnumeratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorContext.prototype.constructor = EnumeratorContext;

EnumeratorContext.prototype.enumerationConstant = function() {
    return this.getTypedRuleContext(EnumerationConstantContext,0);
};

EnumeratorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

EnumeratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterEnumerator(this);
	}
};

EnumeratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitEnumerator(this);
	}
};




CParser.EnumeratorContext = EnumeratorContext;

CParser.prototype.enumerator = function() {

    var localctx = new EnumeratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, CParser.RULE_enumerator);
    try {
        this.state = 669;
        var la_ = this._interp.adaptivePredict(this._input,53,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 664;
            this.enumerationConstant();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 665;
            this.enumerationConstant();
            this.state = 666;
            this.match(CParser.Assign);
            this.state = 667;
            this.constantExpression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumerationConstantContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_enumerationConstant;
    return this;
}

EnumerationConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumerationConstantContext.prototype.constructor = EnumerationConstantContext;

EnumerationConstantContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

EnumerationConstantContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterEnumerationConstant(this);
	}
};

EnumerationConstantContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitEnumerationConstant(this);
	}
};




CParser.EnumerationConstantContext = EnumerationConstantContext;

CParser.prototype.enumerationConstant = function() {

    var localctx = new EnumerationConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, CParser.RULE_enumerationConstant);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 671;
        this.match(CParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AtomicTypeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_atomicTypeSpecifier;
    return this;
}

AtomicTypeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AtomicTypeSpecifierContext.prototype.constructor = AtomicTypeSpecifierContext;

AtomicTypeSpecifierContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

AtomicTypeSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAtomicTypeSpecifier(this);
	}
};

AtomicTypeSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAtomicTypeSpecifier(this);
	}
};




CParser.AtomicTypeSpecifierContext = AtomicTypeSpecifierContext;

CParser.prototype.atomicTypeSpecifier = function() {

    var localctx = new AtomicTypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, CParser.RULE_atomicTypeSpecifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 673;
        this.match(CParser.Atomic);
        this.state = 674;
        this.match(CParser.LeftParen);
        this.state = 675;
        this.typeName();
        this.state = 676;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeQualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeQualifier;
    return this;
}

TypeQualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeQualifierContext.prototype.constructor = TypeQualifierContext;


TypeQualifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTypeQualifier(this);
	}
};

TypeQualifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTypeQualifier(this);
	}
};




CParser.TypeQualifierContext = TypeQualifierContext;

CParser.prototype.typeQualifier = function() {

    var localctx = new TypeQualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, CParser.RULE_typeQualifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 678;
        _la = this._input.LA(1);
        if(!(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_functionSpecifier;
    return this;
}

FunctionSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionSpecifierContext.prototype.constructor = FunctionSpecifierContext;

FunctionSpecifierContext.prototype.gccAttributeSpecifier = function() {
    return this.getTypedRuleContext(GccAttributeSpecifierContext,0);
};

FunctionSpecifierContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

FunctionSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterFunctionSpecifier(this);
	}
};

FunctionSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitFunctionSpecifier(this);
	}
};




CParser.FunctionSpecifierContext = FunctionSpecifierContext;

CParser.prototype.functionSpecifier = function() {

    var localctx = new FunctionSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, CParser.RULE_functionSpecifier);
    var _la = 0; // Token type
    try {
        this.state = 686;
        switch(this._input.LA(1)) {
        case CParser.T__7:
        case CParser.T__8:
        case CParser.Inline:
        case CParser.Noreturn:
            this.enterOuterAlt(localctx, 1);
            this.state = 680;
            _la = this._input.LA(1);
            if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.Inline))) !== 0) || _la===CParser.Noreturn)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            break;
        case CParser.T__11:
            this.enterOuterAlt(localctx, 2);
            this.state = 681;
            this.gccAttributeSpecifier();
            break;
        case CParser.T__9:
            this.enterOuterAlt(localctx, 3);
            this.state = 682;
            this.match(CParser.T__9);
            this.state = 683;
            this.match(CParser.LeftParen);
            this.state = 684;
            this.match(CParser.Identifier);
            this.state = 685;
            this.match(CParser.RightParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AlignmentSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_alignmentSpecifier;
    return this;
}

AlignmentSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AlignmentSpecifierContext.prototype.constructor = AlignmentSpecifierContext;

AlignmentSpecifierContext.prototype.typeName = function() {
    return this.getTypedRuleContext(TypeNameContext,0);
};

AlignmentSpecifierContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

AlignmentSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAlignmentSpecifier(this);
	}
};

AlignmentSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAlignmentSpecifier(this);
	}
};




CParser.AlignmentSpecifierContext = AlignmentSpecifierContext;

CParser.prototype.alignmentSpecifier = function() {

    var localctx = new AlignmentSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, CParser.RULE_alignmentSpecifier);
    try {
        this.state = 698;
        var la_ = this._interp.adaptivePredict(this._input,55,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 688;
            this.match(CParser.Alignas);
            this.state = 689;
            this.match(CParser.LeftParen);
            this.state = 690;
            this.typeName();
            this.state = 691;
            this.match(CParser.RightParen);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 693;
            this.match(CParser.Alignas);
            this.state = 694;
            this.match(CParser.LeftParen);
            this.state = 695;
            this.constantExpression();
            this.state = 696;
            this.match(CParser.RightParen);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarator;
    return this;
}

DeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclaratorContext.prototype.constructor = DeclaratorContext;

DeclaratorContext.prototype.directDeclarator = function() {
    return this.getTypedRuleContext(DirectDeclaratorContext,0);
};

DeclaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

DeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

DeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclarator(this);
	}
};

DeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclarator(this);
	}
};




CParser.DeclaratorContext = DeclaratorContext;

CParser.prototype.declarator = function() {

    var localctx = new DeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, CParser.RULE_declarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 701;
        _la = this._input.LA(1);
        if(_la===CParser.Star || _la===CParser.Caret) {
            this.state = 700;
            this.pointer();
        }

        this.state = 703;
        this.directDeclarator(0);
        this.state = 707;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,57,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 704;
                this.gccDeclaratorExtension(); 
            }
            this.state = 709;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,57,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DirectDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_directDeclarator;
    return this;
}

DirectDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DirectDeclaratorContext.prototype.constructor = DirectDeclaratorContext;

DirectDeclaratorContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

DirectDeclaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

DirectDeclaratorContext.prototype.directDeclarator = function() {
    return this.getTypedRuleContext(DirectDeclaratorContext,0);
};

DirectDeclaratorContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

DirectDeclaratorContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

DirectDeclaratorContext.prototype.parameterTypeList = function() {
    return this.getTypedRuleContext(ParameterTypeListContext,0);
};

DirectDeclaratorContext.prototype.identifierList = function() {
    return this.getTypedRuleContext(IdentifierListContext,0);
};

DirectDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDirectDeclarator(this);
	}
};

DirectDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDirectDeclarator(this);
	}
};



CParser.prototype.directDeclarator = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DirectDeclaratorContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 96;
    this.enterRecursionRule(localctx, 96, CParser.RULE_directDeclarator, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 716;
        switch(this._input.LA(1)) {
        case CParser.Identifier:
            this.state = 711;
            this.match(CParser.Identifier);
            break;
        case CParser.LeftParen:
            this.state = 712;
            this.match(CParser.LeftParen);
            this.state = 713;
            this.declarator();
            this.state = 714;
            this.match(CParser.RightParen);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 763;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,65,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 761;
                var la_ = this._interp.adaptivePredict(this._input,64,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 718;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 719;
                    this.match(CParser.LeftBracket);
                    this.state = 721;
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 720;
                        this.typeQualifierList(0);
                    }

                    this.state = 724;
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 723;
                        this.assignmentExpression();
                    }

                    this.state = 726;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 727;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 728;
                    this.match(CParser.LeftBracket);
                    this.state = 729;
                    this.match(CParser.Static);
                    this.state = 731;
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 730;
                        this.typeQualifierList(0);
                    }

                    this.state = 733;
                    this.assignmentExpression();
                    this.state = 734;
                    this.match(CParser.RightBracket);
                    break;

                case 3:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 736;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 737;
                    this.match(CParser.LeftBracket);
                    this.state = 738;
                    this.typeQualifierList(0);
                    this.state = 739;
                    this.match(CParser.Static);
                    this.state = 740;
                    this.assignmentExpression();
                    this.state = 741;
                    this.match(CParser.RightBracket);
                    break;

                case 4:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 743;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 744;
                    this.match(CParser.LeftBracket);
                    this.state = 746;
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 745;
                        this.typeQualifierList(0);
                    }

                    this.state = 748;
                    this.match(CParser.Star);
                    this.state = 749;
                    this.match(CParser.RightBracket);
                    break;

                case 5:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 750;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 751;
                    this.match(CParser.LeftParen);
                    this.state = 752;
                    this.parameterTypeList();
                    this.state = 753;
                    this.match(CParser.RightParen);
                    break;

                case 6:
                    localctx = new DirectDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directDeclarator);
                    this.state = 755;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 756;
                    this.match(CParser.LeftParen);
                    this.state = 758;
                    _la = this._input.LA(1);
                    if(_la===CParser.Identifier) {
                        this.state = 757;
                        this.identifierList(0);
                    }

                    this.state = 760;
                    this.match(CParser.RightParen);
                    break;

                } 
            }
            this.state = 765;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,65,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function GccDeclaratorExtensionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccDeclaratorExtension;
    return this;
}

GccDeclaratorExtensionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccDeclaratorExtensionContext.prototype.constructor = GccDeclaratorExtensionContext;

GccDeclaratorExtensionContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


GccDeclaratorExtensionContext.prototype.gccAttributeSpecifier = function() {
    return this.getTypedRuleContext(GccAttributeSpecifierContext,0);
};

GccDeclaratorExtensionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGccDeclaratorExtension(this);
	}
};

GccDeclaratorExtensionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGccDeclaratorExtension(this);
	}
};




CParser.GccDeclaratorExtensionContext = GccDeclaratorExtensionContext;

CParser.prototype.gccDeclaratorExtension = function() {

    var localctx = new GccDeclaratorExtensionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, CParser.RULE_gccDeclaratorExtension);
    var _la = 0; // Token type
    try {
        this.state = 775;
        switch(this._input.LA(1)) {
        case CParser.T__10:
            this.enterOuterAlt(localctx, 1);
            this.state = 766;
            this.match(CParser.T__10);
            this.state = 767;
            this.match(CParser.LeftParen);
            this.state = 769; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 768;
                this.match(CParser.StringLiteral);
                this.state = 771; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===CParser.StringLiteral);
            this.state = 773;
            this.match(CParser.RightParen);
            break;
        case CParser.T__11:
            this.enterOuterAlt(localctx, 2);
            this.state = 774;
            this.gccAttributeSpecifier();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeSpecifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttributeSpecifier;
    return this;
}

GccAttributeSpecifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeSpecifierContext.prototype.constructor = GccAttributeSpecifierContext;

GccAttributeSpecifierContext.prototype.gccAttributeList = function() {
    return this.getTypedRuleContext(GccAttributeListContext,0);
};

GccAttributeSpecifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGccAttributeSpecifier(this);
	}
};

GccAttributeSpecifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGccAttributeSpecifier(this);
	}
};




CParser.GccAttributeSpecifierContext = GccAttributeSpecifierContext;

CParser.prototype.gccAttributeSpecifier = function() {

    var localctx = new GccAttributeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, CParser.RULE_gccAttributeSpecifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 777;
        this.match(CParser.T__11);
        this.state = 778;
        this.match(CParser.LeftParen);
        this.state = 779;
        this.match(CParser.LeftParen);
        this.state = 780;
        this.gccAttributeList();
        this.state = 781;
        this.match(CParser.RightParen);
        this.state = 782;
        this.match(CParser.RightParen);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttributeList;
    return this;
}

GccAttributeListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeListContext.prototype.constructor = GccAttributeListContext;

GccAttributeListContext.prototype.gccAttribute = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccAttributeContext);
    } else {
        return this.getTypedRuleContext(GccAttributeContext,i);
    }
};

GccAttributeListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGccAttributeList(this);
	}
};

GccAttributeListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGccAttributeList(this);
	}
};




CParser.GccAttributeListContext = GccAttributeListContext;

CParser.prototype.gccAttributeList = function() {

    var localctx = new GccAttributeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, CParser.RULE_gccAttributeList);
    var _la = 0; // Token type
    try {
        this.state = 793;
        var la_ = this._interp.adaptivePredict(this._input,69,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 784;
            this.gccAttribute();
            this.state = 789;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===CParser.Comma) {
                this.state = 785;
                this.match(CParser.Comma);
                this.state = 786;
                this.gccAttribute();
                this.state = 791;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GccAttributeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_gccAttribute;
    return this;
}

GccAttributeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GccAttributeContext.prototype.constructor = GccAttributeContext;

GccAttributeContext.prototype.argumentExpressionList = function() {
    return this.getTypedRuleContext(ArgumentExpressionListContext,0);
};

GccAttributeContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterGccAttribute(this);
	}
};

GccAttributeContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitGccAttribute(this);
	}
};




CParser.GccAttributeContext = GccAttributeContext;

CParser.prototype.gccAttribute = function() {

    var localctx = new GccAttributeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, CParser.RULE_gccAttribute);
    var _la = 0; // Token type
    try {
        this.state = 804;
        switch(this._input.LA(1)) {
        case CParser.T__0:
        case CParser.T__1:
        case CParser.T__2:
        case CParser.T__3:
        case CParser.T__4:
        case CParser.T__5:
        case CParser.T__6:
        case CParser.T__7:
        case CParser.T__8:
        case CParser.T__9:
        case CParser.T__10:
        case CParser.T__11:
        case CParser.T__12:
        case CParser.T__13:
        case CParser.Auto:
        case CParser.Break:
        case CParser.Case:
        case CParser.Char:
        case CParser.Const:
        case CParser.Continue:
        case CParser.Default:
        case CParser.Do:
        case CParser.Double:
        case CParser.Else:
        case CParser.Enum:
        case CParser.Extern:
        case CParser.Float:
        case CParser.For:
        case CParser.Goto:
        case CParser.If:
        case CParser.Inline:
        case CParser.Int:
        case CParser.Long:
        case CParser.Register:
        case CParser.Restrict:
        case CParser.Return:
        case CParser.Short:
        case CParser.Signed:
        case CParser.Sizeof:
        case CParser.Static:
        case CParser.Struct:
        case CParser.Switch:
        case CParser.Typedef:
        case CParser.Union:
        case CParser.Unsigned:
        case CParser.Void:
        case CParser.Volatile:
        case CParser.While:
        case CParser.Alignas:
        case CParser.Alignof:
        case CParser.Atomic:
        case CParser.Bool:
        case CParser.Complex:
        case CParser.Generic:
        case CParser.Imaginary:
        case CParser.Noreturn:
        case CParser.StaticAssert:
        case CParser.ThreadLocal:
        case CParser.LeftBracket:
        case CParser.RightBracket:
        case CParser.LeftBrace:
        case CParser.RightBrace:
        case CParser.Less:
        case CParser.LessEqual:
        case CParser.Greater:
        case CParser.GreaterEqual:
        case CParser.LeftShift:
        case CParser.RightShift:
        case CParser.Plus:
        case CParser.PlusPlus:
        case CParser.Minus:
        case CParser.MinusMinus:
        case CParser.Star:
        case CParser.Div:
        case CParser.Mod:
        case CParser.And:
        case CParser.Or:
        case CParser.AndAnd:
        case CParser.OrOr:
        case CParser.Caret:
        case CParser.Not:
        case CParser.Tilde:
        case CParser.Question:
        case CParser.Colon:
        case CParser.Semi:
        case CParser.Assign:
        case CParser.StarAssign:
        case CParser.DivAssign:
        case CParser.ModAssign:
        case CParser.PlusAssign:
        case CParser.MinusAssign:
        case CParser.LeftShiftAssign:
        case CParser.RightShiftAssign:
        case CParser.AndAssign:
        case CParser.XorAssign:
        case CParser.OrAssign:
        case CParser.Equal:
        case CParser.NotEqual:
        case CParser.Arrow:
        case CParser.Dot:
        case CParser.Ellipsis:
        case CParser.Identifier:
        case CParser.Constant:
        case CParser.StringLiteral:
        case CParser.LineDirective:
        case CParser.PragmaDirective:
        case CParser.Whitespace:
        case CParser.Newline:
        case CParser.BlockComment:
        case CParser.LineComment:
            this.enterOuterAlt(localctx, 1);
            this.state = 795;
            _la = this._input.LA(1);
            if(_la<=0 || ((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.RightParen - 59)) | (1 << (CParser.Comma - 59)))) !== 0)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 801;
            _la = this._input.LA(1);
            if(_la===CParser.LeftParen) {
                this.state = 796;
                this.match(CParser.LeftParen);
                this.state = 798;
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                    this.state = 797;
                    this.argumentExpressionList(0);
                }

                this.state = 800;
                this.match(CParser.RightParen);
            }

            break;
        case CParser.RightParen:
        case CParser.Comma:
            this.enterOuterAlt(localctx, 2);

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NestedParenthesesBlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_nestedParenthesesBlock;
    return this;
}

NestedParenthesesBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NestedParenthesesBlockContext.prototype.constructor = NestedParenthesesBlockContext;

NestedParenthesesBlockContext.prototype.nestedParenthesesBlock = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(NestedParenthesesBlockContext);
    } else {
        return this.getTypedRuleContext(NestedParenthesesBlockContext,i);
    }
};

NestedParenthesesBlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterNestedParenthesesBlock(this);
	}
};

NestedParenthesesBlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitNestedParenthesesBlock(this);
	}
};




CParser.NestedParenthesesBlockContext = NestedParenthesesBlockContext;

CParser.prototype.nestedParenthesesBlock = function() {

    var localctx = new NestedParenthesesBlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, CParser.RULE_nestedParenthesesBlock);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 813;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.T__13) | (1 << CParser.Auto) | (1 << CParser.Break) | (1 << CParser.Case) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Continue) | (1 << CParser.Default) | (1 << CParser.Do) | (1 << CParser.Double) | (1 << CParser.Else) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.For) | (1 << CParser.Goto) | (1 << CParser.If) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Return - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Sizeof - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Switch - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.While - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Alignof - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Generic - 32)) | (1 << (CParser.Imaginary - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)) | (1 << (CParser.LeftBracket - 32)) | (1 << (CParser.RightBracket - 32)) | (1 << (CParser.LeftBrace - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (CParser.RightBrace - 64)) | (1 << (CParser.Less - 64)) | (1 << (CParser.LessEqual - 64)) | (1 << (CParser.Greater - 64)) | (1 << (CParser.GreaterEqual - 64)) | (1 << (CParser.LeftShift - 64)) | (1 << (CParser.RightShift - 64)) | (1 << (CParser.Plus - 64)) | (1 << (CParser.PlusPlus - 64)) | (1 << (CParser.Minus - 64)) | (1 << (CParser.MinusMinus - 64)) | (1 << (CParser.Star - 64)) | (1 << (CParser.Div - 64)) | (1 << (CParser.Mod - 64)) | (1 << (CParser.And - 64)) | (1 << (CParser.Or - 64)) | (1 << (CParser.AndAnd - 64)) | (1 << (CParser.OrOr - 64)) | (1 << (CParser.Caret - 64)) | (1 << (CParser.Not - 64)) | (1 << (CParser.Tilde - 64)) | (1 << (CParser.Question - 64)) | (1 << (CParser.Colon - 64)) | (1 << (CParser.Semi - 64)) | (1 << (CParser.Comma - 64)) | (1 << (CParser.Assign - 64)) | (1 << (CParser.StarAssign - 64)) | (1 << (CParser.DivAssign - 64)) | (1 << (CParser.ModAssign - 64)) | (1 << (CParser.PlusAssign - 64)) | (1 << (CParser.MinusAssign - 64)) | (1 << (CParser.LeftShiftAssign - 64)))) !== 0) || ((((_la - 96)) & ~0x1f) == 0 && ((1 << (_la - 96)) & ((1 << (CParser.RightShiftAssign - 96)) | (1 << (CParser.AndAssign - 96)) | (1 << (CParser.XorAssign - 96)) | (1 << (CParser.OrAssign - 96)) | (1 << (CParser.Equal - 96)) | (1 << (CParser.NotEqual - 96)) | (1 << (CParser.Arrow - 96)) | (1 << (CParser.Dot - 96)) | (1 << (CParser.Ellipsis - 96)) | (1 << (CParser.Identifier - 96)) | (1 << (CParser.Constant - 96)) | (1 << (CParser.StringLiteral - 96)) | (1 << (CParser.LineDirective - 96)) | (1 << (CParser.PragmaDirective - 96)) | (1 << (CParser.Whitespace - 96)) | (1 << (CParser.Newline - 96)) | (1 << (CParser.BlockComment - 96)) | (1 << (CParser.LineComment - 96)))) !== 0)) {
            this.state = 811;
            switch(this._input.LA(1)) {
            case CParser.T__0:
            case CParser.T__1:
            case CParser.T__2:
            case CParser.T__3:
            case CParser.T__4:
            case CParser.T__5:
            case CParser.T__6:
            case CParser.T__7:
            case CParser.T__8:
            case CParser.T__9:
            case CParser.T__10:
            case CParser.T__11:
            case CParser.T__12:
            case CParser.T__13:
            case CParser.Auto:
            case CParser.Break:
            case CParser.Case:
            case CParser.Char:
            case CParser.Const:
            case CParser.Continue:
            case CParser.Default:
            case CParser.Do:
            case CParser.Double:
            case CParser.Else:
            case CParser.Enum:
            case CParser.Extern:
            case CParser.Float:
            case CParser.For:
            case CParser.Goto:
            case CParser.If:
            case CParser.Inline:
            case CParser.Int:
            case CParser.Long:
            case CParser.Register:
            case CParser.Restrict:
            case CParser.Return:
            case CParser.Short:
            case CParser.Signed:
            case CParser.Sizeof:
            case CParser.Static:
            case CParser.Struct:
            case CParser.Switch:
            case CParser.Typedef:
            case CParser.Union:
            case CParser.Unsigned:
            case CParser.Void:
            case CParser.Volatile:
            case CParser.While:
            case CParser.Alignas:
            case CParser.Alignof:
            case CParser.Atomic:
            case CParser.Bool:
            case CParser.Complex:
            case CParser.Generic:
            case CParser.Imaginary:
            case CParser.Noreturn:
            case CParser.StaticAssert:
            case CParser.ThreadLocal:
            case CParser.LeftBracket:
            case CParser.RightBracket:
            case CParser.LeftBrace:
            case CParser.RightBrace:
            case CParser.Less:
            case CParser.LessEqual:
            case CParser.Greater:
            case CParser.GreaterEqual:
            case CParser.LeftShift:
            case CParser.RightShift:
            case CParser.Plus:
            case CParser.PlusPlus:
            case CParser.Minus:
            case CParser.MinusMinus:
            case CParser.Star:
            case CParser.Div:
            case CParser.Mod:
            case CParser.And:
            case CParser.Or:
            case CParser.AndAnd:
            case CParser.OrOr:
            case CParser.Caret:
            case CParser.Not:
            case CParser.Tilde:
            case CParser.Question:
            case CParser.Colon:
            case CParser.Semi:
            case CParser.Comma:
            case CParser.Assign:
            case CParser.StarAssign:
            case CParser.DivAssign:
            case CParser.ModAssign:
            case CParser.PlusAssign:
            case CParser.MinusAssign:
            case CParser.LeftShiftAssign:
            case CParser.RightShiftAssign:
            case CParser.AndAssign:
            case CParser.XorAssign:
            case CParser.OrAssign:
            case CParser.Equal:
            case CParser.NotEqual:
            case CParser.Arrow:
            case CParser.Dot:
            case CParser.Ellipsis:
            case CParser.Identifier:
            case CParser.Constant:
            case CParser.StringLiteral:
            case CParser.LineDirective:
            case CParser.PragmaDirective:
            case CParser.Whitespace:
            case CParser.Newline:
            case CParser.BlockComment:
            case CParser.LineComment:
                this.state = 806;
                _la = this._input.LA(1);
                if(_la<=0 || _la===CParser.LeftParen || _la===CParser.RightParen) {
                this._errHandler.recoverInline(this);
                }
                else {
                    this.consume();
                }
                break;
            case CParser.LeftParen:
                this.state = 807;
                this.match(CParser.LeftParen);
                this.state = 808;
                this.nestedParenthesesBlock();
                this.state = 809;
                this.match(CParser.RightParen);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 815;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PointerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_pointer;
    return this;
}

PointerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PointerContext.prototype.constructor = PointerContext;

PointerContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

PointerContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

PointerContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterPointer(this);
	}
};

PointerContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitPointer(this);
	}
};




CParser.PointerContext = PointerContext;

CParser.prototype.pointer = function() {

    var localctx = new PointerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, CParser.RULE_pointer);
    var _la = 0; // Token type
    try {
        this.state = 834;
        var la_ = this._interp.adaptivePredict(this._input,79,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 816;
            this.match(CParser.Star);
            this.state = 818;
            var la_ = this._interp.adaptivePredict(this._input,75,this._ctx);
            if(la_===1) {
                this.state = 817;
                this.typeQualifierList(0);

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 820;
            this.match(CParser.Star);
            this.state = 822;
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 821;
                this.typeQualifierList(0);
            }

            this.state = 824;
            this.pointer();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 825;
            this.match(CParser.Caret);
            this.state = 827;
            var la_ = this._interp.adaptivePredict(this._input,77,this._ctx);
            if(la_===1) {
                this.state = 826;
                this.typeQualifierList(0);

            }
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 829;
            this.match(CParser.Caret);
            this.state = 831;
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 830;
                this.typeQualifierList(0);
            }

            this.state = 833;
            this.pointer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeQualifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeQualifierList;
    return this;
}

TypeQualifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeQualifierListContext.prototype.constructor = TypeQualifierListContext;

TypeQualifierListContext.prototype.typeQualifier = function() {
    return this.getTypedRuleContext(TypeQualifierContext,0);
};

TypeQualifierListContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

TypeQualifierListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTypeQualifierList(this);
	}
};

TypeQualifierListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTypeQualifierList(this);
	}
};



CParser.prototype.typeQualifierList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new TypeQualifierListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 110;
    this.enterRecursionRule(localctx, 110, CParser.RULE_typeQualifierList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 837;
        this.typeQualifier();
        this._ctx.stop = this._input.LT(-1);
        this.state = 843;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,80,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new TypeQualifierListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_typeQualifierList);
                this.state = 839;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 840;
                this.typeQualifier(); 
            }
            this.state = 845;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,80,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ParameterTypeListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterTypeList;
    return this;
}

ParameterTypeListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterTypeListContext.prototype.constructor = ParameterTypeListContext;

ParameterTypeListContext.prototype.parameterList = function() {
    return this.getTypedRuleContext(ParameterListContext,0);
};

ParameterTypeListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterParameterTypeList(this);
	}
};

ParameterTypeListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitParameterTypeList(this);
	}
};




CParser.ParameterTypeListContext = ParameterTypeListContext;

CParser.prototype.parameterTypeList = function() {

    var localctx = new ParameterTypeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, CParser.RULE_parameterTypeList);
    try {
        this.state = 851;
        var la_ = this._interp.adaptivePredict(this._input,81,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 846;
            this.parameterList(0);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 847;
            this.parameterList(0);
            this.state = 848;
            this.match(CParser.Comma);
            this.state = 849;
            this.match(CParser.Ellipsis);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParameterListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterList;
    return this;
}

ParameterListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterListContext.prototype.constructor = ParameterListContext;

ParameterListContext.prototype.parameterDeclaration = function() {
    return this.getTypedRuleContext(ParameterDeclarationContext,0);
};

ParameterListContext.prototype.parameterList = function() {
    return this.getTypedRuleContext(ParameterListContext,0);
};

ParameterListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterParameterList(this);
	}
};

ParameterListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitParameterList(this);
	}
};



CParser.prototype.parameterList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ParameterListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 114;
    this.enterRecursionRule(localctx, 114, CParser.RULE_parameterList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 854;
        this.parameterDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 861;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,82,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new ParameterListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_parameterList);
                this.state = 856;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 857;
                this.match(CParser.Comma);
                this.state = 858;
                this.parameterDeclaration(); 
            }
            this.state = 863;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,82,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ParameterDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_parameterDeclaration;
    return this;
}

ParameterDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParameterDeclarationContext.prototype.constructor = ParameterDeclarationContext;

ParameterDeclarationContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

ParameterDeclarationContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

ParameterDeclarationContext.prototype.declarationSpecifiers2 = function() {
    return this.getTypedRuleContext(DeclarationSpecifiers2Context,0);
};

ParameterDeclarationContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

ParameterDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterParameterDeclaration(this);
	}
};

ParameterDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitParameterDeclaration(this);
	}
};




CParser.ParameterDeclarationContext = ParameterDeclarationContext;

CParser.prototype.parameterDeclaration = function() {

    var localctx = new ParameterDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, CParser.RULE_parameterDeclaration);
    try {
        this.state = 871;
        var la_ = this._interp.adaptivePredict(this._input,84,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 864;
            this.declarationSpecifiers();
            this.state = 865;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 867;
            this.declarationSpecifiers2();
            this.state = 869;
            var la_ = this._interp.adaptivePredict(this._input,83,this._ctx);
            if(la_===1) {
                this.state = 868;
                this.abstractDeclarator();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IdentifierListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_identifierList;
    return this;
}

IdentifierListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IdentifierListContext.prototype.constructor = IdentifierListContext;

IdentifierListContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

IdentifierListContext.prototype.identifierList = function() {
    return this.getTypedRuleContext(IdentifierListContext,0);
};

IdentifierListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterIdentifierList(this);
	}
};

IdentifierListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitIdentifierList(this);
	}
};



CParser.prototype.identifierList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new IdentifierListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 118;
    this.enterRecursionRule(localctx, 118, CParser.RULE_identifierList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 874;
        this.match(CParser.Identifier);
        this._ctx.stop = this._input.LT(-1);
        this.state = 881;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,85,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new IdentifierListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_identifierList);
                this.state = 876;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 877;
                this.match(CParser.Comma);
                this.state = 878;
                this.match(CParser.Identifier); 
            }
            this.state = 883;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,85,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function TypeNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typeName;
    return this;
}

TypeNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeNameContext.prototype.constructor = TypeNameContext;

TypeNameContext.prototype.specifierQualifierList = function() {
    return this.getTypedRuleContext(SpecifierQualifierListContext,0);
};

TypeNameContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

TypeNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTypeName(this);
	}
};

TypeNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTypeName(this);
	}
};




CParser.TypeNameContext = TypeNameContext;

CParser.prototype.typeName = function() {

    var localctx = new TypeNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, CParser.RULE_typeName);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 884;
        this.specifierQualifierList();
        this.state = 886;
        _la = this._input.LA(1);
        if(((((_la - 59)) & ~0x1f) == 0 && ((1 << (_la - 59)) & ((1 << (CParser.LeftParen - 59)) | (1 << (CParser.LeftBracket - 59)) | (1 << (CParser.Star - 59)) | (1 << (CParser.Caret - 59)))) !== 0)) {
            this.state = 885;
            this.abstractDeclarator();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AbstractDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_abstractDeclarator;
    return this;
}

AbstractDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AbstractDeclaratorContext.prototype.constructor = AbstractDeclaratorContext;

AbstractDeclaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

AbstractDeclaratorContext.prototype.directAbstractDeclarator = function() {
    return this.getTypedRuleContext(DirectAbstractDeclaratorContext,0);
};

AbstractDeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

AbstractDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterAbstractDeclarator(this);
	}
};

AbstractDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitAbstractDeclarator(this);
	}
};




CParser.AbstractDeclaratorContext = AbstractDeclaratorContext;

CParser.prototype.abstractDeclarator = function() {

    var localctx = new AbstractDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, CParser.RULE_abstractDeclarator);
    var _la = 0; // Token type
    try {
        this.state = 899;
        var la_ = this._interp.adaptivePredict(this._input,89,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 888;
            this.pointer();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 890;
            _la = this._input.LA(1);
            if(_la===CParser.Star || _la===CParser.Caret) {
                this.state = 889;
                this.pointer();
            }

            this.state = 892;
            this.directAbstractDeclarator(0);
            this.state = 896;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,88,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 893;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 898;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,88,this._ctx);
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DirectAbstractDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_directAbstractDeclarator;
    return this;
}

DirectAbstractDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DirectAbstractDeclaratorContext.prototype.constructor = DirectAbstractDeclaratorContext;

DirectAbstractDeclaratorContext.prototype.abstractDeclarator = function() {
    return this.getTypedRuleContext(AbstractDeclaratorContext,0);
};

DirectAbstractDeclaratorContext.prototype.gccDeclaratorExtension = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GccDeclaratorExtensionContext);
    } else {
        return this.getTypedRuleContext(GccDeclaratorExtensionContext,i);
    }
};

DirectAbstractDeclaratorContext.prototype.typeQualifierList = function() {
    return this.getTypedRuleContext(TypeQualifierListContext,0);
};

DirectAbstractDeclaratorContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

DirectAbstractDeclaratorContext.prototype.parameterTypeList = function() {
    return this.getTypedRuleContext(ParameterTypeListContext,0);
};

DirectAbstractDeclaratorContext.prototype.directAbstractDeclarator = function() {
    return this.getTypedRuleContext(DirectAbstractDeclaratorContext,0);
};

DirectAbstractDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDirectAbstractDeclarator(this);
	}
};

DirectAbstractDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDirectAbstractDeclarator(this);
	}
};



CParser.prototype.directAbstractDeclarator = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DirectAbstractDeclaratorContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 124;
    this.enterRecursionRule(localctx, 124, CParser.RULE_directAbstractDeclarator, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 947;
        var la_ = this._interp.adaptivePredict(this._input,96,this._ctx);
        switch(la_) {
        case 1:
            this.state = 902;
            this.match(CParser.LeftParen);
            this.state = 903;
            this.abstractDeclarator();
            this.state = 904;
            this.match(CParser.RightParen);
            this.state = 908;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,90,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 905;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 910;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,90,this._ctx);
            }

            break;

        case 2:
            this.state = 911;
            this.match(CParser.LeftBracket);
            this.state = 913;
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 912;
                this.typeQualifierList(0);
            }

            this.state = 916;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 915;
                this.assignmentExpression();
            }

            this.state = 918;
            this.match(CParser.RightBracket);
            break;

        case 3:
            this.state = 919;
            this.match(CParser.LeftBracket);
            this.state = 920;
            this.match(CParser.Static);
            this.state = 922;
            _la = this._input.LA(1);
            if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                this.state = 921;
                this.typeQualifierList(0);
            }

            this.state = 924;
            this.assignmentExpression();
            this.state = 925;
            this.match(CParser.RightBracket);
            break;

        case 4:
            this.state = 927;
            this.match(CParser.LeftBracket);
            this.state = 928;
            this.typeQualifierList(0);
            this.state = 929;
            this.match(CParser.Static);
            this.state = 930;
            this.assignmentExpression();
            this.state = 931;
            this.match(CParser.RightBracket);
            break;

        case 5:
            this.state = 933;
            this.match(CParser.LeftBracket);
            this.state = 934;
            this.match(CParser.Star);
            this.state = 935;
            this.match(CParser.RightBracket);
            break;

        case 6:
            this.state = 936;
            this.match(CParser.LeftParen);
            this.state = 938;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
                this.state = 937;
                this.parameterTypeList();
            }

            this.state = 940;
            this.match(CParser.RightParen);
            this.state = 944;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,95,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 941;
                    this.gccDeclaratorExtension(); 
                }
                this.state = 946;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,95,this._ctx);
            }

            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 992;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,103,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 990;
                var la_ = this._interp.adaptivePredict(this._input,102,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 949;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 950;
                    this.match(CParser.LeftBracket);
                    this.state = 952;
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 951;
                        this.typeQualifierList(0);
                    }

                    this.state = 955;
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                        this.state = 954;
                        this.assignmentExpression();
                    }

                    this.state = 957;
                    this.match(CParser.RightBracket);
                    break;

                case 2:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 958;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 959;
                    this.match(CParser.LeftBracket);
                    this.state = 960;
                    this.match(CParser.Static);
                    this.state = 962;
                    _la = this._input.LA(1);
                    if(_la===CParser.Const || ((((_la - 35)) & ~0x1f) == 0 && ((1 << (_la - 35)) & ((1 << (CParser.Restrict - 35)) | (1 << (CParser.Volatile - 35)) | (1 << (CParser.Atomic - 35)))) !== 0)) {
                        this.state = 961;
                        this.typeQualifierList(0);
                    }

                    this.state = 964;
                    this.assignmentExpression();
                    this.state = 965;
                    this.match(CParser.RightBracket);
                    break;

                case 3:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 967;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 968;
                    this.match(CParser.LeftBracket);
                    this.state = 969;
                    this.typeQualifierList(0);
                    this.state = 970;
                    this.match(CParser.Static);
                    this.state = 971;
                    this.assignmentExpression();
                    this.state = 972;
                    this.match(CParser.RightBracket);
                    break;

                case 4:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 974;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 975;
                    this.match(CParser.LeftBracket);
                    this.state = 976;
                    this.match(CParser.Star);
                    this.state = 977;
                    this.match(CParser.RightBracket);
                    break;

                case 5:
                    localctx = new DirectAbstractDeclaratorContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, CParser.RULE_directAbstractDeclarator);
                    this.state = 978;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 979;
                    this.match(CParser.LeftParen);
                    this.state = 981;
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
                        this.state = 980;
                        this.parameterTypeList();
                    }

                    this.state = 983;
                    this.match(CParser.RightParen);
                    this.state = 987;
                    this._errHandler.sync(this);
                    var _alt = this._interp.adaptivePredict(this._input,101,this._ctx)
                    while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                        if(_alt===1) {
                            this.state = 984;
                            this.gccDeclaratorExtension(); 
                        }
                        this.state = 989;
                        this._errHandler.sync(this);
                        _alt = this._interp.adaptivePredict(this._input,101,this._ctx);
                    }

                    break;

                } 
            }
            this.state = 994;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,103,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function TypedefNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_typedefName;
    return this;
}

TypedefNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypedefNameContext.prototype.constructor = TypedefNameContext;

TypedefNameContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

TypedefNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTypedefName(this);
	}
};

TypedefNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTypedefName(this);
	}
};




CParser.TypedefNameContext = TypedefNameContext;

CParser.prototype.typedefName = function() {

    var localctx = new TypedefNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, CParser.RULE_typedefName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 995;
        this.match(CParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initializer;
    return this;
}

InitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitializerContext.prototype.constructor = InitializerContext;

InitializerContext.prototype.assignmentExpression = function() {
    return this.getTypedRuleContext(AssignmentExpressionContext,0);
};

InitializerContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

InitializerContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterInitializer(this);
	}
};

InitializerContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitInitializer(this);
	}
};




CParser.InitializerContext = InitializerContext;

CParser.prototype.initializer = function() {

    var localctx = new InitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, CParser.RULE_initializer);
    try {
        this.state = 1007;
        var la_ = this._interp.adaptivePredict(this._input,104,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 997;
            this.assignmentExpression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 998;
            this.match(CParser.LeftBrace);
            this.state = 999;
            this.initializerList(0);
            this.state = 1000;
            this.match(CParser.RightBrace);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1002;
            this.match(CParser.LeftBrace);
            this.state = 1003;
            this.initializerList(0);
            this.state = 1004;
            this.match(CParser.Comma);
            this.state = 1005;
            this.match(CParser.RightBrace);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitializerListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_initializerList;
    return this;
}

InitializerListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitializerListContext.prototype.constructor = InitializerListContext;

InitializerListContext.prototype.initializer = function() {
    return this.getTypedRuleContext(InitializerContext,0);
};

InitializerListContext.prototype.designation = function() {
    return this.getTypedRuleContext(DesignationContext,0);
};

InitializerListContext.prototype.initializerList = function() {
    return this.getTypedRuleContext(InitializerListContext,0);
};

InitializerListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterInitializerList(this);
	}
};

InitializerListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitInitializerList(this);
	}
};



CParser.prototype.initializerList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InitializerListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 130;
    this.enterRecursionRule(localctx, 130, CParser.RULE_initializerList, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1011;
        _la = this._input.LA(1);
        if(_la===CParser.LeftBracket || _la===CParser.Dot) {
            this.state = 1010;
            this.designation();
        }

        this.state = 1013;
        this.initializer();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1023;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,107,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InitializerListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_initializerList);
                this.state = 1015;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1016;
                this.match(CParser.Comma);
                this.state = 1018;
                _la = this._input.LA(1);
                if(_la===CParser.LeftBracket || _la===CParser.Dot) {
                    this.state = 1017;
                    this.designation();
                }

                this.state = 1020;
                this.initializer(); 
            }
            this.state = 1025;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,107,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function DesignationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designation;
    return this;
}

DesignationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignationContext.prototype.constructor = DesignationContext;

DesignationContext.prototype.designatorList = function() {
    return this.getTypedRuleContext(DesignatorListContext,0);
};

DesignationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDesignation(this);
	}
};

DesignationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDesignation(this);
	}
};




CParser.DesignationContext = DesignationContext;

CParser.prototype.designation = function() {

    var localctx = new DesignationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, CParser.RULE_designation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1026;
        this.designatorList(0);
        this.state = 1027;
        this.match(CParser.Assign);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DesignatorListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designatorList;
    return this;
}

DesignatorListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignatorListContext.prototype.constructor = DesignatorListContext;

DesignatorListContext.prototype.designator = function() {
    return this.getTypedRuleContext(DesignatorContext,0);
};

DesignatorListContext.prototype.designatorList = function() {
    return this.getTypedRuleContext(DesignatorListContext,0);
};

DesignatorListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDesignatorList(this);
	}
};

DesignatorListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDesignatorList(this);
	}
};



CParser.prototype.designatorList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DesignatorListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 134;
    this.enterRecursionRule(localctx, 134, CParser.RULE_designatorList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1030;
        this.designator();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1036;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,108,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new DesignatorListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_designatorList);
                this.state = 1032;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1033;
                this.designator(); 
            }
            this.state = 1038;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,108,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function DesignatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_designator;
    return this;
}

DesignatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DesignatorContext.prototype.constructor = DesignatorContext;

DesignatorContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

DesignatorContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

DesignatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDesignator(this);
	}
};

DesignatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDesignator(this);
	}
};




CParser.DesignatorContext = DesignatorContext;

CParser.prototype.designator = function() {

    var localctx = new DesignatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, CParser.RULE_designator);
    try {
        this.state = 1045;
        switch(this._input.LA(1)) {
        case CParser.LeftBracket:
            this.enterOuterAlt(localctx, 1);
            this.state = 1039;
            this.match(CParser.LeftBracket);
            this.state = 1040;
            this.constantExpression();
            this.state = 1041;
            this.match(CParser.RightBracket);
            break;
        case CParser.Dot:
            this.enterOuterAlt(localctx, 2);
            this.state = 1043;
            this.match(CParser.Dot);
            this.state = 1044;
            this.match(CParser.Identifier);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StaticAssertDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_staticAssertDeclaration;
    return this;
}

StaticAssertDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StaticAssertDeclarationContext.prototype.constructor = StaticAssertDeclarationContext;

StaticAssertDeclarationContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

StaticAssertDeclarationContext.prototype.StringLiteral = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(CParser.StringLiteral);
    } else {
        return this.getToken(CParser.StringLiteral, i);
    }
};


StaticAssertDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStaticAssertDeclaration(this);
	}
};

StaticAssertDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStaticAssertDeclaration(this);
	}
};




CParser.StaticAssertDeclarationContext = StaticAssertDeclarationContext;

CParser.prototype.staticAssertDeclaration = function() {

    var localctx = new StaticAssertDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, CParser.RULE_staticAssertDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1047;
        this.match(CParser.StaticAssert);
        this.state = 1048;
        this.match(CParser.LeftParen);
        this.state = 1049;
        this.constantExpression();
        this.state = 1050;
        this.match(CParser.Comma);
        this.state = 1052; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 1051;
            this.match(CParser.StringLiteral);
            this.state = 1054; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===CParser.StringLiteral);
        this.state = 1056;
        this.match(CParser.RightParen);
        this.state = 1057;
        this.match(CParser.Semi);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;

StatementContext.prototype.labeledStatement = function() {
    return this.getTypedRuleContext(LabeledStatementContext,0);
};

StatementContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

StatementContext.prototype.expressionStatement = function() {
    return this.getTypedRuleContext(ExpressionStatementContext,0);
};

StatementContext.prototype.selectionStatement = function() {
    return this.getTypedRuleContext(SelectionStatementContext,0);
};

StatementContext.prototype.iterationStatement = function() {
    return this.getTypedRuleContext(IterationStatementContext,0);
};

StatementContext.prototype.jumpStatement = function() {
    return this.getTypedRuleContext(JumpStatementContext,0);
};

StatementContext.prototype.logicalOrExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LogicalOrExpressionContext);
    } else {
        return this.getTypedRuleContext(LogicalOrExpressionContext,i);
    }
};

StatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterStatement(this);
	}
};

StatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitStatement(this);
	}
};




CParser.StatementContext = StatementContext;

CParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, CParser.RULE_statement);
    var _la = 0; // Token type
    try {
        this.state = 1096;
        var la_ = this._interp.adaptivePredict(this._input,116,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1059;
            this.labeledStatement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1060;
            this.compoundStatement();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1061;
            this.expressionStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1062;
            this.selectionStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1063;
            this.iterationStatement();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 1064;
            this.jumpStatement();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 1065;
            _la = this._input.LA(1);
            if(!(_la===CParser.T__10 || _la===CParser.T__12)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1066;
            _la = this._input.LA(1);
            if(!(_la===CParser.T__13 || _la===CParser.Volatile)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1067;
            this.match(CParser.LeftParen);
            this.state = 1076;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1068;
                this.logicalOrExpression(0);
                this.state = 1073;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===CParser.Comma) {
                    this.state = 1069;
                    this.match(CParser.Comma);
                    this.state = 1070;
                    this.logicalOrExpression(0);
                    this.state = 1075;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 1091;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===CParser.Colon) {
                this.state = 1078;
                this.match(CParser.Colon);
                this.state = 1087;
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                    this.state = 1079;
                    this.logicalOrExpression(0);
                    this.state = 1084;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                    while(_la===CParser.Comma) {
                        this.state = 1080;
                        this.match(CParser.Comma);
                        this.state = 1081;
                        this.logicalOrExpression(0);
                        this.state = 1086;
                        this._errHandler.sync(this);
                        _la = this._input.LA(1);
                    }
                }

                this.state = 1093;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1094;
            this.match(CParser.RightParen);
            this.state = 1095;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LabeledStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_labeledStatement;
    return this;
}

LabeledStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LabeledStatementContext.prototype.constructor = LabeledStatementContext;

LabeledStatementContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

LabeledStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

LabeledStatementContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

LabeledStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterLabeledStatement(this);
	}
};

LabeledStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitLabeledStatement(this);
	}
};




CParser.LabeledStatementContext = LabeledStatementContext;

CParser.prototype.labeledStatement = function() {

    var localctx = new LabeledStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, CParser.RULE_labeledStatement);
    try {
        this.state = 1109;
        switch(this._input.LA(1)) {
        case CParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 1098;
            this.match(CParser.Identifier);
            this.state = 1099;
            this.match(CParser.Colon);
            this.state = 1100;
            this.statement();
            break;
        case CParser.Case:
            this.enterOuterAlt(localctx, 2);
            this.state = 1101;
            this.match(CParser.Case);
            this.state = 1102;
            this.constantExpression();
            this.state = 1103;
            this.match(CParser.Colon);
            this.state = 1104;
            this.statement();
            break;
        case CParser.Default:
            this.enterOuterAlt(localctx, 3);
            this.state = 1106;
            this.match(CParser.Default);
            this.state = 1107;
            this.match(CParser.Colon);
            this.state = 1108;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompoundStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_compoundStatement;
    return this;
}

CompoundStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompoundStatementContext.prototype.constructor = CompoundStatementContext;

CompoundStatementContext.prototype.blockItemList = function() {
    return this.getTypedRuleContext(BlockItemListContext,0);
};

CompoundStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterCompoundStatement(this);
	}
};

CompoundStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitCompoundStatement(this);
	}
};




CParser.CompoundStatementContext = CompoundStatementContext;

CParser.prototype.compoundStatement = function() {

    var localctx = new CompoundStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, CParser.RULE_compoundStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1111;
        this.match(CParser.LeftBrace);
        this.state = 1113;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__10) | (1 << CParser.T__11) | (1 << CParser.T__12) | (1 << CParser.Auto) | (1 << CParser.Break) | (1 << CParser.Case) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Continue) | (1 << CParser.Default) | (1 << CParser.Do) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.For) | (1 << CParser.Goto) | (1 << CParser.If) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Return - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Sizeof - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Switch - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.While - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Alignof - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Generic - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)) | (1 << (CParser.LeftBrace - 32)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)) | (1 << (CParser.Semi - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
            this.state = 1112;
            this.blockItemList(0);
        }

        this.state = 1115;
        this.match(CParser.RightBrace);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockItemListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_blockItemList;
    return this;
}

BlockItemListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockItemListContext.prototype.constructor = BlockItemListContext;

BlockItemListContext.prototype.blockItem = function() {
    return this.getTypedRuleContext(BlockItemContext,0);
};

BlockItemListContext.prototype.blockItemList = function() {
    return this.getTypedRuleContext(BlockItemListContext,0);
};

BlockItemListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterBlockItemList(this);
	}
};

BlockItemListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitBlockItemList(this);
	}
};



CParser.prototype.blockItemList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new BlockItemListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 146;
    this.enterRecursionRule(localctx, 146, CParser.RULE_blockItemList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1118;
        this.blockItem();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1124;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,119,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new BlockItemListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_blockItemList);
                this.state = 1120;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1121;
                this.blockItem(); 
            }
            this.state = 1126;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,119,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function BlockItemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_blockItem;
    return this;
}

BlockItemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockItemContext.prototype.constructor = BlockItemContext;

BlockItemContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

BlockItemContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

BlockItemContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterBlockItem(this);
	}
};

BlockItemContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitBlockItem(this);
	}
};




CParser.BlockItemContext = BlockItemContext;

CParser.prototype.blockItem = function() {

    var localctx = new BlockItemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, CParser.RULE_blockItem);
    try {
        this.state = 1129;
        var la_ = this._interp.adaptivePredict(this._input,120,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1127;
            this.declaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1128;
            this.statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_expressionStatement;
    return this;
}

ExpressionStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionStatementContext.prototype.constructor = ExpressionStatementContext;

ExpressionStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ExpressionStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterExpressionStatement(this);
	}
};

ExpressionStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitExpressionStatement(this);
	}
};




CParser.ExpressionStatementContext = ExpressionStatementContext;

CParser.prototype.expressionStatement = function() {

    var localctx = new ExpressionStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, CParser.RULE_expressionStatement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1132;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
            this.state = 1131;
            this.expression(0);
        }

        this.state = 1134;
        this.match(CParser.Semi);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SelectionStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_selectionStatement;
    return this;
}

SelectionStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SelectionStatementContext.prototype.constructor = SelectionStatementContext;

SelectionStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

SelectionStatementContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

SelectionStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterSelectionStatement(this);
	}
};

SelectionStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitSelectionStatement(this);
	}
};




CParser.SelectionStatementContext = SelectionStatementContext;

CParser.prototype.selectionStatement = function() {

    var localctx = new SelectionStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, CParser.RULE_selectionStatement);
    try {
        this.state = 1151;
        switch(this._input.LA(1)) {
        case CParser.If:
            this.enterOuterAlt(localctx, 1);
            this.state = 1136;
            this.match(CParser.If);
            this.state = 1137;
            this.match(CParser.LeftParen);
            this.state = 1138;
            this.expression(0);
            this.state = 1139;
            this.match(CParser.RightParen);
            this.state = 1140;
            this.statement();
            this.state = 1143;
            var la_ = this._interp.adaptivePredict(this._input,122,this._ctx);
            if(la_===1) {
                this.state = 1141;
                this.match(CParser.Else);
                this.state = 1142;
                this.statement();

            }
            break;
        case CParser.Switch:
            this.enterOuterAlt(localctx, 2);
            this.state = 1145;
            this.match(CParser.Switch);
            this.state = 1146;
            this.match(CParser.LeftParen);
            this.state = 1147;
            this.expression(0);
            this.state = 1148;
            this.match(CParser.RightParen);
            this.state = 1149;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IterationStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_iterationStatement;
    return this;
}

IterationStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IterationStatementContext.prototype.constructor = IterationStatementContext;

IterationStatementContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

IterationStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

IterationStatementContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

IterationStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterIterationStatement(this);
	}
};

IterationStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitIterationStatement(this);
	}
};




CParser.IterationStatementContext = IterationStatementContext;

CParser.prototype.iterationStatement = function() {

    var localctx = new IterationStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, CParser.RULE_iterationStatement);
    var _la = 0; // Token type
    try {
        this.state = 1195;
        var la_ = this._interp.adaptivePredict(this._input,129,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1153;
            this.match(CParser.While);
            this.state = 1154;
            this.match(CParser.LeftParen);
            this.state = 1155;
            this.expression(0);
            this.state = 1156;
            this.match(CParser.RightParen);
            this.state = 1157;
            this.statement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1159;
            this.match(CParser.Do);
            this.state = 1160;
            this.statement();
            this.state = 1161;
            this.match(CParser.While);
            this.state = 1162;
            this.match(CParser.LeftParen);
            this.state = 1163;
            this.expression(0);
            this.state = 1164;
            this.match(CParser.RightParen);
            this.state = 1165;
            this.match(CParser.Semi);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1167;
            this.match(CParser.For);
            this.state = 1168;
            this.match(CParser.LeftParen);
            this.state = 1170;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1169;
                this.expression(0);
            }

            this.state = 1172;
            this.match(CParser.Semi);
            this.state = 1174;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1173;
                this.expression(0);
            }

            this.state = 1176;
            this.match(CParser.Semi);
            this.state = 1178;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1177;
                this.expression(0);
            }

            this.state = 1180;
            this.match(CParser.RightParen);
            this.state = 1181;
            this.statement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1182;
            this.match(CParser.For);
            this.state = 1183;
            this.match(CParser.LeftParen);
            this.state = 1184;
            this.declaration();
            this.state = 1186;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1185;
                this.expression(0);
            }

            this.state = 1188;
            this.match(CParser.Semi);
            this.state = 1190;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1189;
                this.expression(0);
            }

            this.state = 1192;
            this.match(CParser.RightParen);
            this.state = 1193;
            this.statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function JumpStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_jumpStatement;
    return this;
}

JumpStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
JumpStatementContext.prototype.constructor = JumpStatementContext;

JumpStatementContext.prototype.Identifier = function() {
    return this.getToken(CParser.Identifier, 0);
};

JumpStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

JumpStatementContext.prototype.unaryExpression = function() {
    return this.getTypedRuleContext(UnaryExpressionContext,0);
};

JumpStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterJumpStatement(this);
	}
};

JumpStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitJumpStatement(this);
	}
};




CParser.JumpStatementContext = JumpStatementContext;

CParser.prototype.jumpStatement = function() {

    var localctx = new JumpStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, CParser.RULE_jumpStatement);
    var _la = 0; // Token type
    try {
        this.state = 1213;
        var la_ = this._interp.adaptivePredict(this._input,131,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1197;
            this.match(CParser.Goto);
            this.state = 1198;
            this.match(CParser.Identifier);
            this.state = 1199;
            this.match(CParser.Semi);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1200;
            this.match(CParser.Continue);
            this.state = 1201;
            this.match(CParser.Semi);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1202;
            this.match(CParser.Break);
            this.state = 1203;
            this.match(CParser.Semi);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1204;
            this.match(CParser.Return);
            this.state = 1206;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__1) | (1 << CParser.T__2))) !== 0) || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (CParser.Sizeof - 39)) | (1 << (CParser.Alignof - 39)) | (1 << (CParser.Generic - 39)) | (1 << (CParser.LeftParen - 39)))) !== 0) || ((((_la - 71)) & ~0x1f) == 0 && ((1 << (_la - 71)) & ((1 << (CParser.Plus - 71)) | (1 << (CParser.PlusPlus - 71)) | (1 << (CParser.Minus - 71)) | (1 << (CParser.MinusMinus - 71)) | (1 << (CParser.Star - 71)) | (1 << (CParser.And - 71)) | (1 << (CParser.AndAnd - 71)) | (1 << (CParser.Not - 71)) | (1 << (CParser.Tilde - 71)))) !== 0) || ((((_la - 105)) & ~0x1f) == 0 && ((1 << (_la - 105)) & ((1 << (CParser.Identifier - 105)) | (1 << (CParser.Constant - 105)) | (1 << (CParser.StringLiteral - 105)))) !== 0)) {
                this.state = 1205;
                this.expression(0);
            }

            this.state = 1208;
            this.match(CParser.Semi);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1209;
            this.match(CParser.Goto);
            this.state = 1210;
            this.unaryExpression();
            this.state = 1211;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompilationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_compilationUnit;
    return this;
}

CompilationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompilationUnitContext.prototype.constructor = CompilationUnitContext;

CompilationUnitContext.prototype.EOF = function() {
    return this.getToken(CParser.EOF, 0);
};

CompilationUnitContext.prototype.translationUnit = function() {
    return this.getTypedRuleContext(TranslationUnitContext,0);
};

CompilationUnitContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterCompilationUnit(this);
	}
};

CompilationUnitContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitCompilationUnit(this);
	}
};




CParser.CompilationUnitContext = CompilationUnitContext;

CParser.prototype.compilationUnit = function() {

    var localctx = new CompilationUnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, CParser.RULE_compilationUnit);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1216;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)) | (1 << (CParser.LeftParen - 32)))) !== 0) || ((((_la - 75)) & ~0x1f) == 0 && ((1 << (_la - 75)) & ((1 << (CParser.Star - 75)) | (1 << (CParser.Caret - 75)) | (1 << (CParser.Semi - 75)) | (1 << (CParser.Identifier - 75)))) !== 0)) {
            this.state = 1215;
            this.translationUnit(0);
        }

        this.state = 1218;
        this.match(CParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TranslationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_translationUnit;
    return this;
}

TranslationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TranslationUnitContext.prototype.constructor = TranslationUnitContext;

TranslationUnitContext.prototype.externalDeclaration = function() {
    return this.getTypedRuleContext(ExternalDeclarationContext,0);
};

TranslationUnitContext.prototype.translationUnit = function() {
    return this.getTypedRuleContext(TranslationUnitContext,0);
};

TranslationUnitContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterTranslationUnit(this);
	}
};

TranslationUnitContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitTranslationUnit(this);
	}
};



CParser.prototype.translationUnit = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new TranslationUnitContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 160;
    this.enterRecursionRule(localctx, 160, CParser.RULE_translationUnit, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1221;
        this.externalDeclaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1227;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,133,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new TranslationUnitContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_translationUnit);
                this.state = 1223;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1224;
                this.externalDeclaration(); 
            }
            this.state = 1229;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,133,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ExternalDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_externalDeclaration;
    return this;
}

ExternalDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExternalDeclarationContext.prototype.constructor = ExternalDeclarationContext;

ExternalDeclarationContext.prototype.functionDefinition = function() {
    return this.getTypedRuleContext(FunctionDefinitionContext,0);
};

ExternalDeclarationContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

ExternalDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterExternalDeclaration(this);
	}
};

ExternalDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitExternalDeclaration(this);
	}
};




CParser.ExternalDeclarationContext = ExternalDeclarationContext;

CParser.prototype.externalDeclaration = function() {

    var localctx = new ExternalDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, CParser.RULE_externalDeclaration);
    try {
        this.state = 1233;
        var la_ = this._interp.adaptivePredict(this._input,134,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1230;
            this.functionDefinition();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1231;
            this.declaration();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1232;
            this.match(CParser.Semi);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionDefinitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_functionDefinition;
    return this;
}

FunctionDefinitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionDefinitionContext.prototype.constructor = FunctionDefinitionContext;

FunctionDefinitionContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

FunctionDefinitionContext.prototype.compoundStatement = function() {
    return this.getTypedRuleContext(CompoundStatementContext,0);
};

FunctionDefinitionContext.prototype.declarationSpecifiers = function() {
    return this.getTypedRuleContext(DeclarationSpecifiersContext,0);
};

FunctionDefinitionContext.prototype.declarationList = function() {
    return this.getTypedRuleContext(DeclarationListContext,0);
};

FunctionDefinitionContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterFunctionDefinition(this);
	}
};

FunctionDefinitionContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitFunctionDefinition(this);
	}
};




CParser.FunctionDefinitionContext = FunctionDefinitionContext;

CParser.prototype.functionDefinition = function() {

    var localctx = new FunctionDefinitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, CParser.RULE_functionDefinition);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1236;
        var la_ = this._interp.adaptivePredict(this._input,135,this._ctx);
        if(la_===1) {
            this.state = 1235;
            this.declarationSpecifiers();

        }
        this.state = 1238;
        this.declarator();
        this.state = 1240;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << CParser.T__0) | (1 << CParser.T__3) | (1 << CParser.T__4) | (1 << CParser.T__5) | (1 << CParser.T__6) | (1 << CParser.T__7) | (1 << CParser.T__8) | (1 << CParser.T__9) | (1 << CParser.T__11) | (1 << CParser.Auto) | (1 << CParser.Char) | (1 << CParser.Const) | (1 << CParser.Double) | (1 << CParser.Enum) | (1 << CParser.Extern) | (1 << CParser.Float) | (1 << CParser.Inline))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (CParser.Int - 32)) | (1 << (CParser.Long - 32)) | (1 << (CParser.Register - 32)) | (1 << (CParser.Restrict - 32)) | (1 << (CParser.Short - 32)) | (1 << (CParser.Signed - 32)) | (1 << (CParser.Static - 32)) | (1 << (CParser.Struct - 32)) | (1 << (CParser.Typedef - 32)) | (1 << (CParser.Union - 32)) | (1 << (CParser.Unsigned - 32)) | (1 << (CParser.Void - 32)) | (1 << (CParser.Volatile - 32)) | (1 << (CParser.Alignas - 32)) | (1 << (CParser.Atomic - 32)) | (1 << (CParser.Bool - 32)) | (1 << (CParser.Complex - 32)) | (1 << (CParser.Noreturn - 32)) | (1 << (CParser.StaticAssert - 32)) | (1 << (CParser.ThreadLocal - 32)))) !== 0) || _la===CParser.Identifier) {
            this.state = 1239;
            this.declarationList(0);
        }

        this.state = 1242;
        this.compoundStatement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = CParser.RULE_declarationList;
    return this;
}

DeclarationListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationListContext.prototype.constructor = DeclarationListContext;

DeclarationListContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

DeclarationListContext.prototype.declarationList = function() {
    return this.getTypedRuleContext(DeclarationListContext,0);
};

DeclarationListContext.prototype.enterRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.enterDeclarationList(this);
	}
};

DeclarationListContext.prototype.exitRule = function(listener) {
    if(listener instanceof CListener ) {
        listener.exitDeclarationList(this);
	}
};



CParser.prototype.declarationList = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new DeclarationListContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 166;
    this.enterRecursionRule(localctx, 166, CParser.RULE_declarationList, _p);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1245;
        this.declaration();
        this._ctx.stop = this._input.LT(-1);
        this.state = 1251;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,137,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new DeclarationListContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, CParser.RULE_declarationList);
                this.state = 1247;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 1248;
                this.declaration(); 
            }
            this.state = 1253;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,137,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


CParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 2:
			return this.genericAssocList_sempred(localctx, predIndex);
	case 4:
			return this.postfixExpression_sempred(localctx, predIndex);
	case 5:
			return this.argumentExpressionList_sempred(localctx, predIndex);
	case 9:
			return this.multiplicativeExpression_sempred(localctx, predIndex);
	case 10:
			return this.additiveExpression_sempred(localctx, predIndex);
	case 11:
			return this.shiftExpression_sempred(localctx, predIndex);
	case 12:
			return this.relationalExpression_sempred(localctx, predIndex);
	case 13:
			return this.equalityExpression_sempred(localctx, predIndex);
	case 14:
			return this.andExpression_sempred(localctx, predIndex);
	case 15:
			return this.exclusiveOrExpression_sempred(localctx, predIndex);
	case 16:
			return this.inclusiveOrExpression_sempred(localctx, predIndex);
	case 17:
			return this.logicalAndExpression_sempred(localctx, predIndex);
	case 18:
			return this.logicalOrExpression_sempred(localctx, predIndex);
	case 22:
			return this.expression_sempred(localctx, predIndex);
	case 28:
			return this.initDeclaratorList_sempred(localctx, predIndex);
	case 34:
			return this.structDeclarationList_sempred(localctx, predIndex);
	case 37:
			return this.structDeclaratorList_sempred(localctx, predIndex);
	case 40:
			return this.enumeratorList_sempred(localctx, predIndex);
	case 48:
			return this.directDeclarator_sempred(localctx, predIndex);
	case 55:
			return this.typeQualifierList_sempred(localctx, predIndex);
	case 57:
			return this.parameterList_sempred(localctx, predIndex);
	case 59:
			return this.identifierList_sempred(localctx, predIndex);
	case 62:
			return this.directAbstractDeclarator_sempred(localctx, predIndex);
	case 65:
			return this.initializerList_sempred(localctx, predIndex);
	case 67:
			return this.designatorList_sempred(localctx, predIndex);
	case 73:
			return this.blockItemList_sempred(localctx, predIndex);
	case 80:
			return this.translationUnit_sempred(localctx, predIndex);
	case 83:
			return this.declarationList_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

CParser.prototype.genericAssocList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.postfixExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 1:
			return this.precpred(this._ctx, 10);
		case 2:
			return this.precpred(this._ctx, 9);
		case 3:
			return this.precpred(this._ctx, 8);
		case 4:
			return this.precpred(this._ctx, 7);
		case 5:
			return this.precpred(this._ctx, 6);
		case 6:
			return this.precpred(this._ctx, 5);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.argumentExpressionList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 7:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.multiplicativeExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 8:
			return this.precpred(this._ctx, 3);
		case 9:
			return this.precpred(this._ctx, 2);
		case 10:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.additiveExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 11:
			return this.precpred(this._ctx, 2);
		case 12:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.shiftExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 13:
			return this.precpred(this._ctx, 2);
		case 14:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.relationalExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 15:
			return this.precpred(this._ctx, 4);
		case 16:
			return this.precpred(this._ctx, 3);
		case 17:
			return this.precpred(this._ctx, 2);
		case 18:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.equalityExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 19:
			return this.precpred(this._ctx, 2);
		case 20:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.andExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 21:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.exclusiveOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 22:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.inclusiveOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 23:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.logicalAndExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 24:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.logicalOrExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 25:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.expression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 26:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.initDeclaratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 27:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.structDeclarationList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 28:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.structDeclaratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 29:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.enumeratorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 30:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.directDeclarator_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 31:
			return this.precpred(this._ctx, 6);
		case 32:
			return this.precpred(this._ctx, 5);
		case 33:
			return this.precpred(this._ctx, 4);
		case 34:
			return this.precpred(this._ctx, 3);
		case 35:
			return this.precpred(this._ctx, 2);
		case 36:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.typeQualifierList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 37:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.parameterList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 38:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.identifierList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 39:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.directAbstractDeclarator_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 40:
			return this.precpred(this._ctx, 5);
		case 41:
			return this.precpred(this._ctx, 4);
		case 42:
			return this.precpred(this._ctx, 3);
		case 43:
			return this.precpred(this._ctx, 2);
		case 44:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.initializerList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 45:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.designatorList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 46:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.blockItemList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 47:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.translationUnit_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 48:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

CParser.prototype.declarationList_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 49:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.CParser = CParser;

},{"./CListener":2,"antlr4/index":54}],4:[function(require,module,exports){
// Generated from Java.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\2k\u0422\b\1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t",
    "\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20",
    "\t\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4",
    "\27\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35",
    "\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'",
    "\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61",
    "\t\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\4",
    "8\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C",
    "\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\t",
    "N\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY",
    "\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\t",
    "d\4e\te\4f\tf\4g\tg\4h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to",
    "\4p\tp\4q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4z\tz\4",
    "{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080\4\u0081\t\u0081\4",
    "\u0082\t\u0082\4\u0083\t\u0083\4\u0084\t\u0084\4\u0085\t\u0085\4\u0086",
    "\t\u0086\4\u0087\t\u0087\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a",
    "\4\u008b\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e\4\u008f",
    "\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092\t\u0092\4\u0093\t\u0093",
    "\4\u0094\t\u0094\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\3\3\3\3\3\3\3",
    "\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5",
    "\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\b\3\t",
    "\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13\3",
    "\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r",
    "\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\20",
    "\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\3",
    "\22\3\22\3\23\3\23\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24",
    "\3\24\3\24\3\25\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3\27\3",
    "\27\3\27\3\30\3\30\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31",
    "\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\33\3\33\3",
    "\33\3\33\3\33\3\33\3\33\3\33\3\33\3\33\3\33\3\34\3\34\3\34\3\34\3\35",
    "\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\36\3\36\3\36\3\36\3",
    "\36\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3 \3 \3 \3 \3!\3!\3!\3!\3!\3",
    "!\3!\3!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3#\3#\3#\3#\3#\3",
    "#\3$\3$\3$\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\3&\3&\3&\3&\3&\3&\3\'\3",
    "\'\3\'\3\'\3\'\3\'\3\'\3(\3(\3(\3(\3(\3(\3(\3(\3(\3)\3)\3)\3)\3)\3)",
    "\3*\3*\3*\3*\3*\3*\3*\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3,\3,\3",
    ",\3,\3,\3-\3-\3-\3-\3-\3-\3.\3.\3.\3.\3.\3.\3.\3/\3/\3/\3/\3/\3/\3/",
    "\3/\3/\3/\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\61\3\62\3\62\3\62",
    "\3\62\3\62\3\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\3\63\3\64\3",
    "\64\3\64\3\64\5\64\u0281\n\64\3\65\3\65\5\65\u0285\n\65\3\66\3\66\5",
    "\66\u0289\n\66\3\67\3\67\5\67\u028d\n\67\38\38\58\u0291\n8\39\39\3:",
    "\3:\3:\5:\u0298\n:\3:\3:\3:\5:\u029d\n:\5:\u029f\n:\3;\3;\7;\u02a3\n",
    ";\f;\16;\u02a6\13;\3;\5;\u02a9\n;\3<\3<\5<\u02ad\n<\3=\3=\3>\3>\5>\u02b3",
    "\n>\3?\6?\u02b6\n?\r?\16?\u02b7\3@\3@\3@\3@\3A\3A\7A\u02c0\nA\fA\16",
    "A\u02c3\13A\3A\5A\u02c6\nA\3B\3B\3C\3C\5C\u02cc\nC\3D\3D\5D\u02d0\n",
    "D\3D\3D\3E\3E\7E\u02d6\nE\fE\16E\u02d9\13E\3E\5E\u02dc\nE\3F\3F\3G\3",
    "G\5G\u02e2\nG\3H\3H\3H\3H\3I\3I\7I\u02ea\nI\fI\16I\u02ed\13I\3I\5I\u02f0",
    "\nI\3J\3J\3K\3K\5K\u02f6\nK\3L\3L\5L\u02fa\nL\3M\3M\3M\5M\u02ff\nM\3",
    "M\5M\u0302\nM\3M\5M\u0305\nM\3M\3M\3M\5M\u030a\nM\3M\5M\u030d\nM\3M",
    "\3M\3M\5M\u0312\nM\3M\3M\3M\5M\u0317\nM\3N\3N\3N\3O\3O\3P\5P\u031f\n",
    "P\3P\3P\3Q\3Q\3R\3R\3S\3S\3S\5S\u032a\nS\3T\3T\5T\u032e\nT\3T\3T\3T",
    "\5T\u0333\nT\3T\3T\5T\u0337\nT\3U\3U\3U\3V\3V\3W\3W\3W\3W\3W\3W\3W\3",
    "W\3W\5W\u0347\nW\3X\3X\3X\3X\3X\3X\3X\3X\5X\u0351\nX\3Y\3Y\3Z\3Z\5Z",
    "\u0357\nZ\3Z\3Z\3[\6[\u035c\n[\r[\16[\u035d\3\\\3\\\5\\\u0362\n\\\3",
    "]\3]\3]\3]\5]\u0368\n]\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\5^\u0375\n^",
    "\3_\3_\3_\3_\3_\3_\3_\3`\3`\3a\3a\3a\3a\3a\3b\3b\3c\3c\3d\3d\3e\3e\3",
    "f\3f\3g\3g\3h\3h\3i\3i\3j\3j\3k\3k\3l\3l\3m\3m\3n\3n\3o\3o\3p\3p\3q",
    "\3q\3r\3r\3r\3s\3s\3s\3t\3t\3t\3u\3u\3u\3v\3v\3v\3w\3w\3w\3x\3x\3x\3",
    "y\3y\3y\3z\3z\3{\3{\3|\3|\3}\3}\3~\3~\3\177\3\177\3\u0080\3\u0080\3",
    "\u0081\3\u0081\3\u0082\3\u0082\3\u0082\3\u0083\3\u0083\3\u0083\3\u0084",
    "\3\u0084\3\u0084\3\u0085\3\u0085\3\u0085\3\u0086\3\u0086\3\u0086\3\u0087",
    "\3\u0087\3\u0087\3\u0088\3\u0088\3\u0088\3\u0089\3\u0089\3\u0089\3\u008a",
    "\3\u008a\3\u008a\3\u008a\3\u008b\3\u008b\3\u008b\3\u008b\3\u008c\3\u008c",
    "\3\u008c\3\u008c\3\u008c\3\u008d\3\u008d\7\u008d\u03f4\n\u008d\f\u008d",
    "\16\u008d\u03f7\13\u008d\3\u008e\3\u008e\3\u008f\3\u008f\3\u0090\3\u0090",
    "\3\u0091\3\u0091\3\u0091\3\u0091\3\u0092\6\u0092\u0404\n\u0092\r\u0092",
    "\16\u0092\u0405\3\u0092\3\u0092\3\u0093\3\u0093\3\u0093\3\u0093\7\u0093",
    "\u040e\n\u0093\f\u0093\16\u0093\u0411\13\u0093\3\u0093\3\u0093\3\u0093",
    "\3\u0093\3\u0093\3\u0094\3\u0094\3\u0094\3\u0094\7\u0094\u041c\n\u0094",
    "\f\u0094\16\u0094\u041f\13\u0094\3\u0094\3\u0094\3\u040f\2\u0095\3\3",
    "\5\4\7\5\t\6\13\7\r\b\17\t\21\n\23\13\25\f\27\r\31\16\33\17\35\20\37",
    "\21!\22#\23%\24\'\25)\26+\27-\30/\31\61\32\63\33\65\34\67\359\36;\37",
    "= ?!A\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]\60_\61a\62c\63e\64g\65i\2k\2m\2",
    "o\2q\2s\2u\2w\2y\2{\2}\2\177\2\u0081\2\u0083\2\u0085\2\u0087\2\u0089",
    "\2\u008b\2\u008d\2\u008f\2\u0091\2\u0093\2\u0095\2\u0097\66\u0099\2",
    "\u009b\2\u009d\2\u009f\2\u00a1\2\u00a3\2\u00a5\2\u00a7\2\u00a9\2\u00ab",
    "\2\u00ad\67\u00af8\u00b1\2\u00b39\u00b5\2\u00b7\2\u00b9\2\u00bb\2\u00bd",
    "\2\u00bf\2\u00c1:\u00c3;\u00c5<\u00c7=\u00c9>\u00cb?\u00cd@\u00cfA\u00d1",
    "B\u00d3C\u00d5D\u00d7E\u00d9F\u00dbG\u00ddH\u00dfI\u00e1J\u00e3K\u00e5",
    "L\u00e7M\u00e9N\u00ebO\u00edP\u00efQ\u00f1R\u00f3S\u00f5T\u00f7U\u00f9",
    "V\u00fbW\u00fdX\u00ffY\u0101Z\u0103[\u0105\\\u0107]\u0109^\u010b_\u010d",
    "`\u010fa\u0111b\u0113c\u0115d\u0117e\u0119f\u011b\2\u011d\2\u011fg\u0121",
    "h\u0123i\u0125j\u0127k\3\2\25\4\2NNnn\3\2\63;\4\2ZZzz\5\2\62;CHch\3",
    "\2\629\4\2DDdd\3\2\62\63\4\2GGgg\4\2--//\6\2FFHHffhh\4\2RRrr\4\2))^",
    "^\4\2$$^^\n\2$$))^^ddhhppttvv\3\2\62\65\6\2&&C\\aac|\7\2&&\62;C\\aa",
    "c|\5\2\13\f\16\17\"\"\4\2\f\f\17\17\u042c\2\3\3\2\2\2\2\5\3\2\2\2\2",
    "\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2\2\2\17\3\2\2\2\2\21\3",
    "\2\2\2\2\23\3\2\2\2\2\25\3\2\2\2\2\27\3\2\2\2\2\31\3\2\2\2\2\33\3\2",
    "\2\2\2\35\3\2\2\2\2\37\3\2\2\2\2!\3\2\2\2\2#\3\2\2\2\2%\3\2\2\2\2\'",
    "\3\2\2\2\2)\3\2\2\2\2+\3\2\2\2\2-\3\2\2\2\2/\3\2\2\2\2\61\3\2\2\2\2",
    "\63\3\2\2\2\2\65\3\2\2\2\2\67\3\2\2\2\29\3\2\2\2\2;\3\2\2\2\2=\3\2\2",
    "\2\2?\3\2\2\2\2A\3\2\2\2\2C\3\2\2\2\2E\3\2\2\2\2G\3\2\2\2\2I\3\2\2\2",
    "\2K\3\2\2\2\2M\3\2\2\2\2O\3\2\2\2\2Q\3\2\2\2\2S\3\2\2\2\2U\3\2\2\2\2",
    "W\3\2\2\2\2Y\3\2\2\2\2[\3\2\2\2\2]\3\2\2\2\2_\3\2\2\2\2a\3\2\2\2\2c",
    "\3\2\2\2\2e\3\2\2\2\2g\3\2\2\2\2\u0097\3\2\2\2\2\u00ad\3\2\2\2\2\u00af",
    "\3\2\2\2\2\u00b3\3\2\2\2\2\u00c1\3\2\2\2\2\u00c3\3\2\2\2\2\u00c5\3\2",
    "\2\2\2\u00c7\3\2\2\2\2\u00c9\3\2\2\2\2\u00cb\3\2\2\2\2\u00cd\3\2\2\2",
    "\2\u00cf\3\2\2\2\2\u00d1\3\2\2\2\2\u00d3\3\2\2\2\2\u00d5\3\2\2\2\2\u00d7",
    "\3\2\2\2\2\u00d9\3\2\2\2\2\u00db\3\2\2\2\2\u00dd\3\2\2\2\2\u00df\3\2",
    "\2\2\2\u00e1\3\2\2\2\2\u00e3\3\2\2\2\2\u00e5\3\2\2\2\2\u00e7\3\2\2\2",
    "\2\u00e9\3\2\2\2\2\u00eb\3\2\2\2\2\u00ed\3\2\2\2\2\u00ef\3\2\2\2\2\u00f1",
    "\3\2\2\2\2\u00f3\3\2\2\2\2\u00f5\3\2\2\2\2\u00f7\3\2\2\2\2\u00f9\3\2",
    "\2\2\2\u00fb\3\2\2\2\2\u00fd\3\2\2\2\2\u00ff\3\2\2\2\2\u0101\3\2\2\2",
    "\2\u0103\3\2\2\2\2\u0105\3\2\2\2\2\u0107\3\2\2\2\2\u0109\3\2\2\2\2\u010b",
    "\3\2\2\2\2\u010d\3\2\2\2\2\u010f\3\2\2\2\2\u0111\3\2\2\2\2\u0113\3\2",
    "\2\2\2\u0115\3\2\2\2\2\u0117\3\2\2\2\2\u0119\3\2\2\2\2\u011f\3\2\2\2",
    "\2\u0121\3\2\2\2\2\u0123\3\2\2\2\2\u0125\3\2\2\2\2\u0127\3\2\2\2\3\u0129",
    "\3\2\2\2\5\u0132\3\2\2\2\7\u0139\3\2\2\2\t\u0141\3\2\2\2\13\u0147\3",
    "\2\2\2\r\u014c\3\2\2\2\17\u0151\3\2\2\2\21\u0157\3\2\2\2\23\u015c\3",
    "\2\2\2\25\u0162\3\2\2\2\27\u0168\3\2\2\2\31\u0171\3\2\2\2\33\u0179\3",
    "\2\2\2\35\u017c\3\2\2\2\37\u0183\3\2\2\2!\u0188\3\2\2\2#\u018d\3\2\2",
    "\2%\u0195\3\2\2\2\'\u019b\3\2\2\2)\u01a3\3\2\2\2+\u01a9\3\2\2\2-\u01ad",
    "\3\2\2\2/\u01b0\3\2\2\2\61\u01b5\3\2\2\2\63\u01c0\3\2\2\2\65\u01c7\3",
    "\2\2\2\67\u01d2\3\2\2\29\u01d6\3\2\2\2;\u01e0\3\2\2\2=\u01e5\3\2\2\2",
    "?\u01ec\3\2\2\2A\u01f0\3\2\2\2C\u01f8\3\2\2\2E\u0200\3\2\2\2G\u020a",
    "\3\2\2\2I\u0211\3\2\2\2K\u0218\3\2\2\2M\u021e\3\2\2\2O\u0225\3\2\2\2",
    "Q\u022e\3\2\2\2S\u0234\3\2\2\2U\u023b\3\2\2\2W\u0248\3\2\2\2Y\u024d",
    "\3\2\2\2[\u0253\3\2\2\2]\u025a\3\2\2\2_\u0264\3\2\2\2a\u0268\3\2\2\2",
    "c\u026d\3\2\2\2e\u0276\3\2\2\2g\u0280\3\2\2\2i\u0282\3\2\2\2k\u0286",
    "\3\2\2\2m\u028a\3\2\2\2o\u028e\3\2\2\2q\u0292\3\2\2\2s\u029e\3\2\2\2",
    "u\u02a0\3\2\2\2w\u02ac\3\2\2\2y\u02ae\3\2\2\2{\u02b2\3\2\2\2}\u02b5",
    "\3\2\2\2\177\u02b9\3\2\2\2\u0081\u02bd\3\2\2\2\u0083\u02c7\3\2\2\2\u0085",
    "\u02cb\3\2\2\2\u0087\u02cd\3\2\2\2\u0089\u02d3\3\2\2\2\u008b\u02dd\3",
    "\2\2\2\u008d\u02e1\3\2\2\2\u008f\u02e3\3\2\2\2\u0091\u02e7\3\2\2\2\u0093",
    "\u02f1\3\2\2\2\u0095\u02f5\3\2\2\2\u0097\u02f9\3\2\2\2\u0099\u0316\3",
    "\2\2\2\u009b\u0318\3\2\2\2\u009d\u031b\3\2\2\2\u009f\u031e\3\2\2\2\u00a1",
    "\u0322\3\2\2\2\u00a3\u0324\3\2\2\2\u00a5\u0326\3\2\2\2\u00a7\u0336\3",
    "\2\2\2\u00a9\u0338\3\2\2\2\u00ab\u033b\3\2\2\2\u00ad\u0346\3\2\2\2\u00af",
    "\u0350\3\2\2\2\u00b1\u0352\3\2\2\2\u00b3\u0354\3\2\2\2\u00b5\u035b\3",
    "\2\2\2\u00b7\u0361\3\2\2\2\u00b9\u0367\3\2\2\2\u00bb\u0374\3\2\2\2\u00bd",
    "\u0376\3\2\2\2\u00bf\u037d\3\2\2\2\u00c1\u037f\3\2\2\2\u00c3\u0384\3",
    "\2\2\2\u00c5\u0386\3\2\2\2\u00c7\u0388\3\2\2\2\u00c9\u038a\3\2\2\2\u00cb",
    "\u038c\3\2\2\2\u00cd\u038e\3\2\2\2\u00cf\u0390\3\2\2\2\u00d1\u0392\3",
    "\2\2\2\u00d3\u0394\3\2\2\2\u00d5\u0396\3\2\2\2\u00d7\u0398\3\2\2\2\u00d9",
    "\u039a\3\2\2\2\u00db\u039c\3\2\2\2\u00dd\u039e\3\2\2\2\u00df\u03a0\3",
    "\2\2\2\u00e1\u03a2\3\2\2\2\u00e3\u03a4\3\2\2\2\u00e5\u03a7\3\2\2\2\u00e7",
    "\u03aa\3\2\2\2\u00e9\u03ad\3\2\2\2\u00eb\u03b0\3\2\2\2\u00ed\u03b3\3",
    "\2\2\2\u00ef\u03b6\3\2\2\2\u00f1\u03b9\3\2\2\2\u00f3\u03bc\3\2\2\2\u00f5",
    "\u03be\3\2\2\2\u00f7\u03c0\3\2\2\2\u00f9\u03c2\3\2\2\2\u00fb\u03c4\3",
    "\2\2\2\u00fd\u03c6\3\2\2\2\u00ff\u03c8\3\2\2\2\u0101\u03ca\3\2\2\2\u0103",
    "\u03cc\3\2\2\2\u0105\u03cf\3\2\2\2\u0107\u03d2\3\2\2\2\u0109\u03d5\3",
    "\2\2\2\u010b\u03d8\3\2\2\2\u010d\u03db\3\2\2\2\u010f\u03de\3\2\2\2\u0111",
    "\u03e1\3\2\2\2\u0113\u03e4\3\2\2\2\u0115\u03e8\3\2\2\2\u0117\u03ec\3",
    "\2\2\2\u0119\u03f1\3\2\2\2\u011b\u03f8\3\2\2\2\u011d\u03fa\3\2\2\2\u011f",
    "\u03fc\3\2\2\2\u0121\u03fe\3\2\2\2\u0123\u0403\3\2\2\2\u0125\u0409\3",
    "\2\2\2\u0127\u0417\3\2\2\2\u0129\u012a\7c\2\2\u012a\u012b\7d\2\2\u012b",
    "\u012c\7u\2\2\u012c\u012d\7v\2\2\u012d\u012e\7t\2\2\u012e\u012f\7c\2",
    "\2\u012f\u0130\7e\2\2\u0130\u0131\7v\2\2\u0131\4\3\2\2\2\u0132\u0133",
    "\7c\2\2\u0133\u0134\7u\2\2\u0134\u0135\7u\2\2\u0135\u0136\7g\2\2\u0136",
    "\u0137\7t\2\2\u0137\u0138\7v\2\2\u0138\6\3\2\2\2\u0139\u013a\7d\2\2",
    "\u013a\u013b\7q\2\2\u013b\u013c\7q\2\2\u013c\u013d\7n\2\2\u013d\u013e",
    "\7g\2\2\u013e\u013f\7c\2\2\u013f\u0140\7p\2\2\u0140\b\3\2\2\2\u0141",
    "\u0142\7d\2\2\u0142\u0143\7t\2\2\u0143\u0144\7g\2\2\u0144\u0145\7c\2",
    "\2\u0145\u0146\7m\2\2\u0146\n\3\2\2\2\u0147\u0148\7d\2\2\u0148\u0149",
    "\7{\2\2\u0149\u014a\7v\2\2\u014a\u014b\7g\2\2\u014b\f\3\2\2\2\u014c",
    "\u014d\7e\2\2\u014d\u014e\7c\2\2\u014e\u014f\7u\2\2\u014f\u0150\7g\2",
    "\2\u0150\16\3\2\2\2\u0151\u0152\7e\2\2\u0152\u0153\7c\2\2\u0153\u0154",
    "\7v\2\2\u0154\u0155\7e\2\2\u0155\u0156\7j\2\2\u0156\20\3\2\2\2\u0157",
    "\u0158\7e\2\2\u0158\u0159\7j\2\2\u0159\u015a\7c\2\2\u015a\u015b\7t\2",
    "\2\u015b\22\3\2\2\2\u015c\u015d\7e\2\2\u015d\u015e\7n\2\2\u015e\u015f",
    "\7c\2\2\u015f\u0160\7u\2\2\u0160\u0161\7u\2\2\u0161\24\3\2\2\2\u0162",
    "\u0163\7e\2\2\u0163\u0164\7q\2\2\u0164\u0165\7p\2\2\u0165\u0166\7u\2",
    "\2\u0166\u0167\7v\2\2\u0167\26\3\2\2\2\u0168\u0169\7e\2\2\u0169\u016a",
    "\7q\2\2\u016a\u016b\7p\2\2\u016b\u016c\7v\2\2\u016c\u016d\7k\2\2\u016d",
    "\u016e\7p\2\2\u016e\u016f\7w\2\2\u016f\u0170\7g\2\2\u0170\30\3\2\2\2",
    "\u0171\u0172\7f\2\2\u0172\u0173\7g\2\2\u0173\u0174\7h\2\2\u0174\u0175",
    "\7c\2\2\u0175\u0176\7w\2\2\u0176\u0177\7n\2\2\u0177\u0178\7v\2\2\u0178",
    "\32\3\2\2\2\u0179\u017a\7f\2\2\u017a\u017b\7q\2\2\u017b\34\3\2\2\2\u017c",
    "\u017d\7f\2\2\u017d\u017e\7q\2\2\u017e\u017f\7w\2\2\u017f\u0180\7d\2",
    "\2\u0180\u0181\7n\2\2\u0181\u0182\7g\2\2\u0182\36\3\2\2\2\u0183\u0184",
    "\7g\2\2\u0184\u0185\7n\2\2\u0185\u0186\7u\2\2\u0186\u0187\7g\2\2\u0187",
    " \3\2\2\2\u0188\u0189\7g\2\2\u0189\u018a\7p\2\2\u018a\u018b\7w\2\2\u018b",
    "\u018c\7o\2\2\u018c\"\3\2\2\2\u018d\u018e\7g\2\2\u018e\u018f\7z\2\2",
    "\u018f\u0190\7v\2\2\u0190\u0191\7g\2\2\u0191\u0192\7p\2\2\u0192\u0193",
    "\7f\2\2\u0193\u0194\7u\2\2\u0194$\3\2\2\2\u0195\u0196\7h\2\2\u0196\u0197",
    "\7k\2\2\u0197\u0198\7p\2\2\u0198\u0199\7c\2\2\u0199\u019a\7n\2\2\u019a",
    "&\3\2\2\2\u019b\u019c\7h\2\2\u019c\u019d\7k\2\2\u019d\u019e\7p\2\2\u019e",
    "\u019f\7c\2\2\u019f\u01a0\7n\2\2\u01a0\u01a1\7n\2\2\u01a1\u01a2\7{\2",
    "\2\u01a2(\3\2\2\2\u01a3\u01a4\7h\2\2\u01a4\u01a5\7n\2\2\u01a5\u01a6",
    "\7q\2\2\u01a6\u01a7\7c\2\2\u01a7\u01a8\7v\2\2\u01a8*\3\2\2\2\u01a9\u01aa",
    "\7h\2\2\u01aa\u01ab\7q\2\2\u01ab\u01ac\7t\2\2\u01ac,\3\2\2\2\u01ad\u01ae",
    "\7k\2\2\u01ae\u01af\7h\2\2\u01af.\3\2\2\2\u01b0\u01b1\7i\2\2\u01b1\u01b2",
    "\7q\2\2\u01b2\u01b3\7v\2\2\u01b3\u01b4\7q\2\2\u01b4\60\3\2\2\2\u01b5",
    "\u01b6\7k\2\2\u01b6\u01b7\7o\2\2\u01b7\u01b8\7r\2\2\u01b8\u01b9\7n\2",
    "\2\u01b9\u01ba\7g\2\2\u01ba\u01bb\7o\2\2\u01bb\u01bc\7g\2\2\u01bc\u01bd",
    "\7p\2\2\u01bd\u01be\7v\2\2\u01be\u01bf\7u\2\2\u01bf\62\3\2\2\2\u01c0",
    "\u01c1\7k\2\2\u01c1\u01c2\7o\2\2\u01c2\u01c3\7r\2\2\u01c3\u01c4\7q\2",
    "\2\u01c4\u01c5\7t\2\2\u01c5\u01c6\7v\2\2\u01c6\64\3\2\2\2\u01c7\u01c8",
    "\7k\2\2\u01c8\u01c9\7p\2\2\u01c9\u01ca\7u\2\2\u01ca\u01cb\7v\2\2\u01cb",
    "\u01cc\7c\2\2\u01cc\u01cd\7p\2\2\u01cd\u01ce\7e\2\2\u01ce\u01cf\7g\2",
    "\2\u01cf\u01d0\7q\2\2\u01d0\u01d1\7h\2\2\u01d1\66\3\2\2\2\u01d2\u01d3",
    "\7k\2\2\u01d3\u01d4\7p\2\2\u01d4\u01d5\7v\2\2\u01d58\3\2\2\2\u01d6\u01d7",
    "\7k\2\2\u01d7\u01d8\7p\2\2\u01d8\u01d9\7v\2\2\u01d9\u01da\7g\2\2\u01da",
    "\u01db\7t\2\2\u01db\u01dc\7h\2\2\u01dc\u01dd\7c\2\2\u01dd\u01de\7e\2",
    "\2\u01de\u01df\7g\2\2\u01df:\3\2\2\2\u01e0\u01e1\7n\2\2\u01e1\u01e2",
    "\7q\2\2\u01e2\u01e3\7p\2\2\u01e3\u01e4\7i\2\2\u01e4<\3\2\2\2\u01e5\u01e6",
    "\7p\2\2\u01e6\u01e7\7c\2\2\u01e7\u01e8\7v\2\2\u01e8\u01e9\7k\2\2\u01e9",
    "\u01ea\7x\2\2\u01ea\u01eb\7g\2\2\u01eb>\3\2\2\2\u01ec\u01ed\7p\2\2\u01ed",
    "\u01ee\7g\2\2\u01ee\u01ef\7y\2\2\u01ef@\3\2\2\2\u01f0\u01f1\7r\2\2\u01f1",
    "\u01f2\7c\2\2\u01f2\u01f3\7e\2\2\u01f3\u01f4\7m\2\2\u01f4\u01f5\7c\2",
    "\2\u01f5\u01f6\7i\2\2\u01f6\u01f7\7g\2\2\u01f7B\3\2\2\2\u01f8\u01f9",
    "\7r\2\2\u01f9\u01fa\7t\2\2\u01fa\u01fb\7k\2\2\u01fb\u01fc\7x\2\2\u01fc",
    "\u01fd\7c\2\2\u01fd\u01fe\7v\2\2\u01fe\u01ff\7g\2\2\u01ffD\3\2\2\2\u0200",
    "\u0201\7r\2\2\u0201\u0202\7t\2\2\u0202\u0203\7q\2\2\u0203\u0204\7v\2",
    "\2\u0204\u0205\7g\2\2\u0205\u0206\7e\2\2\u0206\u0207\7v\2\2\u0207\u0208",
    "\7g\2\2\u0208\u0209\7f\2\2\u0209F\3\2\2\2\u020a\u020b\7r\2\2\u020b\u020c",
    "\7w\2\2\u020c\u020d\7d\2\2\u020d\u020e\7n\2\2\u020e\u020f\7k\2\2\u020f",
    "\u0210\7e\2\2\u0210H\3\2\2\2\u0211\u0212\7t\2\2\u0212\u0213\7g\2\2\u0213",
    "\u0214\7v\2\2\u0214\u0215\7w\2\2\u0215\u0216\7t\2\2\u0216\u0217\7p\2",
    "\2\u0217J\3\2\2\2\u0218\u0219\7u\2\2\u0219\u021a\7j\2\2\u021a\u021b",
    "\7q\2\2\u021b\u021c\7t\2\2\u021c\u021d\7v\2\2\u021dL\3\2\2\2\u021e\u021f",
    "\7u\2\2\u021f\u0220\7v\2\2\u0220\u0221\7c\2\2\u0221\u0222\7v\2\2\u0222",
    "\u0223\7k\2\2\u0223\u0224\7e\2\2\u0224N\3\2\2\2\u0225\u0226\7u\2\2\u0226",
    "\u0227\7v\2\2\u0227\u0228\7t\2\2\u0228\u0229\7k\2\2\u0229\u022a\7e\2",
    "\2\u022a\u022b\7v\2\2\u022b\u022c\7h\2\2\u022c\u022d\7r\2\2\u022dP\3",
    "\2\2\2\u022e\u022f\7u\2\2\u022f\u0230\7w\2\2\u0230\u0231\7r\2\2\u0231",
    "\u0232\7g\2\2\u0232\u0233\7t\2\2\u0233R\3\2\2\2\u0234\u0235\7u\2\2\u0235",
    "\u0236\7y\2\2\u0236\u0237\7k\2\2\u0237\u0238\7v\2\2\u0238\u0239\7e\2",
    "\2\u0239\u023a\7j\2\2\u023aT\3\2\2\2\u023b\u023c\7u\2\2\u023c\u023d",
    "\7{\2\2\u023d\u023e\7p\2\2\u023e\u023f\7e\2\2\u023f\u0240\7j\2\2\u0240",
    "\u0241\7t\2\2\u0241\u0242\7q\2\2\u0242\u0243\7p\2\2\u0243\u0244\7k\2",
    "\2\u0244\u0245\7|\2\2\u0245\u0246\7g\2\2\u0246\u0247\7f\2\2\u0247V\3",
    "\2\2\2\u0248\u0249\7v\2\2\u0249\u024a\7j\2\2\u024a\u024b\7k\2\2\u024b",
    "\u024c\7u\2\2\u024cX\3\2\2\2\u024d\u024e\7v\2\2\u024e\u024f\7j\2\2\u024f",
    "\u0250\7t\2\2\u0250\u0251\7q\2\2\u0251\u0252\7y\2\2\u0252Z\3\2\2\2\u0253",
    "\u0254\7v\2\2\u0254\u0255\7j\2\2\u0255\u0256\7t\2\2\u0256\u0257\7q\2",
    "\2\u0257\u0258\7y\2\2\u0258\u0259\7u\2\2\u0259\\\3\2\2\2\u025a\u025b",
    "\7v\2\2\u025b\u025c\7t\2\2\u025c\u025d\7c\2\2\u025d\u025e\7p\2\2\u025e",
    "\u025f\7u\2\2\u025f\u0260\7k\2\2\u0260\u0261\7g\2\2\u0261\u0262\7p\2",
    "\2\u0262\u0263\7v\2\2\u0263^\3\2\2\2\u0264\u0265\7v\2\2\u0265\u0266",
    "\7t\2\2\u0266\u0267\7{\2\2\u0267`\3\2\2\2\u0268\u0269\7x\2\2\u0269\u026a",
    "\7q\2\2\u026a\u026b\7k\2\2\u026b\u026c\7f\2\2\u026cb\3\2\2\2\u026d\u026e",
    "\7x\2\2\u026e\u026f\7q\2\2\u026f\u0270\7n\2\2\u0270\u0271\7c\2\2\u0271",
    "\u0272\7v\2\2\u0272\u0273\7k\2\2\u0273\u0274\7n\2\2\u0274\u0275\7g\2",
    "\2\u0275d\3\2\2\2\u0276\u0277\7y\2\2\u0277\u0278\7j\2\2\u0278\u0279",
    "\7k\2\2\u0279\u027a\7n\2\2\u027a\u027b\7g\2\2\u027bf\3\2\2\2\u027c\u0281",
    "\5i\65\2\u027d\u0281\5k\66\2\u027e\u0281\5m\67\2\u027f\u0281\5o8\2\u0280",
    "\u027c\3\2\2\2\u0280\u027d\3\2\2\2\u0280\u027e\3\2\2\2\u0280\u027f\3",
    "\2\2\2\u0281h\3\2\2\2\u0282\u0284\5s:\2\u0283\u0285\5q9\2\u0284\u0283",
    "\3\2\2\2\u0284\u0285\3\2\2\2\u0285j\3\2\2\2\u0286\u0288\5\177@\2\u0287",
    "\u0289\5q9\2\u0288\u0287\3\2\2\2\u0288\u0289\3\2\2\2\u0289l\3\2\2\2",
    "\u028a\u028c\5\u0087D\2\u028b\u028d\5q9\2\u028c\u028b\3\2\2\2\u028c",
    "\u028d\3\2\2\2\u028dn\3\2\2\2\u028e\u0290\5\u008fH\2\u028f\u0291\5q",
    "9\2\u0290\u028f\3\2\2\2\u0290\u0291\3\2\2\2\u0291p\3\2\2\2\u0292\u0293",
    "\t\2\2\2\u0293r\3\2\2\2\u0294\u029f\7\62\2\2\u0295\u029c\5y=\2\u0296",
    "\u0298\5u;\2\u0297\u0296\3\2\2\2\u0297\u0298\3\2\2\2\u0298\u029d\3\2",
    "\2\2\u0299\u029a\5}?\2\u029a\u029b\5u;\2\u029b\u029d\3\2\2\2\u029c\u0297",
    "\3\2\2\2\u029c\u0299\3\2\2\2\u029d\u029f\3\2\2\2\u029e\u0294\3\2\2\2",
    "\u029e\u0295\3\2\2\2\u029ft\3\2\2\2\u02a0\u02a8\5w<\2\u02a1\u02a3\5",
    "{>\2\u02a2\u02a1\3\2\2\2\u02a3\u02a6\3\2\2\2\u02a4\u02a2\3\2\2\2\u02a4",
    "\u02a5\3\2\2\2\u02a5\u02a7\3\2\2\2\u02a6\u02a4\3\2\2\2\u02a7\u02a9\5",
    "w<\2\u02a8\u02a4\3\2\2\2\u02a8\u02a9\3\2\2\2\u02a9v\3\2\2\2\u02aa\u02ad",
    "\7\62\2\2\u02ab\u02ad\5y=\2\u02ac\u02aa\3\2\2\2\u02ac\u02ab\3\2\2\2",
    "\u02adx\3\2\2\2\u02ae\u02af\t\3\2\2\u02afz\3\2\2\2\u02b0\u02b3\5w<\2",
    "\u02b1\u02b3\7a\2\2\u02b2\u02b0\3\2\2\2\u02b2\u02b1\3\2\2\2\u02b3|\3",
    "\2\2\2\u02b4\u02b6\7a\2\2\u02b5\u02b4\3\2\2\2\u02b6\u02b7\3\2\2\2\u02b7",
    "\u02b5\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8~\3\2\2\2\u02b9\u02ba\7\62\2",
    "\2\u02ba\u02bb\t\4\2\2\u02bb\u02bc\5\u0081A\2\u02bc\u0080\3\2\2\2\u02bd",
    "\u02c5\5\u0083B\2\u02be\u02c0\5\u0085C\2\u02bf\u02be\3\2\2\2\u02c0\u02c3",
    "\3\2\2\2\u02c1\u02bf\3\2\2\2\u02c1\u02c2\3\2\2\2\u02c2\u02c4\3\2\2\2",
    "\u02c3\u02c1\3\2\2\2\u02c4\u02c6\5\u0083B\2\u02c5\u02c1\3\2\2\2\u02c5",
    "\u02c6\3\2\2\2\u02c6\u0082\3\2\2\2\u02c7\u02c8\t\5\2\2\u02c8\u0084\3",
    "\2\2\2\u02c9\u02cc\5\u0083B\2\u02ca\u02cc\7a\2\2\u02cb\u02c9\3\2\2\2",
    "\u02cb\u02ca\3\2\2\2\u02cc\u0086\3\2\2\2\u02cd\u02cf\7\62\2\2\u02ce",
    "\u02d0\5}?\2\u02cf\u02ce\3\2\2\2\u02cf\u02d0\3\2\2\2\u02d0\u02d1\3\2",
    "\2\2\u02d1\u02d2\5\u0089E\2\u02d2\u0088\3\2\2\2\u02d3\u02db\5\u008b",
    "F\2\u02d4\u02d6\5\u008dG\2\u02d5\u02d4\3\2\2\2\u02d6\u02d9\3\2\2\2\u02d7",
    "\u02d5\3\2\2\2\u02d7\u02d8\3\2\2\2\u02d8\u02da\3\2\2\2\u02d9\u02d7\3",
    "\2\2\2\u02da\u02dc\5\u008bF\2\u02db\u02d7\3\2\2\2\u02db\u02dc\3\2\2",
    "\2\u02dc\u008a\3\2\2\2\u02dd\u02de\t\6\2\2\u02de\u008c\3\2\2\2\u02df",
    "\u02e2\5\u008bF\2\u02e0\u02e2\7a\2\2\u02e1\u02df\3\2\2\2\u02e1\u02e0",
    "\3\2\2\2\u02e2\u008e\3\2\2\2\u02e3\u02e4\7\62\2\2\u02e4\u02e5\t\7\2",
    "\2\u02e5\u02e6\5\u0091I\2\u02e6\u0090\3\2\2\2\u02e7\u02ef\5\u0093J\2",
    "\u02e8\u02ea\5\u0095K\2\u02e9\u02e8\3\2\2\2\u02ea\u02ed\3\2\2\2\u02eb",
    "\u02e9\3\2\2\2\u02eb\u02ec\3\2\2\2\u02ec\u02ee\3\2\2\2\u02ed\u02eb\3",
    "\2\2\2\u02ee\u02f0\5\u0093J\2\u02ef\u02eb\3\2\2\2\u02ef\u02f0\3\2\2",
    "\2\u02f0\u0092\3\2\2\2\u02f1\u02f2\t\b\2\2\u02f2\u0094\3\2\2\2\u02f3",
    "\u02f6\5\u0093J\2\u02f4\u02f6\7a\2\2\u02f5\u02f3\3\2\2\2\u02f5\u02f4",
    "\3\2\2\2\u02f6\u0096\3\2\2\2\u02f7\u02fa\5\u0099M\2\u02f8\u02fa\5\u00a5",
    "S\2\u02f9\u02f7\3\2\2\2\u02f9\u02f8\3\2\2\2\u02fa\u0098\3\2\2\2\u02fb",
    "\u02fc\5u;\2\u02fc\u02fe\7\60\2\2\u02fd\u02ff\5u;\2\u02fe\u02fd\3\2",
    "\2\2\u02fe\u02ff\3\2\2\2\u02ff\u0301\3\2\2\2\u0300\u0302\5\u009bN\2",
    "\u0301\u0300\3\2\2\2\u0301\u0302\3\2\2\2\u0302\u0304\3\2\2\2\u0303\u0305",
    "\5\u00a3R\2\u0304\u0303\3\2\2\2\u0304\u0305\3\2\2\2\u0305\u0317\3\2",
    "\2\2\u0306\u0307\7\60\2\2\u0307\u0309\5u;\2\u0308\u030a\5\u009bN\2\u0309",
    "\u0308\3\2\2\2\u0309\u030a\3\2\2\2\u030a\u030c\3\2\2\2\u030b\u030d\5",
    "\u00a3R\2\u030c\u030b\3\2\2\2\u030c\u030d\3\2\2\2\u030d\u0317\3\2\2",
    "\2\u030e\u030f\5u;\2\u030f\u0311\5\u009bN\2\u0310\u0312\5\u00a3R\2\u0311",
    "\u0310\3\2\2\2\u0311\u0312\3\2\2\2\u0312\u0317\3\2\2\2\u0313\u0314\5",
    "u;\2\u0314\u0315\5\u00a3R\2\u0315\u0317\3\2\2\2\u0316\u02fb\3\2\2\2",
    "\u0316\u0306\3\2\2\2\u0316\u030e\3\2\2\2\u0316\u0313\3\2\2\2\u0317\u009a",
    "\3\2\2\2\u0318\u0319\5\u009dO\2\u0319\u031a\5\u009fP\2\u031a\u009c\3",
    "\2\2\2\u031b\u031c\t\t\2\2\u031c\u009e\3\2\2\2\u031d\u031f\5\u00a1Q",
    "\2\u031e\u031d\3\2\2\2\u031e\u031f\3\2\2\2\u031f\u0320\3\2\2\2\u0320",
    "\u0321\5u;\2\u0321\u00a0\3\2\2\2\u0322\u0323\t\n\2\2\u0323\u00a2\3\2",
    "\2\2\u0324\u0325\t\13\2\2\u0325\u00a4\3\2\2\2\u0326\u0327\5\u00a7T\2",
    "\u0327\u0329\5\u00a9U\2\u0328\u032a\5\u00a3R\2\u0329\u0328\3\2\2\2\u0329",
    "\u032a\3\2\2\2\u032a\u00a6\3\2\2\2\u032b\u032d\5\177@\2\u032c\u032e",
    "\7\60\2\2\u032d\u032c\3\2\2\2\u032d\u032e\3\2\2\2\u032e\u0337\3\2\2",
    "\2\u032f\u0330\7\62\2\2\u0330\u0332\t\4\2\2\u0331\u0333\5\u0081A\2\u0332",
    "\u0331\3\2\2\2\u0332\u0333\3\2\2\2\u0333\u0334\3\2\2\2\u0334\u0335\7",
    "\60\2\2\u0335\u0337\5\u0081A\2\u0336\u032b\3\2\2\2\u0336\u032f\3\2\2",
    "\2\u0337\u00a8\3\2\2\2\u0338\u0339\5\u00abV\2\u0339\u033a\5\u009fP\2",
    "\u033a\u00aa\3\2\2\2\u033b\u033c\t\f\2\2\u033c\u00ac\3\2\2\2\u033d\u033e",
    "\7v\2\2\u033e\u033f\7t\2\2\u033f\u0340\7w\2\2\u0340\u0347\7g\2\2\u0341",
    "\u0342\7h\2\2\u0342\u0343\7c\2\2\u0343\u0344\7n\2\2\u0344\u0345\7u\2",
    "\2\u0345\u0347\7g\2\2\u0346\u033d\3\2\2\2\u0346\u0341\3\2\2\2\u0347",
    "\u00ae\3\2\2\2\u0348\u0349\7)\2\2\u0349\u034a\5\u00b1Y\2\u034a\u034b",
    "\7)\2\2\u034b\u0351\3\2\2\2\u034c\u034d\7)\2\2\u034d\u034e\5\u00b9]",
    "\2\u034e\u034f\7)\2\2\u034f\u0351\3\2\2\2\u0350\u0348\3\2\2\2\u0350",
    "\u034c\3\2\2\2\u0351\u00b0\3\2\2\2\u0352\u0353\n\r\2\2\u0353\u00b2\3",
    "\2\2\2\u0354\u0356\7$\2\2\u0355\u0357\5\u00b5[\2\u0356\u0355\3\2\2\2",
    "\u0356\u0357\3\2\2\2\u0357\u0358\3\2\2\2\u0358\u0359\7$\2\2\u0359\u00b4",
    "\3\2\2\2\u035a\u035c\5\u00b7\\\2\u035b\u035a\3\2\2\2\u035c\u035d\3\2",
    "\2\2\u035d\u035b\3\2\2\2\u035d\u035e\3\2\2\2\u035e\u00b6\3\2\2\2\u035f",
    "\u0362\n\16\2\2\u0360\u0362\5\u00b9]\2\u0361\u035f\3\2\2\2\u0361\u0360",
    "\3\2\2\2\u0362\u00b8\3\2\2\2\u0363\u0364\7^\2\2\u0364\u0368\t\17\2\2",
    "\u0365\u0368\5\u00bb^\2\u0366\u0368\5\u00bd_\2\u0367\u0363\3\2\2\2\u0367",
    "\u0365\3\2\2\2\u0367\u0366\3\2\2\2\u0368\u00ba\3\2\2\2\u0369\u036a\7",
    "^\2\2\u036a\u0375\5\u008bF\2\u036b\u036c\7^\2\2\u036c\u036d\5\u008b",
    "F\2\u036d\u036e\5\u008bF\2\u036e\u0375\3\2\2\2\u036f\u0370\7^\2\2\u0370",
    "\u0371\5\u00bf`\2\u0371\u0372\5\u008bF\2\u0372\u0373\5\u008bF\2\u0373",
    "\u0375\3\2\2\2\u0374\u0369\3\2\2\2\u0374\u036b\3\2\2\2\u0374\u036f\3",
    "\2\2\2\u0375\u00bc\3\2\2\2\u0376\u0377\7^\2\2\u0377\u0378\7w\2\2\u0378",
    "\u0379\5\u0083B\2\u0379\u037a\5\u0083B\2\u037a\u037b\5\u0083B\2\u037b",
    "\u037c\5\u0083B\2\u037c\u00be\3\2\2\2\u037d\u037e\t\20\2\2\u037e\u00c0",
    "\3\2\2\2\u037f\u0380\7p\2\2\u0380\u0381\7w\2\2\u0381\u0382\7n\2\2\u0382",
    "\u0383\7n\2\2\u0383\u00c2\3\2\2\2\u0384\u0385\7*\2\2\u0385\u00c4\3\2",
    "\2\2\u0386\u0387\7+\2\2\u0387\u00c6\3\2\2\2\u0388\u0389\7}\2\2\u0389",
    "\u00c8\3\2\2\2\u038a\u038b\7\177\2\2\u038b\u00ca\3\2\2\2\u038c\u038d",
    "\7]\2\2\u038d\u00cc\3\2\2\2\u038e\u038f\7_\2\2\u038f\u00ce\3\2\2\2\u0390",
    "\u0391\7=\2\2\u0391\u00d0\3\2\2\2\u0392\u0393\7.\2\2\u0393\u00d2\3\2",
    "\2\2\u0394\u0395\7\60\2\2\u0395\u00d4\3\2\2\2\u0396\u0397\7?\2\2\u0397",
    "\u00d6\3\2\2\2\u0398\u0399\7@\2\2\u0399\u00d8\3\2\2\2\u039a\u039b\7",
    ">\2\2\u039b\u00da\3\2\2\2\u039c\u039d\7#\2\2\u039d\u00dc\3\2\2\2\u039e",
    "\u039f\7\u0080\2\2\u039f\u00de\3\2\2\2\u03a0\u03a1\7A\2\2\u03a1\u00e0",
    "\3\2\2\2\u03a2\u03a3\7<\2\2\u03a3\u00e2\3\2\2\2\u03a4\u03a5\7?\2\2\u03a5",
    "\u03a6\7?\2\2\u03a6\u00e4\3\2\2\2\u03a7\u03a8\7>\2\2\u03a8\u03a9\7?",
    "\2\2\u03a9\u00e6\3\2\2\2\u03aa\u03ab\7@\2\2\u03ab\u03ac\7?\2\2\u03ac",
    "\u00e8\3\2\2\2\u03ad\u03ae\7#\2\2\u03ae\u03af\7?\2\2\u03af\u00ea\3\2",
    "\2\2\u03b0\u03b1\7(\2\2\u03b1\u03b2\7(\2\2\u03b2\u00ec\3\2\2\2\u03b3",
    "\u03b4\7~\2\2\u03b4\u03b5\7~\2\2\u03b5\u00ee\3\2\2\2\u03b6\u03b7\7-",
    "\2\2\u03b7\u03b8\7-\2\2\u03b8\u00f0\3\2\2\2\u03b9\u03ba\7/\2\2\u03ba",
    "\u03bb\7/\2\2\u03bb\u00f2\3\2\2\2\u03bc\u03bd\7-\2\2\u03bd\u00f4\3\2",
    "\2\2\u03be\u03bf\7/\2\2\u03bf\u00f6\3\2\2\2\u03c0\u03c1\7,\2\2\u03c1",
    "\u00f8\3\2\2\2\u03c2\u03c3\7\61\2\2\u03c3\u00fa\3\2\2\2\u03c4\u03c5",
    "\7(\2\2\u03c5\u00fc\3\2\2\2\u03c6\u03c7\7~\2\2\u03c7\u00fe\3\2\2\2\u03c8",
    "\u03c9\7`\2\2\u03c9\u0100\3\2\2\2\u03ca\u03cb\7\'\2\2\u03cb\u0102\3",
    "\2\2\2\u03cc\u03cd\7-\2\2\u03cd\u03ce\7?\2\2\u03ce\u0104\3\2\2\2\u03cf",
    "\u03d0\7/\2\2\u03d0\u03d1\7?\2\2\u03d1\u0106\3\2\2\2\u03d2\u03d3\7,",
    "\2\2\u03d3\u03d4\7?\2\2\u03d4\u0108\3\2\2\2\u03d5\u03d6\7\61\2\2\u03d6",
    "\u03d7\7?\2\2\u03d7\u010a\3\2\2\2\u03d8\u03d9\7(\2\2\u03d9\u03da\7?",
    "\2\2\u03da\u010c\3\2\2\2\u03db\u03dc\7~\2\2\u03dc\u03dd\7?\2\2\u03dd",
    "\u010e\3\2\2\2\u03de\u03df\7`\2\2\u03df\u03e0\7?\2\2\u03e0\u0110\3\2",
    "\2\2\u03e1\u03e2\7\'\2\2\u03e2\u03e3\7?\2\2\u03e3\u0112\3\2\2\2\u03e4",
    "\u03e5\7>\2\2\u03e5\u03e6\7>\2\2\u03e6\u03e7\7?\2\2\u03e7\u0114\3\2",
    "\2\2\u03e8\u03e9\7@\2\2\u03e9\u03ea\7@\2\2\u03ea\u03eb\7?\2\2\u03eb",
    "\u0116\3\2\2\2\u03ec\u03ed\7@\2\2\u03ed\u03ee\7@\2\2\u03ee\u03ef\7@",
    "\2\2\u03ef\u03f0\7?\2\2\u03f0\u0118\3\2\2\2\u03f1\u03f5\5\u011b\u008e",
    "\2\u03f2\u03f4\5\u011d\u008f\2\u03f3\u03f2\3\2\2\2\u03f4\u03f7\3\2\2",
    "\2\u03f5\u03f3\3\2\2\2\u03f5\u03f6\3\2\2\2\u03f6\u011a\3\2\2\2\u03f7",
    "\u03f5\3\2\2\2\u03f8\u03f9\t\21\2\2\u03f9\u011c\3\2\2\2\u03fa\u03fb",
    "\t\22\2\2\u03fb\u011e\3\2\2\2\u03fc\u03fd\7B\2\2\u03fd\u0120\3\2\2\2",
    "\u03fe\u03ff\7\60\2\2\u03ff\u0400\7\60\2\2\u0400\u0401\7\60\2\2\u0401",
    "\u0122\3\2\2\2\u0402\u0404\t\23\2\2\u0403\u0402\3\2\2\2\u0404\u0405",
    "\3\2\2\2\u0405\u0403\3\2\2\2\u0405\u0406\3\2\2\2\u0406\u0407\3\2\2\2",
    "\u0407\u0408\b\u0092\2\2\u0408\u0124\3\2\2\2\u0409\u040a\7\61\2\2\u040a",
    "\u040b\7,\2\2\u040b\u040f\3\2\2\2\u040c\u040e\13\2\2\2\u040d\u040c\3",
    "\2\2\2\u040e\u0411\3\2\2\2\u040f\u0410\3\2\2\2\u040f\u040d\3\2\2\2\u0410",
    "\u0412\3\2\2\2\u0411\u040f\3\2\2\2\u0412\u0413\7,\2\2\u0413\u0414\7",
    "\61\2\2\u0414\u0415\3\2\2\2\u0415\u0416\b\u0093\2\2\u0416\u0126\3\2",
    "\2\2\u0417\u0418\7\61\2\2\u0418\u0419\7\61\2\2\u0419\u041d\3\2\2\2\u041a",
    "\u041c\n\24\2\2\u041b\u041a\3\2\2\2\u041c\u041f\3\2\2\2\u041d\u041b",
    "\3\2\2\2\u041d\u041e\3\2\2\2\u041e\u0420\3\2\2\2\u041f\u041d\3\2\2\2",
    "\u0420\u0421\b\u0094\2\2\u0421\u0128\3\2\2\2\62\2\u0280\u0284\u0288",
    "\u028c\u0290\u0297\u029c\u029e\u02a4\u02a8\u02ac\u02b2\u02b7\u02c1\u02c5",
    "\u02cb\u02cf\u02d7\u02db\u02e1\u02eb\u02ef\u02f5\u02f9\u02fe\u0301\u0304",
    "\u0309\u030c\u0311\u0316\u031e\u0329\u032d\u0332\u0336\u0346\u0350\u0356",
    "\u035d\u0361\u0367\u0374\u03f5\u0405\u040f\u041d\3\b\2\2"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function JavaLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

JavaLexer.prototype = Object.create(antlr4.Lexer.prototype);
JavaLexer.prototype.constructor = JavaLexer;

JavaLexer.EOF = antlr4.Token.EOF;
JavaLexer.ABSTRACT = 1;
JavaLexer.ASSERT = 2;
JavaLexer.BOOLEAN = 3;
JavaLexer.BREAK = 4;
JavaLexer.BYTE = 5;
JavaLexer.CASE = 6;
JavaLexer.CATCH = 7;
JavaLexer.CHAR = 8;
JavaLexer.CLASS = 9;
JavaLexer.CONST = 10;
JavaLexer.CONTINUE = 11;
JavaLexer.DEFAULT = 12;
JavaLexer.DO = 13;
JavaLexer.DOUBLE = 14;
JavaLexer.ELSE = 15;
JavaLexer.ENUM = 16;
JavaLexer.EXTENDS = 17;
JavaLexer.FINAL = 18;
JavaLexer.FINALLY = 19;
JavaLexer.FLOAT = 20;
JavaLexer.FOR = 21;
JavaLexer.IF = 22;
JavaLexer.GOTO = 23;
JavaLexer.IMPLEMENTS = 24;
JavaLexer.IMPORT = 25;
JavaLexer.INSTANCEOF = 26;
JavaLexer.INT = 27;
JavaLexer.INTERFACE = 28;
JavaLexer.LONG = 29;
JavaLexer.NATIVE = 30;
JavaLexer.NEW = 31;
JavaLexer.PACKAGE = 32;
JavaLexer.PRIVATE = 33;
JavaLexer.PROTECTED = 34;
JavaLexer.PUBLIC = 35;
JavaLexer.RETURN = 36;
JavaLexer.SHORT = 37;
JavaLexer.STATIC = 38;
JavaLexer.STRICTFP = 39;
JavaLexer.SUPER = 40;
JavaLexer.SWITCH = 41;
JavaLexer.SYNCHRONIZED = 42;
JavaLexer.THIS = 43;
JavaLexer.THROW = 44;
JavaLexer.THROWS = 45;
JavaLexer.TRANSIENT = 46;
JavaLexer.TRY = 47;
JavaLexer.VOID = 48;
JavaLexer.VOLATILE = 49;
JavaLexer.WHILE = 50;
JavaLexer.IntegerLiteral = 51;
JavaLexer.FloatingPointLiteral = 52;
JavaLexer.BooleanLiteral = 53;
JavaLexer.CharacterLiteral = 54;
JavaLexer.StringLiteral = 55;
JavaLexer.NullLiteral = 56;
JavaLexer.LPAREN = 57;
JavaLexer.RPAREN = 58;
JavaLexer.LBRACE = 59;
JavaLexer.RBRACE = 60;
JavaLexer.LBRACK = 61;
JavaLexer.RBRACK = 62;
JavaLexer.SEMI = 63;
JavaLexer.COMMA = 64;
JavaLexer.DOT = 65;
JavaLexer.ASSIGN = 66;
JavaLexer.GT = 67;
JavaLexer.LT = 68;
JavaLexer.BANG = 69;
JavaLexer.TILDE = 70;
JavaLexer.QUESTION = 71;
JavaLexer.COLON = 72;
JavaLexer.EQUAL = 73;
JavaLexer.LE = 74;
JavaLexer.GE = 75;
JavaLexer.NOTEQUAL = 76;
JavaLexer.AND = 77;
JavaLexer.OR = 78;
JavaLexer.INC = 79;
JavaLexer.DEC = 80;
JavaLexer.ADD = 81;
JavaLexer.SUB = 82;
JavaLexer.MUL = 83;
JavaLexer.DIV = 84;
JavaLexer.BITAND = 85;
JavaLexer.BITOR = 86;
JavaLexer.CARET = 87;
JavaLexer.MOD = 88;
JavaLexer.ADD_ASSIGN = 89;
JavaLexer.SUB_ASSIGN = 90;
JavaLexer.MUL_ASSIGN = 91;
JavaLexer.DIV_ASSIGN = 92;
JavaLexer.AND_ASSIGN = 93;
JavaLexer.OR_ASSIGN = 94;
JavaLexer.XOR_ASSIGN = 95;
JavaLexer.MOD_ASSIGN = 96;
JavaLexer.LSHIFT_ASSIGN = 97;
JavaLexer.RSHIFT_ASSIGN = 98;
JavaLexer.URSHIFT_ASSIGN = 99;
JavaLexer.Identifier = 100;
JavaLexer.AT = 101;
JavaLexer.ELLIPSIS = 102;
JavaLexer.WS = 103;
JavaLexer.COMMENT = 104;
JavaLexer.LINE_COMMENT = 105;


JavaLexer.modeNames = [ "DEFAULT_MODE" ];

JavaLexer.literalNames = [ 'null', "'abstract'", "'assert'", "'boolean'", 
                           "'break'", "'byte'", "'case'", "'catch'", "'char'", 
                           "'class'", "'const'", "'continue'", "'default'", 
                           "'do'", "'double'", "'else'", "'enum'", "'extends'", 
                           "'final'", "'finally'", "'float'", "'for'", "'if'", 
                           "'goto'", "'implements'", "'import'", "'instanceof'", 
                           "'int'", "'interface'", "'long'", "'native'", 
                           "'new'", "'package'", "'private'", "'protected'", 
                           "'public'", "'return'", "'short'", "'static'", 
                           "'strictfp'", "'super'", "'switch'", "'synchronized'", 
                           "'this'", "'throw'", "'throws'", "'transient'", 
                           "'try'", "'void'", "'volatile'", "'while'", 'null', 
                           'null', 'null', 'null', 'null', "'null'", "'('", 
                           "')'", "'{'", "'}'", "'['", "']'", "';'", "','", 
                           "'.'", "'='", "'>'", "'<'", "'!'", "'~'", "'?'", 
                           "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", 
                           "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", 
                           "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", "'-='", 
                           "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", 
                           "'<<='", "'>>='", "'>>>='", 'null', "'@'", "'...'" ];

JavaLexer.symbolicNames = [ 'null', "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", 
                            "BYTE", "CASE", "CATCH", "CHAR", "CLASS", "CONST", 
                            "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE", 
                            "ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", 
                            "FOR", "IF", "GOTO", "IMPLEMENTS", "IMPORT", 
                            "INSTANCEOF", "INT", "INTERFACE", "LONG", "NATIVE", 
                            "NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", 
                            "RETURN", "SHORT", "STATIC", "STRICTFP", "SUPER", 
                            "SWITCH", "SYNCHRONIZED", "THIS", "THROW", "THROWS", 
                            "TRANSIENT", "TRY", "VOID", "VOLATILE", "WHILE", 
                            "IntegerLiteral", "FloatingPointLiteral", "BooleanLiteral", 
                            "CharacterLiteral", "StringLiteral", "NullLiteral", 
                            "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", 
                            "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN", 
                            "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", 
                            "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", 
                            "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", 
                            "BITOR", "CARET", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", 
                            "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", 
                            "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", 
                            "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "Identifier", 
                            "AT", "ELLIPSIS", "WS", "COMMENT", "LINE_COMMENT" ];

JavaLexer.ruleNames = [ "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", "BYTE", 
                        "CASE", "CATCH", "CHAR", "CLASS", "CONST", "CONTINUE", 
                        "DEFAULT", "DO", "DOUBLE", "ELSE", "ENUM", "EXTENDS", 
                        "FINAL", "FINALLY", "FLOAT", "FOR", "IF", "GOTO", 
                        "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", "INTERFACE", 
                        "LONG", "NATIVE", "NEW", "PACKAGE", "PRIVATE", "PROTECTED", 
                        "PUBLIC", "RETURN", "SHORT", "STATIC", "STRICTFP", 
                        "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", "THROW", 
                        "THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", 
                        "WHILE", "IntegerLiteral", "DecimalIntegerLiteral", 
                        "HexIntegerLiteral", "OctalIntegerLiteral", "BinaryIntegerLiteral", 
                        "IntegerTypeSuffix", "DecimalNumeral", "Digits", 
                        "Digit", "NonZeroDigit", "DigitOrUnderscore", "Underscores", 
                        "HexNumeral", "HexDigits", "HexDigit", "HexDigitOrUnderscore", 
                        "OctalNumeral", "OctalDigits", "OctalDigit", "OctalDigitOrUnderscore", 
                        "BinaryNumeral", "BinaryDigits", "BinaryDigit", 
                        "BinaryDigitOrUnderscore", "FloatingPointLiteral", 
                        "DecimalFloatingPointLiteral", "ExponentPart", "ExponentIndicator", 
                        "SignedInteger", "Sign", "FloatTypeSuffix", "HexadecimalFloatingPointLiteral", 
                        "HexSignificand", "BinaryExponent", "BinaryExponentIndicator", 
                        "BooleanLiteral", "CharacterLiteral", "SingleCharacter", 
                        "StringLiteral", "StringCharacters", "StringCharacter", 
                        "EscapeSequence", "OctalEscape", "UnicodeEscape", 
                        "ZeroToThree", "NullLiteral", "LPAREN", "RPAREN", 
                        "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", 
                        "COMMA", "DOT", "ASSIGN", "GT", "LT", "BANG", "TILDE", 
                        "QUESTION", "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", 
                        "AND", "OR", "INC", "DEC", "ADD", "SUB", "MUL", 
                        "DIV", "BITAND", "BITOR", "CARET", "MOD", "ADD_ASSIGN", 
                        "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", 
                        "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", 
                        "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "Identifier", 
                        "JavaLetter", "JavaLetterOrDigit", "AT", "ELLIPSIS", 
                        "WS", "COMMENT", "LINE_COMMENT" ];

JavaLexer.grammarFileName = "Java.g4";



exports.JavaLexer = JavaLexer;


},{"antlr4/index":54}],5:[function(require,module,exports){
// Generated from Java.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by JavaParser.
function JavaListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

JavaListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
JavaListener.prototype.constructor = JavaListener;

// Enter a parse tree produced by JavaParser#compilationUnit.
JavaListener.prototype.enterCompilationUnit = function(ctx) {
};

// Exit a parse tree produced by JavaParser#compilationUnit.
JavaListener.prototype.exitCompilationUnit = function(ctx) {
};


// Enter a parse tree produced by JavaParser#packageDeclaration.
JavaListener.prototype.enterPackageDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#packageDeclaration.
JavaListener.prototype.exitPackageDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#importDeclaration.
JavaListener.prototype.enterImportDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#importDeclaration.
JavaListener.prototype.exitImportDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeDeclaration.
JavaListener.prototype.enterTypeDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeDeclaration.
JavaListener.prototype.exitTypeDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#modifier.
JavaListener.prototype.enterModifier = function(ctx) {
};

// Exit a parse tree produced by JavaParser#modifier.
JavaListener.prototype.exitModifier = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classOrInterfaceModifier.
JavaListener.prototype.enterClassOrInterfaceModifier = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classOrInterfaceModifier.
JavaListener.prototype.exitClassOrInterfaceModifier = function(ctx) {
};


// Enter a parse tree produced by JavaParser#variableModifier.
JavaListener.prototype.enterVariableModifier = function(ctx) {
};

// Exit a parse tree produced by JavaParser#variableModifier.
JavaListener.prototype.exitVariableModifier = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classDeclaration.
JavaListener.prototype.enterClassDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classDeclaration.
JavaListener.prototype.exitClassDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeParameters.
JavaListener.prototype.enterTypeParameters = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeParameters.
JavaListener.prototype.exitTypeParameters = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeParameter.
JavaListener.prototype.enterTypeParameter = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeParameter.
JavaListener.prototype.exitTypeParameter = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeBound.
JavaListener.prototype.enterTypeBound = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeBound.
JavaListener.prototype.exitTypeBound = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enumDeclaration.
JavaListener.prototype.enterEnumDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enumDeclaration.
JavaListener.prototype.exitEnumDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enumConstants.
JavaListener.prototype.enterEnumConstants = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enumConstants.
JavaListener.prototype.exitEnumConstants = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enumConstant.
JavaListener.prototype.enterEnumConstant = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enumConstant.
JavaListener.prototype.exitEnumConstant = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enumBodyDeclarations.
JavaListener.prototype.enterEnumBodyDeclarations = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enumBodyDeclarations.
JavaListener.prototype.exitEnumBodyDeclarations = function(ctx) {
};


// Enter a parse tree produced by JavaParser#interfaceDeclaration.
JavaListener.prototype.enterInterfaceDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#interfaceDeclaration.
JavaListener.prototype.exitInterfaceDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeList.
JavaListener.prototype.enterTypeList = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeList.
JavaListener.prototype.exitTypeList = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classBody.
JavaListener.prototype.enterClassBody = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classBody.
JavaListener.prototype.exitClassBody = function(ctx) {
};


// Enter a parse tree produced by JavaParser#interfaceBody.
JavaListener.prototype.enterInterfaceBody = function(ctx) {
};

// Exit a parse tree produced by JavaParser#interfaceBody.
JavaListener.prototype.exitInterfaceBody = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classBodyDeclaration.
JavaListener.prototype.enterClassBodyDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classBodyDeclaration.
JavaListener.prototype.exitClassBodyDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#memberDeclaration.
JavaListener.prototype.enterMemberDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#memberDeclaration.
JavaListener.prototype.exitMemberDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#methodDeclaration.
JavaListener.prototype.enterMethodDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#methodDeclaration.
JavaListener.prototype.exitMethodDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#genericMethodDeclaration.
JavaListener.prototype.enterGenericMethodDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#genericMethodDeclaration.
JavaListener.prototype.exitGenericMethodDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#constructorDeclaration.
JavaListener.prototype.enterConstructorDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#constructorDeclaration.
JavaListener.prototype.exitConstructorDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#genericConstructorDeclaration.
JavaListener.prototype.enterGenericConstructorDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#genericConstructorDeclaration.
JavaListener.prototype.exitGenericConstructorDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#fieldDeclaration.
JavaListener.prototype.enterFieldDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#fieldDeclaration.
JavaListener.prototype.exitFieldDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#interfaceBodyDeclaration.
JavaListener.prototype.enterInterfaceBodyDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#interfaceBodyDeclaration.
JavaListener.prototype.exitInterfaceBodyDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#interfaceMemberDeclaration.
JavaListener.prototype.enterInterfaceMemberDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#interfaceMemberDeclaration.
JavaListener.prototype.exitInterfaceMemberDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#constDeclaration.
JavaListener.prototype.enterConstDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#constDeclaration.
JavaListener.prototype.exitConstDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#constantDeclarator.
JavaListener.prototype.enterConstantDeclarator = function(ctx) {
};

// Exit a parse tree produced by JavaParser#constantDeclarator.
JavaListener.prototype.exitConstantDeclarator = function(ctx) {
};


// Enter a parse tree produced by JavaParser#interfaceMethodDeclaration.
JavaListener.prototype.enterInterfaceMethodDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#interfaceMethodDeclaration.
JavaListener.prototype.exitInterfaceMethodDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#genericInterfaceMethodDeclaration.
JavaListener.prototype.enterGenericInterfaceMethodDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#genericInterfaceMethodDeclaration.
JavaListener.prototype.exitGenericInterfaceMethodDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#variableDeclarators.
JavaListener.prototype.enterVariableDeclarators = function(ctx) {
};

// Exit a parse tree produced by JavaParser#variableDeclarators.
JavaListener.prototype.exitVariableDeclarators = function(ctx) {
};


// Enter a parse tree produced by JavaParser#variableDeclarator.
JavaListener.prototype.enterVariableDeclarator = function(ctx) {
};

// Exit a parse tree produced by JavaParser#variableDeclarator.
JavaListener.prototype.exitVariableDeclarator = function(ctx) {
};


// Enter a parse tree produced by JavaParser#variableDeclaratorId.
JavaListener.prototype.enterVariableDeclaratorId = function(ctx) {
};

// Exit a parse tree produced by JavaParser#variableDeclaratorId.
JavaListener.prototype.exitVariableDeclaratorId = function(ctx) {
};


// Enter a parse tree produced by JavaParser#variableInitializer.
JavaListener.prototype.enterVariableInitializer = function(ctx) {
};

// Exit a parse tree produced by JavaParser#variableInitializer.
JavaListener.prototype.exitVariableInitializer = function(ctx) {
};


// Enter a parse tree produced by JavaParser#arrayInitializer.
JavaListener.prototype.enterArrayInitializer = function(ctx) {
};

// Exit a parse tree produced by JavaParser#arrayInitializer.
JavaListener.prototype.exitArrayInitializer = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enumConstantName.
JavaListener.prototype.enterEnumConstantName = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enumConstantName.
JavaListener.prototype.exitEnumConstantName = function(ctx) {
};


// Enter a parse tree produced by JavaParser#type.
JavaListener.prototype.enterType = function(ctx) {
};

// Exit a parse tree produced by JavaParser#type.
JavaListener.prototype.exitType = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classOrInterfaceType.
JavaListener.prototype.enterClassOrInterfaceType = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classOrInterfaceType.
JavaListener.prototype.exitClassOrInterfaceType = function(ctx) {
};


// Enter a parse tree produced by JavaParser#primitiveType.
JavaListener.prototype.enterPrimitiveType = function(ctx) {
};

// Exit a parse tree produced by JavaParser#primitiveType.
JavaListener.prototype.exitPrimitiveType = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeArguments.
JavaListener.prototype.enterTypeArguments = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeArguments.
JavaListener.prototype.exitTypeArguments = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeArgument.
JavaListener.prototype.enterTypeArgument = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeArgument.
JavaListener.prototype.exitTypeArgument = function(ctx) {
};


// Enter a parse tree produced by JavaParser#qualifiedNameList.
JavaListener.prototype.enterQualifiedNameList = function(ctx) {
};

// Exit a parse tree produced by JavaParser#qualifiedNameList.
JavaListener.prototype.exitQualifiedNameList = function(ctx) {
};


// Enter a parse tree produced by JavaParser#formalParameters.
JavaListener.prototype.enterFormalParameters = function(ctx) {
};

// Exit a parse tree produced by JavaParser#formalParameters.
JavaListener.prototype.exitFormalParameters = function(ctx) {
};


// Enter a parse tree produced by JavaParser#formalParameterList.
JavaListener.prototype.enterFormalParameterList = function(ctx) {
};

// Exit a parse tree produced by JavaParser#formalParameterList.
JavaListener.prototype.exitFormalParameterList = function(ctx) {
};


// Enter a parse tree produced by JavaParser#formalParameter.
JavaListener.prototype.enterFormalParameter = function(ctx) {
};

// Exit a parse tree produced by JavaParser#formalParameter.
JavaListener.prototype.exitFormalParameter = function(ctx) {
};


// Enter a parse tree produced by JavaParser#lastFormalParameter.
JavaListener.prototype.enterLastFormalParameter = function(ctx) {
};

// Exit a parse tree produced by JavaParser#lastFormalParameter.
JavaListener.prototype.exitLastFormalParameter = function(ctx) {
};


// Enter a parse tree produced by JavaParser#methodBody.
JavaListener.prototype.enterMethodBody = function(ctx) {
};

// Exit a parse tree produced by JavaParser#methodBody.
JavaListener.prototype.exitMethodBody = function(ctx) {
};


// Enter a parse tree produced by JavaParser#constructorBody.
JavaListener.prototype.enterConstructorBody = function(ctx) {
};

// Exit a parse tree produced by JavaParser#constructorBody.
JavaListener.prototype.exitConstructorBody = function(ctx) {
};


// Enter a parse tree produced by JavaParser#qualifiedName.
JavaListener.prototype.enterQualifiedName = function(ctx) {
};

// Exit a parse tree produced by JavaParser#qualifiedName.
JavaListener.prototype.exitQualifiedName = function(ctx) {
};


// Enter a parse tree produced by JavaParser#literal.
JavaListener.prototype.enterLiteral = function(ctx) {
};

// Exit a parse tree produced by JavaParser#literal.
JavaListener.prototype.exitLiteral = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotation.
JavaListener.prototype.enterAnnotation = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotation.
JavaListener.prototype.exitAnnotation = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationName.
JavaListener.prototype.enterAnnotationName = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationName.
JavaListener.prototype.exitAnnotationName = function(ctx) {
};


// Enter a parse tree produced by JavaParser#elementValuePairs.
JavaListener.prototype.enterElementValuePairs = function(ctx) {
};

// Exit a parse tree produced by JavaParser#elementValuePairs.
JavaListener.prototype.exitElementValuePairs = function(ctx) {
};


// Enter a parse tree produced by JavaParser#elementValuePair.
JavaListener.prototype.enterElementValuePair = function(ctx) {
};

// Exit a parse tree produced by JavaParser#elementValuePair.
JavaListener.prototype.exitElementValuePair = function(ctx) {
};


// Enter a parse tree produced by JavaParser#elementValue.
JavaListener.prototype.enterElementValue = function(ctx) {
};

// Exit a parse tree produced by JavaParser#elementValue.
JavaListener.prototype.exitElementValue = function(ctx) {
};


// Enter a parse tree produced by JavaParser#elementValueArrayInitializer.
JavaListener.prototype.enterElementValueArrayInitializer = function(ctx) {
};

// Exit a parse tree produced by JavaParser#elementValueArrayInitializer.
JavaListener.prototype.exitElementValueArrayInitializer = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationTypeDeclaration.
JavaListener.prototype.enterAnnotationTypeDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationTypeDeclaration.
JavaListener.prototype.exitAnnotationTypeDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationTypeBody.
JavaListener.prototype.enterAnnotationTypeBody = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationTypeBody.
JavaListener.prototype.exitAnnotationTypeBody = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationTypeElementDeclaration.
JavaListener.prototype.enterAnnotationTypeElementDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationTypeElementDeclaration.
JavaListener.prototype.exitAnnotationTypeElementDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationTypeElementRest.
JavaListener.prototype.enterAnnotationTypeElementRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationTypeElementRest.
JavaListener.prototype.exitAnnotationTypeElementRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationMethodOrConstantRest.
JavaListener.prototype.enterAnnotationMethodOrConstantRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationMethodOrConstantRest.
JavaListener.prototype.exitAnnotationMethodOrConstantRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationMethodRest.
JavaListener.prototype.enterAnnotationMethodRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationMethodRest.
JavaListener.prototype.exitAnnotationMethodRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#annotationConstantRest.
JavaListener.prototype.enterAnnotationConstantRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#annotationConstantRest.
JavaListener.prototype.exitAnnotationConstantRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#defaultValue.
JavaListener.prototype.enterDefaultValue = function(ctx) {
};

// Exit a parse tree produced by JavaParser#defaultValue.
JavaListener.prototype.exitDefaultValue = function(ctx) {
};


// Enter a parse tree produced by JavaParser#block.
JavaListener.prototype.enterBlock = function(ctx) {
};

// Exit a parse tree produced by JavaParser#block.
JavaListener.prototype.exitBlock = function(ctx) {
};


// Enter a parse tree produced by JavaParser#blockStatement.
JavaListener.prototype.enterBlockStatement = function(ctx) {
};

// Exit a parse tree produced by JavaParser#blockStatement.
JavaListener.prototype.exitBlockStatement = function(ctx) {
};


// Enter a parse tree produced by JavaParser#localVariableDeclarationStatement.
JavaListener.prototype.enterLocalVariableDeclarationStatement = function(ctx) {
};

// Exit a parse tree produced by JavaParser#localVariableDeclarationStatement.
JavaListener.prototype.exitLocalVariableDeclarationStatement = function(ctx) {
};


// Enter a parse tree produced by JavaParser#localVariableDeclaration.
JavaListener.prototype.enterLocalVariableDeclaration = function(ctx) {
};

// Exit a parse tree produced by JavaParser#localVariableDeclaration.
JavaListener.prototype.exitLocalVariableDeclaration = function(ctx) {
};


// Enter a parse tree produced by JavaParser#statement.
JavaListener.prototype.enterStatement = function(ctx) {
};

// Exit a parse tree produced by JavaParser#statement.
JavaListener.prototype.exitStatement = function(ctx) {
};


// Enter a parse tree produced by JavaParser#catchClause.
JavaListener.prototype.enterCatchClause = function(ctx) {
};

// Exit a parse tree produced by JavaParser#catchClause.
JavaListener.prototype.exitCatchClause = function(ctx) {
};


// Enter a parse tree produced by JavaParser#catchType.
JavaListener.prototype.enterCatchType = function(ctx) {
};

// Exit a parse tree produced by JavaParser#catchType.
JavaListener.prototype.exitCatchType = function(ctx) {
};


// Enter a parse tree produced by JavaParser#finallyBlock.
JavaListener.prototype.enterFinallyBlock = function(ctx) {
};

// Exit a parse tree produced by JavaParser#finallyBlock.
JavaListener.prototype.exitFinallyBlock = function(ctx) {
};


// Enter a parse tree produced by JavaParser#resourceSpecification.
JavaListener.prototype.enterResourceSpecification = function(ctx) {
};

// Exit a parse tree produced by JavaParser#resourceSpecification.
JavaListener.prototype.exitResourceSpecification = function(ctx) {
};


// Enter a parse tree produced by JavaParser#resources.
JavaListener.prototype.enterResources = function(ctx) {
};

// Exit a parse tree produced by JavaParser#resources.
JavaListener.prototype.exitResources = function(ctx) {
};


// Enter a parse tree produced by JavaParser#resource.
JavaListener.prototype.enterResource = function(ctx) {
};

// Exit a parse tree produced by JavaParser#resource.
JavaListener.prototype.exitResource = function(ctx) {
};


// Enter a parse tree produced by JavaParser#switchBlockStatementGroup.
JavaListener.prototype.enterSwitchBlockStatementGroup = function(ctx) {
};

// Exit a parse tree produced by JavaParser#switchBlockStatementGroup.
JavaListener.prototype.exitSwitchBlockStatementGroup = function(ctx) {
};


// Enter a parse tree produced by JavaParser#switchLabel.
JavaListener.prototype.enterSwitchLabel = function(ctx) {
};

// Exit a parse tree produced by JavaParser#switchLabel.
JavaListener.prototype.exitSwitchLabel = function(ctx) {
};


// Enter a parse tree produced by JavaParser#forControl.
JavaListener.prototype.enterForControl = function(ctx) {
};

// Exit a parse tree produced by JavaParser#forControl.
JavaListener.prototype.exitForControl = function(ctx) {
};


// Enter a parse tree produced by JavaParser#forInit.
JavaListener.prototype.enterForInit = function(ctx) {
};

// Exit a parse tree produced by JavaParser#forInit.
JavaListener.prototype.exitForInit = function(ctx) {
};


// Enter a parse tree produced by JavaParser#enhancedForControl.
JavaListener.prototype.enterEnhancedForControl = function(ctx) {
};

// Exit a parse tree produced by JavaParser#enhancedForControl.
JavaListener.prototype.exitEnhancedForControl = function(ctx) {
};


// Enter a parse tree produced by JavaParser#forUpdate.
JavaListener.prototype.enterForUpdate = function(ctx) {
};

// Exit a parse tree produced by JavaParser#forUpdate.
JavaListener.prototype.exitForUpdate = function(ctx) {
};


// Enter a parse tree produced by JavaParser#parExpression.
JavaListener.prototype.enterParExpression = function(ctx) {
};

// Exit a parse tree produced by JavaParser#parExpression.
JavaListener.prototype.exitParExpression = function(ctx) {
};


// Enter a parse tree produced by JavaParser#expressionList.
JavaListener.prototype.enterExpressionList = function(ctx) {
};

// Exit a parse tree produced by JavaParser#expressionList.
JavaListener.prototype.exitExpressionList = function(ctx) {
};


// Enter a parse tree produced by JavaParser#statementExpression.
JavaListener.prototype.enterStatementExpression = function(ctx) {
};

// Exit a parse tree produced by JavaParser#statementExpression.
JavaListener.prototype.exitStatementExpression = function(ctx) {
};


// Enter a parse tree produced by JavaParser#constantExpression.
JavaListener.prototype.enterConstantExpression = function(ctx) {
};

// Exit a parse tree produced by JavaParser#constantExpression.
JavaListener.prototype.exitConstantExpression = function(ctx) {
};


// Enter a parse tree produced by JavaParser#expression.
JavaListener.prototype.enterExpression = function(ctx) {
};

// Exit a parse tree produced by JavaParser#expression.
JavaListener.prototype.exitExpression = function(ctx) {
};


// Enter a parse tree produced by JavaParser#primary.
JavaListener.prototype.enterPrimary = function(ctx) {
};

// Exit a parse tree produced by JavaParser#primary.
JavaListener.prototype.exitPrimary = function(ctx) {
};


// Enter a parse tree produced by JavaParser#creator.
JavaListener.prototype.enterCreator = function(ctx) {
};

// Exit a parse tree produced by JavaParser#creator.
JavaListener.prototype.exitCreator = function(ctx) {
};


// Enter a parse tree produced by JavaParser#createdName.
JavaListener.prototype.enterCreatedName = function(ctx) {
};

// Exit a parse tree produced by JavaParser#createdName.
JavaListener.prototype.exitCreatedName = function(ctx) {
};


// Enter a parse tree produced by JavaParser#innerCreator.
JavaListener.prototype.enterInnerCreator = function(ctx) {
};

// Exit a parse tree produced by JavaParser#innerCreator.
JavaListener.prototype.exitInnerCreator = function(ctx) {
};


// Enter a parse tree produced by JavaParser#arrayCreatorRest.
JavaListener.prototype.enterArrayCreatorRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#arrayCreatorRest.
JavaListener.prototype.exitArrayCreatorRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#classCreatorRest.
JavaListener.prototype.enterClassCreatorRest = function(ctx) {
};

// Exit a parse tree produced by JavaParser#classCreatorRest.
JavaListener.prototype.exitClassCreatorRest = function(ctx) {
};


// Enter a parse tree produced by JavaParser#explicitGenericInvocation.
JavaListener.prototype.enterExplicitGenericInvocation = function(ctx) {
};

// Exit a parse tree produced by JavaParser#explicitGenericInvocation.
JavaListener.prototype.exitExplicitGenericInvocation = function(ctx) {
};


// Enter a parse tree produced by JavaParser#nonWildcardTypeArguments.
JavaListener.prototype.enterNonWildcardTypeArguments = function(ctx) {
};

// Exit a parse tree produced by JavaParser#nonWildcardTypeArguments.
JavaListener.prototype.exitNonWildcardTypeArguments = function(ctx) {
};


// Enter a parse tree produced by JavaParser#typeArgumentsOrDiamond.
JavaListener.prototype.enterTypeArgumentsOrDiamond = function(ctx) {
};

// Exit a parse tree produced by JavaParser#typeArgumentsOrDiamond.
JavaListener.prototype.exitTypeArgumentsOrDiamond = function(ctx) {
};


// Enter a parse tree produced by JavaParser#nonWildcardTypeArgumentsOrDiamond.
JavaListener.prototype.enterNonWildcardTypeArgumentsOrDiamond = function(ctx) {
};

// Exit a parse tree produced by JavaParser#nonWildcardTypeArgumentsOrDiamond.
JavaListener.prototype.exitNonWildcardTypeArgumentsOrDiamond = function(ctx) {
};


// Enter a parse tree produced by JavaParser#superSuffix.
JavaListener.prototype.enterSuperSuffix = function(ctx) {
};

// Exit a parse tree produced by JavaParser#superSuffix.
JavaListener.prototype.exitSuperSuffix = function(ctx) {
};


// Enter a parse tree produced by JavaParser#explicitGenericInvocationSuffix.
JavaListener.prototype.enterExplicitGenericInvocationSuffix = function(ctx) {
};

// Exit a parse tree produced by JavaParser#explicitGenericInvocationSuffix.
JavaListener.prototype.exitExplicitGenericInvocationSuffix = function(ctx) {
};


// Enter a parse tree produced by JavaParser#arguments.
JavaListener.prototype.enterArguments = function(ctx) {
};

// Exit a parse tree produced by JavaParser#arguments.
JavaListener.prototype.exitArguments = function(ctx) {
};



exports.JavaListener = JavaListener;
},{"antlr4/index":54}],6:[function(require,module,exports){
// Generated from Java.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');
var JavaListener = require('./JavaListener').JavaListener;
var grammarFileName = "Java.g4";

var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\3k\u0501\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4",
    "\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t",
    "\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27",
    "\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4",
    "\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'\t",
    "\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t",
    "\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t",
    "8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC",
    "\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\tN\4",
    "O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY\4Z",
    "\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4",
    "e\te\4f\tf\3\2\5\2\u00ce\n\2\3\2\7\2\u00d1\n\2\f\2\16\2\u00d4\13\2\3",
    "\2\7\2\u00d7\n\2\f\2\16\2\u00da\13\2\3\2\3\2\3\3\7\3\u00df\n\3\f\3\16",
    "\3\u00e2\13\3\3\3\3\3\3\3\3\3\3\4\3\4\5\4\u00ea\n\4\3\4\3\4\3\4\5\4",
    "\u00ef\n\4\3\4\3\4\3\5\7\5\u00f4\n\5\f\5\16\5\u00f7\13\5\3\5\3\5\7\5",
    "\u00fb\n\5\f\5\16\5\u00fe\13\5\3\5\3\5\7\5\u0102\n\5\f\5\16\5\u0105",
    "\13\5\3\5\3\5\7\5\u0109\n\5\f\5\16\5\u010c\13\5\3\5\3\5\5\5\u0110\n",
    "\5\3\6\3\6\5\6\u0114\n\6\3\7\3\7\5\7\u0118\n\7\3\b\3\b\5\b\u011c\n\b",
    "\3\t\3\t\3\t\5\t\u0121\n\t\3\t\3\t\5\t\u0125\n\t\3\t\3\t\5\t\u0129\n",
    "\t\3\t\3\t\3\n\3\n\3\n\3\n\7\n\u0131\n\n\f\n\16\n\u0134\13\n\3\n\3\n",
    "\3\13\3\13\3\13\5\13\u013b\n\13\3\f\3\f\3\f\7\f\u0140\n\f\f\f\16\f\u0143",
    "\13\f\3\r\3\r\3\r\3\r\5\r\u0149\n\r\3\r\3\r\5\r\u014d\n\r\3\r\5\r\u0150",
    "\n\r\3\r\5\r\u0153\n\r\3\r\3\r\3\16\3\16\3\16\7\16\u015a\n\16\f\16\16",
    "\16\u015d\13\16\3\17\7\17\u0160\n\17\f\17\16\17\u0163\13\17\3\17\3\17",
    "\5\17\u0167\n\17\3\17\5\17\u016a\n\17\3\20\3\20\7\20\u016e\n\20\f\20",
    "\16\20\u0171\13\20\3\21\3\21\3\21\5\21\u0176\n\21\3\21\3\21\5\21\u017a",
    "\n\21\3\21\3\21\3\22\3\22\3\22\7\22\u0181\n\22\f\22\16\22\u0184\13\22",
    "\3\23\3\23\7\23\u0188\n\23\f\23\16\23\u018b\13\23\3\23\3\23\3\24\3\24",
    "\7\24\u0191\n\24\f\24\16\24\u0194\13\24\3\24\3\24\3\25\3\25\5\25\u019a",
    "\n\25\3\25\3\25\7\25\u019e\n\25\f\25\16\25\u01a1\13\25\3\25\5\25\u01a4",
    "\n\25\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\5\26\u01af\n\26\3",
    "\27\3\27\5\27\u01b3\n\27\3\27\3\27\3\27\3\27\7\27\u01b9\n\27\f\27\16",
    "\27\u01bc\13\27\3\27\3\27\5\27\u01c0\n\27\3\27\3\27\5\27\u01c4\n\27",
    "\3\30\3\30\3\30\3\31\3\31\3\31\3\31\5\31\u01cd\n\31\3\31\3\31\3\32\3",
    "\32\3\32\3\33\3\33\3\33\3\33\3\34\7\34\u01d9\n\34\f\34\16\34\u01dc\13",
    "\34\3\34\3\34\5\34\u01e0\n\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\5\35",
    "\u01e9\n\35\3\36\3\36\3\36\3\36\7\36\u01ef\n\36\f\36\16\36\u01f2\13",
    "\36\3\36\3\36\3\37\3\37\3\37\7\37\u01f9\n\37\f\37\16\37\u01fc\13\37",
    "\3\37\3\37\3\37\3 \3 \5 \u0203\n \3 \3 \3 \3 \7 \u0209\n \f \16 \u020c",
    "\13 \3 \3 \5 \u0210\n \3 \3 \3!\3!\3!\3\"\3\"\3\"\7\"\u021a\n\"\f\"",
    "\16\"\u021d\13\"\3#\3#\3#\5#\u0222\n#\3$\3$\3$\7$\u0227\n$\f$\16$\u022a",
    "\13$\3%\3%\5%\u022e\n%\3&\3&\3&\3&\7&\u0234\n&\f&\16&\u0237\13&\3&\5",
    "&\u023a\n&\5&\u023c\n&\3&\3&\3\'\3\'\3(\3(\3(\7(\u0245\n(\f(\16(\u0248",
    "\13(\3(\3(\3(\7(\u024d\n(\f(\16(\u0250\13(\5(\u0252\n(\3)\3)\5)\u0256",
    "\n)\3)\3)\3)\5)\u025b\n)\7)\u025d\n)\f)\16)\u0260\13)\3*\3*\3+\3+\3",
    "+\3+\7+\u0268\n+\f+\16+\u026b\13+\3+\3+\3,\3,\3,\3,\5,\u0273\n,\5,\u0275",
    "\n,\3-\3-\3-\7-\u027a\n-\f-\16-\u027d\13-\3.\3.\5.\u0281\n.\3.\3.\3",
    "/\3/\3/\7/\u0288\n/\f/\16/\u028b\13/\3/\3/\5/\u028f\n/\3/\5/\u0292\n",
    "/\3\60\7\60\u0295\n\60\f\60\16\60\u0298\13\60\3\60\3\60\3\60\3\61\7",
    "\61\u029e\n\61\f\61\16\61\u02a1\13\61\3\61\3\61\3\61\3\61\3\62\3\62",
    "\3\63\3\63\3\64\3\64\3\64\7\64\u02ae\n\64\f\64\16\64\u02b1\13\64\3\65",
    "\3\65\3\66\3\66\3\66\3\66\3\66\5\66\u02ba\n\66\3\66\5\66\u02bd\n\66",
    "\3\67\3\67\38\38\38\78\u02c4\n8\f8\168\u02c7\138\39\39\39\39\3:\3:\3",
    ":\5:\u02d0\n:\3;\3;\3;\3;\7;\u02d6\n;\f;\16;\u02d9\13;\5;\u02db\n;\3",
    ";\5;\u02de\n;\3;\3;\3<\3<\3<\3<\3<\3=\3=\7=\u02e9\n=\f=\16=\u02ec\13",
    "=\3=\3=\3>\7>\u02f1\n>\f>\16>\u02f4\13>\3>\3>\5>\u02f8\n>\3?\3?\3?\3",
    "?\3?\3?\5?\u0300\n?\3?\3?\5?\u0304\n?\3?\3?\5?\u0308\n?\3?\3?\5?\u030c",
    "\n?\5?\u030e\n?\3@\3@\5@\u0312\n@\3A\3A\3A\3A\5A\u0318\nA\3B\3B\3C\3",
    "C\3C\3D\3D\7D\u0321\nD\fD\16D\u0324\13D\3D\3D\3E\3E\3E\5E\u032b\nE\3",
    "F\3F\3F\3G\7G\u0331\nG\fG\16G\u0334\13G\3G\3G\3G\3H\3H\3H\3H\3H\5H\u033e",
    "\nH\3H\3H\3H\3H\3H\3H\3H\5H\u0347\nH\3H\3H\3H\3H\3H\3H\3H\3H\3H\3H\3",
    "H\3H\3H\3H\3H\3H\3H\3H\3H\6H\u035c\nH\rH\16H\u035d\3H\5H\u0361\nH\3",
    "H\5H\u0364\nH\3H\3H\3H\3H\7H\u036a\nH\fH\16H\u036d\13H\3H\5H\u0370\n",
    "H\3H\3H\3H\3H\7H\u0376\nH\fH\16H\u0379\13H\3H\7H\u037c\nH\fH\16H\u037f",
    "\13H\3H\3H\3H\3H\3H\3H\3H\3H\5H\u0389\nH\3H\3H\3H\3H\3H\3H\3H\5H\u0392",
    "\nH\3H\3H\3H\5H\u0397\nH\3H\3H\3H\3H\3H\3H\3H\3H\5H\u03a1\nH\3I\3I\3",
    "I\7I\u03a6\nI\fI\16I\u03a9\13I\3I\3I\3I\3I\3I\3J\3J\3J\7J\u03b3\nJ\f",
    "J\16J\u03b6\13J\3K\3K\3K\3L\3L\3L\5L\u03be\nL\3L\3L\3M\3M\3M\7M\u03c5",
    "\nM\fM\16M\u03c8\13M\3N\7N\u03cb\nN\fN\16N\u03ce\13N\3N\3N\3N\3N\3N",
    "\3O\6O\u03d6\nO\rO\16O\u03d7\3O\6O\u03db\nO\rO\16O\u03dc\3P\3P\3P\3",
    "P\3P\3P\3P\3P\3P\3P\5P\u03e9\nP\3Q\3Q\5Q\u03ed\nQ\3Q\3Q\5Q\u03f1\nQ",
    "\3Q\3Q\5Q\u03f5\nQ\5Q\u03f7\nQ\3R\3R\5R\u03fb\nR\3S\7S\u03fe\nS\fS\16",
    "S\u0401\13S\3S\3S\3S\3S\3S\3T\3T\3U\3U\3U\3U\3V\3V\3V\7V\u0411\nV\f",
    "V\16V\u0414\13V\3W\3W\3X\3X\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\5",
    "Y\u0427\nY\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\5Y\u0437\nY\3Y",
    "\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3",
    "Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\5Y\u0462\nY\3Y",
    "\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\3Y\5Y\u0474\nY\3Y\3Y\3Y\3",
    "Y\3Y\3Y\7Y\u047c\nY\fY\16Y\u047f\13Y\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3",
    "Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\5Z\u0494\nZ\5Z\u0496\nZ\3[\3[\3[\3[\3[\3[",
    "\3[\5[\u049f\n[\5[\u04a1\n[\3\\\3\\\5\\\u04a5\n\\\3\\\3\\\3\\\5\\\u04aa",
    "\n\\\7\\\u04ac\n\\\f\\\16\\\u04af\13\\\3\\\5\\\u04b2\n\\\3]\3]\5]\u04b6",
    "\n]\3]\3]\3^\3^\3^\3^\7^\u04be\n^\f^\16^\u04c1\13^\3^\3^\3^\3^\3^\3",
    "^\3^\7^\u04ca\n^\f^\16^\u04cd\13^\3^\3^\7^\u04d1\n^\f^\16^\u04d4\13",
    "^\5^\u04d6\n^\3_\3_\5_\u04da\n_\3`\3`\3`\3a\3a\3a\3a\3b\3b\3b\5b\u04e6",
    "\nb\3c\3c\3c\5c\u04eb\nc\3d\3d\3d\3d\5d\u04f1\nd\5d\u04f3\nd\3e\3e\3",
    "e\3e\5e\u04f9\ne\3f\3f\5f\u04fd\nf\3f\3f\3f\2\3\u00b0g\2\4\6\b\n\f\16",
    "\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`",
    "bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090",
    "\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8",
    "\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0",
    "\u00c2\u00c4\u00c6\u00c8\u00ca\2\17\6\2  ,,\60\60\63\63\6\2\3\3\24\24",
    "#%()\n\2\5\5\7\7\n\n\20\20\26\26\35\35\37\37\'\'\4\2\23\23**\3\2\65",
    ":\3\2QT\3\2GH\4\2UVZZ\3\2ST\4\2EFLM\4\2KKNN\4\2DD[e\3\2QR\u0573\2\u00cd",
    "\3\2\2\2\4\u00e0\3\2\2\2\6\u00e7\3\2\2\2\b\u010f\3\2\2\2\n\u0113\3\2",
    "\2\2\f\u0117\3\2\2\2\16\u011b\3\2\2\2\20\u011d\3\2\2\2\22\u012c\3\2",
    "\2\2\24\u0137\3\2\2\2\26\u013c\3\2\2\2\30\u0144\3\2\2\2\32\u0156\3\2",
    "\2\2\34\u0161\3\2\2\2\36\u016b\3\2\2\2 \u0172\3\2\2\2\"\u017d\3\2\2",
    "\2$\u0185\3\2\2\2&\u018e\3\2\2\2(\u01a3\3\2\2\2*\u01ae\3\2\2\2,\u01b2",
    "\3\2\2\2.\u01c5\3\2\2\2\60\u01c8\3\2\2\2\62\u01d0\3\2\2\2\64\u01d3\3",
    "\2\2\2\66\u01df\3\2\2\28\u01e8\3\2\2\2:\u01ea\3\2\2\2<\u01f5\3\2\2\2",
    ">\u0202\3\2\2\2@\u0213\3\2\2\2B\u0216\3\2\2\2D\u021e\3\2\2\2F\u0223",
    "\3\2\2\2H\u022d\3\2\2\2J\u022f\3\2\2\2L\u023f\3\2\2\2N\u0251\3\2\2\2",
    "P\u0253\3\2\2\2R\u0261\3\2\2\2T\u0263\3\2\2\2V\u0274\3\2\2\2X\u0276",
    "\3\2\2\2Z\u027e\3\2\2\2\\\u0291\3\2\2\2^\u0296\3\2\2\2`\u029f\3\2\2",
    "\2b\u02a6\3\2\2\2d\u02a8\3\2\2\2f\u02aa\3\2\2\2h\u02b2\3\2\2\2j\u02b4",
    "\3\2\2\2l\u02be\3\2\2\2n\u02c0\3\2\2\2p\u02c8\3\2\2\2r\u02cf\3\2\2\2",
    "t\u02d1\3\2\2\2v\u02e1\3\2\2\2x\u02e6\3\2\2\2z\u02f7\3\2\2\2|\u030d",
    "\3\2\2\2~\u0311\3\2\2\2\u0080\u0313\3\2\2\2\u0082\u0319\3\2\2\2\u0084",
    "\u031b\3\2\2\2\u0086\u031e\3\2\2\2\u0088\u032a\3\2\2\2\u008a\u032c\3",
    "\2\2\2\u008c\u0332\3\2\2\2\u008e\u03a0\3\2\2\2\u0090\u03a2\3\2\2\2\u0092",
    "\u03af\3\2\2\2\u0094\u03b7\3\2\2\2\u0096\u03ba\3\2\2\2\u0098\u03c1\3",
    "\2\2\2\u009a\u03cc\3\2\2\2\u009c\u03d5\3\2\2\2\u009e\u03e8\3\2\2\2\u00a0",
    "\u03f6\3\2\2\2\u00a2\u03fa\3\2\2\2\u00a4\u03ff\3\2\2\2\u00a6\u0407\3",
    "\2\2\2\u00a8\u0409\3\2\2\2\u00aa\u040d\3\2\2\2\u00ac\u0415\3\2\2\2\u00ae",
    "\u0417\3\2\2\2\u00b0\u0426\3\2\2\2\u00b2\u0495\3\2\2\2\u00b4\u04a0\3",
    "\2\2\2\u00b6\u04b1\3\2\2\2\u00b8\u04b3\3\2\2\2\u00ba\u04b9\3\2\2\2\u00bc",
    "\u04d7\3\2\2\2\u00be\u04db\3\2\2\2\u00c0\u04de\3\2\2\2\u00c2\u04e5\3",
    "\2\2\2\u00c4\u04ea\3\2\2\2\u00c6\u04f2\3\2\2\2\u00c8\u04f8\3\2\2\2\u00ca",
    "\u04fa\3\2\2\2\u00cc\u00ce\5\4\3\2\u00cd\u00cc\3\2\2\2\u00cd\u00ce\3",
    "\2\2\2\u00ce\u00d2\3\2\2\2\u00cf\u00d1\5\6\4\2\u00d0\u00cf\3\2\2\2\u00d1",
    "\u00d4\3\2\2\2\u00d2\u00d0\3\2\2\2\u00d2\u00d3\3\2\2\2\u00d3\u00d8\3",
    "\2\2\2\u00d4\u00d2\3\2\2\2\u00d5\u00d7\5\b\5\2\u00d6\u00d5\3\2\2\2\u00d7",
    "\u00da\3\2\2\2\u00d8\u00d6\3\2\2\2\u00d8\u00d9\3\2\2\2\u00d9\u00db\3",
    "\2\2\2\u00da\u00d8\3\2\2\2\u00db\u00dc\7\2\2\3\u00dc\3\3\2\2\2\u00dd",
    "\u00df\5j\66\2\u00de\u00dd\3\2\2\2\u00df\u00e2\3\2\2\2\u00e0\u00de\3",
    "\2\2\2\u00e0\u00e1\3\2\2\2\u00e1\u00e3\3\2\2\2\u00e2\u00e0\3\2\2\2\u00e3",
    "\u00e4\7\"\2\2\u00e4\u00e5\5f\64\2\u00e5\u00e6\7A\2\2\u00e6\5\3\2\2",
    "\2\u00e7\u00e9\7\33\2\2\u00e8\u00ea\7(\2\2\u00e9\u00e8\3\2\2\2\u00e9",
    "\u00ea\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ee\5f\64\2\u00ec\u00ed\7",
    "C\2\2\u00ed\u00ef\7U\2\2\u00ee\u00ec\3\2\2\2\u00ee\u00ef\3\2\2\2\u00ef",
    "\u00f0\3\2\2\2\u00f0\u00f1\7A\2\2\u00f1\7\3\2\2\2\u00f2\u00f4\5\f\7",
    "\2\u00f3\u00f2\3\2\2\2\u00f4\u00f7\3\2\2\2\u00f5\u00f3\3\2\2\2\u00f5",
    "\u00f6\3\2\2\2\u00f6\u00f8\3\2\2\2\u00f7\u00f5\3\2\2\2\u00f8\u0110\5",
    "\20\t\2\u00f9\u00fb\5\f\7\2\u00fa\u00f9\3\2\2\2\u00fb\u00fe\3\2\2\2",
    "\u00fc\u00fa\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u00ff\3\2\2\2\u00fe\u00fc",
    "\3\2\2\2\u00ff\u0110\5\30\r\2\u0100\u0102\5\f\7\2\u0101\u0100\3\2\2",
    "\2\u0102\u0105\3\2\2\2\u0103\u0101\3\2\2\2\u0103\u0104\3\2\2\2\u0104",
    "\u0106\3\2\2\2\u0105\u0103\3\2\2\2\u0106\u0110\5 \21\2\u0107\u0109\5",
    "\f\7\2\u0108\u0107\3\2\2\2\u0109\u010c\3\2\2\2\u010a\u0108\3\2\2\2\u010a",
    "\u010b\3\2\2\2\u010b\u010d\3\2\2\2\u010c\u010a\3\2\2\2\u010d\u0110\5",
    "v<\2\u010e\u0110\7A\2\2\u010f\u00f5\3\2\2\2\u010f\u00fc\3\2\2\2\u010f",
    "\u0103\3\2\2\2\u010f\u010a\3\2\2\2\u010f\u010e\3\2\2\2\u0110\t\3\2\2",
    "\2\u0111\u0114\5\f\7\2\u0112\u0114\t\2\2\2\u0113\u0111\3\2\2\2\u0113",
    "\u0112\3\2\2\2\u0114\13\3\2\2\2\u0115\u0118\5j\66\2\u0116\u0118\t\3",
    "\2\2\u0117\u0115\3\2\2\2\u0117\u0116\3\2\2\2\u0118\r\3\2\2\2\u0119\u011c",
    "\7\24\2\2\u011a\u011c\5j\66\2\u011b\u0119\3\2\2\2\u011b\u011a\3\2\2",
    "\2\u011c\17\3\2\2\2\u011d\u011e\7\13\2\2\u011e\u0120\7f\2\2\u011f\u0121",
    "\5\22\n\2\u0120\u011f\3\2\2\2\u0120\u0121\3\2\2\2\u0121\u0124\3\2\2",
    "\2\u0122\u0123\7\23\2\2\u0123\u0125\5N(\2\u0124\u0122\3\2\2\2\u0124",
    "\u0125\3\2\2\2\u0125\u0128\3\2\2\2\u0126\u0127\7\32\2\2\u0127\u0129",
    "\5\"\22\2\u0128\u0126\3\2\2\2\u0128\u0129\3\2\2\2\u0129\u012a\3\2\2",
    "\2\u012a\u012b\5$\23\2\u012b\21\3\2\2\2\u012c\u012d\7F\2\2\u012d\u0132",
    "\5\24\13\2\u012e\u012f\7B\2\2\u012f\u0131\5\24\13\2\u0130\u012e\3\2",
    "\2\2\u0131\u0134\3\2\2\2\u0132\u0130\3\2\2\2\u0132\u0133\3\2\2\2\u0133",
    "\u0135\3\2\2\2\u0134\u0132\3\2\2\2\u0135\u0136\7E\2\2\u0136\23\3\2\2",
    "\2\u0137\u013a\7f\2\2\u0138\u0139\7\23\2\2\u0139\u013b\5\26\f\2\u013a",
    "\u0138\3\2\2\2\u013a\u013b\3\2\2\2\u013b\25\3\2\2\2\u013c\u0141\5N(",
    "\2\u013d\u013e\7W\2\2\u013e\u0140\5N(\2\u013f\u013d\3\2\2\2\u0140\u0143",
    "\3\2\2\2\u0141\u013f\3\2\2\2\u0141\u0142\3\2\2\2\u0142\27\3\2\2\2\u0143",
    "\u0141\3\2\2\2\u0144\u0145\7\22\2\2\u0145\u0148\7f\2\2\u0146\u0147\7",
    "\32\2\2\u0147\u0149\5\"\22\2\u0148\u0146\3\2\2\2\u0148\u0149\3\2\2\2",
    "\u0149\u014a\3\2\2\2\u014a\u014c\7=\2\2\u014b\u014d\5\32\16\2\u014c",
    "\u014b\3\2\2\2\u014c\u014d\3\2\2\2\u014d\u014f\3\2\2\2\u014e\u0150\7",
    "B\2\2\u014f\u014e\3\2\2\2\u014f\u0150\3\2\2\2\u0150\u0152\3\2\2\2\u0151",
    "\u0153\5\36\20\2\u0152\u0151\3\2\2\2\u0152\u0153\3\2\2\2\u0153\u0154",
    "\3\2\2\2\u0154\u0155\7>\2\2\u0155\31\3\2\2\2\u0156\u015b\5\34\17\2\u0157",
    "\u0158\7B\2\2\u0158\u015a\5\34\17\2\u0159\u0157\3\2\2\2\u015a\u015d",
    "\3\2\2\2\u015b\u0159\3\2\2\2\u015b\u015c\3\2\2\2\u015c\33\3\2\2\2\u015d",
    "\u015b\3\2\2\2\u015e\u0160\5j\66\2\u015f\u015e\3\2\2\2\u0160\u0163\3",
    "\2\2\2\u0161\u015f\3\2\2\2\u0161\u0162\3\2\2\2\u0162\u0164\3\2\2\2\u0163",
    "\u0161\3\2\2\2\u0164\u0166\7f\2\2\u0165\u0167\5\u00caf\2\u0166\u0165",
    "\3\2\2\2\u0166\u0167\3\2\2\2\u0167\u0169\3\2\2\2\u0168\u016a\5$\23\2",
    "\u0169\u0168\3\2\2\2\u0169\u016a\3\2\2\2\u016a\35\3\2\2\2\u016b\u016f",
    "\7A\2\2\u016c\u016e\5(\25\2\u016d\u016c\3\2\2\2\u016e\u0171\3\2\2\2",
    "\u016f\u016d\3\2\2\2\u016f\u0170\3\2\2\2\u0170\37\3\2\2\2\u0171\u016f",
    "\3\2\2\2\u0172\u0173\7\36\2\2\u0173\u0175\7f\2\2\u0174\u0176\5\22\n",
    "\2\u0175\u0174\3\2\2\2\u0175\u0176\3\2\2\2\u0176\u0179\3\2\2\2\u0177",
    "\u0178\7\23\2\2\u0178\u017a\5\"\22\2\u0179\u0177\3\2\2\2\u0179\u017a",
    "\3\2\2\2\u017a\u017b\3\2\2\2\u017b\u017c\5&\24\2\u017c!\3\2\2\2\u017d",
    "\u0182\5N(\2\u017e\u017f\7B\2\2\u017f\u0181\5N(\2\u0180\u017e\3\2\2",
    "\2\u0181\u0184\3\2\2\2\u0182\u0180\3\2\2\2\u0182\u0183\3\2\2\2\u0183",
    "#\3\2\2\2\u0184\u0182\3\2\2\2\u0185\u0189\7=\2\2\u0186\u0188\5(\25\2",
    "\u0187\u0186\3\2\2\2\u0188\u018b\3\2\2\2\u0189\u0187\3\2\2\2\u0189\u018a",
    "\3\2\2\2\u018a\u018c\3\2\2\2\u018b\u0189\3\2\2\2\u018c\u018d\7>\2\2",
    "\u018d%\3\2\2\2\u018e\u0192\7=\2\2\u018f\u0191\5\66\34\2\u0190\u018f",
    "\3\2\2\2\u0191\u0194\3\2\2\2\u0192\u0190\3\2\2\2\u0192\u0193\3\2\2\2",
    "\u0193\u0195\3\2\2\2\u0194\u0192\3\2\2\2\u0195\u0196\7>\2\2\u0196\'",
    "\3\2\2\2\u0197\u01a4\7A\2\2\u0198\u019a\7(\2\2\u0199\u0198\3\2\2\2\u0199",
    "\u019a\3\2\2\2\u019a\u019b\3\2\2\2\u019b\u01a4\5\u0086D\2\u019c\u019e",
    "\5\n\6\2\u019d\u019c\3\2\2\2\u019e\u01a1\3\2\2\2\u019f\u019d\3\2\2\2",
    "\u019f\u01a0\3\2\2\2\u01a0\u01a2\3\2\2\2\u01a1\u019f\3\2\2\2\u01a2\u01a4",
    "\5*\26\2\u01a3\u0197\3\2\2\2\u01a3\u0199\3\2\2\2\u01a3\u019f\3\2\2\2",
    "\u01a4)\3\2\2\2\u01a5\u01af\5,\27\2\u01a6\u01af\5.\30\2\u01a7\u01af",
    "\5\64\33\2\u01a8\u01af\5\60\31\2\u01a9\u01af\5\62\32\2\u01aa\u01af\5",
    " \21\2\u01ab\u01af\5v<\2\u01ac\u01af\5\20\t\2\u01ad\u01af\5\30\r\2\u01ae",
    "\u01a5\3\2\2\2\u01ae\u01a6\3\2\2\2\u01ae\u01a7\3\2\2\2\u01ae\u01a8\3",
    "\2\2\2\u01ae\u01a9\3\2\2\2\u01ae\u01aa\3\2\2\2\u01ae\u01ab\3\2\2\2\u01ae",
    "\u01ac\3\2\2\2\u01ae\u01ad\3\2\2\2\u01af+\3\2\2\2\u01b0\u01b3\5N(\2",
    "\u01b1\u01b3\7\62\2\2\u01b2\u01b0\3\2\2\2\u01b2\u01b1\3\2\2\2\u01b3",
    "\u01b4\3\2\2\2\u01b4\u01b5\7f\2\2\u01b5\u01ba\5Z.\2\u01b6\u01b7\7?\2",
    "\2\u01b7\u01b9\7@\2\2\u01b8\u01b6\3\2\2\2\u01b9\u01bc\3\2\2\2\u01ba",
    "\u01b8\3\2\2\2\u01ba\u01bb\3\2\2\2\u01bb\u01bf\3\2\2\2\u01bc\u01ba\3",
    "\2\2\2\u01bd\u01be\7/\2\2\u01be\u01c0\5X-\2\u01bf\u01bd\3\2\2\2\u01bf",
    "\u01c0\3\2\2\2\u01c0\u01c3\3\2\2\2\u01c1\u01c4\5b\62\2\u01c2\u01c4\7",
    "A\2\2\u01c3\u01c1\3\2\2\2\u01c3\u01c2\3\2\2\2\u01c4-\3\2\2\2\u01c5\u01c6",
    "\5\22\n\2\u01c6\u01c7\5,\27\2\u01c7/\3\2\2\2\u01c8\u01c9\7f\2\2\u01c9",
    "\u01cc\5Z.\2\u01ca\u01cb\7/\2\2\u01cb\u01cd\5X-\2\u01cc\u01ca\3\2\2",
    "\2\u01cc\u01cd\3\2\2\2\u01cd\u01ce\3\2\2\2\u01ce\u01cf\5d\63\2\u01cf",
    "\61\3\2\2\2\u01d0\u01d1\5\22\n\2\u01d1\u01d2\5\60\31\2\u01d2\63\3\2",
    "\2\2\u01d3\u01d4\5N(\2\u01d4\u01d5\5B\"\2\u01d5\u01d6\7A\2\2\u01d6\65",
    "\3\2\2\2\u01d7\u01d9\5\n\6\2\u01d8\u01d7\3\2\2\2\u01d9\u01dc\3\2\2\2",
    "\u01da\u01d8\3\2\2\2\u01da\u01db\3\2\2\2\u01db\u01dd\3\2\2\2\u01dc\u01da",
    "\3\2\2\2\u01dd\u01e0\58\35\2\u01de\u01e0\7A\2\2\u01df\u01da\3\2\2\2",
    "\u01df\u01de\3\2\2\2\u01e0\67\3\2\2\2\u01e1\u01e9\5:\36\2\u01e2\u01e9",
    "\5> \2\u01e3\u01e9\5@!\2\u01e4\u01e9\5 \21\2\u01e5\u01e9\5v<\2\u01e6",
    "\u01e9\5\20\t\2\u01e7\u01e9\5\30\r\2\u01e8\u01e1\3\2\2\2\u01e8\u01e2",
    "\3\2\2\2\u01e8\u01e3\3\2\2\2\u01e8\u01e4\3\2\2\2\u01e8\u01e5\3\2\2\2",
    "\u01e8\u01e6\3\2\2\2\u01e8\u01e7\3\2\2\2\u01e99\3\2\2\2\u01ea\u01eb",
    "\5N(\2\u01eb\u01f0\5<\37\2\u01ec\u01ed\7B\2\2\u01ed\u01ef\5<\37\2\u01ee",
    "\u01ec\3\2\2\2\u01ef\u01f2\3\2\2\2\u01f0\u01ee\3\2\2\2\u01f0\u01f1\3",
    "\2\2\2\u01f1\u01f3\3\2\2\2\u01f2\u01f0\3\2\2\2\u01f3\u01f4\7A\2\2\u01f4",
    ";\3\2\2\2\u01f5\u01fa\7f\2\2\u01f6\u01f7\7?\2\2\u01f7\u01f9\7@\2\2\u01f8",
    "\u01f6\3\2\2\2\u01f9\u01fc\3\2\2\2\u01fa\u01f8\3\2\2\2\u01fa\u01fb\3",
    "\2\2\2\u01fb\u01fd\3\2\2\2\u01fc\u01fa\3\2\2\2\u01fd\u01fe\7D\2\2\u01fe",
    "\u01ff\5H%\2\u01ff=\3\2\2\2\u0200\u0203\5N(\2\u0201\u0203\7\62\2\2\u0202",
    "\u0200\3\2\2\2\u0202\u0201\3\2\2\2\u0203\u0204\3\2\2\2\u0204\u0205\7",
    "f\2\2\u0205\u020a\5Z.\2\u0206\u0207\7?\2\2\u0207\u0209\7@\2\2\u0208",
    "\u0206\3\2\2\2\u0209\u020c\3\2\2\2\u020a\u0208\3\2\2\2\u020a\u020b\3",
    "\2\2\2\u020b\u020f\3\2\2\2\u020c\u020a\3\2\2\2\u020d\u020e\7/\2\2\u020e",
    "\u0210\5X-\2\u020f\u020d\3\2\2\2\u020f\u0210\3\2\2\2\u0210\u0211\3\2",
    "\2\2\u0211\u0212\7A\2\2\u0212?\3\2\2\2\u0213\u0214\5\22\n\2\u0214\u0215",
    "\5> \2\u0215A\3\2\2\2\u0216\u021b\5D#\2\u0217\u0218\7B\2\2\u0218\u021a",
    "\5D#\2\u0219\u0217\3\2\2\2\u021a\u021d\3\2\2\2\u021b\u0219\3\2\2\2\u021b",
    "\u021c\3\2\2\2\u021cC\3\2\2\2\u021d\u021b\3\2\2\2\u021e\u0221\5F$\2",
    "\u021f\u0220\7D\2\2\u0220\u0222\5H%\2\u0221\u021f\3\2\2\2\u0221\u0222",
    "\3\2\2\2\u0222E\3\2\2\2\u0223\u0228\7f\2\2\u0224\u0225\7?\2\2\u0225",
    "\u0227\7@\2\2\u0226\u0224\3\2\2\2\u0227\u022a\3\2\2\2\u0228\u0226\3",
    "\2\2\2\u0228\u0229\3\2\2\2\u0229G\3\2\2\2\u022a\u0228\3\2\2\2\u022b",
    "\u022e\5J&\2\u022c\u022e\5\u00b0Y\2\u022d\u022b\3\2\2\2\u022d\u022c",
    "\3\2\2\2\u022eI\3\2\2\2\u022f\u023b\7=\2\2\u0230\u0235\5H%\2\u0231\u0232",
    "\7B\2\2\u0232\u0234\5H%\2\u0233\u0231\3\2\2\2\u0234\u0237\3\2\2\2\u0235",
    "\u0233\3\2\2\2\u0235\u0236\3\2\2\2\u0236\u0239\3\2\2\2\u0237\u0235\3",
    "\2\2\2\u0238\u023a\7B\2\2\u0239\u0238\3\2\2\2\u0239\u023a\3\2\2\2\u023a",
    "\u023c\3\2\2\2\u023b\u0230\3\2\2\2\u023b\u023c\3\2\2\2\u023c\u023d\3",
    "\2\2\2\u023d\u023e\7>\2\2\u023eK\3\2\2\2\u023f\u0240\7f\2\2\u0240M\3",
    "\2\2\2\u0241\u0246\5P)\2\u0242\u0243\7?\2\2\u0243\u0245\7@\2\2\u0244",
    "\u0242\3\2\2\2\u0245\u0248\3\2\2\2\u0246\u0244\3\2\2\2\u0246\u0247\3",
    "\2\2\2\u0247\u0252\3\2\2\2\u0248\u0246\3\2\2\2\u0249\u024e\5R*\2\u024a",
    "\u024b\7?\2\2\u024b\u024d\7@\2\2\u024c\u024a\3\2\2\2\u024d\u0250\3\2",
    "\2\2\u024e\u024c\3\2\2\2\u024e\u024f\3\2\2\2\u024f\u0252\3\2\2\2\u0250",
    "\u024e\3\2\2\2\u0251\u0241\3\2\2\2\u0251\u0249\3\2\2\2\u0252O\3\2\2",
    "\2\u0253\u0255\7f\2\2\u0254\u0256\5T+\2\u0255\u0254\3\2\2\2\u0255\u0256",
    "\3\2\2\2\u0256\u025e\3\2\2\2\u0257\u0258\7C\2\2\u0258\u025a\7f\2\2\u0259",
    "\u025b\5T+\2\u025a\u0259\3\2\2\2\u025a\u025b\3\2\2\2\u025b\u025d\3\2",
    "\2\2\u025c\u0257\3\2\2\2\u025d\u0260\3\2\2\2\u025e\u025c\3\2\2\2\u025e",
    "\u025f\3\2\2\2\u025fQ\3\2\2\2\u0260\u025e\3\2\2\2\u0261\u0262\t\4\2",
    "\2\u0262S\3\2\2\2\u0263\u0264\7F\2\2\u0264\u0269\5V,\2\u0265\u0266\7",
    "B\2\2\u0266\u0268\5V,\2\u0267\u0265\3\2\2\2\u0268\u026b\3\2\2\2\u0269",
    "\u0267\3\2\2\2\u0269\u026a\3\2\2\2\u026a\u026c\3\2\2\2\u026b\u0269\3",
    "\2\2\2\u026c\u026d\7E\2\2\u026dU\3\2\2\2\u026e\u0275\5N(\2\u026f\u0272",
    "\7I\2\2\u0270\u0271\t\5\2\2\u0271\u0273\5N(\2\u0272\u0270\3\2\2\2\u0272",
    "\u0273\3\2\2\2\u0273\u0275\3\2\2\2\u0274\u026e\3\2\2\2\u0274\u026f\3",
    "\2\2\2\u0275W\3\2\2\2\u0276\u027b\5f\64\2\u0277\u0278\7B\2\2\u0278\u027a",
    "\5f\64\2\u0279\u0277\3\2\2\2\u027a\u027d\3\2\2\2\u027b\u0279\3\2\2\2",
    "\u027b\u027c\3\2\2\2\u027cY\3\2\2\2\u027d\u027b\3\2\2\2\u027e\u0280",
    "\7;\2\2\u027f\u0281\5\\/\2\u0280\u027f\3\2\2\2\u0280\u0281\3\2\2\2\u0281",
    "\u0282\3\2\2\2\u0282\u0283\7<\2\2\u0283[\3\2\2\2\u0284\u0289\5^\60\2",
    "\u0285\u0286\7B\2\2\u0286\u0288\5^\60\2\u0287\u0285\3\2\2\2\u0288\u028b",
    "\3\2\2\2\u0289\u0287\3\2\2\2\u0289\u028a\3\2\2\2\u028a\u028e\3\2\2\2",
    "\u028b\u0289\3\2\2\2\u028c\u028d\7B\2\2\u028d\u028f\5`\61\2\u028e\u028c",
    "\3\2\2\2\u028e\u028f\3\2\2\2\u028f\u0292\3\2\2\2\u0290\u0292\5`\61\2",
    "\u0291\u0284\3\2\2\2\u0291\u0290\3\2\2\2\u0292]\3\2\2\2\u0293\u0295",
    "\5\16\b\2\u0294\u0293\3\2\2\2\u0295\u0298\3\2\2\2\u0296\u0294\3\2\2",
    "\2\u0296\u0297\3\2\2\2\u0297\u0299\3\2\2\2\u0298\u0296\3\2\2\2\u0299",
    "\u029a\5N(\2\u029a\u029b\5F$\2\u029b_\3\2\2\2\u029c\u029e\5\16\b\2\u029d",
    "\u029c\3\2\2\2\u029e\u02a1\3\2\2\2\u029f\u029d\3\2\2\2\u029f\u02a0\3",
    "\2\2\2\u02a0\u02a2\3\2\2\2\u02a1\u029f\3\2\2\2\u02a2\u02a3\5N(\2\u02a3",
    "\u02a4\7h\2\2\u02a4\u02a5\5F$\2\u02a5a\3\2\2\2\u02a6\u02a7\5\u0086D",
    "\2\u02a7c\3\2\2\2\u02a8\u02a9\5\u0086D\2\u02a9e\3\2\2\2\u02aa\u02af",
    "\7f\2\2\u02ab\u02ac\7C\2\2\u02ac\u02ae\7f\2\2\u02ad\u02ab\3\2\2\2\u02ae",
    "\u02b1\3\2\2\2\u02af\u02ad\3\2\2\2\u02af\u02b0\3\2\2\2\u02b0g\3\2\2",
    "\2\u02b1\u02af\3\2\2\2\u02b2\u02b3\t\6\2\2\u02b3i\3\2\2\2\u02b4\u02b5",
    "\7g\2\2\u02b5\u02bc\5l\67\2\u02b6\u02b9\7;\2\2\u02b7\u02ba\5n8\2\u02b8",
    "\u02ba\5r:\2\u02b9\u02b7\3\2\2\2\u02b9\u02b8\3\2\2\2\u02b9\u02ba\3\2",
    "\2\2\u02ba\u02bb\3\2\2\2\u02bb\u02bd\7<\2\2\u02bc\u02b6\3\2\2\2\u02bc",
    "\u02bd\3\2\2\2\u02bdk\3\2\2\2\u02be\u02bf\5f\64\2\u02bfm\3\2\2\2\u02c0",
    "\u02c5\5p9\2\u02c1\u02c2\7B\2\2\u02c2\u02c4\5p9\2\u02c3\u02c1\3\2\2",
    "\2\u02c4\u02c7\3\2\2\2\u02c5\u02c3\3\2\2\2\u02c5\u02c6\3\2\2\2\u02c6",
    "o\3\2\2\2\u02c7\u02c5\3\2\2\2\u02c8\u02c9\7f\2\2\u02c9\u02ca\7D\2\2",
    "\u02ca\u02cb\5r:\2\u02cbq\3\2\2\2\u02cc\u02d0\5\u00b0Y\2\u02cd\u02d0",
    "\5j\66\2\u02ce\u02d0\5t;\2\u02cf\u02cc\3\2\2\2\u02cf\u02cd\3\2\2\2\u02cf",
    "\u02ce\3\2\2\2\u02d0s\3\2\2\2\u02d1\u02da\7=\2\2\u02d2\u02d7\5r:\2\u02d3",
    "\u02d4\7B\2\2\u02d4\u02d6\5r:\2\u02d5\u02d3\3\2\2\2\u02d6\u02d9\3\2",
    "\2\2\u02d7\u02d5\3\2\2\2\u02d7\u02d8\3\2\2\2\u02d8\u02db\3\2\2\2\u02d9",
    "\u02d7\3\2\2\2\u02da\u02d2\3\2\2\2\u02da\u02db\3\2\2\2\u02db\u02dd\3",
    "\2\2\2\u02dc\u02de\7B\2\2\u02dd\u02dc\3\2\2\2\u02dd\u02de\3\2\2\2\u02de",
    "\u02df\3\2\2\2\u02df\u02e0\7>\2\2\u02e0u\3\2\2\2\u02e1\u02e2\7g\2\2",
    "\u02e2\u02e3\7\36\2\2\u02e3\u02e4\7f\2\2\u02e4\u02e5\5x=\2\u02e5w\3",
    "\2\2\2\u02e6\u02ea\7=\2\2\u02e7\u02e9\5z>\2\u02e8\u02e7\3\2\2\2\u02e9",
    "\u02ec\3\2\2\2\u02ea\u02e8\3\2\2\2\u02ea\u02eb\3\2\2\2\u02eb\u02ed\3",
    "\2\2\2\u02ec\u02ea\3\2\2\2\u02ed\u02ee\7>\2\2\u02eey\3\2\2\2\u02ef\u02f1",
    "\5\n\6\2\u02f0\u02ef\3\2\2\2\u02f1\u02f4\3\2\2\2\u02f2\u02f0\3\2\2\2",
    "\u02f2\u02f3\3\2\2\2\u02f3\u02f5\3\2\2\2\u02f4\u02f2\3\2\2\2\u02f5\u02f8",
    "\5|?\2\u02f6\u02f8\7A\2\2\u02f7\u02f2\3\2\2\2\u02f7\u02f6\3\2\2\2\u02f8",
    "{\3\2\2\2\u02f9\u02fa\5N(\2\u02fa\u02fb\5~@\2\u02fb\u02fc\7A\2\2\u02fc",
    "\u030e\3\2\2\2\u02fd\u02ff\5\20\t\2\u02fe\u0300\7A\2\2\u02ff\u02fe\3",
    "\2\2\2\u02ff\u0300\3\2\2\2\u0300\u030e\3\2\2\2\u0301\u0303\5 \21\2\u0302",
    "\u0304\7A\2\2\u0303\u0302\3\2\2\2\u0303\u0304\3\2\2\2\u0304\u030e\3",
    "\2\2\2\u0305\u0307\5\30\r\2\u0306\u0308\7A\2\2\u0307\u0306\3\2\2\2\u0307",
    "\u0308\3\2\2\2\u0308\u030e\3\2\2\2\u0309\u030b\5v<\2\u030a\u030c\7A",
    "\2\2\u030b\u030a\3\2\2\2\u030b\u030c\3\2\2\2\u030c\u030e\3\2\2\2\u030d",
    "\u02f9\3\2\2\2\u030d\u02fd\3\2\2\2\u030d\u0301\3\2\2\2\u030d\u0305\3",
    "\2\2\2\u030d\u0309\3\2\2\2\u030e}\3\2\2\2\u030f\u0312\5\u0080A\2\u0310",
    "\u0312\5\u0082B\2\u0311\u030f\3\2\2\2\u0311\u0310\3\2\2\2\u0312\177",
    "\3\2\2\2\u0313\u0314\7f\2\2\u0314\u0315\7;\2\2\u0315\u0317\7<\2\2\u0316",
    "\u0318\5\u0084C\2\u0317\u0316\3\2\2\2\u0317\u0318\3\2\2\2\u0318\u0081",
    "\3\2\2\2\u0319\u031a\5B\"\2\u031a\u0083\3\2\2\2\u031b\u031c\7\16\2\2",
    "\u031c\u031d\5r:\2\u031d\u0085\3\2\2\2\u031e\u0322\7=\2\2\u031f\u0321",
    "\5\u0088E\2\u0320\u031f\3\2\2\2\u0321\u0324\3\2\2\2\u0322\u0320\3\2",
    "\2\2\u0322\u0323\3\2\2\2\u0323\u0325\3\2\2\2\u0324\u0322\3\2\2\2\u0325",
    "\u0326\7>\2\2\u0326\u0087\3\2\2\2\u0327\u032b\5\u008aF\2\u0328\u032b",
    "\5\u008eH\2\u0329\u032b\5\b\5\2\u032a\u0327\3\2\2\2\u032a\u0328\3\2",
    "\2\2\u032a\u0329\3\2\2\2\u032b\u0089\3\2\2\2\u032c\u032d\5\u008cG\2",
    "\u032d\u032e\7A\2\2\u032e\u008b\3\2\2\2\u032f\u0331\5\16\b\2\u0330\u032f",
    "\3\2\2\2\u0331\u0334\3\2\2\2\u0332\u0330\3\2\2\2\u0332\u0333\3\2\2\2",
    "\u0333\u0335\3\2\2\2\u0334\u0332\3\2\2\2\u0335\u0336\5N(\2\u0336\u0337",
    "\5B\"\2\u0337\u008d\3\2\2\2\u0338\u03a1\5\u0086D\2\u0339\u033a\7\4\2",
    "\2\u033a\u033d\5\u00b0Y\2\u033b\u033c\7J\2\2\u033c\u033e\5\u00b0Y\2",
    "\u033d\u033b\3\2\2\2\u033d\u033e\3\2\2\2\u033e\u033f\3\2\2\2\u033f\u0340",
    "\7A\2\2\u0340\u03a1\3\2\2\2\u0341\u0342\7\30\2\2\u0342\u0343\5\u00a8",
    "U\2\u0343\u0346\5\u008eH\2\u0344\u0345\7\21\2\2\u0345\u0347\5\u008e",
    "H\2\u0346\u0344\3\2\2\2\u0346\u0347\3\2\2\2\u0347\u03a1\3\2\2\2\u0348",
    "\u0349\7\27\2\2\u0349\u034a\7;\2\2\u034a\u034b\5\u00a0Q\2\u034b\u034c",
    "\7<\2\2\u034c\u034d\5\u008eH\2\u034d\u03a1\3\2\2\2\u034e\u034f\7\64",
    "\2\2\u034f\u0350\5\u00a8U\2\u0350\u0351\5\u008eH\2\u0351\u03a1\3\2\2",
    "\2\u0352\u0353\7\17\2\2\u0353\u0354\5\u008eH\2\u0354\u0355\7\64\2\2",
    "\u0355\u0356\5\u00a8U\2\u0356\u0357\7A\2\2\u0357\u03a1\3\2\2\2\u0358",
    "\u0359\7\61\2\2\u0359\u0363\5\u0086D\2\u035a\u035c\5\u0090I\2\u035b",
    "\u035a\3\2\2\2\u035c\u035d\3\2\2\2\u035d\u035b\3\2\2\2\u035d\u035e\3",
    "\2\2\2\u035e\u0360\3\2\2\2\u035f\u0361\5\u0094K\2\u0360\u035f\3\2\2",
    "\2\u0360\u0361\3\2\2\2\u0361\u0364\3\2\2\2\u0362\u0364\5\u0094K\2\u0363",
    "\u035b\3\2\2\2\u0363\u0362\3\2\2\2\u0364\u03a1\3\2\2\2\u0365\u0366\7",
    "\61\2\2\u0366\u0367\5\u0096L\2\u0367\u036b\5\u0086D\2\u0368\u036a\5",
    "\u0090I\2\u0369\u0368\3\2\2\2\u036a\u036d\3\2\2\2\u036b\u0369\3\2\2",
    "\2\u036b\u036c\3\2\2\2\u036c\u036f\3\2\2\2\u036d\u036b\3\2\2\2\u036e",
    "\u0370\5\u0094K\2\u036f\u036e\3\2\2\2\u036f\u0370\3\2\2\2\u0370\u03a1",
    "\3\2\2\2\u0371\u0372\7+\2\2\u0372\u0373\5\u00a8U\2\u0373\u0377\7=\2",
    "\2\u0374\u0376\5\u009cO\2\u0375\u0374\3\2\2\2\u0376\u0379\3\2\2\2\u0377",
    "\u0375\3\2\2\2\u0377\u0378\3\2\2\2\u0378\u037d\3\2\2\2\u0379\u0377\3",
    "\2\2\2\u037a\u037c\5\u009eP\2\u037b\u037a\3\2\2\2\u037c\u037f\3\2\2",
    "\2\u037d\u037b\3\2\2\2\u037d\u037e\3\2\2\2\u037e\u0380\3\2\2\2\u037f",
    "\u037d\3\2\2\2\u0380\u0381\7>\2\2\u0381\u03a1\3\2\2\2\u0382\u0383\7",
    ",\2\2\u0383\u0384\5\u00a8U\2\u0384\u0385\5\u0086D\2\u0385\u03a1\3\2",
    "\2\2\u0386\u0388\7&\2\2\u0387\u0389\5\u00b0Y\2\u0388\u0387\3\2\2\2\u0388",
    "\u0389\3\2\2\2\u0389\u038a\3\2\2\2\u038a\u03a1\7A\2\2\u038b\u038c\7",
    ".\2\2\u038c\u038d\5\u00b0Y\2\u038d\u038e\7A\2\2\u038e\u03a1\3\2\2\2",
    "\u038f\u0391\7\6\2\2\u0390\u0392\7f\2\2\u0391\u0390\3\2\2\2\u0391\u0392",
    "\3\2\2\2\u0392\u0393\3\2\2\2\u0393\u03a1\7A\2\2\u0394\u0396\7\r\2\2",
    "\u0395\u0397\7f\2\2\u0396\u0395\3\2\2\2\u0396\u0397\3\2\2\2\u0397\u0398",
    "\3\2\2\2\u0398\u03a1\7A\2\2\u0399\u03a1\7A\2\2\u039a\u039b\5\u00acW",
    "\2\u039b\u039c\7A\2\2\u039c\u03a1\3\2\2\2\u039d\u039e\7f\2\2\u039e\u039f",
    "\7J\2\2\u039f\u03a1\5\u008eH\2\u03a0\u0338\3\2\2\2\u03a0\u0339\3\2\2",
    "\2\u03a0\u0341\3\2\2\2\u03a0\u0348\3\2\2\2\u03a0\u034e\3\2\2\2\u03a0",
    "\u0352\3\2\2\2\u03a0\u0358\3\2\2\2\u03a0\u0365\3\2\2\2\u03a0\u0371\3",
    "\2\2\2\u03a0\u0382\3\2\2\2\u03a0\u0386\3\2\2\2\u03a0\u038b\3\2\2\2\u03a0",
    "\u038f\3\2\2\2\u03a0\u0394\3\2\2\2\u03a0\u0399\3\2\2\2\u03a0\u039a\3",
    "\2\2\2\u03a0\u039d\3\2\2\2\u03a1\u008f\3\2\2\2\u03a2\u03a3\7\t\2\2\u03a3",
    "\u03a7\7;\2\2\u03a4\u03a6\5\16\b\2\u03a5\u03a4\3\2\2\2\u03a6\u03a9\3",
    "\2\2\2\u03a7\u03a5\3\2\2\2\u03a7\u03a8\3\2\2\2\u03a8\u03aa\3\2\2\2\u03a9",
    "\u03a7\3\2\2\2\u03aa\u03ab\5\u0092J\2\u03ab\u03ac\7f\2\2\u03ac\u03ad",
    "\7<\2\2\u03ad\u03ae\5\u0086D\2\u03ae\u0091\3\2\2\2\u03af\u03b4\5f\64",
    "\2\u03b0\u03b1\7X\2\2\u03b1\u03b3\5f\64\2\u03b2\u03b0\3\2\2\2\u03b3",
    "\u03b6\3\2\2\2\u03b4\u03b2\3\2\2\2\u03b4\u03b5\3\2\2\2\u03b5\u0093\3",
    "\2\2\2\u03b6\u03b4\3\2\2\2\u03b7\u03b8\7\25\2\2\u03b8\u03b9\5\u0086",
    "D\2\u03b9\u0095\3\2\2\2\u03ba\u03bb\7;\2\2\u03bb\u03bd\5\u0098M\2\u03bc",
    "\u03be\7A\2\2\u03bd\u03bc\3\2\2\2\u03bd\u03be\3\2\2\2\u03be\u03bf\3",
    "\2\2\2\u03bf\u03c0\7<\2\2\u03c0\u0097\3\2\2\2\u03c1\u03c6\5\u009aN\2",
    "\u03c2\u03c3\7A\2\2\u03c3\u03c5\5\u009aN\2\u03c4\u03c2\3\2\2\2\u03c5",
    "\u03c8\3\2\2\2\u03c6\u03c4\3\2\2\2\u03c6\u03c7\3\2\2\2\u03c7\u0099\3",
    "\2\2\2\u03c8\u03c6\3\2\2\2\u03c9\u03cb\5\16\b\2\u03ca\u03c9\3\2\2\2",
    "\u03cb\u03ce\3\2\2\2\u03cc\u03ca\3\2\2\2\u03cc\u03cd\3\2\2\2\u03cd\u03cf",
    "\3\2\2\2\u03ce\u03cc\3\2\2\2\u03cf\u03d0\5P)\2\u03d0\u03d1\5F$\2\u03d1",
    "\u03d2\7D\2\2\u03d2\u03d3\5\u00b0Y\2\u03d3\u009b\3\2\2\2\u03d4\u03d6",
    "\5\u009eP\2\u03d5\u03d4\3\2\2\2\u03d6\u03d7\3\2\2\2\u03d7\u03d5\3\2",
    "\2\2\u03d7\u03d8\3\2\2\2\u03d8\u03da\3\2\2\2\u03d9\u03db\5\u0088E\2",
    "\u03da\u03d9\3\2\2\2\u03db\u03dc\3\2\2\2\u03dc\u03da\3\2\2\2\u03dc\u03dd",
    "\3\2\2\2\u03dd\u009d\3\2\2\2\u03de\u03df\7\b\2\2\u03df\u03e0\5\u00ae",
    "X\2\u03e0\u03e1\7J\2\2\u03e1\u03e9\3\2\2\2\u03e2\u03e3\7\b\2\2\u03e3",
    "\u03e4\5L\'\2\u03e4\u03e5\7J\2\2\u03e5\u03e9\3\2\2\2\u03e6\u03e7\7\16",
    "\2\2\u03e7\u03e9\7J\2\2\u03e8\u03de\3\2\2\2\u03e8\u03e2\3\2\2\2\u03e8",
    "\u03e6\3\2\2\2\u03e9\u009f\3\2\2\2\u03ea\u03f7\5\u00a4S\2\u03eb\u03ed",
    "\5\u00a2R\2\u03ec\u03eb\3\2\2\2\u03ec\u03ed\3\2\2\2\u03ed\u03ee\3\2",
    "\2\2\u03ee\u03f0\7A\2\2\u03ef\u03f1\5\u00b0Y\2\u03f0\u03ef\3\2\2\2\u03f0",
    "\u03f1\3\2\2\2\u03f1\u03f2\3\2\2\2\u03f2\u03f4\7A\2\2\u03f3\u03f5\5",
    "\u00a6T\2\u03f4\u03f3\3\2\2\2\u03f4\u03f5\3\2\2\2\u03f5\u03f7\3\2\2",
    "\2\u03f6\u03ea\3\2\2\2\u03f6\u03ec\3\2\2\2\u03f7\u00a1\3\2\2\2\u03f8",
    "\u03fb\5\u008cG\2\u03f9\u03fb\5\u00aaV\2\u03fa\u03f8\3\2\2\2\u03fa\u03f9",
    "\3\2\2\2\u03fb\u00a3\3\2\2\2\u03fc\u03fe\5\16\b\2\u03fd\u03fc\3\2\2",
    "\2\u03fe\u0401\3\2\2\2\u03ff\u03fd\3\2\2\2\u03ff\u0400\3\2\2\2\u0400",
    "\u0402\3\2\2\2\u0401\u03ff\3\2\2\2\u0402\u0403\5N(\2\u0403\u0404\5F",
    "$\2\u0404\u0405\7J\2\2\u0405\u0406\5\u00b0Y\2\u0406\u00a5\3\2\2\2\u0407",
    "\u0408\5\u00aaV\2\u0408\u00a7\3\2\2\2\u0409\u040a\7;\2\2\u040a\u040b",
    "\5\u00b0Y\2\u040b\u040c\7<\2\2\u040c\u00a9\3\2\2\2\u040d\u0412\5\u00b0",
    "Y\2\u040e\u040f\7B\2\2\u040f\u0411\5\u00b0Y\2\u0410\u040e\3\2\2\2\u0411",
    "\u0414\3\2\2\2\u0412\u0410\3\2\2\2\u0412\u0413\3\2\2\2\u0413\u00ab\3",
    "\2\2\2\u0414\u0412\3\2\2\2\u0415\u0416\5\u00b0Y\2\u0416\u00ad\3\2\2",
    "\2\u0417\u0418\5\u00b0Y\2\u0418\u00af\3\2\2\2\u0419\u041a\bY\1\2\u041a",
    "\u041b\7;\2\2\u041b\u041c\5N(\2\u041c\u041d\7<\2\2\u041d\u041e\5\u00b0",
    "Y\23\u041e\u0427\3\2\2\2\u041f\u0420\t\7\2\2\u0420\u0427\5\u00b0Y\21",
    "\u0421\u0422\t\b\2\2\u0422\u0427\5\u00b0Y\20\u0423\u0427\5\u00b2Z\2",
    "\u0424\u0425\7!\2\2\u0425\u0427\5\u00b4[\2\u0426\u0419\3\2\2\2\u0426",
    "\u041f\3\2\2\2\u0426\u0421\3\2\2\2\u0426\u0423\3\2\2\2\u0426\u0424\3",
    "\2\2\2\u0427\u047d\3\2\2\2\u0428\u0429\f\17\2\2\u0429\u042a\t\t\2\2",
    "\u042a\u047c\5\u00b0Y\20\u042b\u042c\f\16\2\2\u042c\u042d\t\n\2\2\u042d",
    "\u047c\5\u00b0Y\17\u042e\u0436\f\r\2\2\u042f\u0430\7F\2\2\u0430\u0437",
    "\7F\2\2\u0431\u0432\7E\2\2\u0432\u0433\7E\2\2\u0433\u0437\7E\2\2\u0434",
    "\u0435\7E\2\2\u0435\u0437\7E\2\2\u0436\u042f\3\2\2\2\u0436\u0431\3\2",
    "\2\2\u0436\u0434\3\2\2\2\u0437\u0438\3\2\2\2\u0438\u047c\5\u00b0Y\16",
    "\u0439\u043a\f\f\2\2\u043a\u043b\t\13\2\2\u043b\u047c\5\u00b0Y\r\u043c",
    "\u043d\f\n\2\2\u043d\u043e\t\f\2\2\u043e\u047c\5\u00b0Y\13\u043f\u0440",
    "\f\t\2\2\u0440\u0441\7W\2\2\u0441\u047c\5\u00b0Y\n\u0442\u0443\f\b\2",
    "\2\u0443\u0444\7Y\2\2\u0444\u047c\5\u00b0Y\t\u0445\u0446\f\7\2\2\u0446",
    "\u0447\7X\2\2\u0447\u047c\5\u00b0Y\b\u0448\u0449\f\6\2\2\u0449\u044a",
    "\7O\2\2\u044a\u047c\5\u00b0Y\7\u044b\u044c\f\5\2\2\u044c\u044d\7P\2",
    "\2\u044d\u047c\5\u00b0Y\6\u044e\u044f\f\4\2\2\u044f\u0450\7I\2\2\u0450",
    "\u0451\5\u00b0Y\2\u0451\u0452\7J\2\2\u0452\u0453\5\u00b0Y\5\u0453\u047c",
    "\3\2\2\2\u0454\u0455\f\3\2\2\u0455\u0456\t\r\2\2\u0456\u047c\5\u00b0",
    "Y\3\u0457\u0458\f\33\2\2\u0458\u0459\7C\2\2\u0459\u047c\7f\2\2\u045a",
    "\u045b\f\32\2\2\u045b\u045c\7C\2\2\u045c\u047c\7-\2\2\u045d\u045e\f",
    "\31\2\2\u045e\u045f\7C\2\2\u045f\u0461\7!\2\2\u0460\u0462\5\u00c0a\2",
    "\u0461\u0460\3\2\2\2\u0461\u0462\3\2\2\2\u0462\u0463\3\2\2\2\u0463\u047c",
    "\5\u00b8]\2\u0464\u0465\f\30\2\2\u0465\u0466\7C\2\2\u0466\u0467\7*\2",
    "\2\u0467\u047c\5\u00c6d\2\u0468\u0469\f\27\2\2\u0469\u046a\7C\2\2\u046a",
    "\u047c\5\u00be`\2\u046b\u046c\f\26\2\2\u046c\u046d\7?\2\2\u046d\u046e",
    "\5\u00b0Y\2\u046e\u046f\7@\2\2\u046f\u047c\3\2\2\2\u0470\u0471\f\25",
    "\2\2\u0471\u0473\7;\2\2\u0472\u0474\5\u00aaV\2\u0473\u0472\3\2\2\2\u0473",
    "\u0474\3\2\2\2\u0474\u0475\3\2\2\2\u0475\u047c\7<\2\2\u0476\u0477\f",
    "\22\2\2\u0477\u047c\t\16\2\2\u0478\u0479\f\13\2\2\u0479\u047a\7\34\2",
    "\2\u047a\u047c\5N(\2\u047b\u0428\3\2\2\2\u047b\u042b\3\2\2\2\u047b\u042e",
    "\3\2\2\2\u047b\u0439\3\2\2\2\u047b\u043c\3\2\2\2\u047b\u043f\3\2\2\2",
    "\u047b\u0442\3\2\2\2\u047b\u0445\3\2\2\2\u047b\u0448\3\2\2\2\u047b\u044b",
    "\3\2\2\2\u047b\u044e\3\2\2\2\u047b\u0454\3\2\2\2\u047b\u0457\3\2\2\2",
    "\u047b\u045a\3\2\2\2\u047b\u045d\3\2\2\2\u047b\u0464\3\2\2\2\u047b\u0468",
    "\3\2\2\2\u047b\u046b\3\2\2\2\u047b\u0470\3\2\2\2\u047b\u0476\3\2\2\2",
    "\u047b\u0478\3\2\2\2\u047c\u047f\3\2\2\2\u047d\u047b\3\2\2\2\u047d\u047e",
    "\3\2\2\2\u047e\u00b1\3\2\2\2\u047f\u047d\3\2\2\2\u0480\u0481\7;\2\2",
    "\u0481\u0482\5\u00b0Y\2\u0482\u0483\7<\2\2\u0483\u0496\3\2\2\2\u0484",
    "\u0496\7-\2\2\u0485\u0496\7*\2\2\u0486\u0496\5h\65\2\u0487\u0496\7f",
    "\2\2\u0488\u0489\5N(\2\u0489\u048a\7C\2\2\u048a\u048b\7\13\2\2\u048b",
    "\u0496\3\2\2\2\u048c\u048d\7\62\2\2\u048d\u048e\7C\2\2\u048e\u0496\7",
    "\13\2\2\u048f\u0493\5\u00c0a\2\u0490\u0494\5\u00c8e\2\u0491\u0492\7",
    "-\2\2\u0492\u0494\5\u00caf\2\u0493\u0490\3\2\2\2\u0493\u0491\3\2\2\2",
    "\u0494\u0496\3\2\2\2\u0495\u0480\3\2\2\2\u0495\u0484\3\2\2\2\u0495\u0485",
    "\3\2\2\2\u0495\u0486\3\2\2\2\u0495\u0487\3\2\2\2\u0495\u0488\3\2\2\2",
    "\u0495\u048c\3\2\2\2\u0495\u048f\3\2\2\2\u0496\u00b3\3\2\2\2\u0497\u0498",
    "\5\u00c0a\2\u0498\u0499\5\u00b6\\\2\u0499\u049a\5\u00bc_\2\u049a\u04a1",
    "\3\2\2\2\u049b\u049e\5\u00b6\\\2\u049c\u049f\5\u00ba^\2\u049d\u049f",
    "\5\u00bc_\2\u049e\u049c\3\2\2\2\u049e\u049d\3\2\2\2\u049f\u04a1\3\2",
    "\2\2\u04a0\u0497\3\2\2\2\u04a0\u049b\3\2\2\2\u04a1\u00b5\3\2\2\2\u04a2",
    "\u04a4\7f\2\2\u04a3\u04a5\5\u00c2b\2\u04a4\u04a3\3\2\2\2\u04a4\u04a5",
    "\3\2\2\2\u04a5\u04ad\3\2\2\2\u04a6\u04a7\7C\2\2\u04a7\u04a9\7f\2\2\u04a8",
    "\u04aa\5\u00c2b\2\u04a9\u04a8\3\2\2\2\u04a9\u04aa\3\2\2\2\u04aa\u04ac",
    "\3\2\2\2\u04ab\u04a6\3\2\2\2\u04ac\u04af\3\2\2\2\u04ad\u04ab\3\2\2\2",
    "\u04ad\u04ae\3\2\2\2\u04ae\u04b2\3\2\2\2\u04af\u04ad\3\2\2\2\u04b0\u04b2",
    "\5R*\2\u04b1\u04a2\3\2\2\2\u04b1\u04b0\3\2\2\2\u04b2\u00b7\3\2\2\2\u04b3",
    "\u04b5\7f\2\2\u04b4\u04b6\5\u00c4c\2\u04b5\u04b4\3\2\2\2\u04b5\u04b6",
    "\3\2\2\2\u04b6\u04b7\3\2\2\2\u04b7\u04b8\5\u00bc_\2\u04b8\u00b9\3\2",
    "\2\2\u04b9\u04d5\7?\2\2\u04ba\u04bf\7@\2\2\u04bb\u04bc\7?\2\2\u04bc",
    "\u04be\7@\2\2\u04bd\u04bb\3\2\2\2\u04be\u04c1\3\2\2\2\u04bf\u04bd\3",
    "\2\2\2\u04bf\u04c0\3\2\2\2\u04c0\u04c2\3\2\2\2\u04c1\u04bf\3\2\2\2\u04c2",
    "\u04d6\5J&\2\u04c3\u04c4\5\u00b0Y\2\u04c4\u04cb\7@\2\2\u04c5\u04c6\7",
    "?\2\2\u04c6\u04c7\5\u00b0Y\2\u04c7\u04c8\7@\2\2\u04c8\u04ca\3\2\2\2",
    "\u04c9\u04c5\3\2\2\2\u04ca\u04cd\3\2\2\2\u04cb\u04c9\3\2\2\2\u04cb\u04cc",
    "\3\2\2\2\u04cc\u04d2\3\2\2\2\u04cd\u04cb\3\2\2\2\u04ce\u04cf\7?\2\2",
    "\u04cf\u04d1\7@\2\2\u04d0\u04ce\3\2\2\2\u04d1\u04d4\3\2\2\2\u04d2\u04d0",
    "\3\2\2\2\u04d2\u04d3\3\2\2\2\u04d3\u04d6\3\2\2\2\u04d4\u04d2\3\2\2\2",
    "\u04d5\u04ba\3\2\2\2\u04d5\u04c3\3\2\2\2\u04d6\u00bb\3\2\2\2\u04d7\u04d9",
    "\5\u00caf\2\u04d8\u04da\5$\23\2\u04d9\u04d8\3\2\2\2\u04d9\u04da\3\2",
    "\2\2\u04da\u00bd\3\2\2\2\u04db\u04dc\5\u00c0a\2\u04dc\u04dd\5\u00c8",
    "e\2\u04dd\u00bf\3\2\2\2\u04de\u04df\7F\2\2\u04df\u04e0\5\"\22\2\u04e0",
    "\u04e1\7E\2\2\u04e1\u00c1\3\2\2\2\u04e2\u04e3\7F\2\2\u04e3\u04e6\7E",
    "\2\2\u04e4\u04e6\5T+\2\u04e5\u04e2\3\2\2\2\u04e5\u04e4\3\2\2\2\u04e6",
    "\u00c3\3\2\2\2\u04e7\u04e8\7F\2\2\u04e8\u04eb\7E\2\2\u04e9\u04eb\5\u00c0",
    "a\2\u04ea\u04e7\3\2\2\2\u04ea\u04e9\3\2\2\2\u04eb\u00c5\3\2\2\2\u04ec",
    "\u04f3\5\u00caf\2\u04ed\u04ee\7C\2\2\u04ee\u04f0\7f\2\2\u04ef\u04f1",
    "\5\u00caf\2\u04f0\u04ef\3\2\2\2\u04f0\u04f1\3\2\2\2\u04f1\u04f3\3\2",
    "\2\2\u04f2\u04ec\3\2\2\2\u04f2\u04ed\3\2\2\2\u04f3\u00c7\3\2\2\2\u04f4",
    "\u04f5\7*\2\2\u04f5\u04f9\5\u00c6d\2\u04f6\u04f7\7f\2\2\u04f7\u04f9",
    "\5\u00caf\2\u04f8\u04f4\3\2\2\2\u04f8\u04f6\3\2\2\2\u04f9\u00c9\3\2",
    "\2\2\u04fa\u04fc\7;\2\2\u04fb\u04fd\5\u00aaV\2\u04fc\u04fb\3\2\2\2\u04fc",
    "\u04fd\3\2\2\2\u04fd\u04fe\3\2\2\2\u04fe\u04ff\7<\2\2\u04ff\u00cb\3",
    "\2\2\2\u0097\u00cd\u00d2\u00d8\u00e0\u00e9\u00ee\u00f5\u00fc\u0103\u010a",
    "\u010f\u0113\u0117\u011b\u0120\u0124\u0128\u0132\u013a\u0141\u0148\u014c",
    "\u014f\u0152\u015b\u0161\u0166\u0169\u016f\u0175\u0179\u0182\u0189\u0192",
    "\u0199\u019f\u01a3\u01ae\u01b2\u01ba\u01bf\u01c3\u01cc\u01da\u01df\u01e8",
    "\u01f0\u01fa\u0202\u020a\u020f\u021b\u0221\u0228\u022d\u0235\u0239\u023b",
    "\u0246\u024e\u0251\u0255\u025a\u025e\u0269\u0272\u0274\u027b\u0280\u0289",
    "\u028e\u0291\u0296\u029f\u02af\u02b9\u02bc\u02c5\u02cf\u02d7\u02da\u02dd",
    "\u02ea\u02f2\u02f7\u02ff\u0303\u0307\u030b\u030d\u0311\u0317\u0322\u032a",
    "\u0332\u033d\u0346\u035d\u0360\u0363\u036b\u036f\u0377\u037d\u0388\u0391",
    "\u0396\u03a0\u03a7\u03b4\u03bd\u03c6\u03cc\u03d7\u03dc\u03e8\u03ec\u03f0",
    "\u03f4\u03f6\u03fa\u03ff\u0412\u0426\u0436\u0461\u0473\u047b\u047d\u0493",
    "\u0495\u049e\u04a0\u04a4\u04a9\u04ad\u04b1\u04b5\u04bf\u04cb\u04d2\u04d5",
    "\u04d9\u04e5\u04ea\u04f0\u04f2\u04f8\u04fc"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ 'null', "'abstract'", "'assert'", "'boolean'", "'break'", 
                     "'byte'", "'case'", "'catch'", "'char'", "'class'", 
                     "'const'", "'continue'", "'default'", "'do'", "'double'", 
                     "'else'", "'enum'", "'extends'", "'final'", "'finally'", 
                     "'float'", "'for'", "'if'", "'goto'", "'implements'", 
                     "'import'", "'instanceof'", "'int'", "'interface'", 
                     "'long'", "'native'", "'new'", "'package'", "'private'", 
                     "'protected'", "'public'", "'return'", "'short'", "'static'", 
                     "'strictfp'", "'super'", "'switch'", "'synchronized'", 
                     "'this'", "'throw'", "'throws'", "'transient'", "'try'", 
                     "'void'", "'volatile'", "'while'", 'null', 'null', 
                     'null', 'null', 'null', "'null'", "'('", "')'", "'{'", 
                     "'}'", "'['", "']'", "';'", "','", "'.'", "'='", "'>'", 
                     "'<'", "'!'", "'~'", "'?'", "':'", "'=='", "'<='", 
                     "'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", 
                     "'-'", "'*'", "'/'", "'&'", "'|'", "'^'", "'%'", "'+='", 
                     "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", 
                     "'<<='", "'>>='", "'>>>='", 'null', "'@'", "'...'" ];

var symbolicNames = [ 'null', "ABSTRACT", "ASSERT", "BOOLEAN", "BREAK", 
                      "BYTE", "CASE", "CATCH", "CHAR", "CLASS", "CONST", 
                      "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE", "ENUM", 
                      "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF", 
                      "GOTO", "IMPLEMENTS", "IMPORT", "INSTANCEOF", "INT", 
                      "INTERFACE", "LONG", "NATIVE", "NEW", "PACKAGE", "PRIVATE", 
                      "PROTECTED", "PUBLIC", "RETURN", "SHORT", "STATIC", 
                      "STRICTFP", "SUPER", "SWITCH", "SYNCHRONIZED", "THIS", 
                      "THROW", "THROWS", "TRANSIENT", "TRY", "VOID", "VOLATILE", 
                      "WHILE", "IntegerLiteral", "FloatingPointLiteral", 
                      "BooleanLiteral", "CharacterLiteral", "StringLiteral", 
                      "NullLiteral", "LPAREN", "RPAREN", "LBRACE", "RBRACE", 
                      "LBRACK", "RBRACK", "SEMI", "COMMA", "DOT", "ASSIGN", 
                      "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", 
                      "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", "INC", 
                      "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", 
                      "CARET", "MOD", "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", 
                      "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", 
                      "MOD_ASSIGN", "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", 
                      "Identifier", "AT", "ELLIPSIS", "WS", "COMMENT", "LINE_COMMENT" ];

var ruleNames =  [ "compilationUnit", "packageDeclaration", "importDeclaration", 
                   "typeDeclaration", "modifier", "classOrInterfaceModifier", 
                   "variableModifier", "classDeclaration", "typeParameters", 
                   "typeParameter", "typeBound", "enumDeclaration", "enumConstants", 
                   "enumConstant", "enumBodyDeclarations", "interfaceDeclaration", 
                   "typeList", "classBody", "interfaceBody", "classBodyDeclaration", 
                   "memberDeclaration", "methodDeclaration", "genericMethodDeclaration", 
                   "constructorDeclaration", "genericConstructorDeclaration", 
                   "fieldDeclaration", "interfaceBodyDeclaration", "interfaceMemberDeclaration", 
                   "constDeclaration", "constantDeclarator", "interfaceMethodDeclaration", 
                   "genericInterfaceMethodDeclaration", "variableDeclarators", 
                   "variableDeclarator", "variableDeclaratorId", "variableInitializer", 
                   "arrayInitializer", "enumConstantName", "type", "classOrInterfaceType", 
                   "primitiveType", "typeArguments", "typeArgument", "qualifiedNameList", 
                   "formalParameters", "formalParameterList", "formalParameter", 
                   "lastFormalParameter", "methodBody", "constructorBody", 
                   "qualifiedName", "literal", "annotation", "annotationName", 
                   "elementValuePairs", "elementValuePair", "elementValue", 
                   "elementValueArrayInitializer", "annotationTypeDeclaration", 
                   "annotationTypeBody", "annotationTypeElementDeclaration", 
                   "annotationTypeElementRest", "annotationMethodOrConstantRest", 
                   "annotationMethodRest", "annotationConstantRest", "defaultValue", 
                   "block", "blockStatement", "localVariableDeclarationStatement", 
                   "localVariableDeclaration", "statement", "catchClause", 
                   "catchType", "finallyBlock", "resourceSpecification", 
                   "resources", "resource", "switchBlockStatementGroup", 
                   "switchLabel", "forControl", "forInit", "enhancedForControl", 
                   "forUpdate", "parExpression", "expressionList", "statementExpression", 
                   "constantExpression", "expression", "primary", "creator", 
                   "createdName", "innerCreator", "arrayCreatorRest", "classCreatorRest", 
                   "explicitGenericInvocation", "nonWildcardTypeArguments", 
                   "typeArgumentsOrDiamond", "nonWildcardTypeArgumentsOrDiamond", 
                   "superSuffix", "explicitGenericInvocationSuffix", "arguments" ];

function JavaParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

JavaParser.prototype = Object.create(antlr4.Parser.prototype);
JavaParser.prototype.constructor = JavaParser;

Object.defineProperty(JavaParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

JavaParser.EOF = antlr4.Token.EOF;
JavaParser.ABSTRACT = 1;
JavaParser.ASSERT = 2;
JavaParser.BOOLEAN = 3;
JavaParser.BREAK = 4;
JavaParser.BYTE = 5;
JavaParser.CASE = 6;
JavaParser.CATCH = 7;
JavaParser.CHAR = 8;
JavaParser.CLASS = 9;
JavaParser.CONST = 10;
JavaParser.CONTINUE = 11;
JavaParser.DEFAULT = 12;
JavaParser.DO = 13;
JavaParser.DOUBLE = 14;
JavaParser.ELSE = 15;
JavaParser.ENUM = 16;
JavaParser.EXTENDS = 17;
JavaParser.FINAL = 18;
JavaParser.FINALLY = 19;
JavaParser.FLOAT = 20;
JavaParser.FOR = 21;
JavaParser.IF = 22;
JavaParser.GOTO = 23;
JavaParser.IMPLEMENTS = 24;
JavaParser.IMPORT = 25;
JavaParser.INSTANCEOF = 26;
JavaParser.INT = 27;
JavaParser.INTERFACE = 28;
JavaParser.LONG = 29;
JavaParser.NATIVE = 30;
JavaParser.NEW = 31;
JavaParser.PACKAGE = 32;
JavaParser.PRIVATE = 33;
JavaParser.PROTECTED = 34;
JavaParser.PUBLIC = 35;
JavaParser.RETURN = 36;
JavaParser.SHORT = 37;
JavaParser.STATIC = 38;
JavaParser.STRICTFP = 39;
JavaParser.SUPER = 40;
JavaParser.SWITCH = 41;
JavaParser.SYNCHRONIZED = 42;
JavaParser.THIS = 43;
JavaParser.THROW = 44;
JavaParser.THROWS = 45;
JavaParser.TRANSIENT = 46;
JavaParser.TRY = 47;
JavaParser.VOID = 48;
JavaParser.VOLATILE = 49;
JavaParser.WHILE = 50;
JavaParser.IntegerLiteral = 51;
JavaParser.FloatingPointLiteral = 52;
JavaParser.BooleanLiteral = 53;
JavaParser.CharacterLiteral = 54;
JavaParser.StringLiteral = 55;
JavaParser.NullLiteral = 56;
JavaParser.LPAREN = 57;
JavaParser.RPAREN = 58;
JavaParser.LBRACE = 59;
JavaParser.RBRACE = 60;
JavaParser.LBRACK = 61;
JavaParser.RBRACK = 62;
JavaParser.SEMI = 63;
JavaParser.COMMA = 64;
JavaParser.DOT = 65;
JavaParser.ASSIGN = 66;
JavaParser.GT = 67;
JavaParser.LT = 68;
JavaParser.BANG = 69;
JavaParser.TILDE = 70;
JavaParser.QUESTION = 71;
JavaParser.COLON = 72;
JavaParser.EQUAL = 73;
JavaParser.LE = 74;
JavaParser.GE = 75;
JavaParser.NOTEQUAL = 76;
JavaParser.AND = 77;
JavaParser.OR = 78;
JavaParser.INC = 79;
JavaParser.DEC = 80;
JavaParser.ADD = 81;
JavaParser.SUB = 82;
JavaParser.MUL = 83;
JavaParser.DIV = 84;
JavaParser.BITAND = 85;
JavaParser.BITOR = 86;
JavaParser.CARET = 87;
JavaParser.MOD = 88;
JavaParser.ADD_ASSIGN = 89;
JavaParser.SUB_ASSIGN = 90;
JavaParser.MUL_ASSIGN = 91;
JavaParser.DIV_ASSIGN = 92;
JavaParser.AND_ASSIGN = 93;
JavaParser.OR_ASSIGN = 94;
JavaParser.XOR_ASSIGN = 95;
JavaParser.MOD_ASSIGN = 96;
JavaParser.LSHIFT_ASSIGN = 97;
JavaParser.RSHIFT_ASSIGN = 98;
JavaParser.URSHIFT_ASSIGN = 99;
JavaParser.Identifier = 100;
JavaParser.AT = 101;
JavaParser.ELLIPSIS = 102;
JavaParser.WS = 103;
JavaParser.COMMENT = 104;
JavaParser.LINE_COMMENT = 105;

JavaParser.RULE_compilationUnit = 0;
JavaParser.RULE_packageDeclaration = 1;
JavaParser.RULE_importDeclaration = 2;
JavaParser.RULE_typeDeclaration = 3;
JavaParser.RULE_modifier = 4;
JavaParser.RULE_classOrInterfaceModifier = 5;
JavaParser.RULE_variableModifier = 6;
JavaParser.RULE_classDeclaration = 7;
JavaParser.RULE_typeParameters = 8;
JavaParser.RULE_typeParameter = 9;
JavaParser.RULE_typeBound = 10;
JavaParser.RULE_enumDeclaration = 11;
JavaParser.RULE_enumConstants = 12;
JavaParser.RULE_enumConstant = 13;
JavaParser.RULE_enumBodyDeclarations = 14;
JavaParser.RULE_interfaceDeclaration = 15;
JavaParser.RULE_typeList = 16;
JavaParser.RULE_classBody = 17;
JavaParser.RULE_interfaceBody = 18;
JavaParser.RULE_classBodyDeclaration = 19;
JavaParser.RULE_memberDeclaration = 20;
JavaParser.RULE_methodDeclaration = 21;
JavaParser.RULE_genericMethodDeclaration = 22;
JavaParser.RULE_constructorDeclaration = 23;
JavaParser.RULE_genericConstructorDeclaration = 24;
JavaParser.RULE_fieldDeclaration = 25;
JavaParser.RULE_interfaceBodyDeclaration = 26;
JavaParser.RULE_interfaceMemberDeclaration = 27;
JavaParser.RULE_constDeclaration = 28;
JavaParser.RULE_constantDeclarator = 29;
JavaParser.RULE_interfaceMethodDeclaration = 30;
JavaParser.RULE_genericInterfaceMethodDeclaration = 31;
JavaParser.RULE_variableDeclarators = 32;
JavaParser.RULE_variableDeclarator = 33;
JavaParser.RULE_variableDeclaratorId = 34;
JavaParser.RULE_variableInitializer = 35;
JavaParser.RULE_arrayInitializer = 36;
JavaParser.RULE_enumConstantName = 37;
JavaParser.RULE_type = 38;
JavaParser.RULE_classOrInterfaceType = 39;
JavaParser.RULE_primitiveType = 40;
JavaParser.RULE_typeArguments = 41;
JavaParser.RULE_typeArgument = 42;
JavaParser.RULE_qualifiedNameList = 43;
JavaParser.RULE_formalParameters = 44;
JavaParser.RULE_formalParameterList = 45;
JavaParser.RULE_formalParameter = 46;
JavaParser.RULE_lastFormalParameter = 47;
JavaParser.RULE_methodBody = 48;
JavaParser.RULE_constructorBody = 49;
JavaParser.RULE_qualifiedName = 50;
JavaParser.RULE_literal = 51;
JavaParser.RULE_annotation = 52;
JavaParser.RULE_annotationName = 53;
JavaParser.RULE_elementValuePairs = 54;
JavaParser.RULE_elementValuePair = 55;
JavaParser.RULE_elementValue = 56;
JavaParser.RULE_elementValueArrayInitializer = 57;
JavaParser.RULE_annotationTypeDeclaration = 58;
JavaParser.RULE_annotationTypeBody = 59;
JavaParser.RULE_annotationTypeElementDeclaration = 60;
JavaParser.RULE_annotationTypeElementRest = 61;
JavaParser.RULE_annotationMethodOrConstantRest = 62;
JavaParser.RULE_annotationMethodRest = 63;
JavaParser.RULE_annotationConstantRest = 64;
JavaParser.RULE_defaultValue = 65;
JavaParser.RULE_block = 66;
JavaParser.RULE_blockStatement = 67;
JavaParser.RULE_localVariableDeclarationStatement = 68;
JavaParser.RULE_localVariableDeclaration = 69;
JavaParser.RULE_statement = 70;
JavaParser.RULE_catchClause = 71;
JavaParser.RULE_catchType = 72;
JavaParser.RULE_finallyBlock = 73;
JavaParser.RULE_resourceSpecification = 74;
JavaParser.RULE_resources = 75;
JavaParser.RULE_resource = 76;
JavaParser.RULE_switchBlockStatementGroup = 77;
JavaParser.RULE_switchLabel = 78;
JavaParser.RULE_forControl = 79;
JavaParser.RULE_forInit = 80;
JavaParser.RULE_enhancedForControl = 81;
JavaParser.RULE_forUpdate = 82;
JavaParser.RULE_parExpression = 83;
JavaParser.RULE_expressionList = 84;
JavaParser.RULE_statementExpression = 85;
JavaParser.RULE_constantExpression = 86;
JavaParser.RULE_expression = 87;
JavaParser.RULE_primary = 88;
JavaParser.RULE_creator = 89;
JavaParser.RULE_createdName = 90;
JavaParser.RULE_innerCreator = 91;
JavaParser.RULE_arrayCreatorRest = 92;
JavaParser.RULE_classCreatorRest = 93;
JavaParser.RULE_explicitGenericInvocation = 94;
JavaParser.RULE_nonWildcardTypeArguments = 95;
JavaParser.RULE_typeArgumentsOrDiamond = 96;
JavaParser.RULE_nonWildcardTypeArgumentsOrDiamond = 97;
JavaParser.RULE_superSuffix = 98;
JavaParser.RULE_explicitGenericInvocationSuffix = 99;
JavaParser.RULE_arguments = 100;

function CompilationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_compilationUnit;
    return this;
}

CompilationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompilationUnitContext.prototype.constructor = CompilationUnitContext;

CompilationUnitContext.prototype.EOF = function() {
    return this.getToken(JavaParser.EOF, 0);
};

CompilationUnitContext.prototype.packageDeclaration = function() {
    return this.getTypedRuleContext(PackageDeclarationContext,0);
};

CompilationUnitContext.prototype.importDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ImportDeclarationContext);
    } else {
        return this.getTypedRuleContext(ImportDeclarationContext,i);
    }
};

CompilationUnitContext.prototype.typeDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeDeclarationContext);
    } else {
        return this.getTypedRuleContext(TypeDeclarationContext,i);
    }
};

CompilationUnitContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterCompilationUnit(this);
	}
};

CompilationUnitContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitCompilationUnit(this);
	}
};




JavaParser.CompilationUnitContext = CompilationUnitContext;

JavaParser.prototype.compilationUnit = function() {

    var localctx = new CompilationUnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, JavaParser.RULE_compilationUnit);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 203;
        var la_ = this._interp.adaptivePredict(this._input,0,this._ctx);
        if(la_===1) {
            this.state = 202;
            this.packageDeclaration();

        }
        this.state = 208;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.IMPORT) {
            this.state = 205;
            this.importDeclaration();
            this.state = 210;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 214;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.CLASS) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.INTERFACE))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || _la===JavaParser.AT) {
            this.state = 211;
            this.typeDeclaration();
            this.state = 216;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 217;
        this.match(JavaParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PackageDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_packageDeclaration;
    return this;
}

PackageDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PackageDeclarationContext.prototype.constructor = PackageDeclarationContext;

PackageDeclarationContext.prototype.qualifiedName = function() {
    return this.getTypedRuleContext(QualifiedNameContext,0);
};

PackageDeclarationContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

PackageDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterPackageDeclaration(this);
	}
};

PackageDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitPackageDeclaration(this);
	}
};




JavaParser.PackageDeclarationContext = PackageDeclarationContext;

JavaParser.prototype.packageDeclaration = function() {

    var localctx = new PackageDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, JavaParser.RULE_packageDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 222;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.AT) {
            this.state = 219;
            this.annotation();
            this.state = 224;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 225;
        this.match(JavaParser.PACKAGE);
        this.state = 226;
        this.qualifiedName();
        this.state = 227;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ImportDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_importDeclaration;
    return this;
}

ImportDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ImportDeclarationContext.prototype.constructor = ImportDeclarationContext;

ImportDeclarationContext.prototype.qualifiedName = function() {
    return this.getTypedRuleContext(QualifiedNameContext,0);
};

ImportDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterImportDeclaration(this);
	}
};

ImportDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitImportDeclaration(this);
	}
};




JavaParser.ImportDeclarationContext = ImportDeclarationContext;

JavaParser.prototype.importDeclaration = function() {

    var localctx = new ImportDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, JavaParser.RULE_importDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 229;
        this.match(JavaParser.IMPORT);
        this.state = 231;
        _la = this._input.LA(1);
        if(_la===JavaParser.STATIC) {
            this.state = 230;
            this.match(JavaParser.STATIC);
        }

        this.state = 233;
        this.qualifiedName();
        this.state = 236;
        _la = this._input.LA(1);
        if(_la===JavaParser.DOT) {
            this.state = 234;
            this.match(JavaParser.DOT);
            this.state = 235;
            this.match(JavaParser.MUL);
        }

        this.state = 238;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeDeclaration;
    return this;
}

TypeDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeDeclarationContext.prototype.constructor = TypeDeclarationContext;

TypeDeclarationContext.prototype.classDeclaration = function() {
    return this.getTypedRuleContext(ClassDeclarationContext,0);
};

TypeDeclarationContext.prototype.classOrInterfaceModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ClassOrInterfaceModifierContext);
    } else {
        return this.getTypedRuleContext(ClassOrInterfaceModifierContext,i);
    }
};

TypeDeclarationContext.prototype.enumDeclaration = function() {
    return this.getTypedRuleContext(EnumDeclarationContext,0);
};

TypeDeclarationContext.prototype.interfaceDeclaration = function() {
    return this.getTypedRuleContext(InterfaceDeclarationContext,0);
};

TypeDeclarationContext.prototype.annotationTypeDeclaration = function() {
    return this.getTypedRuleContext(AnnotationTypeDeclarationContext,0);
};

TypeDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeDeclaration(this);
	}
};

TypeDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeDeclaration(this);
	}
};




JavaParser.TypeDeclarationContext = TypeDeclarationContext;

JavaParser.prototype.typeDeclaration = function() {

    var localctx = new TypeDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, JavaParser.RULE_typeDeclaration);
    var _la = 0; // Token type
    try {
        this.state = 269;
        var la_ = this._interp.adaptivePredict(this._input,10,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 243;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.ABSTRACT || _la===JavaParser.FINAL || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)))) !== 0) || _la===JavaParser.AT) {
                this.state = 240;
                this.classOrInterfaceModifier();
                this.state = 245;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 246;
            this.classDeclaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 250;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.ABSTRACT || _la===JavaParser.FINAL || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)))) !== 0) || _la===JavaParser.AT) {
                this.state = 247;
                this.classOrInterfaceModifier();
                this.state = 252;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 253;
            this.enumDeclaration();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 257;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.ABSTRACT || _la===JavaParser.FINAL || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)))) !== 0) || _la===JavaParser.AT) {
                this.state = 254;
                this.classOrInterfaceModifier();
                this.state = 259;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 260;
            this.interfaceDeclaration();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 264;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,9,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 261;
                    this.classOrInterfaceModifier(); 
                }
                this.state = 266;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,9,this._ctx);
            }

            this.state = 267;
            this.annotationTypeDeclaration();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 268;
            this.match(JavaParser.SEMI);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_modifier;
    return this;
}

ModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ModifierContext.prototype.constructor = ModifierContext;

ModifierContext.prototype.classOrInterfaceModifier = function() {
    return this.getTypedRuleContext(ClassOrInterfaceModifierContext,0);
};

ModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterModifier(this);
	}
};

ModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitModifier(this);
	}
};




JavaParser.ModifierContext = ModifierContext;

JavaParser.prototype.modifier = function() {

    var localctx = new ModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, JavaParser.RULE_modifier);
    var _la = 0; // Token type
    try {
        this.state = 273;
        switch(this._input.LA(1)) {
        case JavaParser.ABSTRACT:
        case JavaParser.FINAL:
        case JavaParser.PRIVATE:
        case JavaParser.PROTECTED:
        case JavaParser.PUBLIC:
        case JavaParser.STATIC:
        case JavaParser.STRICTFP:
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 1);
            this.state = 271;
            this.classOrInterfaceModifier();
            break;
        case JavaParser.NATIVE:
        case JavaParser.SYNCHRONIZED:
        case JavaParser.TRANSIENT:
        case JavaParser.VOLATILE:
            this.enterOuterAlt(localctx, 2);
            this.state = 272;
            _la = this._input.LA(1);
            if(!(((((_la - 30)) & ~0x1f) == 0 && ((1 << (_la - 30)) & ((1 << (JavaParser.NATIVE - 30)) | (1 << (JavaParser.SYNCHRONIZED - 30)) | (1 << (JavaParser.TRANSIENT - 30)) | (1 << (JavaParser.VOLATILE - 30)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassOrInterfaceModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classOrInterfaceModifier;
    return this;
}

ClassOrInterfaceModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassOrInterfaceModifierContext.prototype.constructor = ClassOrInterfaceModifierContext;

ClassOrInterfaceModifierContext.prototype.annotation = function() {
    return this.getTypedRuleContext(AnnotationContext,0);
};

ClassOrInterfaceModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassOrInterfaceModifier(this);
	}
};

ClassOrInterfaceModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassOrInterfaceModifier(this);
	}
};




JavaParser.ClassOrInterfaceModifierContext = ClassOrInterfaceModifierContext;

JavaParser.prototype.classOrInterfaceModifier = function() {

    var localctx = new ClassOrInterfaceModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, JavaParser.RULE_classOrInterfaceModifier);
    var _la = 0; // Token type
    try {
        this.state = 277;
        switch(this._input.LA(1)) {
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 1);
            this.state = 275;
            this.annotation();
            break;
        case JavaParser.ABSTRACT:
        case JavaParser.FINAL:
        case JavaParser.PRIVATE:
        case JavaParser.PROTECTED:
        case JavaParser.PUBLIC:
        case JavaParser.STATIC:
        case JavaParser.STRICTFP:
            this.enterOuterAlt(localctx, 2);
            this.state = 276;
            _la = this._input.LA(1);
            if(!(_la===JavaParser.ABSTRACT || _la===JavaParser.FINAL || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_variableModifier;
    return this;
}

VariableModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableModifierContext.prototype.constructor = VariableModifierContext;

VariableModifierContext.prototype.annotation = function() {
    return this.getTypedRuleContext(AnnotationContext,0);
};

VariableModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterVariableModifier(this);
	}
};

VariableModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitVariableModifier(this);
	}
};




JavaParser.VariableModifierContext = VariableModifierContext;

JavaParser.prototype.variableModifier = function() {

    var localctx = new VariableModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, JavaParser.RULE_variableModifier);
    try {
        this.state = 281;
        switch(this._input.LA(1)) {
        case JavaParser.FINAL:
            this.enterOuterAlt(localctx, 1);
            this.state = 279;
            this.match(JavaParser.FINAL);
            break;
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 2);
            this.state = 280;
            this.annotation();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classDeclaration;
    return this;
}

ClassDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassDeclarationContext.prototype.constructor = ClassDeclarationContext;

ClassDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ClassDeclarationContext.prototype.classBody = function() {
    return this.getTypedRuleContext(ClassBodyContext,0);
};

ClassDeclarationContext.prototype.typeParameters = function() {
    return this.getTypedRuleContext(TypeParametersContext,0);
};

ClassDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

ClassDeclarationContext.prototype.typeList = function() {
    return this.getTypedRuleContext(TypeListContext,0);
};

ClassDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassDeclaration(this);
	}
};

ClassDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassDeclaration(this);
	}
};




JavaParser.ClassDeclarationContext = ClassDeclarationContext;

JavaParser.prototype.classDeclaration = function() {

    var localctx = new ClassDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, JavaParser.RULE_classDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 283;
        this.match(JavaParser.CLASS);
        this.state = 284;
        this.match(JavaParser.Identifier);
        this.state = 286;
        _la = this._input.LA(1);
        if(_la===JavaParser.LT) {
            this.state = 285;
            this.typeParameters();
        }

        this.state = 290;
        _la = this._input.LA(1);
        if(_la===JavaParser.EXTENDS) {
            this.state = 288;
            this.match(JavaParser.EXTENDS);
            this.state = 289;
            this.type();
        }

        this.state = 294;
        _la = this._input.LA(1);
        if(_la===JavaParser.IMPLEMENTS) {
            this.state = 292;
            this.match(JavaParser.IMPLEMENTS);
            this.state = 293;
            this.typeList();
        }

        this.state = 296;
        this.classBody();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeParametersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeParameters;
    return this;
}

TypeParametersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeParametersContext.prototype.constructor = TypeParametersContext;

TypeParametersContext.prototype.typeParameter = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeParameterContext);
    } else {
        return this.getTypedRuleContext(TypeParameterContext,i);
    }
};

TypeParametersContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeParameters(this);
	}
};

TypeParametersContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeParameters(this);
	}
};




JavaParser.TypeParametersContext = TypeParametersContext;

JavaParser.prototype.typeParameters = function() {

    var localctx = new TypeParametersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, JavaParser.RULE_typeParameters);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 298;
        this.match(JavaParser.LT);
        this.state = 299;
        this.typeParameter();
        this.state = 304;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 300;
            this.match(JavaParser.COMMA);
            this.state = 301;
            this.typeParameter();
            this.state = 306;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 307;
        this.match(JavaParser.GT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeParameterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeParameter;
    return this;
}

TypeParameterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeParameterContext.prototype.constructor = TypeParameterContext;

TypeParameterContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

TypeParameterContext.prototype.typeBound = function() {
    return this.getTypedRuleContext(TypeBoundContext,0);
};

TypeParameterContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeParameter(this);
	}
};

TypeParameterContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeParameter(this);
	}
};




JavaParser.TypeParameterContext = TypeParameterContext;

JavaParser.prototype.typeParameter = function() {

    var localctx = new TypeParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, JavaParser.RULE_typeParameter);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 309;
        this.match(JavaParser.Identifier);
        this.state = 312;
        _la = this._input.LA(1);
        if(_la===JavaParser.EXTENDS) {
            this.state = 310;
            this.match(JavaParser.EXTENDS);
            this.state = 311;
            this.typeBound();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeBoundContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeBound;
    return this;
}

TypeBoundContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeBoundContext.prototype.constructor = TypeBoundContext;

TypeBoundContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

TypeBoundContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeBound(this);
	}
};

TypeBoundContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeBound(this);
	}
};




JavaParser.TypeBoundContext = TypeBoundContext;

JavaParser.prototype.typeBound = function() {

    var localctx = new TypeBoundContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, JavaParser.RULE_typeBound);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 314;
        this.type();
        this.state = 319;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.BITAND) {
            this.state = 315;
            this.match(JavaParser.BITAND);
            this.state = 316;
            this.type();
            this.state = 321;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enumDeclaration;
    return this;
}

EnumDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumDeclarationContext.prototype.constructor = EnumDeclarationContext;

EnumDeclarationContext.prototype.ENUM = function() {
    return this.getToken(JavaParser.ENUM, 0);
};

EnumDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

EnumDeclarationContext.prototype.typeList = function() {
    return this.getTypedRuleContext(TypeListContext,0);
};

EnumDeclarationContext.prototype.enumConstants = function() {
    return this.getTypedRuleContext(EnumConstantsContext,0);
};

EnumDeclarationContext.prototype.enumBodyDeclarations = function() {
    return this.getTypedRuleContext(EnumBodyDeclarationsContext,0);
};

EnumDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnumDeclaration(this);
	}
};

EnumDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnumDeclaration(this);
	}
};




JavaParser.EnumDeclarationContext = EnumDeclarationContext;

JavaParser.prototype.enumDeclaration = function() {

    var localctx = new EnumDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, JavaParser.RULE_enumDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 322;
        this.match(JavaParser.ENUM);
        this.state = 323;
        this.match(JavaParser.Identifier);
        this.state = 326;
        _la = this._input.LA(1);
        if(_la===JavaParser.IMPLEMENTS) {
            this.state = 324;
            this.match(JavaParser.IMPLEMENTS);
            this.state = 325;
            this.typeList();
        }

        this.state = 328;
        this.match(JavaParser.LBRACE);
        this.state = 330;
        _la = this._input.LA(1);
        if(_la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 329;
            this.enumConstants();
        }

        this.state = 333;
        _la = this._input.LA(1);
        if(_la===JavaParser.COMMA) {
            this.state = 332;
            this.match(JavaParser.COMMA);
        }

        this.state = 336;
        _la = this._input.LA(1);
        if(_la===JavaParser.SEMI) {
            this.state = 335;
            this.enumBodyDeclarations();
        }

        this.state = 338;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumConstantsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enumConstants;
    return this;
}

EnumConstantsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumConstantsContext.prototype.constructor = EnumConstantsContext;

EnumConstantsContext.prototype.enumConstant = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(EnumConstantContext);
    } else {
        return this.getTypedRuleContext(EnumConstantContext,i);
    }
};

EnumConstantsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnumConstants(this);
	}
};

EnumConstantsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnumConstants(this);
	}
};




JavaParser.EnumConstantsContext = EnumConstantsContext;

JavaParser.prototype.enumConstants = function() {

    var localctx = new EnumConstantsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, JavaParser.RULE_enumConstants);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 340;
        this.enumConstant();
        this.state = 345;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,24,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 341;
                this.match(JavaParser.COMMA);
                this.state = 342;
                this.enumConstant(); 
            }
            this.state = 347;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,24,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumConstantContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enumConstant;
    return this;
}

EnumConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumConstantContext.prototype.constructor = EnumConstantContext;

EnumConstantContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

EnumConstantContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

EnumConstantContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};

EnumConstantContext.prototype.classBody = function() {
    return this.getTypedRuleContext(ClassBodyContext,0);
};

EnumConstantContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnumConstant(this);
	}
};

EnumConstantContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnumConstant(this);
	}
};




JavaParser.EnumConstantContext = EnumConstantContext;

JavaParser.prototype.enumConstant = function() {

    var localctx = new EnumConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, JavaParser.RULE_enumConstant);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 351;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.AT) {
            this.state = 348;
            this.annotation();
            this.state = 353;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 354;
        this.match(JavaParser.Identifier);
        this.state = 356;
        _la = this._input.LA(1);
        if(_la===JavaParser.LPAREN) {
            this.state = 355;
            this.arguments();
        }

        this.state = 359;
        _la = this._input.LA(1);
        if(_la===JavaParser.LBRACE) {
            this.state = 358;
            this.classBody();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumBodyDeclarationsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enumBodyDeclarations;
    return this;
}

EnumBodyDeclarationsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumBodyDeclarationsContext.prototype.constructor = EnumBodyDeclarationsContext;

EnumBodyDeclarationsContext.prototype.classBodyDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ClassBodyDeclarationContext);
    } else {
        return this.getTypedRuleContext(ClassBodyDeclarationContext,i);
    }
};

EnumBodyDeclarationsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnumBodyDeclarations(this);
	}
};

EnumBodyDeclarationsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnumBodyDeclarations(this);
	}
};




JavaParser.EnumBodyDeclarationsContext = EnumBodyDeclarationsContext;

JavaParser.prototype.enumBodyDeclarations = function() {

    var localctx = new EnumBodyDeclarationsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, JavaParser.RULE_enumBodyDeclarations);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 361;
        this.match(JavaParser.SEMI);
        this.state = 365;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NATIVE))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.TRANSIENT - 33)) | (1 << (JavaParser.VOID - 33)) | (1 << (JavaParser.VOLATILE - 33)) | (1 << (JavaParser.LBRACE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || _la===JavaParser.LT || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 362;
            this.classBodyDeclaration();
            this.state = 367;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InterfaceDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_interfaceDeclaration;
    return this;
}

InterfaceDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InterfaceDeclarationContext.prototype.constructor = InterfaceDeclarationContext;

InterfaceDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

InterfaceDeclarationContext.prototype.interfaceBody = function() {
    return this.getTypedRuleContext(InterfaceBodyContext,0);
};

InterfaceDeclarationContext.prototype.typeParameters = function() {
    return this.getTypedRuleContext(TypeParametersContext,0);
};

InterfaceDeclarationContext.prototype.typeList = function() {
    return this.getTypedRuleContext(TypeListContext,0);
};

InterfaceDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInterfaceDeclaration(this);
	}
};

InterfaceDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInterfaceDeclaration(this);
	}
};




JavaParser.InterfaceDeclarationContext = InterfaceDeclarationContext;

JavaParser.prototype.interfaceDeclaration = function() {

    var localctx = new InterfaceDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, JavaParser.RULE_interfaceDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 368;
        this.match(JavaParser.INTERFACE);
        this.state = 369;
        this.match(JavaParser.Identifier);
        this.state = 371;
        _la = this._input.LA(1);
        if(_la===JavaParser.LT) {
            this.state = 370;
            this.typeParameters();
        }

        this.state = 375;
        _la = this._input.LA(1);
        if(_la===JavaParser.EXTENDS) {
            this.state = 373;
            this.match(JavaParser.EXTENDS);
            this.state = 374;
            this.typeList();
        }

        this.state = 377;
        this.interfaceBody();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeList;
    return this;
}

TypeListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeListContext.prototype.constructor = TypeListContext;

TypeListContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

TypeListContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeList(this);
	}
};

TypeListContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeList(this);
	}
};




JavaParser.TypeListContext = TypeListContext;

JavaParser.prototype.typeList = function() {

    var localctx = new TypeListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, JavaParser.RULE_typeList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 379;
        this.type();
        this.state = 384;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 380;
            this.match(JavaParser.COMMA);
            this.state = 381;
            this.type();
            this.state = 386;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classBody;
    return this;
}

ClassBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassBodyContext.prototype.constructor = ClassBodyContext;

ClassBodyContext.prototype.classBodyDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ClassBodyDeclarationContext);
    } else {
        return this.getTypedRuleContext(ClassBodyDeclarationContext,i);
    }
};

ClassBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassBody(this);
	}
};

ClassBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassBody(this);
	}
};




JavaParser.ClassBodyContext = ClassBodyContext;

JavaParser.prototype.classBody = function() {

    var localctx = new ClassBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, JavaParser.RULE_classBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 387;
        this.match(JavaParser.LBRACE);
        this.state = 391;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NATIVE))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.TRANSIENT - 33)) | (1 << (JavaParser.VOID - 33)) | (1 << (JavaParser.VOLATILE - 33)) | (1 << (JavaParser.LBRACE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || _la===JavaParser.LT || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 388;
            this.classBodyDeclaration();
            this.state = 393;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 394;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InterfaceBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_interfaceBody;
    return this;
}

InterfaceBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InterfaceBodyContext.prototype.constructor = InterfaceBodyContext;

InterfaceBodyContext.prototype.interfaceBodyDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(InterfaceBodyDeclarationContext);
    } else {
        return this.getTypedRuleContext(InterfaceBodyDeclarationContext,i);
    }
};

InterfaceBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInterfaceBody(this);
	}
};

InterfaceBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInterfaceBody(this);
	}
};




JavaParser.InterfaceBodyContext = InterfaceBodyContext;

JavaParser.prototype.interfaceBody = function() {

    var localctx = new InterfaceBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, JavaParser.RULE_interfaceBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 396;
        this.match(JavaParser.LBRACE);
        this.state = 400;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NATIVE))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.TRANSIENT - 33)) | (1 << (JavaParser.VOID - 33)) | (1 << (JavaParser.VOLATILE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || _la===JavaParser.LT || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 397;
            this.interfaceBodyDeclaration();
            this.state = 402;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 403;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassBodyDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classBodyDeclaration;
    return this;
}

ClassBodyDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassBodyDeclarationContext.prototype.constructor = ClassBodyDeclarationContext;

ClassBodyDeclarationContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

ClassBodyDeclarationContext.prototype.memberDeclaration = function() {
    return this.getTypedRuleContext(MemberDeclarationContext,0);
};

ClassBodyDeclarationContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

ClassBodyDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassBodyDeclaration(this);
	}
};

ClassBodyDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassBodyDeclaration(this);
	}
};




JavaParser.ClassBodyDeclarationContext = ClassBodyDeclarationContext;

JavaParser.prototype.classBodyDeclaration = function() {

    var localctx = new ClassBodyDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, JavaParser.RULE_classBodyDeclaration);
    var _la = 0; // Token type
    try {
        this.state = 417;
        var la_ = this._interp.adaptivePredict(this._input,36,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 405;
            this.match(JavaParser.SEMI);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 407;
            _la = this._input.LA(1);
            if(_la===JavaParser.STATIC) {
                this.state = 406;
                this.match(JavaParser.STATIC);
            }

            this.state = 409;
            this.block();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 413;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,35,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 410;
                    this.modifier(); 
                }
                this.state = 415;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,35,this._ctx);
            }

            this.state = 416;
            this.memberDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MemberDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_memberDeclaration;
    return this;
}

MemberDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MemberDeclarationContext.prototype.constructor = MemberDeclarationContext;

MemberDeclarationContext.prototype.methodDeclaration = function() {
    return this.getTypedRuleContext(MethodDeclarationContext,0);
};

MemberDeclarationContext.prototype.genericMethodDeclaration = function() {
    return this.getTypedRuleContext(GenericMethodDeclarationContext,0);
};

MemberDeclarationContext.prototype.fieldDeclaration = function() {
    return this.getTypedRuleContext(FieldDeclarationContext,0);
};

MemberDeclarationContext.prototype.constructorDeclaration = function() {
    return this.getTypedRuleContext(ConstructorDeclarationContext,0);
};

MemberDeclarationContext.prototype.genericConstructorDeclaration = function() {
    return this.getTypedRuleContext(GenericConstructorDeclarationContext,0);
};

MemberDeclarationContext.prototype.interfaceDeclaration = function() {
    return this.getTypedRuleContext(InterfaceDeclarationContext,0);
};

MemberDeclarationContext.prototype.annotationTypeDeclaration = function() {
    return this.getTypedRuleContext(AnnotationTypeDeclarationContext,0);
};

MemberDeclarationContext.prototype.classDeclaration = function() {
    return this.getTypedRuleContext(ClassDeclarationContext,0);
};

MemberDeclarationContext.prototype.enumDeclaration = function() {
    return this.getTypedRuleContext(EnumDeclarationContext,0);
};

MemberDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterMemberDeclaration(this);
	}
};

MemberDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitMemberDeclaration(this);
	}
};




JavaParser.MemberDeclarationContext = MemberDeclarationContext;

JavaParser.prototype.memberDeclaration = function() {

    var localctx = new MemberDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, JavaParser.RULE_memberDeclaration);
    try {
        this.state = 428;
        var la_ = this._interp.adaptivePredict(this._input,37,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 419;
            this.methodDeclaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 420;
            this.genericMethodDeclaration();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 421;
            this.fieldDeclaration();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 422;
            this.constructorDeclaration();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 423;
            this.genericConstructorDeclaration();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 424;
            this.interfaceDeclaration();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 425;
            this.annotationTypeDeclaration();
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 426;
            this.classDeclaration();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 427;
            this.enumDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MethodDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_methodDeclaration;
    return this;
}

MethodDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MethodDeclarationContext.prototype.constructor = MethodDeclarationContext;

MethodDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

MethodDeclarationContext.prototype.formalParameters = function() {
    return this.getTypedRuleContext(FormalParametersContext,0);
};

MethodDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

MethodDeclarationContext.prototype.methodBody = function() {
    return this.getTypedRuleContext(MethodBodyContext,0);
};

MethodDeclarationContext.prototype.qualifiedNameList = function() {
    return this.getTypedRuleContext(QualifiedNameListContext,0);
};

MethodDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterMethodDeclaration(this);
	}
};

MethodDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitMethodDeclaration(this);
	}
};




JavaParser.MethodDeclarationContext = MethodDeclarationContext;

JavaParser.prototype.methodDeclaration = function() {

    var localctx = new MethodDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, JavaParser.RULE_methodDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 432;
        switch(this._input.LA(1)) {
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
        case JavaParser.Identifier:
            this.state = 430;
            this.type();
            break;
        case JavaParser.VOID:
            this.state = 431;
            this.match(JavaParser.VOID);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 434;
        this.match(JavaParser.Identifier);
        this.state = 435;
        this.formalParameters();
        this.state = 440;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.LBRACK) {
            this.state = 436;
            this.match(JavaParser.LBRACK);
            this.state = 437;
            this.match(JavaParser.RBRACK);
            this.state = 442;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 445;
        _la = this._input.LA(1);
        if(_la===JavaParser.THROWS) {
            this.state = 443;
            this.match(JavaParser.THROWS);
            this.state = 444;
            this.qualifiedNameList();
        }

        this.state = 449;
        switch(this._input.LA(1)) {
        case JavaParser.LBRACE:
            this.state = 447;
            this.methodBody();
            break;
        case JavaParser.SEMI:
            this.state = 448;
            this.match(JavaParser.SEMI);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericMethodDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_genericMethodDeclaration;
    return this;
}

GenericMethodDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericMethodDeclarationContext.prototype.constructor = GenericMethodDeclarationContext;

GenericMethodDeclarationContext.prototype.typeParameters = function() {
    return this.getTypedRuleContext(TypeParametersContext,0);
};

GenericMethodDeclarationContext.prototype.methodDeclaration = function() {
    return this.getTypedRuleContext(MethodDeclarationContext,0);
};

GenericMethodDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterGenericMethodDeclaration(this);
	}
};

GenericMethodDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitGenericMethodDeclaration(this);
	}
};




JavaParser.GenericMethodDeclarationContext = GenericMethodDeclarationContext;

JavaParser.prototype.genericMethodDeclaration = function() {

    var localctx = new GenericMethodDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, JavaParser.RULE_genericMethodDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 451;
        this.typeParameters();
        this.state = 452;
        this.methodDeclaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstructorDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_constructorDeclaration;
    return this;
}

ConstructorDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstructorDeclarationContext.prototype.constructor = ConstructorDeclarationContext;

ConstructorDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ConstructorDeclarationContext.prototype.formalParameters = function() {
    return this.getTypedRuleContext(FormalParametersContext,0);
};

ConstructorDeclarationContext.prototype.constructorBody = function() {
    return this.getTypedRuleContext(ConstructorBodyContext,0);
};

ConstructorDeclarationContext.prototype.qualifiedNameList = function() {
    return this.getTypedRuleContext(QualifiedNameListContext,0);
};

ConstructorDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterConstructorDeclaration(this);
	}
};

ConstructorDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitConstructorDeclaration(this);
	}
};




JavaParser.ConstructorDeclarationContext = ConstructorDeclarationContext;

JavaParser.prototype.constructorDeclaration = function() {

    var localctx = new ConstructorDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, JavaParser.RULE_constructorDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 454;
        this.match(JavaParser.Identifier);
        this.state = 455;
        this.formalParameters();
        this.state = 458;
        _la = this._input.LA(1);
        if(_la===JavaParser.THROWS) {
            this.state = 456;
            this.match(JavaParser.THROWS);
            this.state = 457;
            this.qualifiedNameList();
        }

        this.state = 460;
        this.constructorBody();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericConstructorDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_genericConstructorDeclaration;
    return this;
}

GenericConstructorDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericConstructorDeclarationContext.prototype.constructor = GenericConstructorDeclarationContext;

GenericConstructorDeclarationContext.prototype.typeParameters = function() {
    return this.getTypedRuleContext(TypeParametersContext,0);
};

GenericConstructorDeclarationContext.prototype.constructorDeclaration = function() {
    return this.getTypedRuleContext(ConstructorDeclarationContext,0);
};

GenericConstructorDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterGenericConstructorDeclaration(this);
	}
};

GenericConstructorDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitGenericConstructorDeclaration(this);
	}
};




JavaParser.GenericConstructorDeclarationContext = GenericConstructorDeclarationContext;

JavaParser.prototype.genericConstructorDeclaration = function() {

    var localctx = new GenericConstructorDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, JavaParser.RULE_genericConstructorDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 462;
        this.typeParameters();
        this.state = 463;
        this.constructorDeclaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FieldDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_fieldDeclaration;
    return this;
}

FieldDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FieldDeclarationContext.prototype.constructor = FieldDeclarationContext;

FieldDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

FieldDeclarationContext.prototype.variableDeclarators = function() {
    return this.getTypedRuleContext(VariableDeclaratorsContext,0);
};

FieldDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterFieldDeclaration(this);
	}
};

FieldDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitFieldDeclaration(this);
	}
};




JavaParser.FieldDeclarationContext = FieldDeclarationContext;

JavaParser.prototype.fieldDeclaration = function() {

    var localctx = new FieldDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, JavaParser.RULE_fieldDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 465;
        this.type();
        this.state = 466;
        this.variableDeclarators();
        this.state = 467;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InterfaceBodyDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_interfaceBodyDeclaration;
    return this;
}

InterfaceBodyDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InterfaceBodyDeclarationContext.prototype.constructor = InterfaceBodyDeclarationContext;

InterfaceBodyDeclarationContext.prototype.interfaceMemberDeclaration = function() {
    return this.getTypedRuleContext(InterfaceMemberDeclarationContext,0);
};

InterfaceBodyDeclarationContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

InterfaceBodyDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInterfaceBodyDeclaration(this);
	}
};

InterfaceBodyDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInterfaceBodyDeclaration(this);
	}
};




JavaParser.InterfaceBodyDeclarationContext = InterfaceBodyDeclarationContext;

JavaParser.prototype.interfaceBodyDeclaration = function() {

    var localctx = new InterfaceBodyDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, JavaParser.RULE_interfaceBodyDeclaration);
    try {
        this.state = 477;
        switch(this._input.LA(1)) {
        case JavaParser.ABSTRACT:
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.CLASS:
        case JavaParser.DOUBLE:
        case JavaParser.ENUM:
        case JavaParser.FINAL:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.INTERFACE:
        case JavaParser.LONG:
        case JavaParser.NATIVE:
        case JavaParser.PRIVATE:
        case JavaParser.PROTECTED:
        case JavaParser.PUBLIC:
        case JavaParser.SHORT:
        case JavaParser.STATIC:
        case JavaParser.STRICTFP:
        case JavaParser.SYNCHRONIZED:
        case JavaParser.TRANSIENT:
        case JavaParser.VOID:
        case JavaParser.VOLATILE:
        case JavaParser.LT:
        case JavaParser.Identifier:
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 1);
            this.state = 472;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,43,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 469;
                    this.modifier(); 
                }
                this.state = 474;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,43,this._ctx);
            }

            this.state = 475;
            this.interfaceMemberDeclaration();
            break;
        case JavaParser.SEMI:
            this.enterOuterAlt(localctx, 2);
            this.state = 476;
            this.match(JavaParser.SEMI);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InterfaceMemberDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_interfaceMemberDeclaration;
    return this;
}

InterfaceMemberDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InterfaceMemberDeclarationContext.prototype.constructor = InterfaceMemberDeclarationContext;

InterfaceMemberDeclarationContext.prototype.constDeclaration = function() {
    return this.getTypedRuleContext(ConstDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.interfaceMethodDeclaration = function() {
    return this.getTypedRuleContext(InterfaceMethodDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.genericInterfaceMethodDeclaration = function() {
    return this.getTypedRuleContext(GenericInterfaceMethodDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.interfaceDeclaration = function() {
    return this.getTypedRuleContext(InterfaceDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.annotationTypeDeclaration = function() {
    return this.getTypedRuleContext(AnnotationTypeDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.classDeclaration = function() {
    return this.getTypedRuleContext(ClassDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.enumDeclaration = function() {
    return this.getTypedRuleContext(EnumDeclarationContext,0);
};

InterfaceMemberDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInterfaceMemberDeclaration(this);
	}
};

InterfaceMemberDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInterfaceMemberDeclaration(this);
	}
};




JavaParser.InterfaceMemberDeclarationContext = InterfaceMemberDeclarationContext;

JavaParser.prototype.interfaceMemberDeclaration = function() {

    var localctx = new InterfaceMemberDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, JavaParser.RULE_interfaceMemberDeclaration);
    try {
        this.state = 486;
        var la_ = this._interp.adaptivePredict(this._input,45,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 479;
            this.constDeclaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 480;
            this.interfaceMethodDeclaration();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 481;
            this.genericInterfaceMethodDeclaration();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 482;
            this.interfaceDeclaration();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 483;
            this.annotationTypeDeclaration();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 484;
            this.classDeclaration();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 485;
            this.enumDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_constDeclaration;
    return this;
}

ConstDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstDeclarationContext.prototype.constructor = ConstDeclarationContext;

ConstDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

ConstDeclarationContext.prototype.constantDeclarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstantDeclaratorContext);
    } else {
        return this.getTypedRuleContext(ConstantDeclaratorContext,i);
    }
};

ConstDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterConstDeclaration(this);
	}
};

ConstDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitConstDeclaration(this);
	}
};




JavaParser.ConstDeclarationContext = ConstDeclarationContext;

JavaParser.prototype.constDeclaration = function() {

    var localctx = new ConstDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, JavaParser.RULE_constDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 488;
        this.type();
        this.state = 489;
        this.constantDeclarator();
        this.state = 494;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 490;
            this.match(JavaParser.COMMA);
            this.state = 491;
            this.constantDeclarator();
            this.state = 496;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 497;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstantDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_constantDeclarator;
    return this;
}

ConstantDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantDeclaratorContext.prototype.constructor = ConstantDeclaratorContext;

ConstantDeclaratorContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ConstantDeclaratorContext.prototype.variableInitializer = function() {
    return this.getTypedRuleContext(VariableInitializerContext,0);
};

ConstantDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterConstantDeclarator(this);
	}
};

ConstantDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitConstantDeclarator(this);
	}
};




JavaParser.ConstantDeclaratorContext = ConstantDeclaratorContext;

JavaParser.prototype.constantDeclarator = function() {

    var localctx = new ConstantDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, JavaParser.RULE_constantDeclarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 499;
        this.match(JavaParser.Identifier);
        this.state = 504;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.LBRACK) {
            this.state = 500;
            this.match(JavaParser.LBRACK);
            this.state = 501;
            this.match(JavaParser.RBRACK);
            this.state = 506;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 507;
        this.match(JavaParser.ASSIGN);
        this.state = 508;
        this.variableInitializer();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InterfaceMethodDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_interfaceMethodDeclaration;
    return this;
}

InterfaceMethodDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InterfaceMethodDeclarationContext.prototype.constructor = InterfaceMethodDeclarationContext;

InterfaceMethodDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

InterfaceMethodDeclarationContext.prototype.formalParameters = function() {
    return this.getTypedRuleContext(FormalParametersContext,0);
};

InterfaceMethodDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

InterfaceMethodDeclarationContext.prototype.qualifiedNameList = function() {
    return this.getTypedRuleContext(QualifiedNameListContext,0);
};

InterfaceMethodDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInterfaceMethodDeclaration(this);
	}
};

InterfaceMethodDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInterfaceMethodDeclaration(this);
	}
};




JavaParser.InterfaceMethodDeclarationContext = InterfaceMethodDeclarationContext;

JavaParser.prototype.interfaceMethodDeclaration = function() {

    var localctx = new InterfaceMethodDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, JavaParser.RULE_interfaceMethodDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 512;
        switch(this._input.LA(1)) {
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
        case JavaParser.Identifier:
            this.state = 510;
            this.type();
            break;
        case JavaParser.VOID:
            this.state = 511;
            this.match(JavaParser.VOID);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 514;
        this.match(JavaParser.Identifier);
        this.state = 515;
        this.formalParameters();
        this.state = 520;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.LBRACK) {
            this.state = 516;
            this.match(JavaParser.LBRACK);
            this.state = 517;
            this.match(JavaParser.RBRACK);
            this.state = 522;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 525;
        _la = this._input.LA(1);
        if(_la===JavaParser.THROWS) {
            this.state = 523;
            this.match(JavaParser.THROWS);
            this.state = 524;
            this.qualifiedNameList();
        }

        this.state = 527;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GenericInterfaceMethodDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_genericInterfaceMethodDeclaration;
    return this;
}

GenericInterfaceMethodDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GenericInterfaceMethodDeclarationContext.prototype.constructor = GenericInterfaceMethodDeclarationContext;

GenericInterfaceMethodDeclarationContext.prototype.typeParameters = function() {
    return this.getTypedRuleContext(TypeParametersContext,0);
};

GenericInterfaceMethodDeclarationContext.prototype.interfaceMethodDeclaration = function() {
    return this.getTypedRuleContext(InterfaceMethodDeclarationContext,0);
};

GenericInterfaceMethodDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterGenericInterfaceMethodDeclaration(this);
	}
};

GenericInterfaceMethodDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitGenericInterfaceMethodDeclaration(this);
	}
};




JavaParser.GenericInterfaceMethodDeclarationContext = GenericInterfaceMethodDeclarationContext;

JavaParser.prototype.genericInterfaceMethodDeclaration = function() {

    var localctx = new GenericInterfaceMethodDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, JavaParser.RULE_genericInterfaceMethodDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 529;
        this.typeParameters();
        this.state = 530;
        this.interfaceMethodDeclaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableDeclaratorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_variableDeclarators;
    return this;
}

VariableDeclaratorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableDeclaratorsContext.prototype.constructor = VariableDeclaratorsContext;

VariableDeclaratorsContext.prototype.variableDeclarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableDeclaratorContext);
    } else {
        return this.getTypedRuleContext(VariableDeclaratorContext,i);
    }
};

VariableDeclaratorsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterVariableDeclarators(this);
	}
};

VariableDeclaratorsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitVariableDeclarators(this);
	}
};




JavaParser.VariableDeclaratorsContext = VariableDeclaratorsContext;

JavaParser.prototype.variableDeclarators = function() {

    var localctx = new VariableDeclaratorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, JavaParser.RULE_variableDeclarators);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 532;
        this.variableDeclarator();
        this.state = 537;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 533;
            this.match(JavaParser.COMMA);
            this.state = 534;
            this.variableDeclarator();
            this.state = 539;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableDeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_variableDeclarator;
    return this;
}

VariableDeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableDeclaratorContext.prototype.constructor = VariableDeclaratorContext;

VariableDeclaratorContext.prototype.variableDeclaratorId = function() {
    return this.getTypedRuleContext(VariableDeclaratorIdContext,0);
};

VariableDeclaratorContext.prototype.variableInitializer = function() {
    return this.getTypedRuleContext(VariableInitializerContext,0);
};

VariableDeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterVariableDeclarator(this);
	}
};

VariableDeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitVariableDeclarator(this);
	}
};




JavaParser.VariableDeclaratorContext = VariableDeclaratorContext;

JavaParser.prototype.variableDeclarator = function() {

    var localctx = new VariableDeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, JavaParser.RULE_variableDeclarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 540;
        this.variableDeclaratorId();
        this.state = 543;
        _la = this._input.LA(1);
        if(_la===JavaParser.ASSIGN) {
            this.state = 541;
            this.match(JavaParser.ASSIGN);
            this.state = 542;
            this.variableInitializer();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableDeclaratorIdContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_variableDeclaratorId;
    return this;
}

VariableDeclaratorIdContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableDeclaratorIdContext.prototype.constructor = VariableDeclaratorIdContext;

VariableDeclaratorIdContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

VariableDeclaratorIdContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterVariableDeclaratorId(this);
	}
};

VariableDeclaratorIdContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitVariableDeclaratorId(this);
	}
};




JavaParser.VariableDeclaratorIdContext = VariableDeclaratorIdContext;

JavaParser.prototype.variableDeclaratorId = function() {

    var localctx = new VariableDeclaratorIdContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, JavaParser.RULE_variableDeclaratorId);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 545;
        this.match(JavaParser.Identifier);
        this.state = 550;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.LBRACK) {
            this.state = 546;
            this.match(JavaParser.LBRACK);
            this.state = 547;
            this.match(JavaParser.RBRACK);
            this.state = 552;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariableInitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_variableInitializer;
    return this;
}

VariableInitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariableInitializerContext.prototype.constructor = VariableInitializerContext;

VariableInitializerContext.prototype.arrayInitializer = function() {
    return this.getTypedRuleContext(ArrayInitializerContext,0);
};

VariableInitializerContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

VariableInitializerContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterVariableInitializer(this);
	}
};

VariableInitializerContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitVariableInitializer(this);
	}
};




JavaParser.VariableInitializerContext = VariableInitializerContext;

JavaParser.prototype.variableInitializer = function() {

    var localctx = new VariableInitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, JavaParser.RULE_variableInitializer);
    try {
        this.state = 555;
        switch(this._input.LA(1)) {
        case JavaParser.LBRACE:
            this.enterOuterAlt(localctx, 1);
            this.state = 553;
            this.arrayInitializer();
            break;
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.NEW:
        case JavaParser.SHORT:
        case JavaParser.SUPER:
        case JavaParser.THIS:
        case JavaParser.VOID:
        case JavaParser.IntegerLiteral:
        case JavaParser.FloatingPointLiteral:
        case JavaParser.BooleanLiteral:
        case JavaParser.CharacterLiteral:
        case JavaParser.StringLiteral:
        case JavaParser.NullLiteral:
        case JavaParser.LPAREN:
        case JavaParser.LT:
        case JavaParser.BANG:
        case JavaParser.TILDE:
        case JavaParser.INC:
        case JavaParser.DEC:
        case JavaParser.ADD:
        case JavaParser.SUB:
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 2);
            this.state = 554;
            this.expression(0);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArrayInitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_arrayInitializer;
    return this;
}

ArrayInitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArrayInitializerContext.prototype.constructor = ArrayInitializerContext;

ArrayInitializerContext.prototype.variableInitializer = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableInitializerContext);
    } else {
        return this.getTypedRuleContext(VariableInitializerContext,i);
    }
};

ArrayInitializerContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterArrayInitializer(this);
	}
};

ArrayInitializerContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitArrayInitializer(this);
	}
};




JavaParser.ArrayInitializerContext = ArrayInitializerContext;

JavaParser.prototype.arrayInitializer = function() {

    var localctx = new ArrayInitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, JavaParser.RULE_arrayInitializer);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 557;
        this.match(JavaParser.LBRACE);
        this.state = 569;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LBRACE - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
            this.state = 558;
            this.variableInitializer();
            this.state = 563;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,55,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 559;
                    this.match(JavaParser.COMMA);
                    this.state = 560;
                    this.variableInitializer(); 
                }
                this.state = 565;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,55,this._ctx);
            }

            this.state = 567;
            _la = this._input.LA(1);
            if(_la===JavaParser.COMMA) {
                this.state = 566;
                this.match(JavaParser.COMMA);
            }

        }

        this.state = 571;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumConstantNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enumConstantName;
    return this;
}

EnumConstantNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumConstantNameContext.prototype.constructor = EnumConstantNameContext;

EnumConstantNameContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

EnumConstantNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnumConstantName(this);
	}
};

EnumConstantNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnumConstantName(this);
	}
};




JavaParser.EnumConstantNameContext = EnumConstantNameContext;

JavaParser.prototype.enumConstantName = function() {

    var localctx = new EnumConstantNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 74, JavaParser.RULE_enumConstantName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 573;
        this.match(JavaParser.Identifier);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_type;
    return this;
}

TypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeContext.prototype.constructor = TypeContext;

TypeContext.prototype.classOrInterfaceType = function() {
    return this.getTypedRuleContext(ClassOrInterfaceTypeContext,0);
};

TypeContext.prototype.primitiveType = function() {
    return this.getTypedRuleContext(PrimitiveTypeContext,0);
};

TypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterType(this);
	}
};

TypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitType(this);
	}
};




JavaParser.TypeContext = TypeContext;

JavaParser.prototype.type = function() {

    var localctx = new TypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, JavaParser.RULE_type);
    try {
        this.state = 591;
        switch(this._input.LA(1)) {
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 575;
            this.classOrInterfaceType();
            this.state = 580;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,58,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 576;
                    this.match(JavaParser.LBRACK);
                    this.state = 577;
                    this.match(JavaParser.RBRACK); 
                }
                this.state = 582;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,58,this._ctx);
            }

            break;
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
            this.enterOuterAlt(localctx, 2);
            this.state = 583;
            this.primitiveType();
            this.state = 588;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,59,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 584;
                    this.match(JavaParser.LBRACK);
                    this.state = 585;
                    this.match(JavaParser.RBRACK); 
                }
                this.state = 590;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,59,this._ctx);
            }

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassOrInterfaceTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classOrInterfaceType;
    return this;
}

ClassOrInterfaceTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassOrInterfaceTypeContext.prototype.constructor = ClassOrInterfaceTypeContext;

ClassOrInterfaceTypeContext.prototype.Identifier = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(JavaParser.Identifier);
    } else {
        return this.getToken(JavaParser.Identifier, i);
    }
};


ClassOrInterfaceTypeContext.prototype.typeArguments = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeArgumentsContext);
    } else {
        return this.getTypedRuleContext(TypeArgumentsContext,i);
    }
};

ClassOrInterfaceTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassOrInterfaceType(this);
	}
};

ClassOrInterfaceTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassOrInterfaceType(this);
	}
};




JavaParser.ClassOrInterfaceTypeContext = ClassOrInterfaceTypeContext;

JavaParser.prototype.classOrInterfaceType = function() {

    var localctx = new ClassOrInterfaceTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, JavaParser.RULE_classOrInterfaceType);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 593;
        this.match(JavaParser.Identifier);
        this.state = 595;
        var la_ = this._interp.adaptivePredict(this._input,61,this._ctx);
        if(la_===1) {
            this.state = 594;
            this.typeArguments();

        }
        this.state = 604;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,63,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 597;
                this.match(JavaParser.DOT);
                this.state = 598;
                this.match(JavaParser.Identifier);
                this.state = 600;
                var la_ = this._interp.adaptivePredict(this._input,62,this._ctx);
                if(la_===1) {
                    this.state = 599;
                    this.typeArguments();

                } 
            }
            this.state = 606;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,63,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PrimitiveTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_primitiveType;
    return this;
}

PrimitiveTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrimitiveTypeContext.prototype.constructor = PrimitiveTypeContext;


PrimitiveTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterPrimitiveType(this);
	}
};

PrimitiveTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitPrimitiveType(this);
	}
};




JavaParser.PrimitiveTypeContext = PrimitiveTypeContext;

JavaParser.prototype.primitiveType = function() {

    var localctx = new PrimitiveTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, JavaParser.RULE_primitiveType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 607;
        _la = this._input.LA(1);
        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG))) !== 0) || _la===JavaParser.SHORT)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeArguments;
    return this;
}

TypeArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeArgumentsContext.prototype.constructor = TypeArgumentsContext;

TypeArgumentsContext.prototype.typeArgument = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeArgumentContext);
    } else {
        return this.getTypedRuleContext(TypeArgumentContext,i);
    }
};

TypeArgumentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeArguments(this);
	}
};

TypeArgumentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeArguments(this);
	}
};




JavaParser.TypeArgumentsContext = TypeArgumentsContext;

JavaParser.prototype.typeArguments = function() {

    var localctx = new TypeArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, JavaParser.RULE_typeArguments);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 609;
        this.match(JavaParser.LT);
        this.state = 610;
        this.typeArgument();
        this.state = 615;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 611;
            this.match(JavaParser.COMMA);
            this.state = 612;
            this.typeArgument();
            this.state = 617;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 618;
        this.match(JavaParser.GT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeArgumentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeArgument;
    return this;
}

TypeArgumentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeArgumentContext.prototype.constructor = TypeArgumentContext;

TypeArgumentContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

TypeArgumentContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeArgument(this);
	}
};

TypeArgumentContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeArgument(this);
	}
};




JavaParser.TypeArgumentContext = TypeArgumentContext;

JavaParser.prototype.typeArgument = function() {

    var localctx = new TypeArgumentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, JavaParser.RULE_typeArgument);
    var _la = 0; // Token type
    try {
        this.state = 626;
        switch(this._input.LA(1)) {
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 620;
            this.type();
            break;
        case JavaParser.QUESTION:
            this.enterOuterAlt(localctx, 2);
            this.state = 621;
            this.match(JavaParser.QUESTION);
            this.state = 624;
            _la = this._input.LA(1);
            if(_la===JavaParser.EXTENDS || _la===JavaParser.SUPER) {
                this.state = 622;
                _la = this._input.LA(1);
                if(!(_la===JavaParser.EXTENDS || _la===JavaParser.SUPER)) {
                this._errHandler.recoverInline(this);
                }
                else {
                    this.consume();
                }
                this.state = 623;
                this.type();
            }

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function QualifiedNameListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_qualifiedNameList;
    return this;
}

QualifiedNameListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
QualifiedNameListContext.prototype.constructor = QualifiedNameListContext;

QualifiedNameListContext.prototype.qualifiedName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(QualifiedNameContext);
    } else {
        return this.getTypedRuleContext(QualifiedNameContext,i);
    }
};

QualifiedNameListContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterQualifiedNameList(this);
	}
};

QualifiedNameListContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitQualifiedNameList(this);
	}
};




JavaParser.QualifiedNameListContext = QualifiedNameListContext;

JavaParser.prototype.qualifiedNameList = function() {

    var localctx = new QualifiedNameListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, JavaParser.RULE_qualifiedNameList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 628;
        this.qualifiedName();
        this.state = 633;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 629;
            this.match(JavaParser.COMMA);
            this.state = 630;
            this.qualifiedName();
            this.state = 635;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FormalParametersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_formalParameters;
    return this;
}

FormalParametersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FormalParametersContext.prototype.constructor = FormalParametersContext;

FormalParametersContext.prototype.formalParameterList = function() {
    return this.getTypedRuleContext(FormalParameterListContext,0);
};

FormalParametersContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterFormalParameters(this);
	}
};

FormalParametersContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitFormalParameters(this);
	}
};




JavaParser.FormalParametersContext = FormalParametersContext;

JavaParser.prototype.formalParameters = function() {

    var localctx = new FormalParametersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, JavaParser.RULE_formalParameters);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 636;
        this.match(JavaParser.LPAREN);
        this.state = 638;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG))) !== 0) || _la===JavaParser.SHORT || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 637;
            this.formalParameterList();
        }

        this.state = 640;
        this.match(JavaParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FormalParameterListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_formalParameterList;
    return this;
}

FormalParameterListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FormalParameterListContext.prototype.constructor = FormalParameterListContext;

FormalParameterListContext.prototype.formalParameter = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(FormalParameterContext);
    } else {
        return this.getTypedRuleContext(FormalParameterContext,i);
    }
};

FormalParameterListContext.prototype.lastFormalParameter = function() {
    return this.getTypedRuleContext(LastFormalParameterContext,0);
};

FormalParameterListContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterFormalParameterList(this);
	}
};

FormalParameterListContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitFormalParameterList(this);
	}
};




JavaParser.FormalParameterListContext = FormalParameterListContext;

JavaParser.prototype.formalParameterList = function() {

    var localctx = new FormalParameterListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, JavaParser.RULE_formalParameterList);
    var _la = 0; // Token type
    try {
        this.state = 655;
        var la_ = this._interp.adaptivePredict(this._input,71,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 642;
            this.formalParameter();
            this.state = 647;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,69,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 643;
                    this.match(JavaParser.COMMA);
                    this.state = 644;
                    this.formalParameter(); 
                }
                this.state = 649;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,69,this._ctx);
            }

            this.state = 652;
            _la = this._input.LA(1);
            if(_la===JavaParser.COMMA) {
                this.state = 650;
                this.match(JavaParser.COMMA);
                this.state = 651;
                this.lastFormalParameter();
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 654;
            this.lastFormalParameter();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FormalParameterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_formalParameter;
    return this;
}

FormalParameterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FormalParameterContext.prototype.constructor = FormalParameterContext;

FormalParameterContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

FormalParameterContext.prototype.variableDeclaratorId = function() {
    return this.getTypedRuleContext(VariableDeclaratorIdContext,0);
};

FormalParameterContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

FormalParameterContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterFormalParameter(this);
	}
};

FormalParameterContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitFormalParameter(this);
	}
};




JavaParser.FormalParameterContext = FormalParameterContext;

JavaParser.prototype.formalParameter = function() {

    var localctx = new FormalParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, JavaParser.RULE_formalParameter);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 660;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 657;
            this.variableModifier();
            this.state = 662;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 663;
        this.type();
        this.state = 664;
        this.variableDeclaratorId();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LastFormalParameterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_lastFormalParameter;
    return this;
}

LastFormalParameterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LastFormalParameterContext.prototype.constructor = LastFormalParameterContext;

LastFormalParameterContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

LastFormalParameterContext.prototype.variableDeclaratorId = function() {
    return this.getTypedRuleContext(VariableDeclaratorIdContext,0);
};

LastFormalParameterContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

LastFormalParameterContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterLastFormalParameter(this);
	}
};

LastFormalParameterContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitLastFormalParameter(this);
	}
};




JavaParser.LastFormalParameterContext = LastFormalParameterContext;

JavaParser.prototype.lastFormalParameter = function() {

    var localctx = new LastFormalParameterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, JavaParser.RULE_lastFormalParameter);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 669;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 666;
            this.variableModifier();
            this.state = 671;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 672;
        this.type();
        this.state = 673;
        this.match(JavaParser.ELLIPSIS);
        this.state = 674;
        this.variableDeclaratorId();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function MethodBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_methodBody;
    return this;
}

MethodBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MethodBodyContext.prototype.constructor = MethodBodyContext;

MethodBodyContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

MethodBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterMethodBody(this);
	}
};

MethodBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitMethodBody(this);
	}
};




JavaParser.MethodBodyContext = MethodBodyContext;

JavaParser.prototype.methodBody = function() {

    var localctx = new MethodBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, JavaParser.RULE_methodBody);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 676;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstructorBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_constructorBody;
    return this;
}

ConstructorBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstructorBodyContext.prototype.constructor = ConstructorBodyContext;

ConstructorBodyContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

ConstructorBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterConstructorBody(this);
	}
};

ConstructorBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitConstructorBody(this);
	}
};




JavaParser.ConstructorBodyContext = ConstructorBodyContext;

JavaParser.prototype.constructorBody = function() {

    var localctx = new ConstructorBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, JavaParser.RULE_constructorBody);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 678;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function QualifiedNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_qualifiedName;
    return this;
}

QualifiedNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
QualifiedNameContext.prototype.constructor = QualifiedNameContext;

QualifiedNameContext.prototype.Identifier = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(JavaParser.Identifier);
    } else {
        return this.getToken(JavaParser.Identifier, i);
    }
};


QualifiedNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterQualifiedName(this);
	}
};

QualifiedNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitQualifiedName(this);
	}
};




JavaParser.QualifiedNameContext = QualifiedNameContext;

JavaParser.prototype.qualifiedName = function() {

    var localctx = new QualifiedNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, JavaParser.RULE_qualifiedName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 680;
        this.match(JavaParser.Identifier);
        this.state = 685;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,74,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 681;
                this.match(JavaParser.DOT);
                this.state = 682;
                this.match(JavaParser.Identifier); 
            }
            this.state = 687;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,74,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_literal;
    return this;
}

LiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LiteralContext.prototype.constructor = LiteralContext;

LiteralContext.prototype.IntegerLiteral = function() {
    return this.getToken(JavaParser.IntegerLiteral, 0);
};

LiteralContext.prototype.FloatingPointLiteral = function() {
    return this.getToken(JavaParser.FloatingPointLiteral, 0);
};

LiteralContext.prototype.CharacterLiteral = function() {
    return this.getToken(JavaParser.CharacterLiteral, 0);
};

LiteralContext.prototype.StringLiteral = function() {
    return this.getToken(JavaParser.StringLiteral, 0);
};

LiteralContext.prototype.BooleanLiteral = function() {
    return this.getToken(JavaParser.BooleanLiteral, 0);
};

LiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterLiteral(this);
	}
};

LiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitLiteral(this);
	}
};




JavaParser.LiteralContext = LiteralContext;

JavaParser.prototype.literal = function() {

    var localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, JavaParser.RULE_literal);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 688;
        _la = this._input.LA(1);
        if(!(((((_la - 51)) & ~0x1f) == 0 && ((1 << (_la - 51)) & ((1 << (JavaParser.IntegerLiteral - 51)) | (1 << (JavaParser.FloatingPointLiteral - 51)) | (1 << (JavaParser.BooleanLiteral - 51)) | (1 << (JavaParser.CharacterLiteral - 51)) | (1 << (JavaParser.StringLiteral - 51)) | (1 << (JavaParser.NullLiteral - 51)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotation;
    return this;
}

AnnotationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationContext.prototype.constructor = AnnotationContext;

AnnotationContext.prototype.annotationName = function() {
    return this.getTypedRuleContext(AnnotationNameContext,0);
};

AnnotationContext.prototype.elementValuePairs = function() {
    return this.getTypedRuleContext(ElementValuePairsContext,0);
};

AnnotationContext.prototype.elementValue = function() {
    return this.getTypedRuleContext(ElementValueContext,0);
};

AnnotationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotation(this);
	}
};

AnnotationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotation(this);
	}
};




JavaParser.AnnotationContext = AnnotationContext;

JavaParser.prototype.annotation = function() {

    var localctx = new AnnotationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, JavaParser.RULE_annotation);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 690;
        this.match(JavaParser.AT);
        this.state = 691;
        this.annotationName();
        this.state = 698;
        _la = this._input.LA(1);
        if(_la===JavaParser.LPAREN) {
            this.state = 692;
            this.match(JavaParser.LPAREN);
            this.state = 695;
            var la_ = this._interp.adaptivePredict(this._input,75,this._ctx);
            if(la_===1) {
                this.state = 693;
                this.elementValuePairs();

            } else if(la_===2) {
                this.state = 694;
                this.elementValue();

            }
            this.state = 697;
            this.match(JavaParser.RPAREN);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationName;
    return this;
}

AnnotationNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationNameContext.prototype.constructor = AnnotationNameContext;

AnnotationNameContext.prototype.qualifiedName = function() {
    return this.getTypedRuleContext(QualifiedNameContext,0);
};

AnnotationNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationName(this);
	}
};

AnnotationNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationName(this);
	}
};




JavaParser.AnnotationNameContext = AnnotationNameContext;

JavaParser.prototype.annotationName = function() {

    var localctx = new AnnotationNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, JavaParser.RULE_annotationName);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 700;
        this.qualifiedName();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementValuePairsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_elementValuePairs;
    return this;
}

ElementValuePairsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementValuePairsContext.prototype.constructor = ElementValuePairsContext;

ElementValuePairsContext.prototype.elementValuePair = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ElementValuePairContext);
    } else {
        return this.getTypedRuleContext(ElementValuePairContext,i);
    }
};

ElementValuePairsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterElementValuePairs(this);
	}
};

ElementValuePairsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitElementValuePairs(this);
	}
};




JavaParser.ElementValuePairsContext = ElementValuePairsContext;

JavaParser.prototype.elementValuePairs = function() {

    var localctx = new ElementValuePairsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, JavaParser.RULE_elementValuePairs);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 702;
        this.elementValuePair();
        this.state = 707;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 703;
            this.match(JavaParser.COMMA);
            this.state = 704;
            this.elementValuePair();
            this.state = 709;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementValuePairContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_elementValuePair;
    return this;
}

ElementValuePairContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementValuePairContext.prototype.constructor = ElementValuePairContext;

ElementValuePairContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ElementValuePairContext.prototype.elementValue = function() {
    return this.getTypedRuleContext(ElementValueContext,0);
};

ElementValuePairContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterElementValuePair(this);
	}
};

ElementValuePairContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitElementValuePair(this);
	}
};




JavaParser.ElementValuePairContext = ElementValuePairContext;

JavaParser.prototype.elementValuePair = function() {

    var localctx = new ElementValuePairContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, JavaParser.RULE_elementValuePair);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 710;
        this.match(JavaParser.Identifier);
        this.state = 711;
        this.match(JavaParser.ASSIGN);
        this.state = 712;
        this.elementValue();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementValueContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_elementValue;
    return this;
}

ElementValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementValueContext.prototype.constructor = ElementValueContext;

ElementValueContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ElementValueContext.prototype.annotation = function() {
    return this.getTypedRuleContext(AnnotationContext,0);
};

ElementValueContext.prototype.elementValueArrayInitializer = function() {
    return this.getTypedRuleContext(ElementValueArrayInitializerContext,0);
};

ElementValueContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterElementValue(this);
	}
};

ElementValueContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitElementValue(this);
	}
};




JavaParser.ElementValueContext = ElementValueContext;

JavaParser.prototype.elementValue = function() {

    var localctx = new ElementValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, JavaParser.RULE_elementValue);
    try {
        this.state = 717;
        switch(this._input.LA(1)) {
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.NEW:
        case JavaParser.SHORT:
        case JavaParser.SUPER:
        case JavaParser.THIS:
        case JavaParser.VOID:
        case JavaParser.IntegerLiteral:
        case JavaParser.FloatingPointLiteral:
        case JavaParser.BooleanLiteral:
        case JavaParser.CharacterLiteral:
        case JavaParser.StringLiteral:
        case JavaParser.NullLiteral:
        case JavaParser.LPAREN:
        case JavaParser.LT:
        case JavaParser.BANG:
        case JavaParser.TILDE:
        case JavaParser.INC:
        case JavaParser.DEC:
        case JavaParser.ADD:
        case JavaParser.SUB:
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 714;
            this.expression(0);
            break;
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 2);
            this.state = 715;
            this.annotation();
            break;
        case JavaParser.LBRACE:
            this.enterOuterAlt(localctx, 3);
            this.state = 716;
            this.elementValueArrayInitializer();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ElementValueArrayInitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_elementValueArrayInitializer;
    return this;
}

ElementValueArrayInitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ElementValueArrayInitializerContext.prototype.constructor = ElementValueArrayInitializerContext;

ElementValueArrayInitializerContext.prototype.elementValue = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ElementValueContext);
    } else {
        return this.getTypedRuleContext(ElementValueContext,i);
    }
};

ElementValueArrayInitializerContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterElementValueArrayInitializer(this);
	}
};

ElementValueArrayInitializerContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitElementValueArrayInitializer(this);
	}
};




JavaParser.ElementValueArrayInitializerContext = ElementValueArrayInitializerContext;

JavaParser.prototype.elementValueArrayInitializer = function() {

    var localctx = new ElementValueArrayInitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, JavaParser.RULE_elementValueArrayInitializer);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 719;
        this.match(JavaParser.LBRACE);
        this.state = 728;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LBRACE - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0) || _la===JavaParser.AT) {
            this.state = 720;
            this.elementValue();
            this.state = 725;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,79,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 721;
                    this.match(JavaParser.COMMA);
                    this.state = 722;
                    this.elementValue(); 
                }
                this.state = 727;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,79,this._ctx);
            }

        }

        this.state = 731;
        _la = this._input.LA(1);
        if(_la===JavaParser.COMMA) {
            this.state = 730;
            this.match(JavaParser.COMMA);
        }

        this.state = 733;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationTypeDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationTypeDeclaration;
    return this;
}

AnnotationTypeDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationTypeDeclarationContext.prototype.constructor = AnnotationTypeDeclarationContext;

AnnotationTypeDeclarationContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

AnnotationTypeDeclarationContext.prototype.annotationTypeBody = function() {
    return this.getTypedRuleContext(AnnotationTypeBodyContext,0);
};

AnnotationTypeDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationTypeDeclaration(this);
	}
};

AnnotationTypeDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationTypeDeclaration(this);
	}
};




JavaParser.AnnotationTypeDeclarationContext = AnnotationTypeDeclarationContext;

JavaParser.prototype.annotationTypeDeclaration = function() {

    var localctx = new AnnotationTypeDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, JavaParser.RULE_annotationTypeDeclaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 735;
        this.match(JavaParser.AT);
        this.state = 736;
        this.match(JavaParser.INTERFACE);
        this.state = 737;
        this.match(JavaParser.Identifier);
        this.state = 738;
        this.annotationTypeBody();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationTypeBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationTypeBody;
    return this;
}

AnnotationTypeBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationTypeBodyContext.prototype.constructor = AnnotationTypeBodyContext;

AnnotationTypeBodyContext.prototype.annotationTypeElementDeclaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationTypeElementDeclarationContext);
    } else {
        return this.getTypedRuleContext(AnnotationTypeElementDeclarationContext,i);
    }
};

AnnotationTypeBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationTypeBody(this);
	}
};

AnnotationTypeBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationTypeBody(this);
	}
};




JavaParser.AnnotationTypeBodyContext = AnnotationTypeBodyContext;

JavaParser.prototype.annotationTypeBody = function() {

    var localctx = new AnnotationTypeBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 118, JavaParser.RULE_annotationTypeBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 740;
        this.match(JavaParser.LBRACE);
        this.state = 744;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NATIVE))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.TRANSIENT - 33)) | (1 << (JavaParser.VOLATILE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 741;
            this.annotationTypeElementDeclaration();
            this.state = 746;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 747;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationTypeElementDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationTypeElementDeclaration;
    return this;
}

AnnotationTypeElementDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationTypeElementDeclarationContext.prototype.constructor = AnnotationTypeElementDeclarationContext;

AnnotationTypeElementDeclarationContext.prototype.annotationTypeElementRest = function() {
    return this.getTypedRuleContext(AnnotationTypeElementRestContext,0);
};

AnnotationTypeElementDeclarationContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

AnnotationTypeElementDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationTypeElementDeclaration(this);
	}
};

AnnotationTypeElementDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationTypeElementDeclaration(this);
	}
};




JavaParser.AnnotationTypeElementDeclarationContext = AnnotationTypeElementDeclarationContext;

JavaParser.prototype.annotationTypeElementDeclaration = function() {

    var localctx = new AnnotationTypeElementDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, JavaParser.RULE_annotationTypeElementDeclaration);
    try {
        this.state = 757;
        switch(this._input.LA(1)) {
        case JavaParser.ABSTRACT:
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.CLASS:
        case JavaParser.DOUBLE:
        case JavaParser.ENUM:
        case JavaParser.FINAL:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.INTERFACE:
        case JavaParser.LONG:
        case JavaParser.NATIVE:
        case JavaParser.PRIVATE:
        case JavaParser.PROTECTED:
        case JavaParser.PUBLIC:
        case JavaParser.SHORT:
        case JavaParser.STATIC:
        case JavaParser.STRICTFP:
        case JavaParser.SYNCHRONIZED:
        case JavaParser.TRANSIENT:
        case JavaParser.VOLATILE:
        case JavaParser.Identifier:
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 1);
            this.state = 752;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,83,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 749;
                    this.modifier(); 
                }
                this.state = 754;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,83,this._ctx);
            }

            this.state = 755;
            this.annotationTypeElementRest();
            break;
        case JavaParser.SEMI:
            this.enterOuterAlt(localctx, 2);
            this.state = 756;
            this.match(JavaParser.SEMI);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationTypeElementRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationTypeElementRest;
    return this;
}

AnnotationTypeElementRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationTypeElementRestContext.prototype.constructor = AnnotationTypeElementRestContext;

AnnotationTypeElementRestContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

AnnotationTypeElementRestContext.prototype.annotationMethodOrConstantRest = function() {
    return this.getTypedRuleContext(AnnotationMethodOrConstantRestContext,0);
};

AnnotationTypeElementRestContext.prototype.classDeclaration = function() {
    return this.getTypedRuleContext(ClassDeclarationContext,0);
};

AnnotationTypeElementRestContext.prototype.interfaceDeclaration = function() {
    return this.getTypedRuleContext(InterfaceDeclarationContext,0);
};

AnnotationTypeElementRestContext.prototype.enumDeclaration = function() {
    return this.getTypedRuleContext(EnumDeclarationContext,0);
};

AnnotationTypeElementRestContext.prototype.annotationTypeDeclaration = function() {
    return this.getTypedRuleContext(AnnotationTypeDeclarationContext,0);
};

AnnotationTypeElementRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationTypeElementRest(this);
	}
};

AnnotationTypeElementRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationTypeElementRest(this);
	}
};




JavaParser.AnnotationTypeElementRestContext = AnnotationTypeElementRestContext;

JavaParser.prototype.annotationTypeElementRest = function() {

    var localctx = new AnnotationTypeElementRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, JavaParser.RULE_annotationTypeElementRest);
    try {
        this.state = 779;
        switch(this._input.LA(1)) {
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 759;
            this.type();
            this.state = 760;
            this.annotationMethodOrConstantRest();
            this.state = 761;
            this.match(JavaParser.SEMI);
            break;
        case JavaParser.CLASS:
            this.enterOuterAlt(localctx, 2);
            this.state = 763;
            this.classDeclaration();
            this.state = 765;
            var la_ = this._interp.adaptivePredict(this._input,85,this._ctx);
            if(la_===1) {
                this.state = 764;
                this.match(JavaParser.SEMI);

            }
            break;
        case JavaParser.INTERFACE:
            this.enterOuterAlt(localctx, 3);
            this.state = 767;
            this.interfaceDeclaration();
            this.state = 769;
            var la_ = this._interp.adaptivePredict(this._input,86,this._ctx);
            if(la_===1) {
                this.state = 768;
                this.match(JavaParser.SEMI);

            }
            break;
        case JavaParser.ENUM:
            this.enterOuterAlt(localctx, 4);
            this.state = 771;
            this.enumDeclaration();
            this.state = 773;
            var la_ = this._interp.adaptivePredict(this._input,87,this._ctx);
            if(la_===1) {
                this.state = 772;
                this.match(JavaParser.SEMI);

            }
            break;
        case JavaParser.AT:
            this.enterOuterAlt(localctx, 5);
            this.state = 775;
            this.annotationTypeDeclaration();
            this.state = 777;
            var la_ = this._interp.adaptivePredict(this._input,88,this._ctx);
            if(la_===1) {
                this.state = 776;
                this.match(JavaParser.SEMI);

            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationMethodOrConstantRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationMethodOrConstantRest;
    return this;
}

AnnotationMethodOrConstantRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationMethodOrConstantRestContext.prototype.constructor = AnnotationMethodOrConstantRestContext;

AnnotationMethodOrConstantRestContext.prototype.annotationMethodRest = function() {
    return this.getTypedRuleContext(AnnotationMethodRestContext,0);
};

AnnotationMethodOrConstantRestContext.prototype.annotationConstantRest = function() {
    return this.getTypedRuleContext(AnnotationConstantRestContext,0);
};

AnnotationMethodOrConstantRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationMethodOrConstantRest(this);
	}
};

AnnotationMethodOrConstantRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationMethodOrConstantRest(this);
	}
};




JavaParser.AnnotationMethodOrConstantRestContext = AnnotationMethodOrConstantRestContext;

JavaParser.prototype.annotationMethodOrConstantRest = function() {

    var localctx = new AnnotationMethodOrConstantRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 124, JavaParser.RULE_annotationMethodOrConstantRest);
    try {
        this.state = 783;
        var la_ = this._interp.adaptivePredict(this._input,90,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 781;
            this.annotationMethodRest();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 782;
            this.annotationConstantRest();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationMethodRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationMethodRest;
    return this;
}

AnnotationMethodRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationMethodRestContext.prototype.constructor = AnnotationMethodRestContext;

AnnotationMethodRestContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

AnnotationMethodRestContext.prototype.defaultValue = function() {
    return this.getTypedRuleContext(DefaultValueContext,0);
};

AnnotationMethodRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationMethodRest(this);
	}
};

AnnotationMethodRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationMethodRest(this);
	}
};




JavaParser.AnnotationMethodRestContext = AnnotationMethodRestContext;

JavaParser.prototype.annotationMethodRest = function() {

    var localctx = new AnnotationMethodRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, JavaParser.RULE_annotationMethodRest);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 785;
        this.match(JavaParser.Identifier);
        this.state = 786;
        this.match(JavaParser.LPAREN);
        this.state = 787;
        this.match(JavaParser.RPAREN);
        this.state = 789;
        _la = this._input.LA(1);
        if(_la===JavaParser.DEFAULT) {
            this.state = 788;
            this.defaultValue();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationConstantRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_annotationConstantRest;
    return this;
}

AnnotationConstantRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationConstantRestContext.prototype.constructor = AnnotationConstantRestContext;

AnnotationConstantRestContext.prototype.variableDeclarators = function() {
    return this.getTypedRuleContext(VariableDeclaratorsContext,0);
};

AnnotationConstantRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterAnnotationConstantRest(this);
	}
};

AnnotationConstantRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitAnnotationConstantRest(this);
	}
};




JavaParser.AnnotationConstantRestContext = AnnotationConstantRestContext;

JavaParser.prototype.annotationConstantRest = function() {

    var localctx = new AnnotationConstantRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, JavaParser.RULE_annotationConstantRest);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 791;
        this.variableDeclarators();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DefaultValueContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_defaultValue;
    return this;
}

DefaultValueContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DefaultValueContext.prototype.constructor = DefaultValueContext;

DefaultValueContext.prototype.elementValue = function() {
    return this.getTypedRuleContext(ElementValueContext,0);
};

DefaultValueContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterDefaultValue(this);
	}
};

DefaultValueContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitDefaultValue(this);
	}
};




JavaParser.DefaultValueContext = DefaultValueContext;

JavaParser.prototype.defaultValue = function() {

    var localctx = new DefaultValueContext(this, this._ctx, this.state);
    this.enterRule(localctx, 130, JavaParser.RULE_defaultValue);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 793;
        this.match(JavaParser.DEFAULT);
        this.state = 794;
        this.elementValue();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_block;
    return this;
}

BlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockContext.prototype.constructor = BlockContext;

BlockContext.prototype.blockStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BlockStatementContext);
    } else {
        return this.getTypedRuleContext(BlockStatementContext,i);
    }
};

BlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterBlock(this);
	}
};

BlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitBlock(this);
	}
};




JavaParser.BlockContext = BlockContext;

JavaParser.prototype.block = function() {

    var localctx = new BlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, JavaParser.RULE_block);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 796;
        this.match(JavaParser.LBRACE);
        this.state = 800;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.ASSERT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BREAK) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.CONTINUE) | (1 << JavaParser.DO) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.FOR) | (1 << JavaParser.IF) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.RETURN - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SUPER - 33)) | (1 << (JavaParser.SWITCH - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.THIS - 33)) | (1 << (JavaParser.THROW - 33)) | (1 << (JavaParser.TRY - 33)) | (1 << (JavaParser.VOID - 33)) | (1 << (JavaParser.WHILE - 33)) | (1 << (JavaParser.IntegerLiteral - 33)) | (1 << (JavaParser.FloatingPointLiteral - 33)) | (1 << (JavaParser.BooleanLiteral - 33)) | (1 << (JavaParser.CharacterLiteral - 33)) | (1 << (JavaParser.StringLiteral - 33)) | (1 << (JavaParser.NullLiteral - 33)) | (1 << (JavaParser.LPAREN - 33)) | (1 << (JavaParser.LBRACE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || ((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (JavaParser.LT - 68)) | (1 << (JavaParser.BANG - 68)) | (1 << (JavaParser.TILDE - 68)) | (1 << (JavaParser.INC - 68)) | (1 << (JavaParser.DEC - 68)) | (1 << (JavaParser.ADD - 68)) | (1 << (JavaParser.SUB - 68)))) !== 0) || _la===JavaParser.Identifier || _la===JavaParser.AT) {
            this.state = 797;
            this.blockStatement();
            this.state = 802;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 803;
        this.match(JavaParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_blockStatement;
    return this;
}

BlockStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockStatementContext.prototype.constructor = BlockStatementContext;

BlockStatementContext.prototype.localVariableDeclarationStatement = function() {
    return this.getTypedRuleContext(LocalVariableDeclarationStatementContext,0);
};

BlockStatementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

BlockStatementContext.prototype.typeDeclaration = function() {
    return this.getTypedRuleContext(TypeDeclarationContext,0);
};

BlockStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterBlockStatement(this);
	}
};

BlockStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitBlockStatement(this);
	}
};




JavaParser.BlockStatementContext = BlockStatementContext;

JavaParser.prototype.blockStatement = function() {

    var localctx = new BlockStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 134, JavaParser.RULE_blockStatement);
    try {
        this.state = 808;
        var la_ = this._interp.adaptivePredict(this._input,93,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 805;
            this.localVariableDeclarationStatement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 806;
            this.statement();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 807;
            this.typeDeclaration();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LocalVariableDeclarationStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_localVariableDeclarationStatement;
    return this;
}

LocalVariableDeclarationStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LocalVariableDeclarationStatementContext.prototype.constructor = LocalVariableDeclarationStatementContext;

LocalVariableDeclarationStatementContext.prototype.localVariableDeclaration = function() {
    return this.getTypedRuleContext(LocalVariableDeclarationContext,0);
};

LocalVariableDeclarationStatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterLocalVariableDeclarationStatement(this);
	}
};

LocalVariableDeclarationStatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitLocalVariableDeclarationStatement(this);
	}
};




JavaParser.LocalVariableDeclarationStatementContext = LocalVariableDeclarationStatementContext;

JavaParser.prototype.localVariableDeclarationStatement = function() {

    var localctx = new LocalVariableDeclarationStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, JavaParser.RULE_localVariableDeclarationStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 810;
        this.localVariableDeclaration();
        this.state = 811;
        this.match(JavaParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LocalVariableDeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_localVariableDeclaration;
    return this;
}

LocalVariableDeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LocalVariableDeclarationContext.prototype.constructor = LocalVariableDeclarationContext;

LocalVariableDeclarationContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

LocalVariableDeclarationContext.prototype.variableDeclarators = function() {
    return this.getTypedRuleContext(VariableDeclaratorsContext,0);
};

LocalVariableDeclarationContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

LocalVariableDeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterLocalVariableDeclaration(this);
	}
};

LocalVariableDeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitLocalVariableDeclaration(this);
	}
};




JavaParser.LocalVariableDeclarationContext = LocalVariableDeclarationContext;

JavaParser.prototype.localVariableDeclaration = function() {

    var localctx = new LocalVariableDeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, JavaParser.RULE_localVariableDeclaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 816;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 813;
            this.variableModifier();
            this.state = 818;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 819;
        this.type();
        this.state = 820;
        this.variableDeclarators();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;

StatementContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

StatementContext.prototype.ASSERT = function() {
    return this.getToken(JavaParser.ASSERT, 0);
};

StatementContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

StatementContext.prototype.parExpression = function() {
    return this.getTypedRuleContext(ParExpressionContext,0);
};

StatementContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

StatementContext.prototype.forControl = function() {
    return this.getTypedRuleContext(ForControlContext,0);
};

StatementContext.prototype.finallyBlock = function() {
    return this.getTypedRuleContext(FinallyBlockContext,0);
};

StatementContext.prototype.catchClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CatchClauseContext);
    } else {
        return this.getTypedRuleContext(CatchClauseContext,i);
    }
};

StatementContext.prototype.resourceSpecification = function() {
    return this.getTypedRuleContext(ResourceSpecificationContext,0);
};

StatementContext.prototype.switchBlockStatementGroup = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SwitchBlockStatementGroupContext);
    } else {
        return this.getTypedRuleContext(SwitchBlockStatementGroupContext,i);
    }
};

StatementContext.prototype.switchLabel = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SwitchLabelContext);
    } else {
        return this.getTypedRuleContext(SwitchLabelContext,i);
    }
};

StatementContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

StatementContext.prototype.statementExpression = function() {
    return this.getTypedRuleContext(StatementExpressionContext,0);
};

StatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterStatement(this);
	}
};

StatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitStatement(this);
	}
};




JavaParser.StatementContext = StatementContext;

JavaParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, JavaParser.RULE_statement);
    var _la = 0; // Token type
    try {
        this.state = 926;
        var la_ = this._interp.adaptivePredict(this._input,107,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 822;
            this.block();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 823;
            this.match(JavaParser.ASSERT);
            this.state = 824;
            this.expression(0);
            this.state = 827;
            _la = this._input.LA(1);
            if(_la===JavaParser.COLON) {
                this.state = 825;
                this.match(JavaParser.COLON);
                this.state = 826;
                this.expression(0);
            }

            this.state = 829;
            this.match(JavaParser.SEMI);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 831;
            this.match(JavaParser.IF);
            this.state = 832;
            this.parExpression();
            this.state = 833;
            this.statement();
            this.state = 836;
            var la_ = this._interp.adaptivePredict(this._input,96,this._ctx);
            if(la_===1) {
                this.state = 834;
                this.match(JavaParser.ELSE);
                this.state = 835;
                this.statement();

            }
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 838;
            this.match(JavaParser.FOR);
            this.state = 839;
            this.match(JavaParser.LPAREN);
            this.state = 840;
            this.forControl();
            this.state = 841;
            this.match(JavaParser.RPAREN);
            this.state = 842;
            this.statement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 844;
            this.match(JavaParser.WHILE);
            this.state = 845;
            this.parExpression();
            this.state = 846;
            this.statement();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 848;
            this.match(JavaParser.DO);
            this.state = 849;
            this.statement();
            this.state = 850;
            this.match(JavaParser.WHILE);
            this.state = 851;
            this.parExpression();
            this.state = 852;
            this.match(JavaParser.SEMI);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 854;
            this.match(JavaParser.TRY);
            this.state = 855;
            this.block();
            this.state = 865;
            switch(this._input.LA(1)) {
            case JavaParser.CATCH:
                this.state = 857; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                do {
                    this.state = 856;
                    this.catchClause();
                    this.state = 859; 
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                } while(_la===JavaParser.CATCH);
                this.state = 862;
                _la = this._input.LA(1);
                if(_la===JavaParser.FINALLY) {
                    this.state = 861;
                    this.finallyBlock();
                }

                break;
            case JavaParser.FINALLY:
                this.state = 864;
                this.finallyBlock();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 867;
            this.match(JavaParser.TRY);
            this.state = 868;
            this.resourceSpecification();
            this.state = 869;
            this.block();
            this.state = 873;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.CATCH) {
                this.state = 870;
                this.catchClause();
                this.state = 875;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 877;
            _la = this._input.LA(1);
            if(_la===JavaParser.FINALLY) {
                this.state = 876;
                this.finallyBlock();
            }

            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 879;
            this.match(JavaParser.SWITCH);
            this.state = 880;
            this.parExpression();
            this.state = 881;
            this.match(JavaParser.LBRACE);
            this.state = 885;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,102,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 882;
                    this.switchBlockStatementGroup(); 
                }
                this.state = 887;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,102,this._ctx);
            }

            this.state = 891;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.CASE || _la===JavaParser.DEFAULT) {
                this.state = 888;
                this.switchLabel();
                this.state = 893;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 894;
            this.match(JavaParser.RBRACE);
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 896;
            this.match(JavaParser.SYNCHRONIZED);
            this.state = 897;
            this.parExpression();
            this.state = 898;
            this.block();
            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 900;
            this.match(JavaParser.RETURN);
            this.state = 902;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
                this.state = 901;
                this.expression(0);
            }

            this.state = 904;
            this.match(JavaParser.SEMI);
            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 905;
            this.match(JavaParser.THROW);
            this.state = 906;
            this.expression(0);
            this.state = 907;
            this.match(JavaParser.SEMI);
            break;

        case 13:
            this.enterOuterAlt(localctx, 13);
            this.state = 909;
            this.match(JavaParser.BREAK);
            this.state = 911;
            _la = this._input.LA(1);
            if(_la===JavaParser.Identifier) {
                this.state = 910;
                this.match(JavaParser.Identifier);
            }

            this.state = 913;
            this.match(JavaParser.SEMI);
            break;

        case 14:
            this.enterOuterAlt(localctx, 14);
            this.state = 914;
            this.match(JavaParser.CONTINUE);
            this.state = 916;
            _la = this._input.LA(1);
            if(_la===JavaParser.Identifier) {
                this.state = 915;
                this.match(JavaParser.Identifier);
            }

            this.state = 918;
            this.match(JavaParser.SEMI);
            break;

        case 15:
            this.enterOuterAlt(localctx, 15);
            this.state = 919;
            this.match(JavaParser.SEMI);
            break;

        case 16:
            this.enterOuterAlt(localctx, 16);
            this.state = 920;
            this.statementExpression();
            this.state = 921;
            this.match(JavaParser.SEMI);
            break;

        case 17:
            this.enterOuterAlt(localctx, 17);
            this.state = 923;
            this.match(JavaParser.Identifier);
            this.state = 924;
            this.match(JavaParser.COLON);
            this.state = 925;
            this.statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CatchClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_catchClause;
    return this;
}

CatchClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CatchClauseContext.prototype.constructor = CatchClauseContext;

CatchClauseContext.prototype.catchType = function() {
    return this.getTypedRuleContext(CatchTypeContext,0);
};

CatchClauseContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

CatchClauseContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

CatchClauseContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

CatchClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterCatchClause(this);
	}
};

CatchClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitCatchClause(this);
	}
};




JavaParser.CatchClauseContext = CatchClauseContext;

JavaParser.prototype.catchClause = function() {

    var localctx = new CatchClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, JavaParser.RULE_catchClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 928;
        this.match(JavaParser.CATCH);
        this.state = 929;
        this.match(JavaParser.LPAREN);
        this.state = 933;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 930;
            this.variableModifier();
            this.state = 935;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 936;
        this.catchType();
        this.state = 937;
        this.match(JavaParser.Identifier);
        this.state = 938;
        this.match(JavaParser.RPAREN);
        this.state = 939;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CatchTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_catchType;
    return this;
}

CatchTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CatchTypeContext.prototype.constructor = CatchTypeContext;

CatchTypeContext.prototype.qualifiedName = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(QualifiedNameContext);
    } else {
        return this.getTypedRuleContext(QualifiedNameContext,i);
    }
};

CatchTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterCatchType(this);
	}
};

CatchTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitCatchType(this);
	}
};




JavaParser.CatchTypeContext = CatchTypeContext;

JavaParser.prototype.catchType = function() {

    var localctx = new CatchTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, JavaParser.RULE_catchType);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 941;
        this.qualifiedName();
        this.state = 946;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.BITOR) {
            this.state = 942;
            this.match(JavaParser.BITOR);
            this.state = 943;
            this.qualifiedName();
            this.state = 948;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FinallyBlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_finallyBlock;
    return this;
}

FinallyBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FinallyBlockContext.prototype.constructor = FinallyBlockContext;

FinallyBlockContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

FinallyBlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterFinallyBlock(this);
	}
};

FinallyBlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitFinallyBlock(this);
	}
};




JavaParser.FinallyBlockContext = FinallyBlockContext;

JavaParser.prototype.finallyBlock = function() {

    var localctx = new FinallyBlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 146, JavaParser.RULE_finallyBlock);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 949;
        this.match(JavaParser.FINALLY);
        this.state = 950;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ResourceSpecificationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_resourceSpecification;
    return this;
}

ResourceSpecificationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ResourceSpecificationContext.prototype.constructor = ResourceSpecificationContext;

ResourceSpecificationContext.prototype.resources = function() {
    return this.getTypedRuleContext(ResourcesContext,0);
};

ResourceSpecificationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterResourceSpecification(this);
	}
};

ResourceSpecificationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitResourceSpecification(this);
	}
};




JavaParser.ResourceSpecificationContext = ResourceSpecificationContext;

JavaParser.prototype.resourceSpecification = function() {

    var localctx = new ResourceSpecificationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, JavaParser.RULE_resourceSpecification);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 952;
        this.match(JavaParser.LPAREN);
        this.state = 953;
        this.resources();
        this.state = 955;
        _la = this._input.LA(1);
        if(_la===JavaParser.SEMI) {
            this.state = 954;
            this.match(JavaParser.SEMI);
        }

        this.state = 957;
        this.match(JavaParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ResourcesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_resources;
    return this;
}

ResourcesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ResourcesContext.prototype.constructor = ResourcesContext;

ResourcesContext.prototype.resource = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ResourceContext);
    } else {
        return this.getTypedRuleContext(ResourceContext,i);
    }
};

ResourcesContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterResources(this);
	}
};

ResourcesContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitResources(this);
	}
};




JavaParser.ResourcesContext = ResourcesContext;

JavaParser.prototype.resources = function() {

    var localctx = new ResourcesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, JavaParser.RULE_resources);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 959;
        this.resource();
        this.state = 964;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,111,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 960;
                this.match(JavaParser.SEMI);
                this.state = 961;
                this.resource(); 
            }
            this.state = 966;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,111,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ResourceContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_resource;
    return this;
}

ResourceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ResourceContext.prototype.constructor = ResourceContext;

ResourceContext.prototype.classOrInterfaceType = function() {
    return this.getTypedRuleContext(ClassOrInterfaceTypeContext,0);
};

ResourceContext.prototype.variableDeclaratorId = function() {
    return this.getTypedRuleContext(VariableDeclaratorIdContext,0);
};

ResourceContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ResourceContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

ResourceContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterResource(this);
	}
};

ResourceContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitResource(this);
	}
};




JavaParser.ResourceContext = ResourceContext;

JavaParser.prototype.resource = function() {

    var localctx = new ResourceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, JavaParser.RULE_resource);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 970;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 967;
            this.variableModifier();
            this.state = 972;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 973;
        this.classOrInterfaceType();
        this.state = 974;
        this.variableDeclaratorId();
        this.state = 975;
        this.match(JavaParser.ASSIGN);
        this.state = 976;
        this.expression(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SwitchBlockStatementGroupContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_switchBlockStatementGroup;
    return this;
}

SwitchBlockStatementGroupContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SwitchBlockStatementGroupContext.prototype.constructor = SwitchBlockStatementGroupContext;

SwitchBlockStatementGroupContext.prototype.switchLabel = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SwitchLabelContext);
    } else {
        return this.getTypedRuleContext(SwitchLabelContext,i);
    }
};

SwitchBlockStatementGroupContext.prototype.blockStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BlockStatementContext);
    } else {
        return this.getTypedRuleContext(BlockStatementContext,i);
    }
};

SwitchBlockStatementGroupContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterSwitchBlockStatementGroup(this);
	}
};

SwitchBlockStatementGroupContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitSwitchBlockStatementGroup(this);
	}
};




JavaParser.SwitchBlockStatementGroupContext = SwitchBlockStatementGroupContext;

JavaParser.prototype.switchBlockStatementGroup = function() {

    var localctx = new SwitchBlockStatementGroupContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, JavaParser.RULE_switchBlockStatementGroup);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 979; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 978;
            this.switchLabel();
            this.state = 981; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===JavaParser.CASE || _la===JavaParser.DEFAULT);
        this.state = 984; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 983;
            this.blockStatement();
            this.state = 986; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.ABSTRACT) | (1 << JavaParser.ASSERT) | (1 << JavaParser.BOOLEAN) | (1 << JavaParser.BREAK) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.CLASS) | (1 << JavaParser.CONTINUE) | (1 << JavaParser.DO) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.ENUM) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.FOR) | (1 << JavaParser.IF) | (1 << JavaParser.INT) | (1 << JavaParser.INTERFACE) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 33)) & ~0x1f) == 0 && ((1 << (_la - 33)) & ((1 << (JavaParser.PRIVATE - 33)) | (1 << (JavaParser.PROTECTED - 33)) | (1 << (JavaParser.PUBLIC - 33)) | (1 << (JavaParser.RETURN - 33)) | (1 << (JavaParser.SHORT - 33)) | (1 << (JavaParser.STATIC - 33)) | (1 << (JavaParser.STRICTFP - 33)) | (1 << (JavaParser.SUPER - 33)) | (1 << (JavaParser.SWITCH - 33)) | (1 << (JavaParser.SYNCHRONIZED - 33)) | (1 << (JavaParser.THIS - 33)) | (1 << (JavaParser.THROW - 33)) | (1 << (JavaParser.TRY - 33)) | (1 << (JavaParser.VOID - 33)) | (1 << (JavaParser.WHILE - 33)) | (1 << (JavaParser.IntegerLiteral - 33)) | (1 << (JavaParser.FloatingPointLiteral - 33)) | (1 << (JavaParser.BooleanLiteral - 33)) | (1 << (JavaParser.CharacterLiteral - 33)) | (1 << (JavaParser.StringLiteral - 33)) | (1 << (JavaParser.NullLiteral - 33)) | (1 << (JavaParser.LPAREN - 33)) | (1 << (JavaParser.LBRACE - 33)) | (1 << (JavaParser.SEMI - 33)))) !== 0) || ((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (JavaParser.LT - 68)) | (1 << (JavaParser.BANG - 68)) | (1 << (JavaParser.TILDE - 68)) | (1 << (JavaParser.INC - 68)) | (1 << (JavaParser.DEC - 68)) | (1 << (JavaParser.ADD - 68)) | (1 << (JavaParser.SUB - 68)))) !== 0) || _la===JavaParser.Identifier || _la===JavaParser.AT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SwitchLabelContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_switchLabel;
    return this;
}

SwitchLabelContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SwitchLabelContext.prototype.constructor = SwitchLabelContext;

SwitchLabelContext.prototype.constantExpression = function() {
    return this.getTypedRuleContext(ConstantExpressionContext,0);
};

SwitchLabelContext.prototype.enumConstantName = function() {
    return this.getTypedRuleContext(EnumConstantNameContext,0);
};

SwitchLabelContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterSwitchLabel(this);
	}
};

SwitchLabelContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitSwitchLabel(this);
	}
};




JavaParser.SwitchLabelContext = SwitchLabelContext;

JavaParser.prototype.switchLabel = function() {

    var localctx = new SwitchLabelContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, JavaParser.RULE_switchLabel);
    try {
        this.state = 998;
        var la_ = this._interp.adaptivePredict(this._input,115,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 988;
            this.match(JavaParser.CASE);
            this.state = 989;
            this.constantExpression();
            this.state = 990;
            this.match(JavaParser.COLON);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 992;
            this.match(JavaParser.CASE);
            this.state = 993;
            this.enumConstantName();
            this.state = 994;
            this.match(JavaParser.COLON);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 996;
            this.match(JavaParser.DEFAULT);
            this.state = 997;
            this.match(JavaParser.COLON);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForControlContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_forControl;
    return this;
}

ForControlContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForControlContext.prototype.constructor = ForControlContext;

ForControlContext.prototype.enhancedForControl = function() {
    return this.getTypedRuleContext(EnhancedForControlContext,0);
};

ForControlContext.prototype.forInit = function() {
    return this.getTypedRuleContext(ForInitContext,0);
};

ForControlContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ForControlContext.prototype.forUpdate = function() {
    return this.getTypedRuleContext(ForUpdateContext,0);
};

ForControlContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterForControl(this);
	}
};

ForControlContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitForControl(this);
	}
};




JavaParser.ForControlContext = ForControlContext;

JavaParser.prototype.forControl = function() {

    var localctx = new ForControlContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, JavaParser.RULE_forControl);
    var _la = 0; // Token type
    try {
        this.state = 1012;
        var la_ = this._interp.adaptivePredict(this._input,119,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1000;
            this.enhancedForControl();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1002;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FINAL) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0) || _la===JavaParser.AT) {
                this.state = 1001;
                this.forInit();
            }

            this.state = 1004;
            this.match(JavaParser.SEMI);
            this.state = 1006;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
                this.state = 1005;
                this.expression(0);
            }

            this.state = 1008;
            this.match(JavaParser.SEMI);
            this.state = 1010;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
                this.state = 1009;
                this.forUpdate();
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForInitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_forInit;
    return this;
}

ForInitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForInitContext.prototype.constructor = ForInitContext;

ForInitContext.prototype.localVariableDeclaration = function() {
    return this.getTypedRuleContext(LocalVariableDeclarationContext,0);
};

ForInitContext.prototype.expressionList = function() {
    return this.getTypedRuleContext(ExpressionListContext,0);
};

ForInitContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterForInit(this);
	}
};

ForInitContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitForInit(this);
	}
};




JavaParser.ForInitContext = ForInitContext;

JavaParser.prototype.forInit = function() {

    var localctx = new ForInitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 160, JavaParser.RULE_forInit);
    try {
        this.state = 1016;
        var la_ = this._interp.adaptivePredict(this._input,120,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1014;
            this.localVariableDeclaration();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1015;
            this.expressionList();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnhancedForControlContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_enhancedForControl;
    return this;
}

EnhancedForControlContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnhancedForControlContext.prototype.constructor = EnhancedForControlContext;

EnhancedForControlContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

EnhancedForControlContext.prototype.variableDeclaratorId = function() {
    return this.getTypedRuleContext(VariableDeclaratorIdContext,0);
};

EnhancedForControlContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

EnhancedForControlContext.prototype.variableModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariableModifierContext);
    } else {
        return this.getTypedRuleContext(VariableModifierContext,i);
    }
};

EnhancedForControlContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterEnhancedForControl(this);
	}
};

EnhancedForControlContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitEnhancedForControl(this);
	}
};




JavaParser.EnhancedForControlContext = EnhancedForControlContext;

JavaParser.prototype.enhancedForControl = function() {

    var localctx = new EnhancedForControlContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, JavaParser.RULE_enhancedForControl);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1021;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.FINAL || _la===JavaParser.AT) {
            this.state = 1018;
            this.variableModifier();
            this.state = 1023;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1024;
        this.type();
        this.state = 1025;
        this.variableDeclaratorId();
        this.state = 1026;
        this.match(JavaParser.COLON);
        this.state = 1027;
        this.expression(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ForUpdateContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_forUpdate;
    return this;
}

ForUpdateContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ForUpdateContext.prototype.constructor = ForUpdateContext;

ForUpdateContext.prototype.expressionList = function() {
    return this.getTypedRuleContext(ExpressionListContext,0);
};

ForUpdateContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterForUpdate(this);
	}
};

ForUpdateContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitForUpdate(this);
	}
};




JavaParser.ForUpdateContext = ForUpdateContext;

JavaParser.prototype.forUpdate = function() {

    var localctx = new ForUpdateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, JavaParser.RULE_forUpdate);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1029;
        this.expressionList();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_parExpression;
    return this;
}

ParExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParExpressionContext.prototype.constructor = ParExpressionContext;

ParExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ParExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterParExpression(this);
	}
};

ParExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitParExpression(this);
	}
};




JavaParser.ParExpressionContext = ParExpressionContext;

JavaParser.prototype.parExpression = function() {

    var localctx = new ParExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 166, JavaParser.RULE_parExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1031;
        this.match(JavaParser.LPAREN);
        this.state = 1032;
        this.expression(0);
        this.state = 1033;
        this.match(JavaParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionListContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_expressionList;
    return this;
}

ExpressionListContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionListContext.prototype.constructor = ExpressionListContext;

ExpressionListContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

ExpressionListContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterExpressionList(this);
	}
};

ExpressionListContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitExpressionList(this);
	}
};




JavaParser.ExpressionListContext = ExpressionListContext;

JavaParser.prototype.expressionList = function() {

    var localctx = new ExpressionListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, JavaParser.RULE_expressionList);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1035;
        this.expression(0);
        this.state = 1040;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===JavaParser.COMMA) {
            this.state = 1036;
            this.match(JavaParser.COMMA);
            this.state = 1037;
            this.expression(0);
            this.state = 1042;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_statementExpression;
    return this;
}

StatementExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementExpressionContext.prototype.constructor = StatementExpressionContext;

StatementExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

StatementExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterStatementExpression(this);
	}
};

StatementExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitStatementExpression(this);
	}
};




JavaParser.StatementExpressionContext = StatementExpressionContext;

JavaParser.prototype.statementExpression = function() {

    var localctx = new StatementExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, JavaParser.RULE_statementExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1043;
        this.expression(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstantExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_constantExpression;
    return this;
}

ConstantExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantExpressionContext.prototype.constructor = ConstantExpressionContext;

ConstantExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ConstantExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterConstantExpression(this);
	}
};

ConstantExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitConstantExpression(this);
	}
};




JavaParser.ConstantExpressionContext = ConstantExpressionContext;

JavaParser.prototype.constantExpression = function() {

    var localctx = new ConstantExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 172, JavaParser.RULE_constantExpression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1045;
        this.expression(0);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;

ExpressionContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

ExpressionContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

ExpressionContext.prototype.primary = function() {
    return this.getTypedRuleContext(PrimaryContext,0);
};

ExpressionContext.prototype.creator = function() {
    return this.getTypedRuleContext(CreatorContext,0);
};

ExpressionContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ExpressionContext.prototype.innerCreator = function() {
    return this.getTypedRuleContext(InnerCreatorContext,0);
};

ExpressionContext.prototype.nonWildcardTypeArguments = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsContext,0);
};

ExpressionContext.prototype.superSuffix = function() {
    return this.getTypedRuleContext(SuperSuffixContext,0);
};

ExpressionContext.prototype.explicitGenericInvocation = function() {
    return this.getTypedRuleContext(ExplicitGenericInvocationContext,0);
};

ExpressionContext.prototype.expressionList = function() {
    return this.getTypedRuleContext(ExpressionListContext,0);
};

ExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterExpression(this);
	}
};

ExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitExpression(this);
	}
};



JavaParser.prototype.expression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 174;
    this.enterRecursionRule(localctx, 174, JavaParser.RULE_expression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1060;
        var la_ = this._interp.adaptivePredict(this._input,123,this._ctx);
        switch(la_) {
        case 1:
            this.state = 1048;
            this.match(JavaParser.LPAREN);
            this.state = 1049;
            this.type();
            this.state = 1050;
            this.match(JavaParser.RPAREN);
            this.state = 1051;
            this.expression(17);
            break;

        case 2:
            this.state = 1053;
            _la = this._input.LA(1);
            if(!(((((_la - 79)) & ~0x1f) == 0 && ((1 << (_la - 79)) & ((1 << (JavaParser.INC - 79)) | (1 << (JavaParser.DEC - 79)) | (1 << (JavaParser.ADD - 79)) | (1 << (JavaParser.SUB - 79)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1054;
            this.expression(15);
            break;

        case 3:
            this.state = 1055;
            _la = this._input.LA(1);
            if(!(_la===JavaParser.BANG || _la===JavaParser.TILDE)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1056;
            this.expression(14);
            break;

        case 4:
            this.state = 1057;
            this.primary();
            break;

        case 5:
            this.state = 1058;
            this.match(JavaParser.NEW);
            this.state = 1059;
            this.creator();
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 1147;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,128,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 1145;
                var la_ = this._interp.adaptivePredict(this._input,127,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1062;
                    if (!( this.precpred(this._ctx, 13))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 13)");
                    }
                    this.state = 1063;
                    _la = this._input.LA(1);
                    if(!(((((_la - 83)) & ~0x1f) == 0 && ((1 << (_la - 83)) & ((1 << (JavaParser.MUL - 83)) | (1 << (JavaParser.DIV - 83)) | (1 << (JavaParser.MOD - 83)))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    this.state = 1064;
                    this.expression(14);
                    break;

                case 2:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1065;
                    if (!( this.precpred(this._ctx, 12))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 12)");
                    }
                    this.state = 1066;
                    _la = this._input.LA(1);
                    if(!(_la===JavaParser.ADD || _la===JavaParser.SUB)) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    this.state = 1067;
                    this.expression(13);
                    break;

                case 3:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1068;
                    if (!( this.precpred(this._ctx, 11))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 11)");
                    }
                    this.state = 1076;
                    var la_ = this._interp.adaptivePredict(this._input,124,this._ctx);
                    switch(la_) {
                    case 1:
                        this.state = 1069;
                        this.match(JavaParser.LT);
                        this.state = 1070;
                        this.match(JavaParser.LT);
                        break;

                    case 2:
                        this.state = 1071;
                        this.match(JavaParser.GT);
                        this.state = 1072;
                        this.match(JavaParser.GT);
                        this.state = 1073;
                        this.match(JavaParser.GT);
                        break;

                    case 3:
                        this.state = 1074;
                        this.match(JavaParser.GT);
                        this.state = 1075;
                        this.match(JavaParser.GT);
                        break;

                    }
                    this.state = 1078;
                    this.expression(12);
                    break;

                case 4:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1079;
                    if (!( this.precpred(this._ctx, 10))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
                    }
                    this.state = 1080;
                    _la = this._input.LA(1);
                    if(!(((((_la - 67)) & ~0x1f) == 0 && ((1 << (_la - 67)) & ((1 << (JavaParser.GT - 67)) | (1 << (JavaParser.LT - 67)) | (1 << (JavaParser.LE - 67)) | (1 << (JavaParser.GE - 67)))) !== 0))) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    this.state = 1081;
                    this.expression(11);
                    break;

                case 5:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1082;
                    if (!( this.precpred(this._ctx, 8))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
                    }
                    this.state = 1083;
                    _la = this._input.LA(1);
                    if(!(_la===JavaParser.EQUAL || _la===JavaParser.NOTEQUAL)) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    this.state = 1084;
                    this.expression(9);
                    break;

                case 6:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1085;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 1086;
                    this.match(JavaParser.BITAND);
                    this.state = 1087;
                    this.expression(8);
                    break;

                case 7:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1088;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 1089;
                    this.match(JavaParser.CARET);
                    this.state = 1090;
                    this.expression(7);
                    break;

                case 8:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1091;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 1092;
                    this.match(JavaParser.BITOR);
                    this.state = 1093;
                    this.expression(6);
                    break;

                case 9:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1094;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 1095;
                    this.match(JavaParser.AND);
                    this.state = 1096;
                    this.expression(5);
                    break;

                case 10:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1097;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 1098;
                    this.match(JavaParser.OR);
                    this.state = 1099;
                    this.expression(4);
                    break;

                case 11:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1100;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 1101;
                    this.match(JavaParser.QUESTION);
                    this.state = 1102;
                    this.expression(0);
                    this.state = 1103;
                    this.match(JavaParser.COLON);
                    this.state = 1104;
                    this.expression(3);
                    break;

                case 12:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1106;
                    if (!( this.precpred(this._ctx, 1))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                    }
                    this.state = 1107;
                    _la = this._input.LA(1);
                    if(!(((((_la - 66)) & ~0x1f) == 0 && ((1 << (_la - 66)) & ((1 << (JavaParser.ASSIGN - 66)) | (1 << (JavaParser.ADD_ASSIGN - 66)) | (1 << (JavaParser.SUB_ASSIGN - 66)) | (1 << (JavaParser.MUL_ASSIGN - 66)) | (1 << (JavaParser.DIV_ASSIGN - 66)) | (1 << (JavaParser.AND_ASSIGN - 66)) | (1 << (JavaParser.OR_ASSIGN - 66)) | (1 << (JavaParser.XOR_ASSIGN - 66)) | (1 << (JavaParser.MOD_ASSIGN - 66)) | (1 << (JavaParser.LSHIFT_ASSIGN - 66)))) !== 0) || _la===JavaParser.RSHIFT_ASSIGN || _la===JavaParser.URSHIFT_ASSIGN)) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    this.state = 1108;
                    this.expression(1);
                    break;

                case 13:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1109;
                    if (!( this.precpred(this._ctx, 25))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 25)");
                    }
                    this.state = 1110;
                    this.match(JavaParser.DOT);
                    this.state = 1111;
                    this.match(JavaParser.Identifier);
                    break;

                case 14:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1112;
                    if (!( this.precpred(this._ctx, 24))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 24)");
                    }
                    this.state = 1113;
                    this.match(JavaParser.DOT);
                    this.state = 1114;
                    this.match(JavaParser.THIS);
                    break;

                case 15:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1115;
                    if (!( this.precpred(this._ctx, 23))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 23)");
                    }
                    this.state = 1116;
                    this.match(JavaParser.DOT);
                    this.state = 1117;
                    this.match(JavaParser.NEW);
                    this.state = 1119;
                    _la = this._input.LA(1);
                    if(_la===JavaParser.LT) {
                        this.state = 1118;
                        this.nonWildcardTypeArguments();
                    }

                    this.state = 1121;
                    this.innerCreator();
                    break;

                case 16:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1122;
                    if (!( this.precpred(this._ctx, 22))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 22)");
                    }
                    this.state = 1123;
                    this.match(JavaParser.DOT);
                    this.state = 1124;
                    this.match(JavaParser.SUPER);
                    this.state = 1125;
                    this.superSuffix();
                    break;

                case 17:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1126;
                    if (!( this.precpred(this._ctx, 21))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 21)");
                    }
                    this.state = 1127;
                    this.match(JavaParser.DOT);
                    this.state = 1128;
                    this.explicitGenericInvocation();
                    break;

                case 18:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1129;
                    if (!( this.precpred(this._ctx, 20))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 20)");
                    }
                    this.state = 1130;
                    this.match(JavaParser.LBRACK);
                    this.state = 1131;
                    this.expression(0);
                    this.state = 1132;
                    this.match(JavaParser.RBRACK);
                    break;

                case 19:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1134;
                    if (!( this.precpred(this._ctx, 19))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 19)");
                    }
                    this.state = 1135;
                    this.match(JavaParser.LPAREN);
                    this.state = 1137;
                    _la = this._input.LA(1);
                    if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
                        this.state = 1136;
                        this.expressionList();
                    }

                    this.state = 1139;
                    this.match(JavaParser.RPAREN);
                    break;

                case 20:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1140;
                    if (!( this.precpred(this._ctx, 16))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 16)");
                    }
                    this.state = 1141;
                    _la = this._input.LA(1);
                    if(!(_la===JavaParser.INC || _la===JavaParser.DEC)) {
                    this._errHandler.recoverInline(this);
                    }
                    else {
                        this.consume();
                    }
                    break;

                case 21:
                    localctx = new ExpressionContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, JavaParser.RULE_expression);
                    this.state = 1142;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 1143;
                    this.match(JavaParser.INSTANCEOF);
                    this.state = 1144;
                    this.type();
                    break;

                } 
            }
            this.state = 1149;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,128,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function PrimaryContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_primary;
    return this;
}

PrimaryContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrimaryContext.prototype.constructor = PrimaryContext;

PrimaryContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

PrimaryContext.prototype.literal = function() {
    return this.getTypedRuleContext(LiteralContext,0);
};

PrimaryContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

PrimaryContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

PrimaryContext.prototype.nonWildcardTypeArguments = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsContext,0);
};

PrimaryContext.prototype.explicitGenericInvocationSuffix = function() {
    return this.getTypedRuleContext(ExplicitGenericInvocationSuffixContext,0);
};

PrimaryContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};

PrimaryContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterPrimary(this);
	}
};

PrimaryContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitPrimary(this);
	}
};




JavaParser.PrimaryContext = PrimaryContext;

JavaParser.prototype.primary = function() {

    var localctx = new PrimaryContext(this, this._ctx, this.state);
    this.enterRule(localctx, 176, JavaParser.RULE_primary);
    try {
        this.state = 1171;
        var la_ = this._interp.adaptivePredict(this._input,130,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1150;
            this.match(JavaParser.LPAREN);
            this.state = 1151;
            this.expression(0);
            this.state = 1152;
            this.match(JavaParser.RPAREN);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1154;
            this.match(JavaParser.THIS);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1155;
            this.match(JavaParser.SUPER);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1156;
            this.literal();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1157;
            this.match(JavaParser.Identifier);
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 1158;
            this.type();
            this.state = 1159;
            this.match(JavaParser.DOT);
            this.state = 1160;
            this.match(JavaParser.CLASS);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 1162;
            this.match(JavaParser.VOID);
            this.state = 1163;
            this.match(JavaParser.DOT);
            this.state = 1164;
            this.match(JavaParser.CLASS);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 1165;
            this.nonWildcardTypeArguments();
            this.state = 1169;
            switch(this._input.LA(1)) {
            case JavaParser.SUPER:
            case JavaParser.Identifier:
                this.state = 1166;
                this.explicitGenericInvocationSuffix();
                break;
            case JavaParser.THIS:
                this.state = 1167;
                this.match(JavaParser.THIS);
                this.state = 1168;
                this.arguments();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CreatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_creator;
    return this;
}

CreatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CreatorContext.prototype.constructor = CreatorContext;

CreatorContext.prototype.nonWildcardTypeArguments = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsContext,0);
};

CreatorContext.prototype.createdName = function() {
    return this.getTypedRuleContext(CreatedNameContext,0);
};

CreatorContext.prototype.classCreatorRest = function() {
    return this.getTypedRuleContext(ClassCreatorRestContext,0);
};

CreatorContext.prototype.arrayCreatorRest = function() {
    return this.getTypedRuleContext(ArrayCreatorRestContext,0);
};

CreatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterCreator(this);
	}
};

CreatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitCreator(this);
	}
};




JavaParser.CreatorContext = CreatorContext;

JavaParser.prototype.creator = function() {

    var localctx = new CreatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 178, JavaParser.RULE_creator);
    try {
        this.state = 1182;
        switch(this._input.LA(1)) {
        case JavaParser.LT:
            this.enterOuterAlt(localctx, 1);
            this.state = 1173;
            this.nonWildcardTypeArguments();
            this.state = 1174;
            this.createdName();
            this.state = 1175;
            this.classCreatorRest();
            break;
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 2);
            this.state = 1177;
            this.createdName();
            this.state = 1180;
            switch(this._input.LA(1)) {
            case JavaParser.LBRACK:
                this.state = 1178;
                this.arrayCreatorRest();
                break;
            case JavaParser.LPAREN:
                this.state = 1179;
                this.classCreatorRest();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CreatedNameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_createdName;
    return this;
}

CreatedNameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CreatedNameContext.prototype.constructor = CreatedNameContext;

CreatedNameContext.prototype.Identifier = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(JavaParser.Identifier);
    } else {
        return this.getToken(JavaParser.Identifier, i);
    }
};


CreatedNameContext.prototype.typeArgumentsOrDiamond = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeArgumentsOrDiamondContext);
    } else {
        return this.getTypedRuleContext(TypeArgumentsOrDiamondContext,i);
    }
};

CreatedNameContext.prototype.primitiveType = function() {
    return this.getTypedRuleContext(PrimitiveTypeContext,0);
};

CreatedNameContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterCreatedName(this);
	}
};

CreatedNameContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitCreatedName(this);
	}
};




JavaParser.CreatedNameContext = CreatedNameContext;

JavaParser.prototype.createdName = function() {

    var localctx = new CreatedNameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 180, JavaParser.RULE_createdName);
    var _la = 0; // Token type
    try {
        this.state = 1199;
        switch(this._input.LA(1)) {
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 1);
            this.state = 1184;
            this.match(JavaParser.Identifier);
            this.state = 1186;
            _la = this._input.LA(1);
            if(_la===JavaParser.LT) {
                this.state = 1185;
                this.typeArgumentsOrDiamond();
            }

            this.state = 1195;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.DOT) {
                this.state = 1188;
                this.match(JavaParser.DOT);
                this.state = 1189;
                this.match(JavaParser.Identifier);
                this.state = 1191;
                _la = this._input.LA(1);
                if(_la===JavaParser.LT) {
                    this.state = 1190;
                    this.typeArgumentsOrDiamond();
                }

                this.state = 1197;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.SHORT:
            this.enterOuterAlt(localctx, 2);
            this.state = 1198;
            this.primitiveType();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InnerCreatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_innerCreator;
    return this;
}

InnerCreatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InnerCreatorContext.prototype.constructor = InnerCreatorContext;

InnerCreatorContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

InnerCreatorContext.prototype.classCreatorRest = function() {
    return this.getTypedRuleContext(ClassCreatorRestContext,0);
};

InnerCreatorContext.prototype.nonWildcardTypeArgumentsOrDiamond = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsOrDiamondContext,0);
};

InnerCreatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterInnerCreator(this);
	}
};

InnerCreatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitInnerCreator(this);
	}
};




JavaParser.InnerCreatorContext = InnerCreatorContext;

JavaParser.prototype.innerCreator = function() {

    var localctx = new InnerCreatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 182, JavaParser.RULE_innerCreator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1201;
        this.match(JavaParser.Identifier);
        this.state = 1203;
        _la = this._input.LA(1);
        if(_la===JavaParser.LT) {
            this.state = 1202;
            this.nonWildcardTypeArgumentsOrDiamond();
        }

        this.state = 1205;
        this.classCreatorRest();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArrayCreatorRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_arrayCreatorRest;
    return this;
}

ArrayCreatorRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArrayCreatorRestContext.prototype.constructor = ArrayCreatorRestContext;

ArrayCreatorRestContext.prototype.arrayInitializer = function() {
    return this.getTypedRuleContext(ArrayInitializerContext,0);
};

ArrayCreatorRestContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

ArrayCreatorRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterArrayCreatorRest(this);
	}
};

ArrayCreatorRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitArrayCreatorRest(this);
	}
};




JavaParser.ArrayCreatorRestContext = ArrayCreatorRestContext;

JavaParser.prototype.arrayCreatorRest = function() {

    var localctx = new ArrayCreatorRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 184, JavaParser.RULE_arrayCreatorRest);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1207;
        this.match(JavaParser.LBRACK);
        this.state = 1235;
        switch(this._input.LA(1)) {
        case JavaParser.RBRACK:
            this.state = 1208;
            this.match(JavaParser.RBRACK);
            this.state = 1213;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===JavaParser.LBRACK) {
                this.state = 1209;
                this.match(JavaParser.LBRACK);
                this.state = 1210;
                this.match(JavaParser.RBRACK);
                this.state = 1215;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1216;
            this.arrayInitializer();
            break;
        case JavaParser.BOOLEAN:
        case JavaParser.BYTE:
        case JavaParser.CHAR:
        case JavaParser.DOUBLE:
        case JavaParser.FLOAT:
        case JavaParser.INT:
        case JavaParser.LONG:
        case JavaParser.NEW:
        case JavaParser.SHORT:
        case JavaParser.SUPER:
        case JavaParser.THIS:
        case JavaParser.VOID:
        case JavaParser.IntegerLiteral:
        case JavaParser.FloatingPointLiteral:
        case JavaParser.BooleanLiteral:
        case JavaParser.CharacterLiteral:
        case JavaParser.StringLiteral:
        case JavaParser.NullLiteral:
        case JavaParser.LPAREN:
        case JavaParser.LT:
        case JavaParser.BANG:
        case JavaParser.TILDE:
        case JavaParser.INC:
        case JavaParser.DEC:
        case JavaParser.ADD:
        case JavaParser.SUB:
        case JavaParser.Identifier:
            this.state = 1217;
            this.expression(0);
            this.state = 1218;
            this.match(JavaParser.RBRACK);
            this.state = 1225;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,139,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 1219;
                    this.match(JavaParser.LBRACK);
                    this.state = 1220;
                    this.expression(0);
                    this.state = 1221;
                    this.match(JavaParser.RBRACK); 
                }
                this.state = 1227;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,139,this._ctx);
            }

            this.state = 1232;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,140,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 1228;
                    this.match(JavaParser.LBRACK);
                    this.state = 1229;
                    this.match(JavaParser.RBRACK); 
                }
                this.state = 1234;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,140,this._ctx);
            }

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassCreatorRestContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_classCreatorRest;
    return this;
}

ClassCreatorRestContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassCreatorRestContext.prototype.constructor = ClassCreatorRestContext;

ClassCreatorRestContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};

ClassCreatorRestContext.prototype.classBody = function() {
    return this.getTypedRuleContext(ClassBodyContext,0);
};

ClassCreatorRestContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterClassCreatorRest(this);
	}
};

ClassCreatorRestContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitClassCreatorRest(this);
	}
};




JavaParser.ClassCreatorRestContext = ClassCreatorRestContext;

JavaParser.prototype.classCreatorRest = function() {

    var localctx = new ClassCreatorRestContext(this, this._ctx, this.state);
    this.enterRule(localctx, 186, JavaParser.RULE_classCreatorRest);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1237;
        this.arguments();
        this.state = 1239;
        var la_ = this._interp.adaptivePredict(this._input,142,this._ctx);
        if(la_===1) {
            this.state = 1238;
            this.classBody();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExplicitGenericInvocationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_explicitGenericInvocation;
    return this;
}

ExplicitGenericInvocationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExplicitGenericInvocationContext.prototype.constructor = ExplicitGenericInvocationContext;

ExplicitGenericInvocationContext.prototype.nonWildcardTypeArguments = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsContext,0);
};

ExplicitGenericInvocationContext.prototype.explicitGenericInvocationSuffix = function() {
    return this.getTypedRuleContext(ExplicitGenericInvocationSuffixContext,0);
};

ExplicitGenericInvocationContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterExplicitGenericInvocation(this);
	}
};

ExplicitGenericInvocationContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitExplicitGenericInvocation(this);
	}
};




JavaParser.ExplicitGenericInvocationContext = ExplicitGenericInvocationContext;

JavaParser.prototype.explicitGenericInvocation = function() {

    var localctx = new ExplicitGenericInvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 188, JavaParser.RULE_explicitGenericInvocation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1241;
        this.nonWildcardTypeArguments();
        this.state = 1242;
        this.explicitGenericInvocationSuffix();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NonWildcardTypeArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_nonWildcardTypeArguments;
    return this;
}

NonWildcardTypeArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NonWildcardTypeArgumentsContext.prototype.constructor = NonWildcardTypeArgumentsContext;

NonWildcardTypeArgumentsContext.prototype.typeList = function() {
    return this.getTypedRuleContext(TypeListContext,0);
};

NonWildcardTypeArgumentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterNonWildcardTypeArguments(this);
	}
};

NonWildcardTypeArgumentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitNonWildcardTypeArguments(this);
	}
};




JavaParser.NonWildcardTypeArgumentsContext = NonWildcardTypeArgumentsContext;

JavaParser.prototype.nonWildcardTypeArguments = function() {

    var localctx = new NonWildcardTypeArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 190, JavaParser.RULE_nonWildcardTypeArguments);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1244;
        this.match(JavaParser.LT);
        this.state = 1245;
        this.typeList();
        this.state = 1246;
        this.match(JavaParser.GT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeArgumentsOrDiamondContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_typeArgumentsOrDiamond;
    return this;
}

TypeArgumentsOrDiamondContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeArgumentsOrDiamondContext.prototype.constructor = TypeArgumentsOrDiamondContext;

TypeArgumentsOrDiamondContext.prototype.typeArguments = function() {
    return this.getTypedRuleContext(TypeArgumentsContext,0);
};

TypeArgumentsOrDiamondContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterTypeArgumentsOrDiamond(this);
	}
};

TypeArgumentsOrDiamondContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitTypeArgumentsOrDiamond(this);
	}
};




JavaParser.TypeArgumentsOrDiamondContext = TypeArgumentsOrDiamondContext;

JavaParser.prototype.typeArgumentsOrDiamond = function() {

    var localctx = new TypeArgumentsOrDiamondContext(this, this._ctx, this.state);
    this.enterRule(localctx, 192, JavaParser.RULE_typeArgumentsOrDiamond);
    try {
        this.state = 1251;
        var la_ = this._interp.adaptivePredict(this._input,143,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1248;
            this.match(JavaParser.LT);
            this.state = 1249;
            this.match(JavaParser.GT);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1250;
            this.typeArguments();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function NonWildcardTypeArgumentsOrDiamondContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_nonWildcardTypeArgumentsOrDiamond;
    return this;
}

NonWildcardTypeArgumentsOrDiamondContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NonWildcardTypeArgumentsOrDiamondContext.prototype.constructor = NonWildcardTypeArgumentsOrDiamondContext;

NonWildcardTypeArgumentsOrDiamondContext.prototype.nonWildcardTypeArguments = function() {
    return this.getTypedRuleContext(NonWildcardTypeArgumentsContext,0);
};

NonWildcardTypeArgumentsOrDiamondContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterNonWildcardTypeArgumentsOrDiamond(this);
	}
};

NonWildcardTypeArgumentsOrDiamondContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitNonWildcardTypeArgumentsOrDiamond(this);
	}
};




JavaParser.NonWildcardTypeArgumentsOrDiamondContext = NonWildcardTypeArgumentsOrDiamondContext;

JavaParser.prototype.nonWildcardTypeArgumentsOrDiamond = function() {

    var localctx = new NonWildcardTypeArgumentsOrDiamondContext(this, this._ctx, this.state);
    this.enterRule(localctx, 194, JavaParser.RULE_nonWildcardTypeArgumentsOrDiamond);
    try {
        this.state = 1256;
        var la_ = this._interp.adaptivePredict(this._input,144,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1253;
            this.match(JavaParser.LT);
            this.state = 1254;
            this.match(JavaParser.GT);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1255;
            this.nonWildcardTypeArguments();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SuperSuffixContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_superSuffix;
    return this;
}

SuperSuffixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SuperSuffixContext.prototype.constructor = SuperSuffixContext;

SuperSuffixContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};

SuperSuffixContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

SuperSuffixContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterSuperSuffix(this);
	}
};

SuperSuffixContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitSuperSuffix(this);
	}
};




JavaParser.SuperSuffixContext = SuperSuffixContext;

JavaParser.prototype.superSuffix = function() {

    var localctx = new SuperSuffixContext(this, this._ctx, this.state);
    this.enterRule(localctx, 196, JavaParser.RULE_superSuffix);
    try {
        this.state = 1264;
        switch(this._input.LA(1)) {
        case JavaParser.LPAREN:
            this.enterOuterAlt(localctx, 1);
            this.state = 1258;
            this.arguments();
            break;
        case JavaParser.DOT:
            this.enterOuterAlt(localctx, 2);
            this.state = 1259;
            this.match(JavaParser.DOT);
            this.state = 1260;
            this.match(JavaParser.Identifier);
            this.state = 1262;
            var la_ = this._interp.adaptivePredict(this._input,145,this._ctx);
            if(la_===1) {
                this.state = 1261;
                this.arguments();

            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExplicitGenericInvocationSuffixContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_explicitGenericInvocationSuffix;
    return this;
}

ExplicitGenericInvocationSuffixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExplicitGenericInvocationSuffixContext.prototype.constructor = ExplicitGenericInvocationSuffixContext;

ExplicitGenericInvocationSuffixContext.prototype.superSuffix = function() {
    return this.getTypedRuleContext(SuperSuffixContext,0);
};

ExplicitGenericInvocationSuffixContext.prototype.Identifier = function() {
    return this.getToken(JavaParser.Identifier, 0);
};

ExplicitGenericInvocationSuffixContext.prototype.arguments = function() {
    return this.getTypedRuleContext(ArgumentsContext,0);
};

ExplicitGenericInvocationSuffixContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterExplicitGenericInvocationSuffix(this);
	}
};

ExplicitGenericInvocationSuffixContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitExplicitGenericInvocationSuffix(this);
	}
};




JavaParser.ExplicitGenericInvocationSuffixContext = ExplicitGenericInvocationSuffixContext;

JavaParser.prototype.explicitGenericInvocationSuffix = function() {

    var localctx = new ExplicitGenericInvocationSuffixContext(this, this._ctx, this.state);
    this.enterRule(localctx, 198, JavaParser.RULE_explicitGenericInvocationSuffix);
    try {
        this.state = 1270;
        switch(this._input.LA(1)) {
        case JavaParser.SUPER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1266;
            this.match(JavaParser.SUPER);
            this.state = 1267;
            this.superSuffix();
            break;
        case JavaParser.Identifier:
            this.enterOuterAlt(localctx, 2);
            this.state = 1268;
            this.match(JavaParser.Identifier);
            this.state = 1269;
            this.arguments();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = JavaParser.RULE_arguments;
    return this;
}

ArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentsContext.prototype.constructor = ArgumentsContext;

ArgumentsContext.prototype.expressionList = function() {
    return this.getTypedRuleContext(ExpressionListContext,0);
};

ArgumentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.enterArguments(this);
	}
};

ArgumentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof JavaListener ) {
        listener.exitArguments(this);
	}
};




JavaParser.ArgumentsContext = ArgumentsContext;

JavaParser.prototype.arguments = function() {

    var localctx = new ArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 200, JavaParser.RULE_arguments);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1272;
        this.match(JavaParser.LPAREN);
        this.state = 1274;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << JavaParser.BOOLEAN) | (1 << JavaParser.BYTE) | (1 << JavaParser.CHAR) | (1 << JavaParser.DOUBLE) | (1 << JavaParser.FLOAT) | (1 << JavaParser.INT) | (1 << JavaParser.LONG) | (1 << JavaParser.NEW))) !== 0) || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (JavaParser.SHORT - 37)) | (1 << (JavaParser.SUPER - 37)) | (1 << (JavaParser.THIS - 37)) | (1 << (JavaParser.VOID - 37)) | (1 << (JavaParser.IntegerLiteral - 37)) | (1 << (JavaParser.FloatingPointLiteral - 37)) | (1 << (JavaParser.BooleanLiteral - 37)) | (1 << (JavaParser.CharacterLiteral - 37)) | (1 << (JavaParser.StringLiteral - 37)) | (1 << (JavaParser.NullLiteral - 37)) | (1 << (JavaParser.LPAREN - 37)) | (1 << (JavaParser.LT - 37)))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (JavaParser.BANG - 69)) | (1 << (JavaParser.TILDE - 69)) | (1 << (JavaParser.INC - 69)) | (1 << (JavaParser.DEC - 69)) | (1 << (JavaParser.ADD - 69)) | (1 << (JavaParser.SUB - 69)) | (1 << (JavaParser.Identifier - 69)))) !== 0)) {
            this.state = 1273;
            this.expressionList();
        }

        this.state = 1276;
        this.match(JavaParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


JavaParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 87:
			return this.expression_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

JavaParser.prototype.expression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 13);
		case 1:
			return this.precpred(this._ctx, 12);
		case 2:
			return this.precpred(this._ctx, 11);
		case 3:
			return this.precpred(this._ctx, 10);
		case 4:
			return this.precpred(this._ctx, 8);
		case 5:
			return this.precpred(this._ctx, 7);
		case 6:
			return this.precpred(this._ctx, 6);
		case 7:
			return this.precpred(this._ctx, 5);
		case 8:
			return this.precpred(this._ctx, 4);
		case 9:
			return this.precpred(this._ctx, 3);
		case 10:
			return this.precpred(this._ctx, 2);
		case 11:
			return this.precpred(this._ctx, 1);
		case 12:
			return this.precpred(this._ctx, 25);
		case 13:
			return this.precpred(this._ctx, 24);
		case 14:
			return this.precpred(this._ctx, 23);
		case 15:
			return this.precpred(this._ctx, 22);
		case 16:
			return this.precpred(this._ctx, 21);
		case 17:
			return this.precpred(this._ctx, 20);
		case 18:
			return this.precpred(this._ctx, 19);
		case 19:
			return this.precpred(this._ctx, 16);
		case 20:
			return this.precpred(this._ctx, 9);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.JavaParser = JavaParser;

},{"./JavaListener":5,"antlr4/index":54}],7:[function(require,module,exports){
// Generated from ObjC.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\2\u0091\u0524\b\1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4",
    "\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17",
    "\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t",
    "\26\4\27\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35",
    "\t\35\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t",
    "&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60",
    "\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t",
    "\67\48\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\t",
    "B\4C\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM",
    "\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4",
    "Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4",
    "d\td\4e\te\4f\tf\4g\tg\4h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o",
    "\to\4p\tp\4q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4z\t",
    "z\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080\4\u0081\t\u0081",
    "\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084\t\u0084\4\u0085\t\u0085\4\u0086",
    "\t\u0086\4\u0087\t\u0087\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a",
    "\4\u008b\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e\4\u008f",
    "\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092\t\u0092\4\u0093\t\u0093",
    "\4\u0094\t\u0094\4\u0095\t\u0095\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098",
    "\t\u0098\4\u0099\t\u0099\4\u009a\t\u009a\3\2\3\2\3\2\3\2\3\2\3\2\3\2",
    "\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3\3\3",
    "\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\6",
    "\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b",
    "\3\b\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t",
    "\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\13\3\13\3",
    "\13\3\13\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3",
    "\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3",
    "\16\3\16\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17",
    "\3\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3",
    "\21\3\21\3\21\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22",
    "\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\3",
    "\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24",
    "\3\24\3\24\3\25\3\25\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3\26\3",
    "\26\3\27\3\27\3\27\3\27\3\27\3\27\3\30\3\30\3\30\3\30\3\30\3\31\3\31",
    "\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\33\3",
    "\33\3\33\3\33\3\33\3\33\3\33\3\33\3\34\3\34\3\34\3\34\3\34\3\34\3\35",
    "\3\35\3\35\3\35\3\35\3\35\3\35\3\36\3\36\3\36\3\36\3\36\3\36\3\37\3",
    "\37\3\37\3\37\3\37\3 \3 \3 \3 \3 \3!\3!\3!\3!\3!\3!\3\"\3\"\3\"\3\"",
    "\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3#\3#\3#\3#\3$\3$\3$\3%\3%\3%\3%\3",
    "%\3%\3%\3&\3&\3&\3&\3&\3\'\3\'\3\'\3\'\3\'\3(\3(\3(\3(\3(\3(\3(\3)\3",
    ")\3)\3)\3)\3)\3*\3*\3*\3*\3+\3+\3+\3,\3,\3,\3-\3-\3-\3.\3.\3.\3.\3.",
    "\3.\3/\3/\3/\3/\3/\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\61\3\62",
    "\3\62\3\62\3\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\64\3\64\3\64\3",
    "\64\3\64\3\64\3\64\3\64\3\64\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\66",
    "\3\66\3\66\3\66\3\66\3\66\3\67\3\67\3\67\3\67\3\67\3\67\3\67\38\38\3",
    "8\38\38\38\38\39\39\39\39\39\39\39\3:\3:\3:\3:\3:\3:\3:\3;\3;\3;\3;",
    "\3;\3;\3;\3<\3<\3<\3<\3<\3<\3<\3<\3=\3=\3=\3=\3=\3=\3>\3>\3>\3>\3>\3",
    ">\3>\3>\3>\3?\3?\3?\3?\3?\3@\3@\3@\3@\3@\3@\3@\3@\3@\3A\3A\3A\3A\3A",
    "\3A\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3B\3C\3C\3C\3C\3C\3C\3C\3C\3D\3D\3",
    "D\3D\3D\3D\3D\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E\3E",
    "\3E\3E\3F\3F\3G\3G\3H\3H\3I\3I\3J\3J\3K\3K\3L\3L\3M\3M\3N\3N\3O\3O\3",
    "O\3P\3P\3Q\3Q\3R\3R\3S\3S\3T\3T\3U\3U\3V\3V\3W\3W\3X\3X\3X\3Y\3Y\3Y",
    "\3Z\3Z\3Z\3[\3[\3[\3\\\3\\\3\\\3]\3]\3]\3^\3^\3^\3_\3_\3_\3`\3`\3a\3",
    "a\3b\3b\3c\3c\3d\3d\3e\3e\3f\3f\3g\3g\3h\3h\3h\3i\3i\3i\3j\3j\3j\3k",
    "\3k\3k\3l\3l\3l\3m\3m\3m\3n\3n\3n\3o\3o\3o\3p\3p\3p\3q\3q\3q\3r\3r\3",
    "r\3r\3s\3s\3s\3s\3t\3t\3t\3t\3u\3u\3u\3u\3u\3u\3u\3v\3v\3v\3v\3v\3v",
    "\3v\3w\3w\3w\3w\3w\3w\3w\3w\3w\3w\3x\3x\3x\3x\3x\3x\3x\3y\3y\3y\3y\3",
    "y\3y\3y\3z\3z\3z\3z\3z\3z\3z\3{\3{\3{\3{\3{\3{\3{\3{\3{\3|\3|\3|\3|",
    "\3|\3|\3|\3|\3|\3|\3}\3}\3}\3}\3}\3~\3~\3~\7~\u03f5\n~\f~\16~\u03f8",
    "\13~\3\177\3\177\3\u0080\3\u0080\3\u0080\5\u0080\u03ff\n\u0080\3\u0080",
    "\3\u0080\3\u0081\3\u0081\3\u0081\3\u0082\3\u0082\3\u0082\7\u0082\u0409",
    "\n\u0082\f\u0082\16\u0082\u040c\13\u0082\3\u0082\3\u0082\3\u0083\3\u0083",
    "\3\u0083\6\u0083\u0413\n\u0083\r\u0083\16\u0083\u0414\3\u0083\5\u0083",
    "\u0418\n\u0083\3\u0084\3\u0084\3\u0084\7\u0084\u041d\n\u0084\f\u0084",
    "\16\u0084\u0420\13\u0084\5\u0084\u0422\n\u0084\3\u0084\5\u0084\u0425",
    "\n\u0084\3\u0085\3\u0085\6\u0085\u0429\n\u0085\r\u0085\16\u0085\u042a",
    "\3\u0085\5\u0085\u042e\n\u0085\3\u0086\3\u0086\3\u0087\3\u0087\3\u0088",
    "\6\u0088\u0435\n\u0088\r\u0088\16\u0088\u0436\3\u0088\3\u0088\7\u0088",
    "\u043b\n\u0088\f\u0088\16\u0088\u043e\13\u0088\5\u0088\u0440\n\u0088",
    "\3\u0088\5\u0088\u0443\n\u0088\3\u0088\5\u0088\u0446\n\u0088\3\u0089",
    "\3\u0089\5\u0089\u044a\n\u0089\3\u0089\6\u0089\u044d\n\u0089\r\u0089",
    "\16\u0089\u044e\3\u008a\3\u008a\3\u008b\3\u008b\3\u008b\5\u008b\u0456",
    "\n\u008b\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c",
    "\3\u008c\5\u008c\u0461\n\u008c\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d",
    "\3\u008d\3\u008d\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e\3\u008e",
    "\3\u008e\3\u008e\7\u008e\u0473\n\u008e\f\u008e\16\u008e\u0476\13\u008e",
    "\3\u008e\3\u008e\5\u008e\u047a\n\u008e\3\u008e\3\u008e\3\u008e\3\u008e",
    "\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f",
    "\3\u008f\7\u008f\u048a\n\u008f\f\u008f\16\u008f\u048d\13\u008f\3\u008f",
    "\3\u008f\5\u008f\u0491\n\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u0090",
    "\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\3\u0090\7\u0090",
    "\u04a0\n\u0090\f\u0090\16\u0090\u04a3\13\u0090\3\u0090\3\u0090\3\u0091",
    "\3\u0091\7\u0091\u04a9\n\u0091\f\u0091\16\u0091\u04ac\13\u0091\3\u0091",
    "\3\u0091\3\u0092\3\u0092\3\u0092\3\u0092\3\u0093\3\u0093\3\u0093\3\u0093",
    "\7\u0093\u04b8\n\u0093\f\u0093\16\u0093\u04bb\13\u0093\3\u0093\3\u0093",
    "\3\u0093\3\u0093\3\u0093\3\u0094\3\u0094\3\u0094\3\u0094\7\u0094\u04c6",
    "\n\u0094\f\u0094\16\u0094\u04c9\13\u0094\3\u0094\3\u0094\3\u0095\3\u0095",
    "\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\7\u0095\u04d6",
    "\n\u0095\f\u0095\16\u0095\u04d9\13\u0095\3\u0095\3\u0095\3\u0096\3\u0096",
    "\3\u0096\3\u0096\3\u0096\7\u0096\u04e2\n\u0096\f\u0096\16\u0096\u04e5",
    "\13\u0096\3\u0096\3\u0096\3\u0097\3\u0097\3\u0097\3\u0097\3\u0097\3",
    "\u0097\3\u0097\7\u0097\u04f0\n\u0097\f\u0097\16\u0097\u04f3\13\u0097",
    "\3\u0097\3\u0097\3\u0098\3\u0098\3\u0098\3\u0098\3\u0098\3\u0098\3\u0098",
    "\3\u0098\7\u0098\u04ff\n\u0098\f\u0098\16\u0098\u0502\13\u0098\3\u0098",
    "\3\u0098\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099",
    "\3\u0099\7\u0099\u050f\n\u0099\f\u0099\16\u0099\u0512\13\u0099\3\u0099",
    "\3\u0099\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a",
    "\7\u009a\u051e\n\u009a\f\u009a\16\u009a\u0521\13\u009a\3\u009a\3\u009a",
    "\4\u04aa\u04b9\2\u009b\3\3\5\4\7\5\t\6\13\7\r\b\17\t\21\n\23\13\25\f",
    "\27\r\31\16\33\17\35\20\37\21!\22#\23%\24\'\25)\26+\27-\30/\31\61\32",
    "\63\33\65\34\67\359\36;\37= ?!A\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]\60_\61",
    "a\62c\63e\64g\65i\66k\67m8o9q:s;u<w=y>{?}@\177A\u0081B\u0083C\u0085",
    "D\u0087E\u0089F\u008bG\u008dH\u008fI\u0091J\u0093K\u0095L\u0097M\u0099",
    "N\u009bO\u009dP\u009fQ\u00a1R\u00a3S\u00a5T\u00a7U\u00a9V\u00abW\u00ad",
    "X\u00afY\u00b1Z\u00b3[\u00b5\\\u00b7]\u00b9^\u00bb_\u00bd`\u00bfa\u00c1",
    "b\u00c3c\u00c5d\u00c7e\u00c9f\u00cbg\u00cdh\u00cfi\u00d1j\u00d3k\u00d5",
    "l\u00d7m\u00d9n\u00dbo\u00ddp\u00dfq\u00e1r\u00e3s\u00e5t\u00e7u\u00e9",
    "v\u00ebw\u00edx\u00efy\u00f1z\u00f3{\u00f5|\u00f7}\u00f9~\u00fb\177",
    "\u00fd\2\u00ff\u0080\u0101\u0081\u0103\2\u0105\u0082\u0107\u0083\u0109",
    "\u0084\u010b\2\u010d\2\u010f\u0085\u0111\2\u0113\2\u0115\2\u0117\2\u0119",
    "\2\u011b\u0086\u011d\u0087\u011f\u0088\u0121\2\u0123\u0089\u0125\u008a",
    "\u0127\u008b\u0129\u008c\u012b\u008d\u012d\u008e\u012f\u008f\u0131\u0090",
    "\u0133\u0091\3\2\20\6\2&&C\\aac|\4\2))^^\4\2BBNN\4\2$$^^\4\2ZZzz\5\2",
    "\62;CHch\6\2NNWWnnww\4\2GGgg\4\2--//\6\2FFHHffhh\n\2$$))^^ddhhppttv",
    "v\4\2\13\13\"\"\4\2\f\f\17\17\5\2\13\f\16\17\"\"\u053d\2\3\3\2\2\2\2",
    "\5\3\2\2\2\2\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2\2\2\17\3\2",
    "\2\2\2\21\3\2\2\2\2\23\3\2\2\2\2\25\3\2\2\2\2\27\3\2\2\2\2\31\3\2\2",
    "\2\2\33\3\2\2\2\2\35\3\2\2\2\2\37\3\2\2\2\2!\3\2\2\2\2#\3\2\2\2\2%\3",
    "\2\2\2\2\'\3\2\2\2\2)\3\2\2\2\2+\3\2\2\2\2-\3\2\2\2\2/\3\2\2\2\2\61",
    "\3\2\2\2\2\63\3\2\2\2\2\65\3\2\2\2\2\67\3\2\2\2\29\3\2\2\2\2;\3\2\2",
    "\2\2=\3\2\2\2\2?\3\2\2\2\2A\3\2\2\2\2C\3\2\2\2\2E\3\2\2\2\2G\3\2\2\2",
    "\2I\3\2\2\2\2K\3\2\2\2\2M\3\2\2\2\2O\3\2\2\2\2Q\3\2\2\2\2S\3\2\2\2\2",
    "U\3\2\2\2\2W\3\2\2\2\2Y\3\2\2\2\2[\3\2\2\2\2]\3\2\2\2\2_\3\2\2\2\2a",
    "\3\2\2\2\2c\3\2\2\2\2e\3\2\2\2\2g\3\2\2\2\2i\3\2\2\2\2k\3\2\2\2\2m\3",
    "\2\2\2\2o\3\2\2\2\2q\3\2\2\2\2s\3\2\2\2\2u\3\2\2\2\2w\3\2\2\2\2y\3\2",
    "\2\2\2{\3\2\2\2\2}\3\2\2\2\2\177\3\2\2\2\2\u0081\3\2\2\2\2\u0083\3\2",
    "\2\2\2\u0085\3\2\2\2\2\u0087\3\2\2\2\2\u0089\3\2\2\2\2\u008b\3\2\2\2",
    "\2\u008d\3\2\2\2\2\u008f\3\2\2\2\2\u0091\3\2\2\2\2\u0093\3\2\2\2\2\u0095",
    "\3\2\2\2\2\u0097\3\2\2\2\2\u0099\3\2\2\2\2\u009b\3\2\2\2\2\u009d\3\2",
    "\2\2\2\u009f\3\2\2\2\2\u00a1\3\2\2\2\2\u00a3\3\2\2\2\2\u00a5\3\2\2\2",
    "\2\u00a7\3\2\2\2\2\u00a9\3\2\2\2\2\u00ab\3\2\2\2\2\u00ad\3\2\2\2\2\u00af",
    "\3\2\2\2\2\u00b1\3\2\2\2\2\u00b3\3\2\2\2\2\u00b5\3\2\2\2\2\u00b7\3\2",
    "\2\2\2\u00b9\3\2\2\2\2\u00bb\3\2\2\2\2\u00bd\3\2\2\2\2\u00bf\3\2\2\2",
    "\2\u00c1\3\2\2\2\2\u00c3\3\2\2\2\2\u00c5\3\2\2\2\2\u00c7\3\2\2\2\2\u00c9",
    "\3\2\2\2\2\u00cb\3\2\2\2\2\u00cd\3\2\2\2\2\u00cf\3\2\2\2\2\u00d1\3\2",
    "\2\2\2\u00d3\3\2\2\2\2\u00d5\3\2\2\2\2\u00d7\3\2\2\2\2\u00d9\3\2\2\2",
    "\2\u00db\3\2\2\2\2\u00dd\3\2\2\2\2\u00df\3\2\2\2\2\u00e1\3\2\2\2\2\u00e3",
    "\3\2\2\2\2\u00e5\3\2\2\2\2\u00e7\3\2\2\2\2\u00e9\3\2\2\2\2\u00eb\3\2",
    "\2\2\2\u00ed\3\2\2\2\2\u00ef\3\2\2\2\2\u00f1\3\2\2\2\2\u00f3\3\2\2\2",
    "\2\u00f5\3\2\2\2\2\u00f7\3\2\2\2\2\u00f9\3\2\2\2\2\u00fb\3\2\2\2\2\u00ff",
    "\3\2\2\2\2\u0101\3\2\2\2\2\u0105\3\2\2\2\2\u0107\3\2\2\2\2\u0109\3\2",
    "\2\2\2\u010f\3\2\2\2\2\u011b\3\2\2\2\2\u011d\3\2\2\2\2\u011f\3\2\2\2",
    "\2\u0123\3\2\2\2\2\u0125\3\2\2\2\2\u0127\3\2\2\2\2\u0129\3\2\2\2\2\u012b",
    "\3\2\2\2\2\u012d\3\2\2\2\2\u012f\3\2\2\2\2\u0131\3\2\2\2\2\u0133\3\2",
    "\2\2\3\u0135\3\2\2\2\5\u0146\3\2\2\2\7\u014d\3\2\2\2\t\u0154\3\2\2\2",
    "\13\u015d\3\2\2\2\r\u0165\3\2\2\2\17\u016a\3\2\2\2\21\u0173\3\2\2\2",
    "\23\u0183\3\2\2\2\25\u018e\3\2\2\2\27\u0197\3\2\2\2\31\u01a1\3\2\2\2",
    "\33\u01ab\3\2\2\2\35\u01b4\3\2\2\2\37\u01be\3\2\2\2!\u01c9\3\2\2\2#",
    "\u01d1\3\2\2\2%\u01db\3\2\2\2\'\u01e9\3\2\2\2)\u01f5\3\2\2\2+\u01fc",
    "\3\2\2\2-\u0201\3\2\2\2/\u0207\3\2\2\2\61\u020c\3\2\2\2\63\u0215\3\2",
    "\2\2\65\u021a\3\2\2\2\67\u0222\3\2\2\29\u0228\3\2\2\2;\u022f\3\2\2\2",
    "=\u0235\3\2\2\2?\u023a\3\2\2\2A\u023f\3\2\2\2C\u0245\3\2\2\2E\u024e",
    "\3\2\2\2G\u0256\3\2\2\2I\u0259\3\2\2\2K\u0260\3\2\2\2M\u0265\3\2\2\2",
    "O\u026a\3\2\2\2Q\u0271\3\2\2\2S\u0277\3\2\2\2U\u027b\3\2\2\2W\u027e",
    "\3\2\2\2Y\u0281\3\2\2\2[\u0284\3\2\2\2]\u028a\3\2\2\2_\u028f\3\2\2\2",
    "a\u0293\3\2\2\2c\u0298\3\2\2\2e\u029f\3\2\2\2g\u02a3\3\2\2\2i\u02ac",
    "\3\2\2\2k\u02b3\3\2\2\2m\u02b9\3\2\2\2o\u02c0\3\2\2\2q\u02c7\3\2\2\2",
    "s\u02ce\3\2\2\2u\u02d5\3\2\2\2w\u02dc\3\2\2\2y\u02e4\3\2\2\2{\u02ea",
    "\3\2\2\2}\u02f3\3\2\2\2\177\u02f8\3\2\2\2\u0081\u0301\3\2\2\2\u0083",
    "\u0307\3\2\2\2\u0085\u0312\3\2\2\2\u0087\u031a\3\2\2\2\u0089\u0321\3",
    "\2\2\2\u008b\u0335\3\2\2\2\u008d\u0337\3\2\2\2\u008f\u0339\3\2\2\2\u0091",
    "\u033b\3\2\2\2\u0093\u033d\3\2\2\2\u0095\u033f\3\2\2\2\u0097\u0341\3",
    "\2\2\2\u0099\u0343\3\2\2\2\u009b\u0345\3\2\2\2\u009d\u0347\3\2\2\2\u009f",
    "\u034a\3\2\2\2\u00a1\u034c\3\2\2\2\u00a3\u034e\3\2\2\2\u00a5\u0350\3",
    "\2\2\2\u00a7\u0352\3\2\2\2\u00a9\u0354\3\2\2\2\u00ab\u0356\3\2\2\2\u00ad",
    "\u0358\3\2\2\2\u00af\u035a\3\2\2\2\u00b1\u035d\3\2\2\2\u00b3\u0360\3",
    "\2\2\2\u00b5\u0363\3\2\2\2\u00b7\u0366\3\2\2\2\u00b9\u0369\3\2\2\2\u00bb",
    "\u036c\3\2\2\2\u00bd\u036f\3\2\2\2\u00bf\u0372\3\2\2\2\u00c1\u0374\3",
    "\2\2\2\u00c3\u0376\3\2\2\2\u00c5\u0378\3\2\2\2\u00c7\u037a\3\2\2\2\u00c9",
    "\u037c\3\2\2\2\u00cb\u037e\3\2\2\2\u00cd\u0380\3\2\2\2\u00cf\u0382\3",
    "\2\2\2\u00d1\u0385\3\2\2\2\u00d3\u0388\3\2\2\2\u00d5\u038b\3\2\2\2\u00d7",
    "\u038e\3\2\2\2\u00d9\u0391\3\2\2\2\u00db\u0394\3\2\2\2\u00dd\u0397\3",
    "\2\2\2\u00df\u039a\3\2\2\2\u00e1\u039d\3\2\2\2\u00e3\u03a0\3\2\2\2\u00e5",
    "\u03a4\3\2\2\2\u00e7\u03a8\3\2\2\2\u00e9\u03ac\3\2\2\2\u00eb\u03b3\3",
    "\2\2\2\u00ed\u03ba\3\2\2\2\u00ef\u03c4\3\2\2\2\u00f1\u03cb\3\2\2\2\u00f3",
    "\u03d2\3\2\2\2\u00f5\u03d9\3\2\2\2\u00f7\u03e2\3\2\2\2\u00f9\u03ec\3",
    "\2\2\2\u00fb\u03f1\3\2\2\2\u00fd\u03f9\3\2\2\2\u00ff\u03fb\3\2\2\2\u0101",
    "\u0402\3\2\2\2\u0103\u0405\3\2\2\2\u0105\u040f\3\2\2\2\u0107\u0421\3",
    "\2\2\2\u0109\u0426\3\2\2\2\u010b\u042f\3\2\2\2\u010d\u0431\3\2\2\2\u010f",
    "\u0434\3\2\2\2\u0111\u0447\3\2\2\2\u0113\u0450\3\2\2\2\u0115\u0455\3",
    "\2\2\2\u0117\u0460\3\2\2\2\u0119\u0462\3\2\2\2\u011b\u0469\3\2\2\2\u011d",
    "\u047f\3\2\2\2\u011f\u0496\3\2\2\2\u0121\u04a6\3\2\2\2\u0123\u04af\3",
    "\2\2\2\u0125\u04b3\3\2\2\2\u0127\u04c1\3\2\2\2\u0129\u04cc\3\2\2\2\u012b",
    "\u04dc\3\2\2\2\u012d\u04e8\3\2\2\2\u012f\u04f6\3\2\2\2\u0131\u0505\3",
    "\2\2\2\u0133\u0515\3\2\2\2\u0135\u0136\7B\2\2\u0136\u0137\7c\2\2\u0137",
    "\u0138\7w\2\2\u0138\u0139\7v\2\2\u0139\u013a\7q\2\2\u013a\u013b\7t\2",
    "\2\u013b\u013c\7g\2\2\u013c\u013d\7n\2\2\u013d\u013e\7g\2\2\u013e\u013f",
    "\7c\2\2\u013f\u0140\7u\2\2\u0140\u0141\7g\2\2\u0141\u0142\7r\2\2\u0142",
    "\u0143\7q\2\2\u0143\u0144\7q\2\2\u0144\u0145\7n\2\2\u0145\4\3\2\2\2",
    "\u0146\u0147\7B\2\2\u0147\u0148\7e\2\2\u0148\u0149\7c\2\2\u0149\u014a",
    "\7v\2\2\u014a\u014b\7e\2\2\u014b\u014c\7j\2\2\u014c\6\3\2\2\2\u014d",
    "\u014e\7B\2\2\u014e\u014f\7e\2\2\u014f\u0150\7n\2\2\u0150\u0151\7c\2",
    "\2\u0151\u0152\7u\2\2\u0152\u0153\7u\2\2\u0153\b\3\2\2\2\u0154\u0155",
    "\7B\2\2\u0155\u0156\7f\2\2\u0156\u0157\7{\2\2\u0157\u0158\7p\2\2\u0158",
    "\u0159\7c\2\2\u0159\u015a\7o\2\2\u015a\u015b\7k\2\2\u015b\u015c\7e\2",
    "\2\u015c\n\3\2\2\2\u015d\u015e\7B\2\2\u015e\u015f\7g\2\2\u015f\u0160",
    "\7p\2\2\u0160\u0161\7e\2\2\u0161\u0162\7q\2\2\u0162\u0163\7f\2\2\u0163",
    "\u0164\7g\2\2\u0164\f\3\2\2\2\u0165\u0166\7B\2\2\u0166\u0167\7g\2\2",
    "\u0167\u0168\7p\2\2\u0168\u0169\7f\2\2\u0169\16\3\2\2\2\u016a\u016b",
    "\7B\2\2\u016b\u016c\7h\2\2\u016c\u016d\7k\2\2\u016d\u016e\7p\2\2\u016e",
    "\u016f\7c\2\2\u016f\u0170\7n\2\2\u0170\u0171\7n\2\2\u0171\u0172\7{\2",
    "\2\u0172\20\3\2\2\2\u0173\u0174\7B\2\2\u0174\u0175\7k\2\2\u0175\u0176",
    "\7o\2\2\u0176\u0177\7r\2\2\u0177\u0178\7n\2\2\u0178\u0179\7g\2\2\u0179",
    "\u017a\7o\2\2\u017a\u017b\7g\2\2\u017b\u017c\7p\2\2\u017c\u017d\7v\2",
    "\2\u017d\u017e\7c\2\2\u017e\u017f\7v\2\2\u017f\u0180\7k\2\2\u0180\u0181",
    "\7q\2\2\u0181\u0182\7p\2\2\u0182\22\3\2\2\2\u0183\u0184\7B\2\2\u0184",
    "\u0185\7k\2\2\u0185\u0186\7p\2\2\u0186\u0187\7v\2\2\u0187\u0188\7g\2",
    "\2\u0188\u0189\7t\2\2\u0189\u018a\7h\2\2\u018a\u018b\7c\2\2\u018b\u018c",
    "\7e\2\2\u018c\u018d\7g\2\2\u018d\24\3\2\2\2\u018e\u018f\7B\2\2\u018f",
    "\u0190\7r\2\2\u0190\u0191\7c\2\2\u0191\u0192\7e\2\2\u0192\u0193\7m\2",
    "\2\u0193\u0194\7c\2\2\u0194\u0195\7i\2\2\u0195\u0196\7g\2\2\u0196\26",
    "\3\2\2\2\u0197\u0198\7B\2\2\u0198\u0199\7r\2\2\u0199\u019a\7t\2\2\u019a",
    "\u019b\7q\2\2\u019b\u019c\7v\2\2\u019c\u019d\7q\2\2\u019d\u019e\7e\2",
    "\2\u019e\u019f\7q\2\2\u019f\u01a0\7n\2\2\u01a0\30\3\2\2\2\u01a1\u01a2",
    "\7B\2\2\u01a2\u01a3\7q\2\2\u01a3\u01a4\7r\2\2\u01a4\u01a5\7v\2\2\u01a5",
    "\u01a6\7k\2\2\u01a6\u01a7\7q\2\2\u01a7\u01a8\7p\2\2\u01a8\u01a9\7c\2",
    "\2\u01a9\u01aa\7n\2\2\u01aa\32\3\2\2\2\u01ab\u01ac\7B\2\2\u01ac\u01ad",
    "\7r\2\2\u01ad\u01ae\7t\2\2\u01ae\u01af\7k\2\2\u01af\u01b0\7x\2\2\u01b0",
    "\u01b1\7c\2\2\u01b1\u01b2\7v\2\2\u01b2\u01b3\7g\2\2\u01b3\34\3\2\2\2",
    "\u01b4\u01b5\7B\2\2\u01b5\u01b6\7r\2\2\u01b6\u01b7\7t\2\2\u01b7\u01b8",
    "\7q\2\2\u01b8\u01b9\7r\2\2\u01b9\u01ba\7g\2\2\u01ba\u01bb\7t\2\2\u01bb",
    "\u01bc\7v\2\2\u01bc\u01bd\7{\2\2\u01bd\36\3\2\2\2\u01be\u01bf\7B\2\2",
    "\u01bf\u01c0\7r\2\2\u01c0\u01c1\7t\2\2\u01c1\u01c2\7q\2\2\u01c2\u01c3",
    "\7v\2\2\u01c3\u01c4\7g\2\2\u01c4\u01c5\7e\2\2\u01c5\u01c6\7v\2\2\u01c6",
    "\u01c7\7g\2\2\u01c7\u01c8\7f\2\2\u01c8 \3\2\2\2\u01c9\u01ca\7B\2\2\u01ca",
    "\u01cb\7r\2\2\u01cb\u01cc\7w\2\2\u01cc\u01cd\7d\2\2\u01cd\u01ce\7n\2",
    "\2\u01ce\u01cf\7k\2\2\u01cf\u01d0\7e\2\2\u01d0\"\3\2\2\2\u01d1\u01d2",
    "\7B\2\2\u01d2\u01d3\7u\2\2\u01d3\u01d4\7g\2\2\u01d4\u01d5\7n\2\2\u01d5",
    "\u01d6\7g\2\2\u01d6\u01d7\7e\2\2\u01d7\u01d8\7v\2\2\u01d8\u01d9\7q\2",
    "\2\u01d9\u01da\7t\2\2\u01da$\3\2\2\2\u01db\u01dc\7B\2\2\u01dc\u01dd",
    "\7u\2\2\u01dd\u01de\7{\2\2\u01de\u01df\7p\2\2\u01df\u01e0\7e\2\2\u01e0",
    "\u01e1\7j\2\2\u01e1\u01e2\7t\2\2\u01e2\u01e3\7q\2\2\u01e3\u01e4\7p\2",
    "\2\u01e4\u01e5\7k\2\2\u01e5\u01e6\7|\2\2\u01e6\u01e7\7g\2\2\u01e7\u01e8",
    "\7f\2\2\u01e8&\3\2\2\2\u01e9\u01ea\7B\2\2\u01ea\u01eb\7u\2\2\u01eb\u01ec",
    "\7{\2\2\u01ec\u01ed\7p\2\2\u01ed\u01ee\7v\2\2\u01ee\u01ef\7j\2\2\u01ef",
    "\u01f0\7g\2\2\u01f0\u01f1\7u\2\2\u01f1\u01f2\7k\2\2\u01f2\u01f3\7|\2",
    "\2\u01f3\u01f4\7g\2\2\u01f4(\3\2\2\2\u01f5\u01f6\7B\2\2\u01f6\u01f7",
    "\7v\2\2\u01f7\u01f8\7j\2\2\u01f8\u01f9\7t\2\2\u01f9\u01fa\7q\2\2\u01fa",
    "\u01fb\7y\2\2\u01fb*\3\2\2\2\u01fc\u01fd\7B\2\2\u01fd\u01fe\7v\2\2\u01fe",
    "\u01ff\7t\2\2\u01ff\u0200\7{\2\2\u0200,\3\2\2\2\u0201\u0202\7u\2\2\u0202",
    "\u0203\7w\2\2\u0203\u0204\7r\2\2\u0204\u0205\7g\2\2\u0205\u0206\7t\2",
    "\2\u0206.\3\2\2\2\u0207\u0208\7u\2\2\u0208\u0209\7g\2\2\u0209\u020a",
    "\7n\2\2\u020a\u020b\7h\2\2\u020b\60\3\2\2\2\u020c\u020d\7c\2\2\u020d",
    "\u020e\7d\2\2\u020e\u020f\7u\2\2\u020f\u0210\7v\2\2\u0210\u0211\7t\2",
    "\2\u0211\u0212\7c\2\2\u0212\u0213\7e\2\2\u0213\u0214\7v\2\2\u0214\62",
    "\3\2\2\2\u0215\u0216\7c\2\2\u0216\u0217\7w\2\2\u0217\u0218\7v\2\2\u0218",
    "\u0219\7q\2\2\u0219\64\3\2\2\2\u021a\u021b\7d\2\2\u021b\u021c\7q\2\2",
    "\u021c\u021d\7q\2\2\u021d\u021e\7n\2\2\u021e\u021f\7g\2\2\u021f\u0220",
    "\7c\2\2\u0220\u0221\7p\2\2\u0221\66\3\2\2\2\u0222\u0223\7d\2\2\u0223",
    "\u0224\7t\2\2\u0224\u0225\7g\2\2\u0225\u0226\7c\2\2\u0226\u0227\7m\2",
    "\2\u02278\3\2\2\2\u0228\u0229\7d\2\2\u0229\u022a\7{\2\2\u022a\u022b",
    "\7e\2\2\u022b\u022c\7q\2\2\u022c\u022d\7r\2\2\u022d\u022e\7{\2\2\u022e",
    ":\3\2\2\2\u022f\u0230\7d\2\2\u0230\u0231\7{\2\2\u0231\u0232\7t\2\2\u0232",
    "\u0233\7g\2\2\u0233\u0234\7h\2\2\u0234<\3\2\2\2\u0235\u0236\7e\2\2\u0236",
    "\u0237\7c\2\2\u0237\u0238\7u\2\2\u0238\u0239\7g\2\2\u0239>\3\2\2\2\u023a",
    "\u023b\7e\2\2\u023b\u023c\7j\2\2\u023c\u023d\7c\2\2\u023d\u023e\7t\2",
    "\2\u023e@\3\2\2\2\u023f\u0240\7e\2\2\u0240\u0241\7q\2\2\u0241\u0242",
    "\7p\2\2\u0242\u0243\7u\2\2\u0243\u0244\7v\2\2\u0244B\3\2\2\2\u0245\u0246",
    "\7e\2\2\u0246\u0247\7q\2\2\u0247\u0248\7p\2\2\u0248\u0249\7v\2\2\u0249",
    "\u024a\7k\2\2\u024a\u024b\7p\2\2\u024b\u024c\7w\2\2\u024c\u024d\7g\2",
    "\2\u024dD\3\2\2\2\u024e\u024f\7f\2\2\u024f\u0250\7g\2\2\u0250\u0251",
    "\7h\2\2\u0251\u0252\7c\2\2\u0252\u0253\7w\2\2\u0253\u0254\7n\2\2\u0254",
    "\u0255\7v\2\2\u0255F\3\2\2\2\u0256\u0257\7f\2\2\u0257\u0258\7q\2\2\u0258",
    "H\3\2\2\2\u0259\u025a\7f\2\2\u025a\u025b\7q\2\2\u025b\u025c\7w\2\2\u025c",
    "\u025d\7d\2\2\u025d\u025e\7n\2\2\u025e\u025f\7g\2\2\u025fJ\3\2\2\2\u0260",
    "\u0261\7g\2\2\u0261\u0262\7n\2\2\u0262\u0263\7u\2\2\u0263\u0264\7g\2",
    "\2\u0264L\3\2\2\2\u0265\u0266\7g\2\2\u0266\u0267\7p\2\2\u0267\u0268",
    "\7w\2\2\u0268\u0269\7o\2\2\u0269N\3\2\2\2\u026a\u026b\7g\2\2\u026b\u026c",
    "\7z\2\2\u026c\u026d\7v\2\2\u026d\u026e\7g\2\2\u026e\u026f\7t\2\2\u026f",
    "\u0270\7p\2\2\u0270P\3\2\2\2\u0271\u0272\7h\2\2\u0272\u0273\7n\2\2\u0273",
    "\u0274\7q\2\2\u0274\u0275\7c\2\2\u0275\u0276\7v\2\2\u0276R\3\2\2\2\u0277",
    "\u0278\7h\2\2\u0278\u0279\7q\2\2\u0279\u027a\7t\2\2\u027aT\3\2\2\2\u027b",
    "\u027c\7k\2\2\u027c\u027d\7f\2\2\u027dV\3\2\2\2\u027e\u027f\7k\2\2\u027f",
    "\u0280\7h\2\2\u0280X\3\2\2\2\u0281\u0282\7k\2\2\u0282\u0283\7p\2\2\u0283",
    "Z\3\2\2\2\u0284\u0285\7k\2\2\u0285\u0286\7p\2\2\u0286\u0287\7q\2\2\u0287",
    "\u0288\7w\2\2\u0288\u0289\7v\2\2\u0289\\\3\2\2\2\u028a\u028b\7i\2\2",
    "\u028b\u028c\7q\2\2\u028c\u028d\7v\2\2\u028d\u028e\7q\2\2\u028e^\3\2",
    "\2\2\u028f\u0290\7k\2\2\u0290\u0291\7p\2\2\u0291\u0292\7v\2\2\u0292",
    "`\3\2\2\2\u0293\u0294\7n\2\2\u0294\u0295\7q\2\2\u0295\u0296\7p\2\2\u0296",
    "\u0297\7i\2\2\u0297b\3\2\2\2\u0298\u0299\7q\2\2\u0299\u029a\7p\2\2\u029a",
    "\u029b\7g\2\2\u029b\u029c\7y\2\2\u029c\u029d\7c\2\2\u029d\u029e\7{\2",
    "\2\u029ed\3\2\2\2\u029f\u02a0\7q\2\2\u02a0\u02a1\7w\2\2\u02a1\u02a2",
    "\7v\2\2\u02a2f\3\2\2\2\u02a3\u02a4\7t\2\2\u02a4\u02a5\7g\2\2\u02a5\u02a6",
    "\7i\2\2\u02a6\u02a7\7k\2\2\u02a7\u02a8\7u\2\2\u02a8\u02a9\7v\2\2\u02a9",
    "\u02aa\7g\2\2\u02aa\u02ab\7t\2\2\u02abh\3\2\2\2\u02ac\u02ad\7t\2\2\u02ad",
    "\u02ae\7g\2\2\u02ae\u02af\7v\2\2\u02af\u02b0\7w\2\2\u02b0\u02b1\7t\2",
    "\2\u02b1\u02b2\7p\2\2\u02b2j\3\2\2\2\u02b3\u02b4\7u\2\2\u02b4\u02b5",
    "\7j\2\2\u02b5\u02b6\7q\2\2\u02b6\u02b7\7t\2\2\u02b7\u02b8\7v\2\2\u02b8",
    "l\3\2\2\2\u02b9\u02ba\7u\2\2\u02ba\u02bb\7k\2\2\u02bb\u02bc\7i\2\2\u02bc",
    "\u02bd\7p\2\2\u02bd\u02be\7g\2\2\u02be\u02bf\7f\2\2\u02bfn\3\2\2\2\u02c0",
    "\u02c1\7u\2\2\u02c1\u02c2\7k\2\2\u02c2\u02c3\7|\2\2\u02c3\u02c4\7g\2",
    "\2\u02c4\u02c5\7q\2\2\u02c5\u02c6\7h\2\2\u02c6p\3\2\2\2\u02c7\u02c8",
    "\7u\2\2\u02c8\u02c9\7v\2\2\u02c9\u02ca\7c\2\2\u02ca\u02cb\7v\2\2\u02cb",
    "\u02cc\7k\2\2\u02cc\u02cd\7e\2\2\u02cdr\3\2\2\2\u02ce\u02cf\7u\2\2\u02cf",
    "\u02d0\7v\2\2\u02d0\u02d1\7t\2\2\u02d1\u02d2\7w\2\2\u02d2\u02d3\7e\2",
    "\2\u02d3\u02d4\7v\2\2\u02d4t\3\2\2\2\u02d5\u02d6\7u\2\2\u02d6\u02d7",
    "\7y\2\2\u02d7\u02d8\7k\2\2\u02d8\u02d9\7v\2\2\u02d9\u02da\7e\2\2\u02da",
    "\u02db\7j\2\2\u02dbv\3\2\2\2\u02dc\u02dd\7v\2\2\u02dd\u02de\7{\2\2\u02de",
    "\u02df\7r\2\2\u02df\u02e0\7g\2\2\u02e0\u02e1\7f\2\2\u02e1\u02e2\7g\2",
    "\2\u02e2\u02e3\7h\2\2\u02e3x\3\2\2\2\u02e4\u02e5\7w\2\2\u02e5\u02e6",
    "\7p\2\2\u02e6\u02e7\7k\2\2\u02e7\u02e8\7q\2\2\u02e8\u02e9\7p\2\2\u02e9",
    "z\3\2\2\2\u02ea\u02eb\7w\2\2\u02eb\u02ec\7p\2\2\u02ec\u02ed\7u\2\2\u02ed",
    "\u02ee\7k\2\2\u02ee\u02ef\7i\2\2\u02ef\u02f0\7p\2\2\u02f0\u02f1\7g\2",
    "\2\u02f1\u02f2\7f\2\2\u02f2|\3\2\2\2\u02f3\u02f4\7x\2\2\u02f4\u02f5",
    "\7q\2\2\u02f5\u02f6\7k\2\2\u02f6\u02f7\7f\2\2\u02f7~\3\2\2\2\u02f8\u02f9",
    "\7x\2\2\u02f9\u02fa\7q\2\2\u02fa\u02fb\7n\2\2\u02fb\u02fc\7c\2\2\u02fc",
    "\u02fd\7v\2\2\u02fd\u02fe\7k\2\2\u02fe\u02ff\7n\2\2\u02ff\u0300\7g\2",
    "\2\u0300\u0080\3\2\2\2\u0301\u0302\7y\2\2\u0302\u0303\7j\2\2\u0303\u0304",
    "\7k\2\2\u0304\u0305\7n\2\2\u0305\u0306\7g\2\2\u0306\u0082\3\2\2\2\u0307",
    "\u0308\7P\2\2\u0308\u0309\7U\2\2\u0309\u030a\7a\2\2\u030a\u030b\7Q\2",
    "\2\u030b\u030c\7R\2\2\u030c\u030d\7V\2\2\u030d\u030e\7K\2\2\u030e\u030f",
    "\7Q\2\2\u030f\u0310\7P\2\2\u0310\u0311\7U\2\2\u0311\u0084\3\2\2\2\u0312",
    "\u0313\7P\2\2\u0313\u0314\7U\2\2\u0314\u0315\7a\2\2\u0315\u0316\7G\2",
    "\2\u0316\u0317\7P\2\2\u0317\u0318\7W\2\2\u0318\u0319\7O\2\2\u0319\u0086",
    "\3\2\2\2\u031a\u031b\7a\2\2\u031b\u031c\7a\2\2\u031c\u031d\7y\2\2\u031d",
    "\u031e\7g\2\2\u031e\u031f\7c\2\2\u031f\u0320\7m\2\2\u0320\u0088\3\2",
    "\2\2\u0321\u0322\7a\2\2\u0322\u0323\7a\2\2\u0323\u0324\7w\2\2\u0324",
    "\u0325\7p\2\2\u0325\u0326\7u\2\2\u0326\u0327\7c\2\2\u0327\u0328\7h\2",
    "\2\u0328\u0329\7g\2\2\u0329\u032a\7a\2\2\u032a\u032b\7w\2\2\u032b\u032c",
    "\7p\2\2\u032c\u032d\7t\2\2\u032d\u032e\7g\2\2\u032e\u032f\7v\2\2\u032f",
    "\u0330\7c\2\2\u0330\u0331\7k\2\2\u0331\u0332\7p\2\2\u0332\u0333\7g\2",
    "\2\u0333\u0334\7f\2\2\u0334\u008a\3\2\2\2\u0335\u0336\7*\2\2\u0336\u008c",
    "\3\2\2\2\u0337\u0338\7+\2\2\u0338\u008e\3\2\2\2\u0339\u033a\7}\2\2\u033a",
    "\u0090\3\2\2\2\u033b\u033c\7\177\2\2\u033c\u0092\3\2\2\2\u033d\u033e",
    "\7]\2\2\u033e\u0094\3\2\2\2\u033f\u0340\7_\2\2\u0340\u0096\3\2\2\2\u0341",
    "\u0342\7=\2\2\u0342\u0098\3\2\2\2\u0343\u0344\7.\2\2\u0344\u009a\3\2",
    "\2\2\u0345\u0346\7\60\2\2\u0346\u009c\3\2\2\2\u0347\u0348\7/\2\2\u0348",
    "\u0349\7@\2\2\u0349\u009e\3\2\2\2\u034a\u034b\7B\2\2\u034b\u00a0\3\2",
    "\2\2\u034c\u034d\7?\2\2\u034d\u00a2\3\2\2\2\u034e\u034f\7@\2\2\u034f",
    "\u00a4\3\2\2\2\u0350\u0351\7>\2\2\u0351\u00a6\3\2\2\2\u0352\u0353\7",
    "#\2\2\u0353\u00a8\3\2\2\2\u0354\u0355\7\u0080\2\2\u0355\u00aa\3\2\2",
    "\2\u0356\u0357\7A\2\2\u0357\u00ac\3\2\2\2\u0358\u0359\7<\2\2\u0359\u00ae",
    "\3\2\2\2\u035a\u035b\7?\2\2\u035b\u035c\7?\2\2\u035c\u00b0\3\2\2\2\u035d",
    "\u035e\7>\2\2\u035e\u035f\7?\2\2\u035f\u00b2\3\2\2\2\u0360\u0361\7@",
    "\2\2\u0361\u0362\7?\2\2\u0362\u00b4\3\2\2\2\u0363\u0364\7#\2\2\u0364",
    "\u0365\7?\2\2\u0365\u00b6\3\2\2\2\u0366\u0367\7(\2\2\u0367\u0368\7(",
    "\2\2\u0368\u00b8\3\2\2\2\u0369\u036a\7~\2\2\u036a\u036b\7~\2\2\u036b",
    "\u00ba\3\2\2\2\u036c\u036d\7-\2\2\u036d\u036e\7-\2\2\u036e\u00bc\3\2",
    "\2\2\u036f\u0370\7/\2\2\u0370\u0371\7/\2\2\u0371\u00be\3\2\2\2\u0372",
    "\u0373\7-\2\2\u0373\u00c0\3\2\2\2\u0374\u0375\7/\2\2\u0375\u00c2\3\2",
    "\2\2\u0376\u0377\7,\2\2\u0377\u00c4\3\2\2\2\u0378\u0379\7\61\2\2\u0379",
    "\u00c6\3\2\2\2\u037a\u037b\7(\2\2\u037b\u00c8\3\2\2\2\u037c\u037d\7",
    "~\2\2\u037d\u00ca\3\2\2\2\u037e\u037f\7`\2\2\u037f\u00cc\3\2\2\2\u0380",
    "\u0381\7\'\2\2\u0381\u00ce\3\2\2\2\u0382\u0383\7@\2\2\u0383\u0384\7",
    "@\2\2\u0384\u00d0\3\2\2\2\u0385\u0386\7>\2\2\u0386\u0387\7>\2\2\u0387",
    "\u00d2\3\2\2\2\u0388\u0389\7-\2\2\u0389\u038a\7?\2\2\u038a\u00d4\3\2",
    "\2\2\u038b\u038c\7/\2\2\u038c\u038d\7?\2\2\u038d\u00d6\3\2\2\2\u038e",
    "\u038f\7,\2\2\u038f\u0390\7?\2\2\u0390\u00d8\3\2\2\2\u0391\u0392\7\61",
    "\2\2\u0392\u0393\7?\2\2\u0393\u00da\3\2\2\2\u0394\u0395\7(\2\2\u0395",
    "\u0396\7?\2\2\u0396\u00dc\3\2\2\2\u0397\u0398\7~\2\2\u0398\u0399\7?",
    "\2\2\u0399\u00de\3\2\2\2\u039a\u039b\7`\2\2\u039b\u039c\7?\2\2\u039c",
    "\u00e0\3\2\2\2\u039d\u039e\7\'\2\2\u039e\u039f\7?\2\2\u039f\u00e2\3",
    "\2\2\2\u03a0\u03a1\7>\2\2\u03a1\u03a2\7>\2\2\u03a2\u03a3\7?\2\2\u03a3",
    "\u00e4\3\2\2\2\u03a4\u03a5\7@\2\2\u03a5\u03a6\7@\2\2\u03a6\u03a7\7?",
    "\2\2\u03a7\u00e6\3\2\2\2\u03a8\u03a9\7\60\2\2\u03a9\u03aa\7\60\2\2\u03aa",
    "\u03ab\7\60\2\2\u03ab\u00e8\3\2\2\2\u03ac\u03ad\7c\2\2\u03ad\u03ae\7",
    "u\2\2\u03ae\u03af\7u\2\2\u03af\u03b0\7k\2\2\u03b0\u03b1\7i\2\2\u03b1",
    "\u03b2\7p\2\2\u03b2\u00ea\3\2\2\2\u03b3\u03b4\7i\2\2\u03b4\u03b5\7g",
    "\2\2\u03b5\u03b6\7v\2\2\u03b6\u03b7\7v\2\2\u03b7\u03b8\7g\2\2\u03b8",
    "\u03b9\7t\2\2\u03b9\u00ec\3\2\2\2\u03ba\u03bb\7p\2\2\u03bb\u03bc\7q",
    "\2\2\u03bc\u03bd\7p\2\2\u03bd\u03be\7c\2\2\u03be\u03bf\7v\2\2\u03bf",
    "\u03c0\7q\2\2\u03c0\u03c1\7o\2\2\u03c1\u03c2\7k\2\2\u03c2\u03c3\7e\2",
    "\2\u03c3\u00ee\3\2\2\2\u03c4\u03c5\7u\2\2\u03c5\u03c6\7g\2\2\u03c6\u03c7",
    "\7v\2\2\u03c7\u03c8\7v\2\2\u03c8\u03c9\7g\2\2\u03c9\u03ca\7t\2\2\u03ca",
    "\u00f0\3\2\2\2\u03cb\u03cc\7u\2\2\u03cc\u03cd\7v\2\2\u03cd\u03ce\7t",
    "\2\2\u03ce\u03cf\7q\2\2\u03cf\u03d0\7p\2\2\u03d0\u03d1\7i\2\2\u03d1",
    "\u00f2\3\2\2\2\u03d2\u03d3\7t\2\2\u03d3\u03d4\7g\2\2\u03d4\u03d5\7v",
    "\2\2\u03d5\u03d6\7c\2\2\u03d6\u03d7\7k\2\2\u03d7\u03d8\7p\2\2\u03d8",
    "\u00f4\3\2\2\2\u03d9\u03da\7t\2\2\u03da\u03db\7g\2\2\u03db\u03dc\7c",
    "\2\2\u03dc\u03dd\7f\2\2\u03dd\u03de\7q\2\2\u03de\u03df\7p\2\2\u03df",
    "\u03e0\7n\2\2\u03e0\u03e1\7{\2\2\u03e1\u00f6\3\2\2\2\u03e2\u03e3\7t",
    "\2\2\u03e3\u03e4\7g\2\2\u03e4\u03e5\7c\2\2\u03e5\u03e6\7f\2\2\u03e6",
    "\u03e7\7y\2\2\u03e7\u03e8\7t\2\2\u03e8\u03e9\7k\2\2\u03e9\u03ea\7v\2",
    "\2\u03ea\u03eb\7g\2\2\u03eb\u00f8\3\2\2\2\u03ec\u03ed\7y\2\2\u03ed\u03ee",
    "\7g\2\2\u03ee\u03ef\7c\2\2\u03ef\u03f0\7m\2\2\u03f0\u00fa\3\2\2\2\u03f1",
    "\u03f6\5\u00fd\177\2\u03f2\u03f5\5\u00fd\177\2\u03f3\u03f5\4\62;\2\u03f4",
    "\u03f2\3\2\2\2\u03f4\u03f3\3\2\2\2\u03f5\u03f8\3\2\2\2\u03f6\u03f4\3",
    "\2\2\2\u03f6\u03f7\3\2\2\2\u03f7\u00fc\3\2\2\2\u03f8\u03f6\3\2\2\2\u03f9",
    "\u03fa\t\2\2\2\u03fa\u00fe\3\2\2\2\u03fb\u03fe\7)\2\2\u03fc\u03ff\5",
    "\u0115\u008b\2\u03fd\u03ff\n\3\2\2\u03fe\u03fc\3\2\2\2\u03fe\u03fd\3",
    "\2\2\2\u03ff\u0400\3\2\2\2\u0400\u0401\7)\2\2\u0401\u0100\3\2\2\2\u0402",
    "\u0403\t\4\2\2\u0403\u0404\5\u0103\u0082\2\u0404\u0102\3\2\2\2\u0405",
    "\u040a\7$\2\2\u0406\u0409\5\u0115\u008b\2\u0407\u0409\n\5\2\2\u0408",
    "\u0406\3\2\2\2\u0408\u0407\3\2\2\2\u0409\u040c\3\2\2\2\u040a\u0408\3",
    "\2\2\2\u040a\u040b\3\2\2\2\u040b\u040d\3\2\2\2\u040c\u040a\3\2\2\2\u040d",
    "\u040e\7$\2\2\u040e\u0104\3\2\2\2\u040f\u0410\7\62\2\2\u0410\u0412\t",
    "\6\2\2\u0411\u0413\5\u010b\u0086\2\u0412\u0411\3\2\2\2\u0413\u0414\3",
    "\2\2\2\u0414\u0412\3\2\2\2\u0414\u0415\3\2\2\2\u0415\u0417\3\2\2\2\u0416",
    "\u0418\5\u010d\u0087\2\u0417\u0416\3\2\2\2\u0417\u0418\3\2\2\2\u0418",
    "\u0106\3\2\2\2\u0419\u0422\7\62\2\2\u041a\u041e\4\63;\2\u041b\u041d",
    "\4\62;\2\u041c\u041b\3\2\2\2\u041d\u0420\3\2\2\2\u041e\u041c\3\2\2\2",
    "\u041e\u041f\3\2\2\2\u041f\u0422\3\2\2\2\u0420\u041e\3\2\2\2\u0421\u0419",
    "\3\2\2\2\u0421\u041a\3\2\2\2\u0422\u0424\3\2\2\2\u0423\u0425\5\u010d",
    "\u0087\2\u0424\u0423\3\2\2\2\u0424\u0425\3\2\2\2\u0425\u0108\3\2\2\2",
    "\u0426\u0428\7\62\2\2\u0427\u0429\4\629\2\u0428\u0427\3\2\2\2\u0429",
    "\u042a\3\2\2\2\u042a\u0428\3\2\2\2\u042a\u042b\3\2\2\2\u042b\u042d\3",
    "\2\2\2\u042c\u042e\5\u010d\u0087\2\u042d\u042c\3\2\2\2\u042d\u042e\3",
    "\2\2\2\u042e\u010a\3\2\2\2\u042f\u0430\t\7\2\2\u0430\u010c\3\2\2\2\u0431",
    "\u0432\t\b\2\2\u0432\u010e\3\2\2\2\u0433\u0435\4\62;\2\u0434\u0433\3",
    "\2\2\2\u0435\u0436\3\2\2\2\u0436\u0434\3\2\2\2\u0436\u0437\3\2\2\2\u0437",
    "\u043f\3\2\2\2\u0438\u043c\7\60\2\2\u0439\u043b\4\62;\2\u043a\u0439",
    "\3\2\2\2\u043b\u043e\3\2\2\2\u043c\u043a\3\2\2\2\u043c\u043d\3\2\2\2",
    "\u043d\u0440\3\2\2\2\u043e\u043c\3\2\2\2\u043f\u0438\3\2\2\2\u043f\u0440",
    "\3\2\2\2\u0440\u0442\3\2\2\2\u0441\u0443\5\u0111\u0089\2\u0442\u0441",
    "\3\2\2\2\u0442\u0443\3\2\2\2\u0443\u0445\3\2\2\2\u0444\u0446\5\u0113",
    "\u008a\2\u0445\u0444\3\2\2\2\u0445\u0446\3\2\2\2\u0446\u0110\3\2\2\2",
    "\u0447\u0449\t\t\2\2\u0448\u044a\t\n\2\2\u0449\u0448\3\2\2\2\u0449\u044a",
    "\3\2\2\2\u044a\u044c\3\2\2\2\u044b\u044d\4\62;\2\u044c\u044b\3\2\2\2",
    "\u044d\u044e\3\2\2\2\u044e\u044c\3\2\2\2\u044e\u044f\3\2\2\2\u044f\u0112",
    "\3\2\2\2\u0450\u0451\t\13\2\2\u0451\u0114\3\2\2\2\u0452\u0453\7^\2\2",
    "\u0453\u0456\t\f\2\2\u0454\u0456\5\u0117\u008c\2\u0455\u0452\3\2\2\2",
    "\u0455\u0454\3\2\2\2\u0456\u0116\3\2\2\2\u0457\u0458\7^\2\2\u0458\u0459",
    "\4\62\65\2\u0459\u045a\4\629\2\u045a\u0461\4\629\2\u045b\u045c\7^\2",
    "\2\u045c\u045d\4\629\2\u045d\u0461\4\629\2\u045e\u045f\7^\2\2\u045f",
    "\u0461\4\629\2\u0460\u0457\3\2\2\2\u0460\u045b\3\2\2\2\u0460\u045e\3",
    "\2\2\2\u0461\u0118\3\2\2\2\u0462\u0463\7^\2\2\u0463\u0464\7w\2\2\u0464",
    "\u0465\5\u010b\u0086\2\u0465\u0466\5\u010b\u0086\2\u0466\u0467\5\u010b",
    "\u0086\2\u0467\u0468\5\u010b\u0086\2\u0468\u011a\3\2\2\2\u0469\u046a",
    "\7%\2\2\u046a\u046b\7k\2\2\u046b\u046c\7o\2\2\u046c\u046d\7r\2\2\u046d",
    "\u046e\7q\2\2\u046e\u046f\7t\2\2\u046f\u0470\7v\2\2\u0470\u0474\3\2",
    "\2\2\u0471\u0473\t\r\2\2\u0472\u0471\3\2\2\2\u0473\u0476\3\2\2\2\u0474",
    "\u0472\3\2\2\2\u0474\u0475\3\2\2\2\u0475\u0479\3\2\2\2\u0476\u0474\3",
    "\2\2\2\u0477\u047a\5\u0103\u0082\2\u0478\u047a\5\u0121\u0091\2\u0479",
    "\u0477\3\2\2\2\u0479\u0478\3\2\2\2\u047a\u047b\3\2\2\2\u047b\u047c\5",
    "\u0123\u0092\2\u047c\u047d\3\2\2\2\u047d\u047e\b\u008e\2\2\u047e\u011c",
    "\3\2\2\2\u047f\u0480\7%\2\2\u0480\u0481\7k\2\2\u0481\u0482\7p\2\2\u0482",
    "\u0483\7e\2\2\u0483\u0484\7n\2\2\u0484\u0485\7w\2\2\u0485\u0486\7f\2",
    "\2\u0486\u0487\7g\2\2\u0487\u048b\3\2\2\2\u0488\u048a\t\r\2\2\u0489",
    "\u0488\3\2\2\2\u048a\u048d\3\2\2\2\u048b\u0489\3\2\2\2\u048b\u048c\3",
    "\2\2\2\u048c\u0490\3\2\2\2\u048d\u048b\3\2\2\2\u048e\u0491\5\u0103\u0082",
    "\2\u048f\u0491\5\u0121\u0091\2\u0490\u048e\3\2\2\2\u0490\u048f\3\2\2",
    "\2\u0491\u0492\3\2\2\2\u0492\u0493\5\u0123\u0092\2\u0493\u0494\3\2\2",
    "\2\u0494\u0495\b\u008f\2\2\u0495\u011e\3\2\2\2\u0496\u0497\7%\2\2\u0497",
    "\u0498\7r\2\2\u0498\u0499\7t\2\2\u0499\u049a\7c\2\2\u049a\u049b\7i\2",
    "\2\u049b\u049c\7o\2\2\u049c\u049d\7c\2\2\u049d\u04a1\3\2\2\2\u049e\u04a0",
    "\n\16\2\2\u049f\u049e\3\2\2\2\u04a0\u04a3\3\2\2\2\u04a1\u049f\3\2\2",
    "\2\u04a1\u04a2\3\2\2\2\u04a2\u04a4\3\2\2\2\u04a3\u04a1\3\2\2\2\u04a4",
    "\u04a5\b\u0090\2\2\u04a5\u0120\3\2\2\2\u04a6\u04aa\7>\2\2\u04a7\u04a9",
    "\13\2\2\2\u04a8\u04a7\3\2\2\2\u04a9\u04ac\3\2\2\2\u04aa\u04ab\3\2\2",
    "\2\u04aa\u04a8\3\2\2\2\u04ab\u04ad\3\2\2\2\u04ac\u04aa\3\2\2\2\u04ad",
    "\u04ae\7@\2\2\u04ae\u0122\3\2\2\2\u04af\u04b0\t\17\2\2\u04b0\u04b1\3",
    "\2\2\2\u04b1\u04b2\b\u0092\2\2\u04b2\u0124\3\2\2\2\u04b3\u04b4\7\61",
    "\2\2\u04b4\u04b5\7,\2\2\u04b5\u04b9\3\2\2\2\u04b6\u04b8\13\2\2\2\u04b7",
    "\u04b6\3\2\2\2\u04b8\u04bb\3\2\2\2\u04b9\u04ba\3\2\2\2\u04b9\u04b7\3",
    "\2\2\2\u04ba\u04bc\3\2\2\2\u04bb\u04b9\3\2\2\2\u04bc\u04bd\7,\2\2\u04bd",
    "\u04be\7\61\2\2\u04be\u04bf\3\2\2\2\u04bf\u04c0\b\u0093\2\2\u04c0\u0126",
    "\3\2\2\2\u04c1\u04c2\7\61\2\2\u04c2\u04c3\7\61\2\2\u04c3\u04c7\3\2\2",
    "\2\u04c4\u04c6\n\16\2\2\u04c5\u04c4\3\2\2\2\u04c6\u04c9\3\2\2\2\u04c7",
    "\u04c5\3\2\2\2\u04c7\u04c8\3\2\2\2\u04c8\u04ca\3\2\2\2\u04c9\u04c7\3",
    "\2\2\2\u04ca\u04cb\b\u0094\2\2\u04cb\u0128\3\2\2\2\u04cc\u04cd\7%\2",
    "\2\u04cd\u04ce\7f\2\2\u04ce\u04cf\7g\2\2\u04cf\u04d0\7h\2\2\u04d0\u04d1",
    "\7k\2\2\u04d1\u04d2\7p\2\2\u04d2\u04d3\7g\2\2\u04d3\u04d7\3\2\2\2\u04d4",
    "\u04d6\n\16\2\2\u04d5\u04d4\3\2\2\2\u04d6\u04d9\3\2\2\2\u04d7\u04d5",
    "\3\2\2\2\u04d7\u04d8\3\2\2\2\u04d8\u04da\3\2\2\2\u04d9\u04d7\3\2\2\2",
    "\u04da\u04db\b\u0095\2\2\u04db\u012a\3\2\2\2\u04dc\u04dd\7%\2\2\u04dd",
    "\u04de\7k\2\2\u04de\u04df\7h\2\2\u04df\u04e3\3\2\2\2\u04e0\u04e2\n\16",
    "\2\2\u04e1\u04e0\3\2\2\2\u04e2\u04e5\3\2\2\2\u04e3\u04e1\3\2\2\2\u04e3",
    "\u04e4\3\2\2\2\u04e4\u04e6\3\2\2\2\u04e5\u04e3\3\2\2\2\u04e6\u04e7\b",
    "\u0096\2\2\u04e7\u012c\3\2\2\2\u04e8\u04e9\7%\2\2\u04e9\u04ea\7g\2\2",
    "\u04ea\u04eb\7n\2\2\u04eb\u04ec\7u\2\2\u04ec\u04ed\7g\2\2\u04ed\u04f1",
    "\3\2\2\2\u04ee\u04f0\n\16\2\2\u04ef\u04ee\3\2\2\2\u04f0\u04f3\3\2\2",
    "\2\u04f1\u04ef\3\2\2\2\u04f1\u04f2\3\2\2\2\u04f2\u04f4\3\2\2\2\u04f3",
    "\u04f1\3\2\2\2\u04f4\u04f5\b\u0097\2\2\u04f5\u012e\3\2\2\2\u04f6\u04f7",
    "\7%\2\2\u04f7\u04f8\7w\2\2\u04f8\u04f9\7p\2\2\u04f9\u04fa\7f\2\2\u04fa",
    "\u04fb\7g\2\2\u04fb\u04fc\7h\2\2\u04fc\u0500\3\2\2\2\u04fd\u04ff\n\16",
    "\2\2\u04fe\u04fd\3\2\2\2\u04ff\u0502\3\2\2\2\u0500\u04fe\3\2\2\2\u0500",
    "\u0501\3\2\2\2\u0501\u0503\3\2\2\2\u0502\u0500\3\2\2\2\u0503\u0504\b",
    "\u0098\2\2\u0504\u0130\3\2\2\2\u0505\u0506\7%\2\2\u0506\u0507\7k\2\2",
    "\u0507\u0508\7h\2\2\u0508\u0509\7p\2\2\u0509\u050a\7f\2\2\u050a\u050b",
    "\7g\2\2\u050b\u050c\7h\2\2\u050c\u0510\3\2\2\2\u050d\u050f\n\16\2\2",
    "\u050e\u050d\3\2\2\2\u050f\u0512\3\2\2\2\u0510\u050e\3\2\2\2\u0510\u0511",
    "\3\2\2\2\u0511\u0513\3\2\2\2\u0512\u0510\3\2\2\2\u0513\u0514\b\u0099",
    "\2\2\u0514\u0132\3\2\2\2\u0515\u0516\7%\2\2\u0516\u0517\7g\2\2\u0517",
    "\u0518\7p\2\2\u0518\u0519\7f\2\2\u0519\u051a\7k\2\2\u051a\u051b\7h\2",
    "\2\u051b\u051f\3\2\2\2\u051c\u051e\n\16\2\2\u051d\u051c\3\2\2\2\u051e",
    "\u0521\3\2\2\2\u051f\u051d\3\2\2\2\u051f\u0520\3\2\2\2\u0520\u0522\3",
    "\2\2\2\u0521\u051f\3\2\2\2\u0522\u0523\b\u009a\2\2\u0523\u0134\3\2\2",
    "\2&\2\u03f4\u03f6\u03fe\u0408\u040a\u0414\u0417\u041e\u0421\u0424\u042a",
    "\u042d\u0436\u043c\u043f\u0442\u0445\u0449\u044e\u0455\u0460\u0474\u0479",
    "\u048b\u0490\u04a1\u04aa\u04b9\u04c7\u04d7\u04e3\u04f1\u0500\u0510\u051f",
    "\3\2\3\2"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function ObjCLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

ObjCLexer.prototype = Object.create(antlr4.Lexer.prototype);
ObjCLexer.prototype.constructor = ObjCLexer;

ObjCLexer.EOF = antlr4.Token.EOF;
ObjCLexer.AUTORELEASEPOOL = 1;
ObjCLexer.CATCH = 2;
ObjCLexer.CLASS = 3;
ObjCLexer.DYNAMIC = 4;
ObjCLexer.ENCODE = 5;
ObjCLexer.END = 6;
ObjCLexer.FINALLY = 7;
ObjCLexer.IMPLEMENTATION = 8;
ObjCLexer.INTERFACE = 9;
ObjCLexer.PACKAGE = 10;
ObjCLexer.PROTOCOL = 11;
ObjCLexer.OPTIONAL = 12;
ObjCLexer.PRIVATE = 13;
ObjCLexer.PROPERTY = 14;
ObjCLexer.PROTECTED = 15;
ObjCLexer.PUBLIC = 16;
ObjCLexer.SELECTOR = 17;
ObjCLexer.SYNCHRONIZED = 18;
ObjCLexer.SYNTHESIZE = 19;
ObjCLexer.THROW = 20;
ObjCLexer.TRY = 21;
ObjCLexer.SUPER = 22;
ObjCLexer.SELF = 23;
ObjCLexer.ABSTRACT = 24;
ObjCLexer.AUTO = 25;
ObjCLexer.BOOLEAN = 26;
ObjCLexer.BREAK = 27;
ObjCLexer.BYCOPY = 28;
ObjCLexer.BYREF = 29;
ObjCLexer.CASE = 30;
ObjCLexer.CHAR = 31;
ObjCLexer.CONST = 32;
ObjCLexer.CONTINUE = 33;
ObjCLexer.DEFAULT = 34;
ObjCLexer.DO = 35;
ObjCLexer.DOUBLE = 36;
ObjCLexer.ELSE = 37;
ObjCLexer.ENUM = 38;
ObjCLexer.EXTERN = 39;
ObjCLexer.FLOAT = 40;
ObjCLexer.FOR = 41;
ObjCLexer.ID = 42;
ObjCLexer.IF = 43;
ObjCLexer.IN = 44;
ObjCLexer.INOUT = 45;
ObjCLexer.GOTO = 46;
ObjCLexer.INT = 47;
ObjCLexer.LONG = 48;
ObjCLexer.ONEWAY = 49;
ObjCLexer.OUT = 50;
ObjCLexer.REGISTER = 51;
ObjCLexer.RETURN = 52;
ObjCLexer.SHORT = 53;
ObjCLexer.SIGNED = 54;
ObjCLexer.SIZEOF = 55;
ObjCLexer.STATIC = 56;
ObjCLexer.STRUCT = 57;
ObjCLexer.SWITCH = 58;
ObjCLexer.TYPEDEF = 59;
ObjCLexer.UNION = 60;
ObjCLexer.UNSIGNED = 61;
ObjCLexer.VOID = 62;
ObjCLexer.VOLATILE = 63;
ObjCLexer.WHILE = 64;
ObjCLexer.NS_OPTIONS = 65;
ObjCLexer.NS_ENUM = 66;
ObjCLexer.WWEAK = 67;
ObjCLexer.WUNSAFE_UNRETAINED = 68;
ObjCLexer.LPAREN = 69;
ObjCLexer.RPAREN = 70;
ObjCLexer.LBRACE = 71;
ObjCLexer.RBRACE = 72;
ObjCLexer.LBRACK = 73;
ObjCLexer.RBRACK = 74;
ObjCLexer.SEMI = 75;
ObjCLexer.COMMA = 76;
ObjCLexer.DOT = 77;
ObjCLexer.STRUCTACCESS = 78;
ObjCLexer.AT = 79;
ObjCLexer.ASSIGN = 80;
ObjCLexer.GT = 81;
ObjCLexer.LT = 82;
ObjCLexer.BANG = 83;
ObjCLexer.TILDE = 84;
ObjCLexer.QUESTION = 85;
ObjCLexer.COLON = 86;
ObjCLexer.EQUAL = 87;
ObjCLexer.LE = 88;
ObjCLexer.GE = 89;
ObjCLexer.NOTEQUAL = 90;
ObjCLexer.AND = 91;
ObjCLexer.OR = 92;
ObjCLexer.INC = 93;
ObjCLexer.DEC = 94;
ObjCLexer.ADD = 95;
ObjCLexer.SUB = 96;
ObjCLexer.MUL = 97;
ObjCLexer.DIV = 98;
ObjCLexer.BITAND = 99;
ObjCLexer.BITOR = 100;
ObjCLexer.CARET = 101;
ObjCLexer.MOD = 102;
ObjCLexer.SHIFT_R = 103;
ObjCLexer.SHIFT_L = 104;
ObjCLexer.ADD_ASSIGN = 105;
ObjCLexer.SUB_ASSIGN = 106;
ObjCLexer.MUL_ASSIGN = 107;
ObjCLexer.DIV_ASSIGN = 108;
ObjCLexer.AND_ASSIGN = 109;
ObjCLexer.OR_ASSIGN = 110;
ObjCLexer.XOR_ASSIGN = 111;
ObjCLexer.MOD_ASSIGN = 112;
ObjCLexer.LSHIFT_ASSIGN = 113;
ObjCLexer.RSHIFT_ASSIGN = 114;
ObjCLexer.ELIPSIS = 115;
ObjCLexer.ASSIGNPA = 116;
ObjCLexer.GETTER = 117;
ObjCLexer.NONATOMIC = 118;
ObjCLexer.SETTER = 119;
ObjCLexer.STRONG = 120;
ObjCLexer.RETAIN = 121;
ObjCLexer.READONLY = 122;
ObjCLexer.READWRITE = 123;
ObjCLexer.WEAK = 124;
ObjCLexer.IDENTIFIER = 125;
ObjCLexer.CHARACTER_LITERAL = 126;
ObjCLexer.STRING_LITERAL = 127;
ObjCLexer.HEX_LITERAL = 128;
ObjCLexer.DECIMAL_LITERAL = 129;
ObjCLexer.OCTAL_LITERAL = 130;
ObjCLexer.FLOATING_POINT_LITERAL = 131;
ObjCLexer.IMPORT = 132;
ObjCLexer.INCLUDE = 133;
ObjCLexer.PRAGMA = 134;
ObjCLexer.WS = 135;
ObjCLexer.COMMENT = 136;
ObjCLexer.LINE_COMMENT = 137;
ObjCLexer.HDEFINE = 138;
ObjCLexer.HIF = 139;
ObjCLexer.HELSE = 140;
ObjCLexer.HUNDEF = 141;
ObjCLexer.HIFNDEF = 142;
ObjCLexer.HENDIF = 143;


ObjCLexer.modeNames = [ "DEFAULT_MODE" ];

ObjCLexer.literalNames = [ 'null', "'@autoreleasepool'", "'@catch'", "'@class'", 
                           "'@dynamic'", "'@encode'", "'@end'", "'@finally'", 
                           "'@implementation'", "'@interface'", "'@package'", 
                           "'@protocol'", "'@optional'", "'@private'", "'@property'", 
                           "'@protected'", "'@public'", "'@selector'", "'@synchronized'", 
                           "'@synthesize'", "'@throw'", "'@try'", "'super'", 
                           "'self'", "'abstract'", "'auto'", "'boolean'", 
                           "'break'", "'bycopy'", "'byref'", "'case'", "'char'", 
                           "'const'", "'continue'", "'default'", "'do'", 
                           "'double'", "'else'", "'enum'", "'extern'", "'float'", 
                           "'for'", "'id'", "'if'", "'in'", "'inout'", "'goto'", 
                           "'int'", "'long'", "'oneway'", "'out'", "'register'", 
                           "'return'", "'short'", "'signed'", "'sizeof'", 
                           "'static'", "'struct'", "'switch'", "'typedef'", 
                           "'union'", "'unsigned'", "'void'", "'volatile'", 
                           "'while'", "'NS_OPTIONS'", "'NS_ENUM'", "'__weak'", 
                           "'__unsafe_unretained'", "'('", "')'", "'{'", 
                           "'}'", "'['", "']'", "';'", "','", "'.'", "'->'", 
                           "'@'", "'='", "'>'", "'<'", "'!'", "'~'", "'?'", 
                           "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", 
                           "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", 
                           "'/'", "'&'", "'|'", "'^'", "'%'", "'>>'", "'<<'", 
                           "'+='", "'-='", "'*='", "'/='", "'&='", "'|='", 
                           "'^='", "'%='", "'<<='", "'>>='", "'...'", "'assign'", 
                           "'getter'", "'nonatomic'", "'setter'", "'strong'", 
                           "'retain'", "'readonly'", "'readwrite'", "'weak'" ];

ObjCLexer.symbolicNames = [ 'null', "AUTORELEASEPOOL", "CATCH", "CLASS", 
                            "DYNAMIC", "ENCODE", "END", "FINALLY", "IMPLEMENTATION", 
                            "INTERFACE", "PACKAGE", "PROTOCOL", "OPTIONAL", 
                            "PRIVATE", "PROPERTY", "PROTECTED", "PUBLIC", 
                            "SELECTOR", "SYNCHRONIZED", "SYNTHESIZE", "THROW", 
                            "TRY", "SUPER", "SELF", "ABSTRACT", "AUTO", 
                            "BOOLEAN", "BREAK", "BYCOPY", "BYREF", "CASE", 
                            "CHAR", "CONST", "CONTINUE", "DEFAULT", "DO", 
                            "DOUBLE", "ELSE", "ENUM", "EXTERN", "FLOAT", 
                            "FOR", "ID", "IF", "IN", "INOUT", "GOTO", "INT", 
                            "LONG", "ONEWAY", "OUT", "REGISTER", "RETURN", 
                            "SHORT", "SIGNED", "SIZEOF", "STATIC", "STRUCT", 
                            "SWITCH", "TYPEDEF", "UNION", "UNSIGNED", "VOID", 
                            "VOLATILE", "WHILE", "NS_OPTIONS", "NS_ENUM", 
                            "WWEAK", "WUNSAFE_UNRETAINED", "LPAREN", "RPAREN", 
                            "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", 
                            "COMMA", "DOT", "STRUCTACCESS", "AT", "ASSIGN", 
                            "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", 
                            "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", 
                            "INC", "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", 
                            "BITOR", "CARET", "MOD", "SHIFT_R", "SHIFT_L", 
                            "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", 
                            "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", 
                            "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "ELIPSIS", 
                            "ASSIGNPA", "GETTER", "NONATOMIC", "SETTER", 
                            "STRONG", "RETAIN", "READONLY", "READWRITE", 
                            "WEAK", "IDENTIFIER", "CHARACTER_LITERAL", "STRING_LITERAL", 
                            "HEX_LITERAL", "DECIMAL_LITERAL", "OCTAL_LITERAL", 
                            "FLOATING_POINT_LITERAL", "IMPORT", "INCLUDE", 
                            "PRAGMA", "WS", "COMMENT", "LINE_COMMENT", "HDEFINE", 
                            "HIF", "HELSE", "HUNDEF", "HIFNDEF", "HENDIF" ];

ObjCLexer.ruleNames = [ "AUTORELEASEPOOL", "CATCH", "CLASS", "DYNAMIC", 
                        "ENCODE", "END", "FINALLY", "IMPLEMENTATION", "INTERFACE", 
                        "PACKAGE", "PROTOCOL", "OPTIONAL", "PRIVATE", "PROPERTY", 
                        "PROTECTED", "PUBLIC", "SELECTOR", "SYNCHRONIZED", 
                        "SYNTHESIZE", "THROW", "TRY", "SUPER", "SELF", "ABSTRACT", 
                        "AUTO", "BOOLEAN", "BREAK", "BYCOPY", "BYREF", "CASE", 
                        "CHAR", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", 
                        "ELSE", "ENUM", "EXTERN", "FLOAT", "FOR", "ID", 
                        "IF", "IN", "INOUT", "GOTO", "INT", "LONG", "ONEWAY", 
                        "OUT", "REGISTER", "RETURN", "SHORT", "SIGNED", 
                        "SIZEOF", "STATIC", "STRUCT", "SWITCH", "TYPEDEF", 
                        "UNION", "UNSIGNED", "VOID", "VOLATILE", "WHILE", 
                        "NS_OPTIONS", "NS_ENUM", "WWEAK", "WUNSAFE_UNRETAINED", 
                        "LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", 
                        "RBRACK", "SEMI", "COMMA", "DOT", "STRUCTACCESS", 
                        "AT", "ASSIGN", "GT", "LT", "BANG", "TILDE", "QUESTION", 
                        "COLON", "EQUAL", "LE", "GE", "NOTEQUAL", "AND", 
                        "OR", "INC", "DEC", "ADD", "SUB", "MUL", "DIV", 
                        "BITAND", "BITOR", "CARET", "MOD", "SHIFT_R", "SHIFT_L", 
                        "ADD_ASSIGN", "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", 
                        "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", 
                        "LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "ELIPSIS", "ASSIGNPA", 
                        "GETTER", "NONATOMIC", "SETTER", "STRONG", "RETAIN", 
                        "READONLY", "READWRITE", "WEAK", "IDENTIFIER", "LETTER", 
                        "CHARACTER_LITERAL", "STRING_LITERAL", "STRING", 
                        "HEX_LITERAL", "DECIMAL_LITERAL", "OCTAL_LITERAL", 
                        "HexDigit", "IntegerTypeSuffix", "FLOATING_POINT_LITERAL", 
                        "Exponent", "FloatTypeSuffix", "EscapeSequence", 
                        "OctalEscape", "UnicodeEscape", "IMPORT", "INCLUDE", 
                        "PRAGMA", "ANGLE_STRING", "WS", "COMMENT", "LINE_COMMENT", 
                        "HDEFINE", "HIF", "HELSE", "HUNDEF", "HIFNDEF", 
                        "HENDIF" ];

ObjCLexer.grammarFileName = "ObjC.g4";



exports.ObjCLexer = ObjCLexer;


},{"antlr4/index":54}],8:[function(require,module,exports){
// Generated from ObjC.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by ObjCParser.
function ObjCListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

ObjCListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
ObjCListener.prototype.constructor = ObjCListener;

// Enter a parse tree produced by ObjCParser#translation_unit.
ObjCListener.prototype.enterTranslation_unit = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#translation_unit.
ObjCListener.prototype.exitTranslation_unit = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#external_declaration.
ObjCListener.prototype.enterExternal_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#external_declaration.
ObjCListener.prototype.exitExternal_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#preprocessor_declaration.
ObjCListener.prototype.enterPreprocessor_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#preprocessor_declaration.
ObjCListener.prototype.exitPreprocessor_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_interface.
ObjCListener.prototype.enterClass_interface = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_interface.
ObjCListener.prototype.exitClass_interface = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#category_interface.
ObjCListener.prototype.enterCategory_interface = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#category_interface.
ObjCListener.prototype.exitCategory_interface = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_implementation.
ObjCListener.prototype.enterClass_implementation = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_implementation.
ObjCListener.prototype.exitClass_implementation = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#category_implementation.
ObjCListener.prototype.enterCategory_implementation = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#category_implementation.
ObjCListener.prototype.exitCategory_implementation = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_declaration.
ObjCListener.prototype.enterProtocol_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_declaration.
ObjCListener.prototype.exitProtocol_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_declaration_list.
ObjCListener.prototype.enterProtocol_declaration_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_declaration_list.
ObjCListener.prototype.exitProtocol_declaration_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_declaration_list.
ObjCListener.prototype.enterClass_declaration_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_declaration_list.
ObjCListener.prototype.exitClass_declaration_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_list.
ObjCListener.prototype.enterClass_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_list.
ObjCListener.prototype.exitClass_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_reference_list.
ObjCListener.prototype.enterProtocol_reference_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_reference_list.
ObjCListener.prototype.exitProtocol_reference_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_list.
ObjCListener.prototype.enterProtocol_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_list.
ObjCListener.prototype.exitProtocol_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_declaration.
ObjCListener.prototype.enterProperty_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_declaration.
ObjCListener.prototype.exitProperty_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_attributes_declaration.
ObjCListener.prototype.enterProperty_attributes_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_attributes_declaration.
ObjCListener.prototype.exitProperty_attributes_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_attributes_list.
ObjCListener.prototype.enterProperty_attributes_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_attributes_list.
ObjCListener.prototype.exitProperty_attributes_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_attribute.
ObjCListener.prototype.enterProperty_attribute = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_attribute.
ObjCListener.prototype.exitProperty_attribute = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_name.
ObjCListener.prototype.enterClass_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_name.
ObjCListener.prototype.exitClass_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#superclass_name.
ObjCListener.prototype.enterSuperclass_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#superclass_name.
ObjCListener.prototype.exitSuperclass_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#category_name.
ObjCListener.prototype.enterCategory_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#category_name.
ObjCListener.prototype.exitCategory_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_name.
ObjCListener.prototype.enterProtocol_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_name.
ObjCListener.prototype.exitProtocol_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#instance_variables.
ObjCListener.prototype.enterInstance_variables = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#instance_variables.
ObjCListener.prototype.exitInstance_variables = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#visibility_specification.
ObjCListener.prototype.enterVisibility_specification = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#visibility_specification.
ObjCListener.prototype.exitVisibility_specification = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#interface_declaration_list.
ObjCListener.prototype.enterInterface_declaration_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#interface_declaration_list.
ObjCListener.prototype.exitInterface_declaration_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_method_declaration.
ObjCListener.prototype.enterClass_method_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_method_declaration.
ObjCListener.prototype.exitClass_method_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#instance_method_declaration.
ObjCListener.prototype.enterInstance_method_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#instance_method_declaration.
ObjCListener.prototype.exitInstance_method_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#method_declaration.
ObjCListener.prototype.enterMethod_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#method_declaration.
ObjCListener.prototype.exitMethod_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#implementation_definition_list.
ObjCListener.prototype.enterImplementation_definition_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#implementation_definition_list.
ObjCListener.prototype.exitImplementation_definition_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#class_method_definition.
ObjCListener.prototype.enterClass_method_definition = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#class_method_definition.
ObjCListener.prototype.exitClass_method_definition = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#instance_method_definition.
ObjCListener.prototype.enterInstance_method_definition = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#instance_method_definition.
ObjCListener.prototype.exitInstance_method_definition = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#method_definition.
ObjCListener.prototype.enterMethod_definition = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#method_definition.
ObjCListener.prototype.exitMethod_definition = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#method_selector.
ObjCListener.prototype.enterMethod_selector = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#method_selector.
ObjCListener.prototype.exitMethod_selector = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#keyword_declarator.
ObjCListener.prototype.enterKeyword_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#keyword_declarator.
ObjCListener.prototype.exitKeyword_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#selector.
ObjCListener.prototype.enterSelector = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#selector.
ObjCListener.prototype.exitSelector = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#method_type.
ObjCListener.prototype.enterMethod_type = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#method_type.
ObjCListener.prototype.exitMethod_type = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_implementation.
ObjCListener.prototype.enterProperty_implementation = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_implementation.
ObjCListener.prototype.exitProperty_implementation = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_synthesize_list.
ObjCListener.prototype.enterProperty_synthesize_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_synthesize_list.
ObjCListener.prototype.exitProperty_synthesize_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#property_synthesize_item.
ObjCListener.prototype.enterProperty_synthesize_item = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#property_synthesize_item.
ObjCListener.prototype.exitProperty_synthesize_item = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#block_type.
ObjCListener.prototype.enterBlock_type = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#block_type.
ObjCListener.prototype.exitBlock_type = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#type_specifier.
ObjCListener.prototype.enterType_specifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#type_specifier.
ObjCListener.prototype.exitType_specifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#type_qualifier.
ObjCListener.prototype.enterType_qualifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#type_qualifier.
ObjCListener.prototype.exitType_qualifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_qualifier.
ObjCListener.prototype.enterProtocol_qualifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_qualifier.
ObjCListener.prototype.exitProtocol_qualifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#primary_expression.
ObjCListener.prototype.enterPrimary_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#primary_expression.
ObjCListener.prototype.exitPrimary_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#dictionary_pair.
ObjCListener.prototype.enterDictionary_pair = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#dictionary_pair.
ObjCListener.prototype.exitDictionary_pair = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#dictionary_expression.
ObjCListener.prototype.enterDictionary_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#dictionary_expression.
ObjCListener.prototype.exitDictionary_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#array_expression.
ObjCListener.prototype.enterArray_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#array_expression.
ObjCListener.prototype.exitArray_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#box_expression.
ObjCListener.prototype.enterBox_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#box_expression.
ObjCListener.prototype.exitBox_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#block_parameters.
ObjCListener.prototype.enterBlock_parameters = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#block_parameters.
ObjCListener.prototype.exitBlock_parameters = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#block_expression.
ObjCListener.prototype.enterBlock_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#block_expression.
ObjCListener.prototype.exitBlock_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#message_expression.
ObjCListener.prototype.enterMessage_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#message_expression.
ObjCListener.prototype.exitMessage_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#receiver.
ObjCListener.prototype.enterReceiver = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#receiver.
ObjCListener.prototype.exitReceiver = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#message_selector.
ObjCListener.prototype.enterMessage_selector = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#message_selector.
ObjCListener.prototype.exitMessage_selector = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#keyword_argument.
ObjCListener.prototype.enterKeyword_argument = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#keyword_argument.
ObjCListener.prototype.exitKeyword_argument = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#selector_expression.
ObjCListener.prototype.enterSelector_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#selector_expression.
ObjCListener.prototype.exitSelector_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#selector_name.
ObjCListener.prototype.enterSelector_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#selector_name.
ObjCListener.prototype.exitSelector_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#protocol_expression.
ObjCListener.prototype.enterProtocol_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#protocol_expression.
ObjCListener.prototype.exitProtocol_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#encode_expression.
ObjCListener.prototype.enterEncode_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#encode_expression.
ObjCListener.prototype.exitEncode_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#type_variable_declarator.
ObjCListener.prototype.enterType_variable_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#type_variable_declarator.
ObjCListener.prototype.exitType_variable_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#try_statement.
ObjCListener.prototype.enterTry_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#try_statement.
ObjCListener.prototype.exitTry_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#catch_statement.
ObjCListener.prototype.enterCatch_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#catch_statement.
ObjCListener.prototype.exitCatch_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#finally_statement.
ObjCListener.prototype.enterFinally_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#finally_statement.
ObjCListener.prototype.exitFinally_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#throw_statement.
ObjCListener.prototype.enterThrow_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#throw_statement.
ObjCListener.prototype.exitThrow_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#try_block.
ObjCListener.prototype.enterTry_block = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#try_block.
ObjCListener.prototype.exitTry_block = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#synchronized_statement.
ObjCListener.prototype.enterSynchronized_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#synchronized_statement.
ObjCListener.prototype.exitSynchronized_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#autorelease_statement.
ObjCListener.prototype.enterAutorelease_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#autorelease_statement.
ObjCListener.prototype.exitAutorelease_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#function_definition.
ObjCListener.prototype.enterFunction_definition = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#function_definition.
ObjCListener.prototype.exitFunction_definition = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#declaration.
ObjCListener.prototype.enterDeclaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#declaration.
ObjCListener.prototype.exitDeclaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#declaration_specifiers.
ObjCListener.prototype.enterDeclaration_specifiers = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#declaration_specifiers.
ObjCListener.prototype.exitDeclaration_specifiers = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#arc_behaviour_specifier.
ObjCListener.prototype.enterArc_behaviour_specifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#arc_behaviour_specifier.
ObjCListener.prototype.exitArc_behaviour_specifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#storage_class_specifier.
ObjCListener.prototype.enterStorage_class_specifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#storage_class_specifier.
ObjCListener.prototype.exitStorage_class_specifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#init_declarator_list.
ObjCListener.prototype.enterInit_declarator_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#init_declarator_list.
ObjCListener.prototype.exitInit_declarator_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#init_declarator.
ObjCListener.prototype.enterInit_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#init_declarator.
ObjCListener.prototype.exitInit_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#struct_or_union_specifier.
ObjCListener.prototype.enterStruct_or_union_specifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#struct_or_union_specifier.
ObjCListener.prototype.exitStruct_or_union_specifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#struct_declaration.
ObjCListener.prototype.enterStruct_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#struct_declaration.
ObjCListener.prototype.exitStruct_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#specifier_qualifier_list.
ObjCListener.prototype.enterSpecifier_qualifier_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#specifier_qualifier_list.
ObjCListener.prototype.exitSpecifier_qualifier_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#struct_declarator_list.
ObjCListener.prototype.enterStruct_declarator_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#struct_declarator_list.
ObjCListener.prototype.exitStruct_declarator_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#struct_declarator.
ObjCListener.prototype.enterStruct_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#struct_declarator.
ObjCListener.prototype.exitStruct_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#enum_specifier.
ObjCListener.prototype.enterEnum_specifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#enum_specifier.
ObjCListener.prototype.exitEnum_specifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#enumerator_list.
ObjCListener.prototype.enterEnumerator_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#enumerator_list.
ObjCListener.prototype.exitEnumerator_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#enumerator.
ObjCListener.prototype.enterEnumerator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#enumerator.
ObjCListener.prototype.exitEnumerator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#pointer.
ObjCListener.prototype.enterPointer = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#pointer.
ObjCListener.prototype.exitPointer = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#declarator.
ObjCListener.prototype.enterDeclarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#declarator.
ObjCListener.prototype.exitDeclarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#direct_declarator.
ObjCListener.prototype.enterDirect_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#direct_declarator.
ObjCListener.prototype.exitDirect_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#declarator_suffix.
ObjCListener.prototype.enterDeclarator_suffix = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#declarator_suffix.
ObjCListener.prototype.exitDeclarator_suffix = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#parameter_list.
ObjCListener.prototype.enterParameter_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#parameter_list.
ObjCListener.prototype.exitParameter_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#parameter_declaration.
ObjCListener.prototype.enterParameter_declaration = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#parameter_declaration.
ObjCListener.prototype.exitParameter_declaration = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#initializer.
ObjCListener.prototype.enterInitializer = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#initializer.
ObjCListener.prototype.exitInitializer = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#type_name.
ObjCListener.prototype.enterType_name = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#type_name.
ObjCListener.prototype.exitType_name = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#abstract_declarator.
ObjCListener.prototype.enterAbstract_declarator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#abstract_declarator.
ObjCListener.prototype.exitAbstract_declarator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#abstract_declarator_suffix.
ObjCListener.prototype.enterAbstract_declarator_suffix = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#abstract_declarator_suffix.
ObjCListener.prototype.exitAbstract_declarator_suffix = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#parameter_declaration_list.
ObjCListener.prototype.enterParameter_declaration_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#parameter_declaration_list.
ObjCListener.prototype.exitParameter_declaration_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#statement_list.
ObjCListener.prototype.enterStatement_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#statement_list.
ObjCListener.prototype.exitStatement_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#statement.
ObjCListener.prototype.enterStatement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#statement.
ObjCListener.prototype.exitStatement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#labeled_statement.
ObjCListener.prototype.enterLabeled_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#labeled_statement.
ObjCListener.prototype.exitLabeled_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#compound_statement.
ObjCListener.prototype.enterCompound_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#compound_statement.
ObjCListener.prototype.exitCompound_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#selection_statement.
ObjCListener.prototype.enterSelection_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#selection_statement.
ObjCListener.prototype.exitSelection_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#for_in_statement.
ObjCListener.prototype.enterFor_in_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#for_in_statement.
ObjCListener.prototype.exitFor_in_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#for_statement.
ObjCListener.prototype.enterFor_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#for_statement.
ObjCListener.prototype.exitFor_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#while_statement.
ObjCListener.prototype.enterWhile_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#while_statement.
ObjCListener.prototype.exitWhile_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#do_statement.
ObjCListener.prototype.enterDo_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#do_statement.
ObjCListener.prototype.exitDo_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#iteration_statement.
ObjCListener.prototype.enterIteration_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#iteration_statement.
ObjCListener.prototype.exitIteration_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#jump_statement.
ObjCListener.prototype.enterJump_statement = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#jump_statement.
ObjCListener.prototype.exitJump_statement = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#expression.
ObjCListener.prototype.enterExpression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#expression.
ObjCListener.prototype.exitExpression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#assignment_expression.
ObjCListener.prototype.enterAssignment_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#assignment_expression.
ObjCListener.prototype.exitAssignment_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#assignment_operator.
ObjCListener.prototype.enterAssignment_operator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#assignment_operator.
ObjCListener.prototype.exitAssignment_operator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#conditional_expression.
ObjCListener.prototype.enterConditional_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#conditional_expression.
ObjCListener.prototype.exitConditional_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#constant_expression.
ObjCListener.prototype.enterConstant_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#constant_expression.
ObjCListener.prototype.exitConstant_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#logical_or_expression.
ObjCListener.prototype.enterLogical_or_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#logical_or_expression.
ObjCListener.prototype.exitLogical_or_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#logical_and_expression.
ObjCListener.prototype.enterLogical_and_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#logical_and_expression.
ObjCListener.prototype.exitLogical_and_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#inclusive_or_expression.
ObjCListener.prototype.enterInclusive_or_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#inclusive_or_expression.
ObjCListener.prototype.exitInclusive_or_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#exclusive_or_expression.
ObjCListener.prototype.enterExclusive_or_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#exclusive_or_expression.
ObjCListener.prototype.exitExclusive_or_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#and_expression.
ObjCListener.prototype.enterAnd_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#and_expression.
ObjCListener.prototype.exitAnd_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#equality_expression.
ObjCListener.prototype.enterEquality_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#equality_expression.
ObjCListener.prototype.exitEquality_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#relational_expression.
ObjCListener.prototype.enterRelational_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#relational_expression.
ObjCListener.prototype.exitRelational_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#shift_expression.
ObjCListener.prototype.enterShift_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#shift_expression.
ObjCListener.prototype.exitShift_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#additive_expression.
ObjCListener.prototype.enterAdditive_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#additive_expression.
ObjCListener.prototype.exitAdditive_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#multiplicative_expression.
ObjCListener.prototype.enterMultiplicative_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#multiplicative_expression.
ObjCListener.prototype.exitMultiplicative_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#cast_expression.
ObjCListener.prototype.enterCast_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#cast_expression.
ObjCListener.prototype.exitCast_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#unary_expression.
ObjCListener.prototype.enterUnary_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#unary_expression.
ObjCListener.prototype.exitUnary_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#unary_operator.
ObjCListener.prototype.enterUnary_operator = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#unary_operator.
ObjCListener.prototype.exitUnary_operator = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#postfix_expression.
ObjCListener.prototype.enterPostfix_expression = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#postfix_expression.
ObjCListener.prototype.exitPostfix_expression = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#argument_expression_list.
ObjCListener.prototype.enterArgument_expression_list = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#argument_expression_list.
ObjCListener.prototype.exitArgument_expression_list = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#identifier.
ObjCListener.prototype.enterIdentifier = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#identifier.
ObjCListener.prototype.exitIdentifier = function(ctx) {
};


// Enter a parse tree produced by ObjCParser#constant.
ObjCListener.prototype.enterConstant = function(ctx) {
};

// Exit a parse tree produced by ObjCParser#constant.
ObjCListener.prototype.exitConstant = function(ctx) {
};



exports.ObjCListener = ObjCListener;
},{"antlr4/index":54}],9:[function(require,module,exports){
// Generated from ObjC.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');
var ObjCListener = require('./ObjCListener').ObjCListener;
var grammarFileName = "ObjC.g4";

var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\3\u0091\u053a\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t",
    "\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20",
    "\t\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4",
    "\27\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35",
    "\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'",
    "\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61",
    "\t\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\4",
    "8\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C",
    "\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\t",
    "N\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY",
    "\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\t",
    "d\4e\te\4f\tf\4g\tg\4h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to",
    "\4p\tp\4q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4z\tz\4",
    "{\t{\4|\t|\4}\t}\3\2\6\2\u00fc\n\2\r\2\16\2\u00fd\3\2\3\2\3\3\3\3\3",
    "\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\5\3\u010e\n\3\3\4\3\4\3\5\3\5",
    "\3\5\3\5\5\5\u0116\n\5\3\5\5\5\u0119\n\5\3\5\5\5\u011c\n\5\3\5\5\5\u011f",
    "\n\5\3\5\3\5\3\6\3\6\3\6\3\6\5\6\u0127\n\6\3\6\3\6\5\6\u012b\n\6\3\6",
    "\5\6\u012e\n\6\3\6\5\6\u0131\n\6\3\6\3\6\3\7\3\7\3\7\3\7\5\7\u0139\n",
    "\7\3\7\5\7\u013c\n\7\3\7\5\7\u013f\n\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3",
    "\b\5\b\u0149\n\b\3\b\3\b\3\t\3\t\3\t\5\t\u0150\n\t\3\t\5\t\u0153\n\t",
    "\3\t\5\t\u0156\n\t\3\t\5\t\u0159\n\t\3\t\3\t\3\n\3\n\3\n\3\n\3\13\3",
    "\13\3\13\3\13\3\f\3\f\3\f\7\f\u0168\n\f\f\f\16\f\u016b\13\f\3\r\3\r",
    "\3\r\3\r\3\16\3\16\3\16\7\16\u0174\n\16\f\16\16\16\u0177\13\16\3\17",
    "\3\17\5\17\u017b\n\17\3\17\3\17\3\20\3\20\3\20\3\20\3\21\3\21\3\21\7",
    "\21\u0186\n\21\f\21\16\21\u0189\13\21\3\22\3\22\3\22\3\22\3\22\3\22",
    "\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u019b\n\22\3",
    "\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27\7\27\u01a7\n\27\f\27",
    "\16\27\u01aa\13\27\3\27\3\27\3\27\3\27\6\27\u01b0\n\27\r\27\16\27\u01b1",
    "\3\27\3\27\3\27\3\27\6\27\u01b8\n\27\r\27\16\27\u01b9\3\27\3\27\3\27",
    "\3\27\3\27\3\27\6\27\u01c2\n\27\r\27\16\27\u01c3\3\27\3\27\3\27\5\27",
    "\u01c9\n\27\3\30\3\30\3\31\3\31\3\31\3\31\6\31\u01d1\n\31\r\31\16\31",
    "\u01d2\3\32\3\32\3\32\3\33\3\33\3\33\3\34\5\34\u01dc\n\34\3\34\3\34",
    "\3\34\3\35\3\35\3\35\3\35\3\35\6\35\u01e6\n\35\r\35\16\35\u01e7\3\36",
    "\3\36\3\36\3\37\3\37\3\37\3 \5 \u01f1\n \3 \3 \5 \u01f5\n \3 \5 \u01f8",
    "\n \3 \3 \3!\3!\6!\u01fe\n!\r!\16!\u01ff\3!\5!\u0203\n!\5!\u0205\n!",
    "\3\"\5\"\u0208\n\"\3\"\3\"\7\"\u020c\n\"\f\"\16\"\u020f\13\"\3\"\3\"",
    "\3#\3#\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\3%\5%\u0221\n%\3&\3&\3&\7&\u0226",
    "\n&\f&\16&\u0229\13&\3\'\3\'\3\'\3\'\5\'\u022f\n\'\3(\3(\3(\3(\5(\u0235",
    "\n(\3(\3(\5(\u0239\n(\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\3)\5)\u0246\n)\3",
    ")\3)\5)\u024a\n)\3)\3)\3)\3)\3)\5)\u0251\n)\3*\3*\3*\5*\u0256\n*\3+",
    "\3+\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\5,\u026b\n,\3",
    "-\3-\3-\3-\3.\3.\3.\5.\u0274\n.\3.\3.\7.\u0278\n.\f.\16.\u027b\13.\3",
    ".\5.\u027e\n.\3.\3.\3/\3/\3/\5/\u0285\n/\3/\3/\7/\u0289\n/\f/\16/\u028c",
    "\13/\3/\5/\u028f\n/\3/\3/\3\60\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u029a",
    "\n\60\3\61\3\61\3\61\5\61\u029f\n\61\3\61\3\61\7\61\u02a3\n\61\f\61",
    "\16\61\u02a6\13\61\3\61\3\61\3\62\3\62\5\62\u02ac\n\62\3\62\5\62\u02af",
    "\n\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\3\64\3\64\3\64\5\64\u02bb\n",
    "\64\3\65\3\65\6\65\u02bf\n\65\r\65\16\65\u02c0\5\65\u02c3\n\65\3\66",
    "\5\66\u02c6\n\66\3\66\3\66\3\66\3\67\3\67\3\67\3\67\3\67\38\38\58\u02d2",
    "\n8\38\68\u02d5\n8\r8\168\u02d6\58\u02d9\n8\39\39\39\39\39\3:\3:\3:",
    "\3:\3:\3;\3;\3;\3<\3<\3<\3=\3=\3=\3=\3=\3=\3>\3>\3>\3?\3?\3?\3?\3?\3",
    "@\3@\7@\u02fb\n@\f@\16@\u02fe\13@\3@\5@\u0301\n@\3A\3A\3A\3A\3A\3A\3",
    "B\3B\3B\3C\5C\u030d\nC\3C\3C\3C\3D\3D\5D\u0314\nD\3D\3D\3E\3E\3E\3E",
    "\6E\u031c\nE\rE\16E\u031d\3F\3F\3G\3G\3H\3H\3H\7H\u0327\nH\fH\16H\u032a",
    "\13H\3I\3I\3I\5I\u032f\nI\3J\3J\3J\5J\u0334\nJ\3J\3J\6J\u0338\nJ\rJ",
    "\16J\u0339\3J\3J\5J\u033e\nJ\3K\3K\3K\3K\3L\3L\3L\6L\u0347\nL\rL\16",
    "L\u0348\3M\3M\3M\7M\u034e\nM\fM\16M\u0351\13M\3N\3N\5N\u0355\nN\3N\3",
    "N\5N\u0359\nN\3O\3O\3O\5O\u035e\nO\3O\3O\3O\3O\3O\5O\u0365\nO\3O\3O",
    "\3O\3O\5O\u036b\nO\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3",
    "O\3O\3O\3O\5O\u0381\nO\3P\3P\3P\7P\u0386\nP\fP\16P\u0389\13P\3P\5P\u038c",
    "\nP\3Q\3Q\3Q\5Q\u0391\nQ\3R\3R\5R\u0395\nR\3R\3R\5R\u0399\nR\3R\5R\u039c",
    "\nR\3S\5S\u039f\nS\3S\3S\3T\3T\7T\u03a5\nT\fT\16T\u03a8\13T\3T\3T\3",
    "T\3T\7T\u03ae\nT\fT\16T\u03b1\13T\3T\3T\3T\5T\u03b6\nT\3T\3T\5T\u03ba",
    "\nT\3U\3U\5U\u03be\nU\3U\3U\3U\5U\u03c3\nU\3U\5U\u03c6\nU\3V\3V\3V\5",
    "V\u03cb\nV\3W\3W\5W\u03cf\nW\3W\5W\u03d2\nW\3X\3X\3X\3X\3X\7X\u03d9",
    "\nX\fX\16X\u03dc\13X\3X\5X\u03df\nX\3X\3X\5X\u03e3\nX\3Y\3Y\3Y\3Y\5",
    "Y\u03e9\nY\3Z\3Z\3Z\3Z\3Z\3Z\3Z\6Z\u03f2\nZ\rZ\16Z\u03f3\3Z\3Z\5Z\u03f8",
    "\nZ\3Z\6Z\u03fb\nZ\rZ\16Z\u03fc\3Z\5Z\u0400\nZ\3[\3[\5[\u0404\n[\3[",
    "\3[\3[\5[\u0409\n[\3[\5[\u040c\n[\3\\\3\\\3\\\7\\\u0411\n\\\f\\\16\\",
    "\u0414\13\\\3]\6]\u0417\n]\r]\16]\u0418\3^\3^\3^\3^\3^\3^\3^\3^\3^\3",
    "^\3^\3^\5^\u0427\n^\3_\3_\3_\3_\3_\3_\3_\3_\3_\3_\3_\3_\5_\u0435\n_",
    "\3`\3`\3`\7`\u043a\n`\f`\16`\u043d\13`\3`\3`\3a\3a\3a\3a\3a\3a\3a\5",
    "a\u0448\na\3a\3a\3a\3a\3a\3a\5a\u0450\na\3b\3b\3b\3b\3b\5b\u0457\nb",
    "\3b\3b\3b\3c\3c\3c\3c\3c\3c\5c\u0462\nc\3c\3c\5c\u0466\nc\3c\3c\5c\u046a",
    "\nc\3c\3c\3c\3d\3d\3d\3d\3d\3d\3e\3e\3e\3e\3e\3e\3e\3e\3f\3f\3f\3f\5",
    "f\u0481\nf\3g\3g\3g\3g\3g\3g\3g\3g\3g\3g\5g\u048d\ng\3g\5g\u0490\ng",
    "\3h\3h\3h\7h\u0495\nh\fh\16h\u0498\13h\3i\3i\3i\3i\3i\5i\u049f\ni\3",
    "j\3j\3k\3k\3k\3k\3k\3k\5k\u04a9\nk\3l\3l\3m\3m\3m\7m\u04b0\nm\fm\16",
    "m\u04b3\13m\3n\3n\3n\7n\u04b8\nn\fn\16n\u04bb\13n\3o\3o\3o\7o\u04c0",
    "\no\fo\16o\u04c3\13o\3p\3p\3p\7p\u04c8\np\fp\16p\u04cb\13p\3q\3q\3q",
    "\7q\u04d0\nq\fq\16q\u04d3\13q\3r\3r\3r\7r\u04d8\nr\fr\16r\u04db\13r",
    "\3s\3s\3s\7s\u04e0\ns\fs\16s\u04e3\13s\3t\3t\3t\7t\u04e8\nt\ft\16t\u04eb",
    "\13t\3u\3u\3u\7u\u04f0\nu\fu\16u\u04f3\13u\3v\3v\3v\7v\u04f8\nv\fv\16",
    "v\u04fb\13v\3w\3w\3w\3w\3w\3w\5w\u0503\nw\3x\3x\3x\3x\3x\3x\3x\3x\3",
    "x\3x\3x\3x\3x\3x\5x\u0513\nx\5x\u0515\nx\3y\3y\3z\3z\3z\3z\3z\3z\3z",
    "\5z\u0520\nz\3z\3z\3z\3z\3z\3z\3z\7z\u0529\nz\fz\16z\u052c\13z\3{\3",
    "{\3{\7{\u0531\n{\f{\16{\u0534\13{\3|\3|\3}\3}\3}\2\2~\2\4\6\b\n\f\16",
    "\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`",
    "bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090",
    "\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8",
    "\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0",
    "\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8",
    "\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0",
    "\u00f2\u00f4\u00f6\u00f8\2\20\3\2\u0086\u0087\5\2\f\f\17\17\21\22\5",
    "\2\36\37./\63\64\3\2EF\7\2\33\33))\65\65::==\4\2;;>>\4\2RRkt\4\2YY\\",
    "\\\4\2STZ[\3\2ij\3\2ab\4\2cdhh\5\2UVbcee\4\2\u0080\u0080\u0082\u0085",
    "\u05a7\2\u00fb\3\2\2\2\4\u010d\3\2\2\2\6\u010f\3\2\2\2\b\u0111\3\2\2",
    "\2\n\u0122\3\2\2\2\f\u0134\3\2\2\2\16\u0142\3\2\2\2\20\u014c\3\2\2\2",
    "\22\u015c\3\2\2\2\24\u0160\3\2\2\2\26\u0164\3\2\2\2\30\u016c\3\2\2\2",
    "\32\u0170\3\2\2\2\34\u0178\3\2\2\2\36\u017e\3\2\2\2 \u0182\3\2\2\2\"",
    "\u019a\3\2\2\2$\u019c\3\2\2\2&\u019e\3\2\2\2(\u01a0\3\2\2\2*\u01a2\3",
    "\2\2\2,\u01c8\3\2\2\2.\u01ca\3\2\2\2\60\u01d0\3\2\2\2\62\u01d4\3\2\2",
    "\2\64\u01d7\3\2\2\2\66\u01db\3\2\2\28\u01e5\3\2\2\2:\u01e9\3\2\2\2<",
    "\u01ec\3\2\2\2>\u01f0\3\2\2\2@\u0204\3\2\2\2B\u0207\3\2\2\2D\u0212\3",
    "\2\2\2F\u0214\3\2\2\2H\u0220\3\2\2\2J\u0222\3\2\2\2L\u022e\3\2\2\2N",
    "\u0230\3\2\2\2P\u0250\3\2\2\2R\u0255\3\2\2\2T\u0257\3\2\2\2V\u026a\3",
    "\2\2\2X\u026c\3\2\2\2Z\u0270\3\2\2\2\\\u0281\3\2\2\2^\u0299\3\2\2\2",
    "`\u029b\3\2\2\2b\u02a9\3\2\2\2d\u02b2\3\2\2\2f\u02ba\3\2\2\2h\u02c2",
    "\3\2\2\2j\u02c5\3\2\2\2l\u02ca\3\2\2\2n\u02d8\3\2\2\2p\u02da\3\2\2\2",
    "r\u02df\3\2\2\2t\u02e4\3\2\2\2v\u02e7\3\2\2\2x\u02ea\3\2\2\2z\u02f0",
    "\3\2\2\2|\u02f3\3\2\2\2~\u02f8\3\2\2\2\u0080\u0302\3\2\2\2\u0082\u0308",
    "\3\2\2\2\u0084\u030c\3\2\2\2\u0086\u0311\3\2\2\2\u0088\u031b\3\2\2\2",
    "\u008a\u031f\3\2\2\2\u008c\u0321\3\2\2\2\u008e\u0323\3\2\2\2\u0090\u032b",
    "\3\2\2\2\u0092\u0330\3\2\2\2\u0094\u033f\3\2\2\2\u0096\u0346\3\2\2\2",
    "\u0098\u034a\3\2\2\2\u009a\u0358\3\2\2\2\u009c\u0380\3\2\2\2\u009e\u0382",
    "\3\2\2\2\u00a0\u038d\3\2\2\2\u00a2\u039b\3\2\2\2\u00a4\u039e\3\2\2\2",
    "\u00a6\u03b9\3\2\2\2\u00a8\u03c5\3\2\2\2\u00aa\u03c7\3\2\2\2\u00ac\u03cc",
    "\3\2\2\2\u00ae\u03e2\3\2\2\2\u00b0\u03e8\3\2\2\2\u00b2\u03ff\3\2\2\2",
    "\u00b4\u040b\3\2\2\2\u00b6\u040d\3\2\2\2\u00b8\u0416\3\2\2\2\u00ba\u0426",
    "\3\2\2\2\u00bc\u0434\3\2\2\2\u00be\u0436\3\2\2\2\u00c0\u044f\3\2\2\2",
    "\u00c2\u0451\3\2\2\2\u00c4\u045b\3\2\2\2\u00c6\u046e\3\2\2\2\u00c8\u0474",
    "\3\2\2\2\u00ca\u0480\3\2\2\2\u00cc\u048f\3\2\2\2\u00ce\u0491\3\2\2\2",
    "\u00d0\u049e\3\2\2\2\u00d2\u04a0\3\2\2\2\u00d4\u04a2\3\2\2\2\u00d6\u04aa",
    "\3\2\2\2\u00d8\u04ac\3\2\2\2\u00da\u04b4\3\2\2\2\u00dc\u04bc\3\2\2\2",
    "\u00de\u04c4\3\2\2\2\u00e0\u04cc\3\2\2\2\u00e2\u04d4\3\2\2\2\u00e4\u04dc",
    "\3\2\2\2\u00e6\u04e4\3\2\2\2\u00e8\u04ec\3\2\2\2\u00ea\u04f4\3\2\2\2",
    "\u00ec\u0502\3\2\2\2\u00ee\u0514\3\2\2\2\u00f0\u0516\3\2\2\2\u00f2\u0518",
    "\3\2\2\2\u00f4\u052d\3\2\2\2\u00f6\u0535\3\2\2\2\u00f8\u0537\3\2\2\2",
    "\u00fa\u00fc\5\4\3\2\u00fb\u00fa\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u00fb",
    "\3\2\2\2\u00fd\u00fe\3\2\2\2\u00fe\u00ff\3\2\2\2\u00ff\u0100\7\2\2\3",
    "\u0100\3\3\2\2\2\u0101\u010e\7\u008a\2\2\u0102\u010e\7\u008b\2\2\u0103",
    "\u010e\5\6\4\2\u0104\u010e\5\u0084C\2\u0105\u010e\5\u0086D\2\u0106\u010e",
    "\5\b\5\2\u0107\u010e\5\f\7\2\u0108\u010e\5\n\6\2\u0109\u010e\5\16\b",
    "\2\u010a\u010e\5\20\t\2\u010b\u010e\5\22\n\2\u010c\u010e\5\24\13\2\u010d",
    "\u0101\3\2\2\2\u010d\u0102\3\2\2\2\u010d\u0103\3\2\2\2\u010d\u0104\3",
    "\2\2\2\u010d\u0105\3\2\2\2\u010d\u0106\3\2\2\2\u010d\u0107\3\2\2\2\u010d",
    "\u0108\3\2\2\2\u010d\u0109\3\2\2\2\u010d\u010a\3\2\2\2\u010d\u010b\3",
    "\2\2\2\u010d\u010c\3\2\2\2\u010e\5\3\2\2\2\u010f\u0110\t\2\2\2\u0110",
    "\7\3\2\2\2\u0111\u0112\7\13\2\2\u0112\u0115\5$\23\2\u0113\u0114\7X\2",
    "\2\u0114\u0116\5&\24\2\u0115\u0113\3\2\2\2\u0115\u0116\3\2\2\2\u0116",
    "\u0118\3\2\2\2\u0117\u0119\5\30\r\2\u0118\u0117\3\2\2\2\u0118\u0119",
    "\3\2\2\2\u0119\u011b\3\2\2\2\u011a\u011c\5,\27\2\u011b\u011a\3\2\2\2",
    "\u011b\u011c\3\2\2\2\u011c\u011e\3\2\2\2\u011d\u011f\5\60\31\2\u011e",
    "\u011d\3\2\2\2\u011e\u011f\3\2\2\2\u011f\u0120\3\2\2\2\u0120\u0121\7",
    "\b\2\2\u0121\t\3\2\2\2\u0122\u0123\7\13\2\2\u0123\u0124\5$\23\2\u0124",
    "\u0126\7G\2\2\u0125\u0127\5(\25\2\u0126\u0125\3\2\2\2\u0126\u0127\3",
    "\2\2\2\u0127\u0128\3\2\2\2\u0128\u012a\7H\2\2\u0129\u012b\5\30\r\2\u012a",
    "\u0129\3\2\2\2\u012a\u012b\3\2\2\2\u012b\u012d\3\2\2\2\u012c\u012e\5",
    ",\27\2\u012d\u012c\3\2\2\2\u012d\u012e\3\2\2\2\u012e\u0130\3\2\2\2\u012f",
    "\u0131\5\60\31\2\u0130\u012f\3\2\2\2\u0130\u0131\3\2\2\2\u0131\u0132",
    "\3\2\2\2\u0132\u0133\7\b\2\2\u0133\13\3\2\2\2\u0134\u0135\7\n\2\2\u0135",
    "\u0138\5$\23\2\u0136\u0137\7X\2\2\u0137\u0139\5&\24\2\u0138\u0136\3",
    "\2\2\2\u0138\u0139\3\2\2\2\u0139\u013b\3\2\2\2\u013a\u013c\5,\27\2\u013b",
    "\u013a\3\2\2\2\u013b\u013c\3\2\2\2\u013c\u013e\3\2\2\2\u013d\u013f\5",
    "8\35\2\u013e\u013d\3\2\2\2\u013e\u013f\3\2\2\2\u013f\u0140\3\2\2\2\u0140",
    "\u0141\7\b\2\2\u0141\r\3\2\2\2\u0142\u0143\7\n\2\2\u0143\u0144\5$\23",
    "\2\u0144\u0145\7G\2\2\u0145\u0146\5(\25\2\u0146\u0148\7H\2\2\u0147\u0149",
    "\58\35\2\u0148\u0147\3\2\2\2\u0148\u0149\3\2\2\2\u0149\u014a\3\2\2\2",
    "\u014a\u014b\7\b\2\2\u014b\17\3\2\2\2\u014c\u014d\7\r\2\2\u014d\u014f",
    "\5*\26\2\u014e\u0150\5\30\r\2\u014f\u014e\3\2\2\2\u014f\u0150\3\2\2",
    "\2\u0150\u0152\3\2\2\2\u0151\u0153\5\60\31\2\u0152\u0151\3\2\2\2\u0152",
    "\u0153\3\2\2\2\u0153\u0155\3\2\2\2\u0154\u0156\7\16\2\2\u0155\u0154",
    "\3\2\2\2\u0155\u0156\3\2\2\2\u0156\u0158\3\2\2\2\u0157\u0159\5\60\31",
    "\2\u0158\u0157\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015a\3\2\2\2\u015a",
    "\u015b\7\b\2\2\u015b\21\3\2\2\2\u015c\u015d\7\r\2\2\u015d\u015e\5\32",
    "\16\2\u015e\u015f\7M\2\2\u015f\23\3\2\2\2\u0160\u0161\7\5\2\2\u0161",
    "\u0162\5\26\f\2\u0162\u0163\7M\2\2\u0163\25\3\2\2\2\u0164\u0169\5$\23",
    "\2\u0165\u0166\7N\2\2\u0166\u0168\5$\23\2\u0167\u0165\3\2\2\2\u0168",
    "\u016b\3\2\2\2\u0169\u0167\3\2\2\2\u0169\u016a\3\2\2\2\u016a\27\3\2",
    "\2\2\u016b\u0169\3\2\2\2\u016c\u016d\7T\2\2\u016d\u016e\5\32\16\2\u016e",
    "\u016f\7S\2\2\u016f\31\3\2\2\2\u0170\u0175\5*\26\2\u0171\u0172\7N\2",
    "\2\u0172\u0174\5*\26\2\u0173\u0171\3\2\2\2\u0174\u0177\3\2\2\2\u0175",
    "\u0173\3\2\2\2\u0175\u0176\3\2\2\2\u0176\33\3\2\2\2\u0177\u0175\3\2",
    "\2\2\u0178\u017a\7\20\2\2\u0179\u017b\5\36\20\2\u017a\u0179\3\2\2\2",
    "\u017a\u017b\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017d\5\u0094K\2\u017d",
    "\35\3\2\2\2\u017e\u017f\7G\2\2\u017f\u0180\5 \21\2\u0180\u0181\7H\2",
    "\2\u0181\37\3\2\2\2\u0182\u0187\5\"\22\2\u0183\u0184\7N\2\2\u0184\u0186",
    "\5\"\22\2\u0185\u0183\3\2\2\2\u0186\u0189\3\2\2\2\u0187\u0185\3\2\2",
    "\2\u0187\u0188\3\2\2\2\u0188!\3\2\2\2\u0189\u0187\3\2\2\2\u018a\u019b",
    "\7x\2\2\u018b\u019b\7v\2\2\u018c\u019b\7~\2\2\u018d\u019b\7z\2\2\u018e",
    "\u019b\7{\2\2\u018f\u019b\7|\2\2\u0190\u019b\7}\2\2\u0191\u019b\3\2",
    "\2\2\u0192\u0193\7w\2\2\u0193\u0194\7R\2\2\u0194\u019b\7\177\2\2\u0195",
    "\u0196\7y\2\2\u0196\u0197\7R\2\2\u0197\u0198\7\177\2\2\u0198\u019b\7",
    "X\2\2\u0199\u019b\7\177\2\2\u019a\u018a\3\2\2\2\u019a\u018b\3\2\2\2",
    "\u019a\u018c\3\2\2\2\u019a\u018d\3\2\2\2\u019a\u018e\3\2\2\2\u019a\u018f",
    "\3\2\2\2\u019a\u0190\3\2\2\2\u019a\u0191\3\2\2\2\u019a\u0192\3\2\2\2",
    "\u019a\u0195\3\2\2\2\u019a\u0199\3\2\2\2\u019b#\3\2\2\2\u019c\u019d",
    "\7\177\2\2\u019d%\3\2\2\2\u019e\u019f\7\177\2\2\u019f\'\3\2\2\2\u01a0",
    "\u01a1\7\177\2\2\u01a1)\3\2\2\2\u01a2\u01a3\7\177\2\2\u01a3+\3\2\2\2",
    "\u01a4\u01a8\7I\2\2\u01a5\u01a7\5\u0094K\2\u01a6\u01a5\3\2\2\2\u01a7",
    "\u01aa\3\2\2\2\u01a8\u01a6\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9\u01ab\3",
    "\2\2\2\u01aa\u01a8\3\2\2\2\u01ab\u01c9\7J\2\2\u01ac\u01ad\7I\2\2\u01ad",
    "\u01af\5.\30\2\u01ae\u01b0\5\u0094K\2\u01af\u01ae\3\2\2\2\u01b0\u01b1",
    "\3\2\2\2\u01b1\u01af\3\2\2\2\u01b1\u01b2\3\2\2\2\u01b2\u01b3\3\2\2\2",
    "\u01b3\u01b4\7J\2\2\u01b4\u01c9\3\2\2\2\u01b5\u01b7\7I\2\2\u01b6\u01b8",
    "\5\u0094K\2\u01b7\u01b6\3\2\2\2\u01b8\u01b9\3\2\2\2\u01b9\u01b7\3\2",
    "\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01bb\3\2\2\2\u01bb\u01bc\5,\27\2\u01bc",
    "\u01bd\7J\2\2\u01bd\u01c9\3\2\2\2\u01be\u01bf\7I\2\2\u01bf\u01c1\5.",
    "\30\2\u01c0\u01c2\5\u0094K\2\u01c1\u01c0\3\2\2\2\u01c2\u01c3\3\2\2\2",
    "\u01c3\u01c1\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4\u01c5\3\2\2\2\u01c5\u01c6",
    "\5,\27\2\u01c6\u01c7\7J\2\2\u01c7\u01c9\3\2\2\2\u01c8\u01a4\3\2\2\2",
    "\u01c8\u01ac\3\2\2\2\u01c8\u01b5\3\2\2\2\u01c8\u01be\3\2\2\2\u01c9-",
    "\3\2\2\2\u01ca\u01cb\t\3\2\2\u01cb/\3\2\2\2\u01cc\u01d1\5\u0086D\2\u01cd",
    "\u01d1\5\62\32\2\u01ce\u01d1\5\64\33\2\u01cf\u01d1\5\34\17\2\u01d0\u01cc",
    "\3\2\2\2\u01d0\u01cd\3\2\2\2\u01d0\u01ce\3\2\2\2\u01d0\u01cf\3\2\2\2",
    "\u01d1\u01d2\3\2\2\2\u01d2\u01d0\3\2\2\2\u01d2\u01d3\3\2\2\2\u01d3\61",
    "\3\2\2\2\u01d4\u01d5\7a\2\2\u01d5\u01d6\5\66\34\2\u01d6\63\3\2\2\2\u01d7",
    "\u01d8\7b\2\2\u01d8\u01d9\5\66\34\2\u01d9\65\3\2\2\2\u01da\u01dc\5F",
    "$\2\u01db\u01da\3\2\2\2\u01db\u01dc\3\2\2\2\u01dc\u01dd\3\2\2\2\u01dd",
    "\u01de\5@!\2\u01de\u01df\7M\2\2\u01df\67\3\2\2\2\u01e0\u01e6\5\u0084",
    "C\2\u01e1\u01e6\5\u0086D\2\u01e2\u01e6\5:\36\2\u01e3\u01e6\5<\37\2\u01e4",
    "\u01e6\5H%\2\u01e5\u01e0\3\2\2\2\u01e5\u01e1\3\2\2\2\u01e5\u01e2\3\2",
    "\2\2\u01e5\u01e3\3\2\2\2\u01e5\u01e4\3\2\2\2\u01e6\u01e7\3\2\2\2\u01e7",
    "\u01e5\3\2\2\2\u01e7\u01e8\3\2\2\2\u01e89\3\2\2\2\u01e9\u01ea\7a\2\2",
    "\u01ea\u01eb\5> \2\u01eb;\3\2\2\2\u01ec\u01ed\7b\2\2\u01ed\u01ee\5>",
    " \2\u01ee=\3\2\2\2\u01ef\u01f1\5F$\2\u01f0\u01ef\3\2\2\2\u01f0\u01f1",
    "\3\2\2\2\u01f1\u01f2\3\2\2\2\u01f2\u01f4\5@!\2\u01f3\u01f5\5\u008eH",
    "\2\u01f4\u01f3\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01f7\3\2\2\2\u01f6",
    "\u01f8\7M\2\2\u01f7\u01f6\3\2\2\2\u01f7\u01f8\3\2\2\2\u01f8\u01f9\3",
    "\2\2\2\u01f9\u01fa\5\u00be`\2\u01fa?\3\2\2\2\u01fb\u0205\5D#\2\u01fc",
    "\u01fe\5B\"\2\u01fd\u01fc\3\2\2\2\u01fe\u01ff\3\2\2\2\u01ff\u01fd\3",
    "\2\2\2\u01ff\u0200\3\2\2\2\u0200\u0202\3\2\2\2\u0201\u0203\5\u00aaV",
    "\2\u0202\u0201\3\2\2\2\u0202\u0203\3\2\2\2\u0203\u0205\3\2\2\2\u0204",
    "\u01fb\3\2\2\2\u0204\u01fd\3\2\2\2\u0205A\3\2\2\2\u0206\u0208\5D#\2",
    "\u0207\u0206\3\2\2\2\u0207\u0208\3\2\2\2\u0208\u0209\3\2\2\2\u0209\u020d",
    "\7X\2\2\u020a\u020c\5F$\2\u020b\u020a\3\2\2\2\u020c\u020f\3\2\2\2\u020d",
    "\u020b\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u0210\3\2\2\2\u020f\u020d\3",
    "\2\2\2\u0210\u0211\7\177\2\2\u0211C\3\2\2\2\u0212\u0213\7\177\2\2\u0213",
    "E\3\2\2\2\u0214\u0215\7G\2\2\u0215\u0216\5\u00b0Y\2\u0216\u0217\7H\2",
    "\2\u0217G\3\2\2\2\u0218\u0219\7\25\2\2\u0219\u021a\5J&\2\u021a\u021b",
    "\7M\2\2\u021b\u0221\3\2\2\2\u021c\u021d\7\6\2\2\u021d\u021e\5J&\2\u021e",
    "\u021f\7M\2\2\u021f\u0221\3\2\2\2\u0220\u0218\3\2\2\2\u0220\u021c\3",
    "\2\2\2\u0221I\3\2\2\2\u0222\u0227\5L\'\2\u0223\u0224\7N\2\2\u0224\u0226",
    "\5L\'\2\u0225\u0223\3\2\2\2\u0226\u0229\3\2\2\2\u0227\u0225\3\2\2\2",
    "\u0227\u0228\3\2\2\2\u0228K\3\2\2\2\u0229\u0227\3\2\2\2\u022a\u022f",
    "\7\177\2\2\u022b\u022c\7\177\2\2\u022c\u022d\7R\2\2\u022d\u022f\7\177",
    "\2\2\u022e\u022a\3\2\2\2\u022e\u022b\3\2\2\2\u022fM\3\2\2\2\u0230\u0231",
    "\5P)\2\u0231\u0232\7G\2\2\u0232\u0234\7g\2\2\u0233\u0235\5P)\2\u0234",
    "\u0233\3\2\2\2\u0234\u0235\3\2\2\2\u0235\u0236\3\2\2\2\u0236\u0238\7",
    "H\2\2\u0237\u0239\5`\61\2\u0238\u0237\3\2\2\2\u0238\u0239\3\2\2\2\u0239",
    "O\3\2\2\2\u023a\u0251\7@\2\2\u023b\u0251\7!\2\2\u023c\u0251\7\67\2\2",
    "\u023d\u0251\7\61\2\2\u023e\u0251\7\62\2\2\u023f\u0251\7*\2\2\u0240",
    "\u0251\7&\2\2\u0241\u0251\78\2\2\u0242\u0251\7?\2\2\u0243\u0245\7,\2",
    "\2\u0244\u0246\5\30\r\2\u0245\u0244\3\2\2\2\u0245\u0246\3\2\2\2\u0246",
    "\u0251\3\2\2\2\u0247\u0249\5$\23\2\u0248\u024a\5\30\r\2\u0249\u0248",
    "\3\2\2\2\u0249\u024a\3\2\2\2\u024a\u0251\3\2\2\2\u024b\u0251\5\u0092",
    "J\2\u024c\u0251\5\u009cO\2\u024d\u0251\7\177\2\2\u024e\u024f\7\177\2",
    "\2\u024f\u0251\5\u00a2R\2\u0250\u023a\3\2\2\2\u0250\u023b\3\2\2\2\u0250",
    "\u023c\3\2\2\2\u0250\u023d\3\2\2\2\u0250\u023e\3\2\2\2\u0250\u023f\3",
    "\2\2\2\u0250\u0240\3\2\2\2\u0250\u0241\3\2\2\2\u0250\u0242\3\2\2\2\u0250",
    "\u0243\3\2\2\2\u0250\u0247\3\2\2\2\u0250\u024b\3\2\2\2\u0250\u024c\3",
    "\2\2\2\u0250\u024d\3\2\2\2\u0250\u024e\3\2\2\2\u0251Q\3\2\2\2\u0252",
    "\u0256\7\"\2\2\u0253\u0256\7A\2\2\u0254\u0256\5T+\2\u0255\u0252\3\2",
    "\2\2\u0255\u0253\3\2\2\2\u0255\u0254\3\2\2\2\u0256S\3\2\2\2\u0257\u0258",
    "\t\4\2\2\u0258U\3\2\2\2\u0259\u026b\7\177\2\2\u025a\u026b\5\u00f8}\2",
    "\u025b\u026b\7\u0081\2\2\u025c\u025d\7G\2\2\u025d\u025e\5\u00ceh\2\u025e",
    "\u025f\7H\2\2\u025f\u026b\3\2\2\2\u0260\u026b\7\31\2\2\u0261\u026b\7",
    "\30\2\2\u0262\u026b\5d\63\2\u0263\u026b\5l\67\2\u0264\u026b\5p9\2\u0265",
    "\u026b\5r:\2\u0266\u026b\5Z.\2\u0267\u026b\5\\/\2\u0268\u026b\5^\60",
    "\2\u0269\u026b\5b\62\2\u026a\u0259\3\2\2\2\u026a\u025a\3\2\2\2\u026a",
    "\u025b\3\2\2\2\u026a\u025c\3\2\2\2\u026a\u0260\3\2\2\2\u026a\u0261\3",
    "\2\2\2\u026a\u0262\3\2\2\2\u026a\u0263\3\2\2\2\u026a\u0264\3\2\2\2\u026a",
    "\u0265\3\2\2\2\u026a\u0266\3\2\2\2\u026a\u0267\3\2\2\2\u026a\u0268\3",
    "\2\2\2\u026a\u0269\3\2\2\2\u026bW\3\2\2\2\u026c\u026d\5\u00f2z\2\u026d",
    "\u026e\7X\2\2\u026e\u026f\5\u00f2z\2\u026fY\3\2\2\2\u0270\u0271\7Q\2",
    "\2\u0271\u0273\7I\2\2\u0272\u0274\5X-\2\u0273\u0272\3\2\2\2\u0273\u0274",
    "\3\2\2\2\u0274\u0279\3\2\2\2\u0275\u0276\7N\2\2\u0276\u0278\5X-\2\u0277",
    "\u0275\3\2\2\2\u0278\u027b\3\2\2\2\u0279\u0277\3\2\2\2\u0279\u027a\3",
    "\2\2\2\u027a\u027d\3\2\2\2\u027b\u0279\3\2\2\2\u027c\u027e\7N\2\2\u027d",
    "\u027c\3\2\2\2\u027d\u027e\3\2\2\2\u027e\u027f\3\2\2\2\u027f\u0280\7",
    "J\2\2\u0280[\3\2\2\2\u0281\u0282\7Q\2\2\u0282\u0284\7K\2\2\u0283\u0285",
    "\5\u00f2z\2\u0284\u0283\3\2\2\2\u0284\u0285\3\2\2\2\u0285\u028a\3\2",
    "\2\2\u0286\u0287\7N\2\2\u0287\u0289\5\u00f2z\2\u0288\u0286\3\2\2\2\u0289",
    "\u028c\3\2\2\2\u028a\u0288\3\2\2\2\u028a\u028b\3\2\2\2\u028b\u028e\3",
    "\2\2\2\u028c\u028a\3\2\2\2\u028d\u028f\7N\2\2\u028e\u028d\3\2\2\2\u028e",
    "\u028f\3\2\2\2\u028f\u0290\3\2\2\2\u0290\u0291\7L\2\2\u0291]\3\2\2\2",
    "\u0292\u0293\7Q\2\2\u0293\u0294\7G\2\2\u0294\u0295\5\u00f2z\2\u0295",
    "\u0296\7H\2\2\u0296\u029a\3\2\2\2\u0297\u0298\7Q\2\2\u0298\u029a\5\u00f8",
    "}\2\u0299\u0292\3\2\2\2\u0299\u0297\3\2\2\2\u029a_\3\2\2\2\u029b\u029e",
    "\7G\2\2\u029c\u029f\5t;\2\u029d\u029f\7@\2\2\u029e\u029c\3\2\2\2\u029e",
    "\u029d\3\2\2\2\u029e\u029f\3\2\2\2\u029f\u02a4\3\2\2\2\u02a0\u02a1\7",
    "N\2\2\u02a1\u02a3\5t;\2\u02a2\u02a0\3\2\2\2\u02a3\u02a6\3\2\2\2\u02a4",
    "\u02a2\3\2\2\2\u02a4\u02a5\3\2\2\2\u02a5\u02a7\3\2\2\2\u02a6\u02a4\3",
    "\2\2\2\u02a7\u02a8\7H\2\2\u02a8a\3\2\2\2\u02a9\u02ab\7g\2\2\u02aa\u02ac",
    "\5P)\2\u02ab\u02aa\3\2\2\2\u02ab\u02ac\3\2\2\2\u02ac\u02ae\3\2\2\2\u02ad",
    "\u02af\5`\61\2\u02ae\u02ad\3\2\2\2\u02ae\u02af\3\2\2\2\u02af\u02b0\3",
    "\2\2\2\u02b0\u02b1\5\u00be`\2\u02b1c\3\2\2\2\u02b2\u02b3\7K\2\2\u02b3",
    "\u02b4\5f\64\2\u02b4\u02b5\5h\65\2\u02b5\u02b6\7L\2\2\u02b6e\3\2\2\2",
    "\u02b7\u02bb\5\u00ceh\2\u02b8\u02bb\5$\23\2\u02b9\u02bb\7\30\2\2\u02ba",
    "\u02b7\3\2\2\2\u02ba\u02b8\3\2\2\2\u02ba\u02b9\3\2\2\2\u02bbg\3\2\2",
    "\2\u02bc\u02c3\5D#\2\u02bd\u02bf\5j\66\2\u02be\u02bd\3\2\2\2\u02bf\u02c0",
    "\3\2\2\2\u02c0\u02be\3\2\2\2\u02c0\u02c1\3\2\2\2\u02c1\u02c3\3\2\2\2",
    "\u02c2\u02bc\3\2\2\2\u02c2\u02be\3\2\2\2\u02c3i\3\2\2\2\u02c4\u02c6",
    "\5D#\2\u02c5\u02c4\3\2\2\2\u02c5\u02c6\3\2\2\2\u02c6\u02c7\3\2\2\2\u02c7",
    "\u02c8\7X\2\2\u02c8\u02c9\5\u00ceh\2\u02c9k\3\2\2\2\u02ca\u02cb\7\23",
    "\2\2\u02cb\u02cc\7G\2\2\u02cc\u02cd\5n8\2\u02cd\u02ce\7H\2\2\u02cem",
    "\3\2\2\2\u02cf\u02d9\5D#\2\u02d0\u02d2\5D#\2\u02d1\u02d0\3\2\2\2\u02d1",
    "\u02d2\3\2\2\2\u02d2\u02d3\3\2\2\2\u02d3\u02d5\7X\2\2\u02d4\u02d1\3",
    "\2\2\2\u02d5\u02d6\3\2\2\2\u02d6\u02d4\3\2\2\2\u02d6\u02d7\3\2\2\2\u02d7",
    "\u02d9\3\2\2\2\u02d8\u02cf\3\2\2\2\u02d8\u02d4\3\2\2\2\u02d9o\3\2\2",
    "\2\u02da\u02db\7\r\2\2\u02db\u02dc\7G\2\2\u02dc\u02dd\5*\26\2\u02dd",
    "\u02de\7H\2\2\u02deq\3\2\2\2\u02df\u02e0\7\7\2\2\u02e0\u02e1\7G\2\2",
    "\u02e1\u02e2\5\u00b0Y\2\u02e2\u02e3\7H\2\2\u02e3s\3\2\2\2\u02e4\u02e5",
    "\5\u0088E\2\u02e5\u02e6\5\u00a4S\2\u02e6u\3\2\2\2\u02e7\u02e8\7\27\2",
    "\2\u02e8\u02e9\5\u00be`\2\u02e9w\3\2\2\2\u02ea\u02eb\7\4\2\2\u02eb\u02ec",
    "\7G\2\2\u02ec\u02ed\5t;\2\u02ed\u02ee\7H\2\2\u02ee\u02ef\5\u00be`\2",
    "\u02efy\3\2\2\2\u02f0\u02f1\7\t\2\2\u02f1\u02f2\5\u00be`\2\u02f2{\3",
    "\2\2\2\u02f3\u02f4\7\26\2\2\u02f4\u02f5\7G\2\2\u02f5\u02f6\7\177\2\2",
    "\u02f6\u02f7\7H\2\2\u02f7}\3\2\2\2\u02f8\u02fc\5v<\2\u02f9\u02fb\5x",
    "=\2\u02fa\u02f9\3\2\2\2\u02fb\u02fe\3\2\2\2\u02fc\u02fa\3\2\2\2\u02fc",
    "\u02fd\3\2\2\2\u02fd\u0300\3\2\2\2\u02fe\u02fc\3\2\2\2\u02ff\u0301\5",
    "z>\2\u0300\u02ff\3\2\2\2\u0300\u0301\3\2\2\2\u0301\177\3\2\2\2\u0302",
    "\u0303\7\24\2\2\u0303\u0304\7G\2\2\u0304\u0305\5V,\2\u0305\u0306\7H",
    "\2\2\u0306\u0307\5\u00be`\2\u0307\u0081\3\2\2\2\u0308\u0309\7\3\2\2",
    "\u0309\u030a\5\u00be`\2\u030a\u0083\3\2\2\2\u030b\u030d\5\u0088E\2\u030c",
    "\u030b\3\2\2\2\u030c\u030d\3\2\2\2\u030d\u030e\3\2\2\2\u030e\u030f\5",
    "\u00a4S\2\u030f\u0310\5\u00be`\2\u0310\u0085\3\2\2\2\u0311\u0313\5\u0088",
    "E\2\u0312\u0314\5\u008eH\2\u0313\u0312\3\2\2\2\u0313\u0314\3\2\2\2\u0314",
    "\u0315\3\2\2\2\u0315\u0316\7M\2\2\u0316\u0087\3\2\2\2\u0317\u031c\5",
    "\u008aF\2\u0318\u031c\5\u008cG\2\u0319\u031c\5P)\2\u031a\u031c\5R*\2",
    "\u031b\u0317\3\2\2\2\u031b\u0318\3\2\2\2\u031b\u0319\3\2\2\2\u031b\u031a",
    "\3\2\2\2\u031c\u031d\3\2\2\2\u031d\u031b\3\2\2\2\u031d\u031e\3\2\2\2",
    "\u031e\u0089\3\2\2\2\u031f\u0320\t\5\2\2\u0320\u008b\3\2\2\2\u0321\u0322",
    "\t\6\2\2\u0322\u008d\3\2\2\2\u0323\u0328\5\u0090I\2\u0324\u0325\7N\2",
    "\2\u0325\u0327\5\u0090I\2\u0326\u0324\3\2\2\2\u0327\u032a\3\2\2\2\u0328",
    "\u0326\3\2\2\2\u0328\u0329\3\2\2\2\u0329\u008f\3\2\2\2\u032a\u0328\3",
    "\2\2\2\u032b\u032e\5\u00a4S\2\u032c\u032d\7R\2\2\u032d\u032f\5\u00ae",
    "X\2\u032e\u032c\3\2\2\2\u032e\u032f\3\2\2\2\u032f\u0091\3\2\2\2\u0330",
    "\u033d\t\7\2\2\u0331\u033e\7\177\2\2\u0332\u0334\7\177\2\2\u0333\u0332",
    "\3\2\2\2\u0333\u0334\3\2\2\2\u0334\u0335\3\2\2\2\u0335\u0337\7I\2\2",
    "\u0336\u0338\5\u0094K\2\u0337\u0336\3\2\2\2\u0338\u0339\3\2\2\2\u0339",
    "\u0337\3\2\2\2\u0339\u033a\3\2\2\2\u033a\u033b\3\2\2\2\u033b\u033c\7",
    "J\2\2\u033c\u033e\3\2\2\2\u033d\u0331\3\2\2\2\u033d\u0333\3\2\2\2\u033e",
    "\u0093\3\2\2\2\u033f\u0340\5\u0096L\2\u0340\u0341\5\u0098M\2\u0341\u0342",
    "\7M\2\2\u0342\u0095\3\2\2\2\u0343\u0347\5\u008aF\2\u0344\u0347\5P)\2",
    "\u0345\u0347\5R*\2\u0346\u0343\3\2\2\2\u0346\u0344\3\2\2\2\u0346\u0345",
    "\3\2\2\2\u0347\u0348\3\2\2\2\u0348\u0346\3\2\2\2\u0348\u0349\3\2\2\2",
    "\u0349\u0097\3\2\2\2\u034a\u034f\5\u009aN\2\u034b\u034c\7N\2\2\u034c",
    "\u034e\5\u009aN\2\u034d\u034b\3\2\2\2\u034e\u0351\3\2\2\2\u034f\u034d",
    "\3\2\2\2\u034f\u0350\3\2\2\2\u0350\u0099\3\2\2\2\u0351\u034f\3\2\2\2",
    "\u0352\u0359\5\u00a4S\2\u0353\u0355\5\u00a4S\2\u0354\u0353\3\2\2\2\u0354",
    "\u0355\3\2\2\2\u0355\u0356\3\2\2\2\u0356\u0357\7X\2\2\u0357\u0359\5",
    "\u00f8}\2\u0358\u0352\3\2\2\2\u0358\u0354\3\2\2\2\u0359\u009b\3\2\2",
    "\2\u035a\u035d\7(\2\2\u035b\u035c\7X\2\2\u035c\u035e\5\u00b0Y\2\u035d",
    "\u035b\3\2\2\2\u035d\u035e\3\2\2\2\u035e\u036a\3\2\2\2\u035f\u0364\5",
    "\u00f6|\2\u0360\u0361\7I\2\2\u0361\u0362\5\u009eP\2\u0362\u0363\7J\2",
    "\2\u0363\u0365\3\2\2\2\u0364\u0360\3\2\2\2\u0364\u0365\3\2\2\2\u0365",
    "\u036b\3\2\2\2\u0366\u0367\7I\2\2\u0367\u0368\5\u009eP\2\u0368\u0369",
    "\7J\2\2\u0369\u036b\3\2\2\2\u036a\u035f\3\2\2\2\u036a\u0366\3\2\2\2",
    "\u036b\u0381\3\2\2\2\u036c\u036d\7C\2\2\u036d\u036e\7G\2\2\u036e\u036f",
    "\5\u00b0Y\2\u036f\u0370\7N\2\2\u0370\u0371\5\u00f6|\2\u0371\u0372\7",
    "H\2\2\u0372\u0373\7I\2\2\u0373\u0374\5\u009eP\2\u0374\u0375\7J\2\2\u0375",
    "\u0381\3\2\2\2\u0376\u0377\7D\2\2\u0377\u0378\7G\2\2\u0378\u0379\5\u00b0",
    "Y\2\u0379\u037a\7N\2\2\u037a\u037b\5\u00f6|\2\u037b\u037c\7H\2\2\u037c",
    "\u037d\7I\2\2\u037d\u037e\5\u009eP\2\u037e\u037f\7J\2\2\u037f\u0381",
    "\3\2\2\2\u0380\u035a\3\2\2\2\u0380\u036c\3\2\2\2\u0380\u0376\3\2\2\2",
    "\u0381\u009d\3\2\2\2\u0382\u0387\5\u00a0Q\2\u0383\u0384\7N\2\2\u0384",
    "\u0386\5\u00a0Q\2\u0385\u0383\3\2\2\2\u0386\u0389\3\2\2\2\u0387\u0385",
    "\3\2\2\2\u0387\u0388\3\2\2\2\u0388\u038b\3\2\2\2\u0389\u0387\3\2\2\2",
    "\u038a\u038c\7N\2\2\u038b\u038a\3\2\2\2\u038b\u038c\3\2\2\2\u038c\u009f",
    "\3\2\2\2\u038d\u0390\5\u00f6|\2\u038e\u038f\7R\2\2\u038f\u0391\5\u00d6",
    "l\2\u0390\u038e\3\2\2\2\u0390\u0391\3\2\2\2\u0391\u00a1\3\2\2\2\u0392",
    "\u0394\7c\2\2\u0393\u0395\5\u0088E\2\u0394\u0393\3\2\2\2\u0394\u0395",
    "\3\2\2\2\u0395\u039c\3\2\2\2\u0396\u0398\7c\2\2\u0397\u0399\5\u0088",
    "E\2\u0398\u0397\3\2\2\2\u0398\u0399\3\2\2\2\u0399\u039a\3\2\2\2\u039a",
    "\u039c\5\u00a2R\2\u039b\u0392\3\2\2\2\u039b\u0396\3\2\2\2\u039c\u00a3",
    "\3\2\2\2\u039d\u039f\5\u00a2R\2\u039e\u039d\3\2\2\2\u039e\u039f\3\2",
    "\2\2\u039f\u03a0\3\2\2\2\u03a0\u03a1\5\u00a6T\2\u03a1\u00a5\3\2\2\2",
    "\u03a2\u03a6\5\u00f6|\2\u03a3\u03a5\5\u00a8U\2\u03a4\u03a3\3\2\2\2\u03a5",
    "\u03a8\3\2\2\2\u03a6\u03a4\3\2\2\2\u03a6\u03a7\3\2\2\2\u03a7\u03ba\3",
    "\2\2\2\u03a8\u03a6\3\2\2\2\u03a9\u03aa\7G\2\2\u03aa\u03ab\5\u00a4S\2",
    "\u03ab\u03af\7H\2\2\u03ac\u03ae\5\u00a8U\2\u03ad\u03ac\3\2\2\2\u03ae",
    "\u03b1\3\2\2\2\u03af\u03ad\3\2\2\2\u03af\u03b0\3\2\2\2\u03b0\u03ba\3",
    "\2\2\2\u03b1\u03af\3\2\2\2\u03b2\u03b3\7G\2\2\u03b3\u03b5\7g\2\2\u03b4",
    "\u03b6\5\u00f6|\2\u03b5\u03b4\3\2\2\2\u03b5\u03b6\3\2\2\2\u03b6\u03b7",
    "\3\2\2\2\u03b7\u03b8\7H\2\2\u03b8\u03ba\5`\61\2\u03b9\u03a2\3\2\2\2",
    "\u03b9\u03a9\3\2\2\2\u03b9\u03b2\3\2\2\2\u03ba\u00a7\3\2\2\2\u03bb\u03bd",
    "\7K\2\2\u03bc\u03be\5\u00d6l\2\u03bd\u03bc\3\2\2\2\u03bd\u03be\3\2\2",
    "\2\u03be\u03bf\3\2\2\2\u03bf\u03c6\7L\2\2\u03c0\u03c2\7G\2\2\u03c1\u03c3",
    "\5\u00aaV\2\u03c2\u03c1\3\2\2\2\u03c2\u03c3\3\2\2\2\u03c3\u03c4\3\2",
    "\2\2\u03c4\u03c6\7H\2\2\u03c5\u03bb\3\2\2\2\u03c5\u03c0\3\2\2\2\u03c6",
    "\u00a9\3\2\2\2\u03c7\u03ca\5\u00b6\\\2\u03c8\u03c9\7N\2\2\u03c9\u03cb",
    "\7u\2\2\u03ca\u03c8\3\2\2\2\u03ca\u03cb\3\2\2\2\u03cb\u00ab\3\2\2\2",
    "\u03cc\u03d1\5\u0088E\2\u03cd\u03cf\5\u00a4S\2\u03ce\u03cd\3\2\2\2\u03ce",
    "\u03cf\3\2\2\2\u03cf\u03d2\3\2\2\2\u03d0\u03d2\5\u00b2Z\2\u03d1\u03ce",
    "\3\2\2\2\u03d1\u03d0\3\2\2\2\u03d2\u00ad\3\2\2\2\u03d3\u03e3\5\u00d0",
    "i\2\u03d4\u03d5\7I\2\2\u03d5\u03da\5\u00aeX\2\u03d6\u03d7\7N\2\2\u03d7",
    "\u03d9\5\u00aeX\2\u03d8\u03d6\3\2\2\2\u03d9\u03dc\3\2\2\2\u03da\u03d8",
    "\3\2\2\2\u03da\u03db\3\2\2\2\u03db\u03de\3\2\2\2\u03dc\u03da\3\2\2\2",
    "\u03dd\u03df\7N\2\2\u03de\u03dd\3\2\2\2\u03de\u03df\3\2\2\2\u03df\u03e0",
    "\3\2\2\2\u03e0\u03e1\7J\2\2\u03e1\u03e3\3\2\2\2\u03e2\u03d3\3\2\2\2",
    "\u03e2\u03d4\3\2\2\2\u03e3\u00af\3\2\2\2\u03e4\u03e5\5\u0096L\2\u03e5",
    "\u03e6\5\u00b2Z\2\u03e6\u03e9\3\2\2\2\u03e7\u03e9\5N(\2\u03e8\u03e4",
    "\3\2\2\2\u03e8\u03e7\3\2\2\2\u03e9\u00b1\3\2\2\2\u03ea\u03eb\5\u00a2",
    "R\2\u03eb\u03ec\5\u00b2Z\2\u03ec\u0400\3\2\2\2\u03ed\u03ee\7G\2\2\u03ee",
    "\u03ef\5\u00b2Z\2\u03ef\u03f1\7H\2\2\u03f0\u03f2\5\u00b4[\2\u03f1\u03f0",
    "\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u03f1\3\2\2\2\u03f3\u03f4\3\2\2\2",
    "\u03f4\u0400\3\2\2\2\u03f5\u03f7\7K\2\2\u03f6\u03f8\5\u00d6l\2\u03f7",
    "\u03f6\3\2\2\2\u03f7\u03f8\3\2\2\2\u03f8\u03f9\3\2\2\2\u03f9\u03fb\7",
    "L\2\2\u03fa\u03f5\3\2\2\2\u03fb\u03fc\3\2\2\2\u03fc\u03fa\3\2\2\2\u03fc",
    "\u03fd\3\2\2\2\u03fd\u0400\3\2\2\2\u03fe\u0400\3\2\2\2\u03ff\u03ea\3",
    "\2\2\2\u03ff\u03ed\3\2\2\2\u03ff\u03fa\3\2\2\2\u03ff\u03fe\3\2\2\2\u0400",
    "\u00b3\3\2\2\2\u0401\u0403\7K\2\2\u0402\u0404\5\u00d6l\2\u0403\u0402",
    "\3\2\2\2\u0403\u0404\3\2\2\2\u0404\u0405\3\2\2\2\u0405\u040c\7L\2\2",
    "\u0406\u0408\7G\2\2\u0407\u0409\5\u00b6\\\2\u0408\u0407\3\2\2\2\u0408",
    "\u0409\3\2\2\2\u0409\u040a\3\2\2\2\u040a\u040c\7H\2\2\u040b\u0401\3",
    "\2\2\2\u040b\u0406\3\2\2\2\u040c\u00b5\3\2\2\2\u040d\u0412\5\u00acW",
    "\2\u040e\u040f\7N\2\2\u040f\u0411\5\u00acW\2\u0410\u040e\3\2\2\2\u0411",
    "\u0414\3\2\2\2\u0412\u0410\3\2\2\2\u0412\u0413\3\2\2\2\u0413\u00b7\3",
    "\2\2\2\u0414\u0412\3\2\2\2\u0415\u0417\5\u00ba^\2\u0416\u0415\3\2\2",
    "\2\u0417\u0418\3\2\2\2\u0418\u0416\3\2\2\2\u0418\u0419\3\2\2\2\u0419",
    "\u00b9\3\2\2\2\u041a\u0427\5\u00bc_\2\u041b\u041c\5\u00ceh\2\u041c\u041d",
    "\7M\2\2\u041d\u0427\3\2\2\2\u041e\u0427\5\u00be`\2\u041f\u0427\5\u00c0",
    "a\2\u0420\u0427\5\u00caf\2\u0421\u0427\5\u00ccg\2\u0422\u0427\5\u0080",
    "A\2\u0423\u0427\5\u0082B\2\u0424\u0427\5~@\2\u0425\u0427\7M\2\2\u0426",
    "\u041a\3\2\2\2\u0426\u041b\3\2\2\2\u0426\u041e\3\2\2\2\u0426\u041f\3",
    "\2\2\2\u0426\u0420\3\2\2\2\u0426\u0421\3\2\2\2\u0426\u0422\3\2\2\2\u0426",
    "\u0423\3\2\2\2\u0426\u0424\3\2\2\2\u0426\u0425\3\2\2\2\u0427\u00bb\3",
    "\2\2\2\u0428\u0429\5\u00f6|\2\u0429\u042a\7X\2\2\u042a\u042b\5\u00ba",
    "^\2\u042b\u0435\3\2\2\2\u042c\u042d\7 \2\2\u042d\u042e\5\u00d6l\2\u042e",
    "\u042f\7X\2\2\u042f\u0430\5\u00ba^\2\u0430\u0435\3\2\2\2\u0431\u0432",
    "\7$\2\2\u0432\u0433\7X\2\2\u0433\u0435\5\u00ba^\2\u0434\u0428\3\2\2",
    "\2\u0434\u042c\3\2\2\2\u0434\u0431\3\2\2\2\u0435\u00bd\3\2\2\2\u0436",
    "\u043b\7I\2\2\u0437\u043a\5\u0086D\2\u0438\u043a\5\u00b8]\2\u0439\u0437",
    "\3\2\2\2\u0439\u0438\3\2\2\2\u043a\u043d\3\2\2\2\u043b\u0439\3\2\2\2",
    "\u043b\u043c\3\2\2\2\u043c\u043e\3\2\2\2\u043d\u043b\3\2\2\2\u043e\u043f",
    "\7J\2\2\u043f\u00bf\3\2\2\2\u0440\u0441\7-\2\2\u0441\u0442\7G\2\2\u0442",
    "\u0443\5\u00ceh\2\u0443\u0444\7H\2\2\u0444\u0447\5\u00ba^\2\u0445\u0446",
    "\7\'\2\2\u0446\u0448\5\u00ba^\2\u0447\u0445\3\2\2\2\u0447\u0448\3\2",
    "\2\2\u0448\u0450\3\2\2\2\u0449\u044a\7<\2\2\u044a\u044b\7G\2\2\u044b",
    "\u044c\5\u00ceh\2\u044c\u044d\7H\2\2\u044d\u044e\5\u00ba^\2\u044e\u0450",
    "\3\2\2\2\u044f\u0440\3\2\2\2\u044f\u0449\3\2\2\2\u0450\u00c1\3\2\2\2",
    "\u0451\u0452\7+\2\2\u0452\u0453\7G\2\2\u0453\u0454\5t;\2\u0454\u0456",
    "\7.\2\2\u0455\u0457\5\u00ceh\2\u0456\u0455\3\2\2\2\u0456\u0457\3\2\2",
    "\2\u0457\u0458\3\2\2\2\u0458\u0459\7H\2\2\u0459\u045a\5\u00ba^\2\u045a",
    "\u00c3\3\2\2\2\u045b\u045c\7+\2\2\u045c\u0461\7G\2\2\u045d\u045e\5\u0088",
    "E\2\u045e\u045f\5\u008eH\2\u045f\u0462\3\2\2\2\u0460\u0462\5\u00ceh",
    "\2\u0461\u045d\3\2\2\2\u0461\u0460\3\2\2\2\u0461\u0462\3\2\2\2\u0462",
    "\u0463\3\2\2\2\u0463\u0465\7M\2\2\u0464\u0466\5\u00ceh\2\u0465\u0464",
    "\3\2\2\2\u0465\u0466\3\2\2\2\u0466\u0467\3\2\2\2\u0467\u0469\7M\2\2",
    "\u0468\u046a\5\u00ceh\2\u0469\u0468\3\2\2\2\u0469\u046a\3\2\2\2\u046a",
    "\u046b\3\2\2\2\u046b\u046c\7H\2\2\u046c\u046d\5\u00ba^\2\u046d\u00c5",
    "\3\2\2\2\u046e\u046f\7B\2\2\u046f\u0470\7G\2\2\u0470\u0471\5\u00ceh",
    "\2\u0471\u0472\7H\2\2\u0472\u0473\5\u00ba^\2\u0473\u00c7\3\2\2\2\u0474",
    "\u0475\7%\2\2\u0475\u0476\5\u00ba^\2\u0476\u0477\7B\2\2\u0477\u0478",
    "\7G\2\2\u0478\u0479\5\u00ceh\2\u0479\u047a\7H\2\2\u047a\u047b\7M\2\2",
    "\u047b\u00c9\3\2\2\2\u047c\u0481\5\u00c6d\2\u047d\u0481\5\u00c8e\2\u047e",
    "\u0481\5\u00c4c\2\u047f\u0481\5\u00c2b\2\u0480\u047c\3\2\2\2\u0480\u047d",
    "\3\2\2\2\u0480\u047e\3\2\2\2\u0480\u047f\3\2\2\2\u0481\u00cb\3\2\2\2",
    "\u0482\u0483\7\60\2\2\u0483\u0484\5\u00f6|\2\u0484\u0485\7M\2\2\u0485",
    "\u0490\3\2\2\2\u0486\u0487\7#\2\2\u0487\u0490\7M\2\2\u0488\u0489\7\35",
    "\2\2\u0489\u0490\7M\2\2\u048a\u048c\7\66\2\2\u048b\u048d\5\u00ceh\2",
    "\u048c\u048b\3\2\2\2\u048c\u048d\3\2\2\2\u048d\u048e\3\2\2\2\u048e\u0490",
    "\7M\2\2\u048f\u0482\3\2\2\2\u048f\u0486\3\2\2\2\u048f\u0488\3\2\2\2",
    "\u048f\u048a\3\2\2\2\u0490\u00cd\3\2\2\2\u0491\u0496\5\u00d0i\2\u0492",
    "\u0493\7N\2\2\u0493\u0495\5\u00d0i\2\u0494\u0492\3\2\2\2\u0495\u0498",
    "\3\2\2\2\u0496\u0494\3\2\2\2\u0496\u0497\3\2\2\2\u0497\u00cf\3\2\2\2",
    "\u0498\u0496\3\2\2\2\u0499\u049f\5\u00d4k\2\u049a\u049b\5\u00eex\2\u049b",
    "\u049c\5\u00d2j\2\u049c\u049d\5\u00d0i\2\u049d\u049f\3\2\2\2\u049e\u0499",
    "\3\2\2\2\u049e\u049a\3\2\2\2\u049f\u00d1\3\2\2\2\u04a0\u04a1\t\b\2\2",
    "\u04a1\u00d3\3\2\2\2\u04a2\u04a8\5\u00d8m\2\u04a3\u04a4\7W\2\2\u04a4",
    "\u04a5\5\u00d4k\2\u04a5\u04a6\7X\2\2\u04a6\u04a7\5\u00d4k\2\u04a7\u04a9",
    "\3\2\2\2\u04a8\u04a3\3\2\2\2\u04a8\u04a9\3\2\2\2\u04a9\u00d5\3\2\2\2",
    "\u04aa\u04ab\5\u00d4k\2\u04ab\u00d7\3\2\2\2\u04ac\u04b1\5\u00dan\2\u04ad",
    "\u04ae\7^\2\2\u04ae\u04b0\5\u00dan\2\u04af\u04ad\3\2\2\2\u04b0\u04b3",
    "\3\2\2\2\u04b1\u04af\3\2\2\2\u04b1\u04b2\3\2\2\2\u04b2\u00d9\3\2\2\2",
    "\u04b3\u04b1\3\2\2\2\u04b4\u04b9\5\u00dco\2\u04b5\u04b6\7]\2\2\u04b6",
    "\u04b8\5\u00dco\2\u04b7\u04b5\3\2\2\2\u04b8\u04bb\3\2\2\2\u04b9\u04b7",
    "\3\2\2\2\u04b9\u04ba\3\2\2\2\u04ba\u00db\3\2\2\2\u04bb\u04b9\3\2\2\2",
    "\u04bc\u04c1\5\u00dep\2\u04bd\u04be\7f\2\2\u04be\u04c0\5\u00dep\2\u04bf",
    "\u04bd\3\2\2\2\u04c0\u04c3\3\2\2\2\u04c1\u04bf\3\2\2\2\u04c1\u04c2\3",
    "\2\2\2\u04c2\u00dd\3\2\2\2\u04c3\u04c1\3\2\2\2\u04c4\u04c9\5\u00e0q",
    "\2\u04c5\u04c6\7g\2\2\u04c6\u04c8\5\u00e0q\2\u04c7\u04c5\3\2\2\2\u04c8",
    "\u04cb\3\2\2\2\u04c9\u04c7\3\2\2\2\u04c9\u04ca\3\2\2\2\u04ca\u00df\3",
    "\2\2\2\u04cb\u04c9\3\2\2\2\u04cc\u04d1\5\u00e2r\2\u04cd\u04ce\7e\2\2",
    "\u04ce\u04d0\5\u00e2r\2\u04cf\u04cd\3\2\2\2\u04d0\u04d3\3\2\2\2\u04d1",
    "\u04cf\3\2\2\2\u04d1\u04d2\3\2\2\2\u04d2\u00e1\3\2\2\2\u04d3\u04d1\3",
    "\2\2\2\u04d4\u04d9\5\u00e4s\2\u04d5\u04d6\t\t\2\2\u04d6\u04d8\5\u00e4",
    "s\2\u04d7\u04d5\3\2\2\2\u04d8\u04db\3\2\2\2\u04d9\u04d7\3\2\2\2\u04d9",
    "\u04da\3\2\2\2\u04da\u00e3\3\2\2\2\u04db\u04d9\3\2\2\2\u04dc\u04e1\5",
    "\u00e6t\2\u04dd\u04de\t\n\2\2\u04de\u04e0\5\u00e6t\2\u04df\u04dd\3\2",
    "\2\2\u04e0\u04e3\3\2\2\2\u04e1\u04df\3\2\2\2\u04e1\u04e2\3\2\2\2\u04e2",
    "\u00e5\3\2\2\2\u04e3\u04e1\3\2\2\2\u04e4\u04e9\5\u00e8u\2\u04e5\u04e6",
    "\t\13\2\2\u04e6\u04e8\5\u00e8u\2\u04e7\u04e5\3\2\2\2\u04e8\u04eb\3\2",
    "\2\2\u04e9\u04e7\3\2\2\2\u04e9\u04ea\3\2\2\2\u04ea\u00e7\3\2\2\2\u04eb",
    "\u04e9\3\2\2\2\u04ec\u04f1\5\u00eav\2\u04ed\u04ee\t\f\2\2\u04ee\u04f0",
    "\5\u00eav\2\u04ef\u04ed\3\2\2\2\u04f0\u04f3\3\2\2\2\u04f1\u04ef\3\2",
    "\2\2\u04f1\u04f2\3\2\2\2\u04f2\u00e9\3\2\2\2\u04f3\u04f1\3\2\2\2\u04f4",
    "\u04f9\5\u00ecw\2\u04f5\u04f6\t\r\2\2\u04f6\u04f8\5\u00ecw\2\u04f7\u04f5",
    "\3\2\2\2\u04f8\u04fb\3\2\2\2\u04f9\u04f7\3\2\2\2\u04f9\u04fa\3\2\2\2",
    "\u04fa\u00eb\3\2\2\2\u04fb\u04f9\3\2\2\2\u04fc\u04fd\7G\2\2\u04fd\u04fe",
    "\5\u00b0Y\2\u04fe\u04ff\7H\2\2\u04ff\u0500\5\u00ecw\2\u0500\u0503\3",
    "\2\2\2\u0501\u0503\5\u00eex\2\u0502\u04fc\3\2\2\2\u0502\u0501\3\2\2",
    "\2\u0503\u00ed\3\2\2\2\u0504\u0515\5\u00f2z\2\u0505\u0506\7_\2\2\u0506",
    "\u0515\5\u00eex\2\u0507\u0508\7`\2\2\u0508\u0515\5\u00eex\2\u0509\u050a",
    "\5\u00f0y\2\u050a\u050b\5\u00ecw\2\u050b\u0515\3\2\2\2\u050c\u0512\7",
    "9\2\2\u050d\u050e\7G\2\2\u050e\u050f\5\u00b0Y\2\u050f\u0510\7H\2\2\u0510",
    "\u0513\3\2\2\2\u0511\u0513\5\u00eex\2\u0512\u050d\3\2\2\2\u0512\u0511",
    "\3\2\2\2\u0513\u0515\3\2\2\2\u0514\u0504\3\2\2\2\u0514\u0505\3\2\2\2",
    "\u0514\u0507\3\2\2\2\u0514\u0509\3\2\2\2\u0514\u050c\3\2\2\2\u0515\u00ef",
    "\3\2\2\2\u0516\u0517\t\16\2\2\u0517\u00f1\3\2\2\2\u0518\u052a\5V,\2",
    "\u0519\u051a\7K\2\2\u051a\u051b\5\u00ceh\2\u051b\u051c\7L\2\2\u051c",
    "\u0529\3\2\2\2\u051d\u051f\7G\2\2\u051e\u0520\5\u00f4{\2\u051f\u051e",
    "\3\2\2\2\u051f\u0520\3\2\2\2\u0520\u0521\3\2\2\2\u0521\u0529\7H\2\2",
    "\u0522\u0523\7O\2\2\u0523\u0529\5\u00f6|\2\u0524\u0525\7P\2\2\u0525",
    "\u0529\5\u00f6|\2\u0526\u0529\7_\2\2\u0527\u0529\7`\2\2\u0528\u0519",
    "\3\2\2\2\u0528\u051d\3\2\2\2\u0528\u0522\3\2\2\2\u0528\u0524\3\2\2\2",
    "\u0528\u0526\3\2\2\2\u0528\u0527\3\2\2\2\u0529\u052c\3\2\2\2\u052a\u0528",
    "\3\2\2\2\u052a\u052b\3\2\2\2\u052b\u00f3\3\2\2\2\u052c\u052a\3\2\2\2",
    "\u052d\u0532\5\u00d0i\2\u052e\u052f\7N\2\2\u052f\u0531\5\u00d0i\2\u0530",
    "\u052e\3\2\2\2\u0531\u0534\3\2\2\2\u0532\u0530\3\2\2\2\u0532\u0533\3",
    "\2\2\2\u0533\u00f5\3\2\2\2\u0534\u0532\3\2\2\2\u0535\u0536\7\177\2\2",
    "\u0536\u00f7\3\2\2\2\u0537\u0538\t\17\2\2\u0538\u00f9\3\2\2\2\u009a",
    "\u00fd\u010d\u0115\u0118\u011b\u011e\u0126\u012a\u012d\u0130\u0138\u013b",
    "\u013e\u0148\u014f\u0152\u0155\u0158\u0169\u0175\u017a\u0187\u019a\u01a8",
    "\u01b1\u01b9\u01c3\u01c8\u01d0\u01d2\u01db\u01e5\u01e7\u01f0\u01f4\u01f7",
    "\u01ff\u0202\u0204\u0207\u020d\u0220\u0227\u022e\u0234\u0238\u0245\u0249",
    "\u0250\u0255\u026a\u0273\u0279\u027d\u0284\u028a\u028e\u0299\u029e\u02a4",
    "\u02ab\u02ae\u02ba\u02c0\u02c2\u02c5\u02d1\u02d6\u02d8\u02fc\u0300\u030c",
    "\u0313\u031b\u031d\u0328\u032e\u0333\u0339\u033d\u0346\u0348\u034f\u0354",
    "\u0358\u035d\u0364\u036a\u0380\u0387\u038b\u0390\u0394\u0398\u039b\u039e",
    "\u03a6\u03af\u03b5\u03b9\u03bd\u03c2\u03c5\u03ca\u03ce\u03d1\u03da\u03de",
    "\u03e2\u03e8\u03f3\u03f7\u03fc\u03ff\u0403\u0408\u040b\u0412\u0418\u0426",
    "\u0434\u0439\u043b\u0447\u044f\u0456\u0461\u0465\u0469\u0480\u048c\u048f",
    "\u0496\u049e\u04a8\u04b1\u04b9\u04c1\u04c9\u04d1\u04d9\u04e1\u04e9\u04f1",
    "\u04f9\u0502\u0512\u0514\u051f\u0528\u052a\u0532"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ 'null', "'@autoreleasepool'", "'@catch'", "'@class'", 
                     "'@dynamic'", "'@encode'", "'@end'", "'@finally'", 
                     "'@implementation'", "'@interface'", "'@package'", 
                     "'@protocol'", "'@optional'", "'@private'", "'@property'", 
                     "'@protected'", "'@public'", "'@selector'", "'@synchronized'", 
                     "'@synthesize'", "'@throw'", "'@try'", "'super'", "'self'", 
                     "'abstract'", "'auto'", "'boolean'", "'break'", "'bycopy'", 
                     "'byref'", "'case'", "'char'", "'const'", "'continue'", 
                     "'default'", "'do'", "'double'", "'else'", "'enum'", 
                     "'extern'", "'float'", "'for'", "'id'", "'if'", "'in'", 
                     "'inout'", "'goto'", "'int'", "'long'", "'oneway'", 
                     "'out'", "'register'", "'return'", "'short'", "'signed'", 
                     "'sizeof'", "'static'", "'struct'", "'switch'", "'typedef'", 
                     "'union'", "'unsigned'", "'void'", "'volatile'", "'while'", 
                     "'NS_OPTIONS'", "'NS_ENUM'", "'__weak'", "'__unsafe_unretained'", 
                     "'('", "')'", "'{'", "'}'", "'['", "']'", "';'", "','", 
                     "'.'", "'->'", "'@'", "'='", "'>'", "'<'", "'!'", "'~'", 
                     "'?'", "':'", "'=='", "'<='", "'>='", "'!='", "'&&'", 
                     "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'", 
                     "'&'", "'|'", "'^'", "'%'", "'>>'", "'<<'", "'+='", 
                     "'-='", "'*='", "'/='", "'&='", "'|='", "'^='", "'%='", 
                     "'<<='", "'>>='", "'...'", "'assign'", "'getter'", 
                     "'nonatomic'", "'setter'", "'strong'", "'retain'", 
                     "'readonly'", "'readwrite'", "'weak'" ];

var symbolicNames = [ 'null', "AUTORELEASEPOOL", "CATCH", "CLASS", "DYNAMIC", 
                      "ENCODE", "END", "FINALLY", "IMPLEMENTATION", "INTERFACE", 
                      "PACKAGE", "PROTOCOL", "OPTIONAL", "PRIVATE", "PROPERTY", 
                      "PROTECTED", "PUBLIC", "SELECTOR", "SYNCHRONIZED", 
                      "SYNTHESIZE", "THROW", "TRY", "SUPER", "SELF", "ABSTRACT", 
                      "AUTO", "BOOLEAN", "BREAK", "BYCOPY", "BYREF", "CASE", 
                      "CHAR", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", 
                      "ELSE", "ENUM", "EXTERN", "FLOAT", "FOR", "ID", "IF", 
                      "IN", "INOUT", "GOTO", "INT", "LONG", "ONEWAY", "OUT", 
                      "REGISTER", "RETURN", "SHORT", "SIGNED", "SIZEOF", 
                      "STATIC", "STRUCT", "SWITCH", "TYPEDEF", "UNION", 
                      "UNSIGNED", "VOID", "VOLATILE", "WHILE", "NS_OPTIONS", 
                      "NS_ENUM", "WWEAK", "WUNSAFE_UNRETAINED", "LPAREN", 
                      "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", 
                      "SEMI", "COMMA", "DOT", "STRUCTACCESS", "AT", "ASSIGN", 
                      "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", 
                      "EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", "INC", 
                      "DEC", "ADD", "SUB", "MUL", "DIV", "BITAND", "BITOR", 
                      "CARET", "MOD", "SHIFT_R", "SHIFT_L", "ADD_ASSIGN", 
                      "SUB_ASSIGN", "MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", 
                      "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN", "LSHIFT_ASSIGN", 
                      "RSHIFT_ASSIGN", "ELIPSIS", "ASSIGNPA", "GETTER", 
                      "NONATOMIC", "SETTER", "STRONG", "RETAIN", "READONLY", 
                      "READWRITE", "WEAK", "IDENTIFIER", "CHARACTER_LITERAL", 
                      "STRING_LITERAL", "HEX_LITERAL", "DECIMAL_LITERAL", 
                      "OCTAL_LITERAL", "FLOATING_POINT_LITERAL", "IMPORT", 
                      "INCLUDE", "PRAGMA", "WS", "COMMENT", "LINE_COMMENT", 
                      "HDEFINE", "HIF", "HELSE", "HUNDEF", "HIFNDEF", "HENDIF" ];

var ruleNames =  [ "translation_unit", "external_declaration", "preprocessor_declaration", 
                   "class_interface", "category_interface", "class_implementation", 
                   "category_implementation", "protocol_declaration", "protocol_declaration_list", 
                   "class_declaration_list", "class_list", "protocol_reference_list", 
                   "protocol_list", "property_declaration", "property_attributes_declaration", 
                   "property_attributes_list", "property_attribute", "class_name", 
                   "superclass_name", "category_name", "protocol_name", 
                   "instance_variables", "visibility_specification", "interface_declaration_list", 
                   "class_method_declaration", "instance_method_declaration", 
                   "method_declaration", "implementation_definition_list", 
                   "class_method_definition", "instance_method_definition", 
                   "method_definition", "method_selector", "keyword_declarator", 
                   "selector", "method_type", "property_implementation", 
                   "property_synthesize_list", "property_synthesize_item", 
                   "block_type", "type_specifier", "type_qualifier", "protocol_qualifier", 
                   "primary_expression", "dictionary_pair", "dictionary_expression", 
                   "array_expression", "box_expression", "block_parameters", 
                   "block_expression", "message_expression", "receiver", 
                   "message_selector", "keyword_argument", "selector_expression", 
                   "selector_name", "protocol_expression", "encode_expression", 
                   "type_variable_declarator", "try_statement", "catch_statement", 
                   "finally_statement", "throw_statement", "try_block", 
                   "synchronized_statement", "autorelease_statement", "function_definition", 
                   "declaration", "declaration_specifiers", "arc_behaviour_specifier", 
                   "storage_class_specifier", "init_declarator_list", "init_declarator", 
                   "struct_or_union_specifier", "struct_declaration", "specifier_qualifier_list", 
                   "struct_declarator_list", "struct_declarator", "enum_specifier", 
                   "enumerator_list", "enumerator", "pointer", "declarator", 
                   "direct_declarator", "declarator_suffix", "parameter_list", 
                   "parameter_declaration", "initializer", "type_name", 
                   "abstract_declarator", "abstract_declarator_suffix", 
                   "parameter_declaration_list", "statement_list", "statement", 
                   "labeled_statement", "compound_statement", "selection_statement", 
                   "for_in_statement", "for_statement", "while_statement", 
                   "do_statement", "iteration_statement", "jump_statement", 
                   "expression", "assignment_expression", "assignment_operator", 
                   "conditional_expression", "constant_expression", "logical_or_expression", 
                   "logical_and_expression", "inclusive_or_expression", 
                   "exclusive_or_expression", "and_expression", "equality_expression", 
                   "relational_expression", "shift_expression", "additive_expression", 
                   "multiplicative_expression", "cast_expression", "unary_expression", 
                   "unary_operator", "postfix_expression", "argument_expression_list", 
                   "identifier", "constant" ];

function ObjCParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

ObjCParser.prototype = Object.create(antlr4.Parser.prototype);
ObjCParser.prototype.constructor = ObjCParser;

Object.defineProperty(ObjCParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

ObjCParser.EOF = antlr4.Token.EOF;
ObjCParser.AUTORELEASEPOOL = 1;
ObjCParser.CATCH = 2;
ObjCParser.CLASS = 3;
ObjCParser.DYNAMIC = 4;
ObjCParser.ENCODE = 5;
ObjCParser.END = 6;
ObjCParser.FINALLY = 7;
ObjCParser.IMPLEMENTATION = 8;
ObjCParser.INTERFACE = 9;
ObjCParser.PACKAGE = 10;
ObjCParser.PROTOCOL = 11;
ObjCParser.OPTIONAL = 12;
ObjCParser.PRIVATE = 13;
ObjCParser.PROPERTY = 14;
ObjCParser.PROTECTED = 15;
ObjCParser.PUBLIC = 16;
ObjCParser.SELECTOR = 17;
ObjCParser.SYNCHRONIZED = 18;
ObjCParser.SYNTHESIZE = 19;
ObjCParser.THROW = 20;
ObjCParser.TRY = 21;
ObjCParser.SUPER = 22;
ObjCParser.SELF = 23;
ObjCParser.ABSTRACT = 24;
ObjCParser.AUTO = 25;
ObjCParser.BOOLEAN = 26;
ObjCParser.BREAK = 27;
ObjCParser.BYCOPY = 28;
ObjCParser.BYREF = 29;
ObjCParser.CASE = 30;
ObjCParser.CHAR = 31;
ObjCParser.CONST = 32;
ObjCParser.CONTINUE = 33;
ObjCParser.DEFAULT = 34;
ObjCParser.DO = 35;
ObjCParser.DOUBLE = 36;
ObjCParser.ELSE = 37;
ObjCParser.ENUM = 38;
ObjCParser.EXTERN = 39;
ObjCParser.FLOAT = 40;
ObjCParser.FOR = 41;
ObjCParser.ID = 42;
ObjCParser.IF = 43;
ObjCParser.IN = 44;
ObjCParser.INOUT = 45;
ObjCParser.GOTO = 46;
ObjCParser.INT = 47;
ObjCParser.LONG = 48;
ObjCParser.ONEWAY = 49;
ObjCParser.OUT = 50;
ObjCParser.REGISTER = 51;
ObjCParser.RETURN = 52;
ObjCParser.SHORT = 53;
ObjCParser.SIGNED = 54;
ObjCParser.SIZEOF = 55;
ObjCParser.STATIC = 56;
ObjCParser.STRUCT = 57;
ObjCParser.SWITCH = 58;
ObjCParser.TYPEDEF = 59;
ObjCParser.UNION = 60;
ObjCParser.UNSIGNED = 61;
ObjCParser.VOID = 62;
ObjCParser.VOLATILE = 63;
ObjCParser.WHILE = 64;
ObjCParser.NS_OPTIONS = 65;
ObjCParser.NS_ENUM = 66;
ObjCParser.WWEAK = 67;
ObjCParser.WUNSAFE_UNRETAINED = 68;
ObjCParser.LPAREN = 69;
ObjCParser.RPAREN = 70;
ObjCParser.LBRACE = 71;
ObjCParser.RBRACE = 72;
ObjCParser.LBRACK = 73;
ObjCParser.RBRACK = 74;
ObjCParser.SEMI = 75;
ObjCParser.COMMA = 76;
ObjCParser.DOT = 77;
ObjCParser.STRUCTACCESS = 78;
ObjCParser.AT = 79;
ObjCParser.ASSIGN = 80;
ObjCParser.GT = 81;
ObjCParser.LT = 82;
ObjCParser.BANG = 83;
ObjCParser.TILDE = 84;
ObjCParser.QUESTION = 85;
ObjCParser.COLON = 86;
ObjCParser.EQUAL = 87;
ObjCParser.LE = 88;
ObjCParser.GE = 89;
ObjCParser.NOTEQUAL = 90;
ObjCParser.AND = 91;
ObjCParser.OR = 92;
ObjCParser.INC = 93;
ObjCParser.DEC = 94;
ObjCParser.ADD = 95;
ObjCParser.SUB = 96;
ObjCParser.MUL = 97;
ObjCParser.DIV = 98;
ObjCParser.BITAND = 99;
ObjCParser.BITOR = 100;
ObjCParser.CARET = 101;
ObjCParser.MOD = 102;
ObjCParser.SHIFT_R = 103;
ObjCParser.SHIFT_L = 104;
ObjCParser.ADD_ASSIGN = 105;
ObjCParser.SUB_ASSIGN = 106;
ObjCParser.MUL_ASSIGN = 107;
ObjCParser.DIV_ASSIGN = 108;
ObjCParser.AND_ASSIGN = 109;
ObjCParser.OR_ASSIGN = 110;
ObjCParser.XOR_ASSIGN = 111;
ObjCParser.MOD_ASSIGN = 112;
ObjCParser.LSHIFT_ASSIGN = 113;
ObjCParser.RSHIFT_ASSIGN = 114;
ObjCParser.ELIPSIS = 115;
ObjCParser.ASSIGNPA = 116;
ObjCParser.GETTER = 117;
ObjCParser.NONATOMIC = 118;
ObjCParser.SETTER = 119;
ObjCParser.STRONG = 120;
ObjCParser.RETAIN = 121;
ObjCParser.READONLY = 122;
ObjCParser.READWRITE = 123;
ObjCParser.WEAK = 124;
ObjCParser.IDENTIFIER = 125;
ObjCParser.CHARACTER_LITERAL = 126;
ObjCParser.STRING_LITERAL = 127;
ObjCParser.HEX_LITERAL = 128;
ObjCParser.DECIMAL_LITERAL = 129;
ObjCParser.OCTAL_LITERAL = 130;
ObjCParser.FLOATING_POINT_LITERAL = 131;
ObjCParser.IMPORT = 132;
ObjCParser.INCLUDE = 133;
ObjCParser.PRAGMA = 134;
ObjCParser.WS = 135;
ObjCParser.COMMENT = 136;
ObjCParser.LINE_COMMENT = 137;
ObjCParser.HDEFINE = 138;
ObjCParser.HIF = 139;
ObjCParser.HELSE = 140;
ObjCParser.HUNDEF = 141;
ObjCParser.HIFNDEF = 142;
ObjCParser.HENDIF = 143;

ObjCParser.RULE_translation_unit = 0;
ObjCParser.RULE_external_declaration = 1;
ObjCParser.RULE_preprocessor_declaration = 2;
ObjCParser.RULE_class_interface = 3;
ObjCParser.RULE_category_interface = 4;
ObjCParser.RULE_class_implementation = 5;
ObjCParser.RULE_category_implementation = 6;
ObjCParser.RULE_protocol_declaration = 7;
ObjCParser.RULE_protocol_declaration_list = 8;
ObjCParser.RULE_class_declaration_list = 9;
ObjCParser.RULE_class_list = 10;
ObjCParser.RULE_protocol_reference_list = 11;
ObjCParser.RULE_protocol_list = 12;
ObjCParser.RULE_property_declaration = 13;
ObjCParser.RULE_property_attributes_declaration = 14;
ObjCParser.RULE_property_attributes_list = 15;
ObjCParser.RULE_property_attribute = 16;
ObjCParser.RULE_class_name = 17;
ObjCParser.RULE_superclass_name = 18;
ObjCParser.RULE_category_name = 19;
ObjCParser.RULE_protocol_name = 20;
ObjCParser.RULE_instance_variables = 21;
ObjCParser.RULE_visibility_specification = 22;
ObjCParser.RULE_interface_declaration_list = 23;
ObjCParser.RULE_class_method_declaration = 24;
ObjCParser.RULE_instance_method_declaration = 25;
ObjCParser.RULE_method_declaration = 26;
ObjCParser.RULE_implementation_definition_list = 27;
ObjCParser.RULE_class_method_definition = 28;
ObjCParser.RULE_instance_method_definition = 29;
ObjCParser.RULE_method_definition = 30;
ObjCParser.RULE_method_selector = 31;
ObjCParser.RULE_keyword_declarator = 32;
ObjCParser.RULE_selector = 33;
ObjCParser.RULE_method_type = 34;
ObjCParser.RULE_property_implementation = 35;
ObjCParser.RULE_property_synthesize_list = 36;
ObjCParser.RULE_property_synthesize_item = 37;
ObjCParser.RULE_block_type = 38;
ObjCParser.RULE_type_specifier = 39;
ObjCParser.RULE_type_qualifier = 40;
ObjCParser.RULE_protocol_qualifier = 41;
ObjCParser.RULE_primary_expression = 42;
ObjCParser.RULE_dictionary_pair = 43;
ObjCParser.RULE_dictionary_expression = 44;
ObjCParser.RULE_array_expression = 45;
ObjCParser.RULE_box_expression = 46;
ObjCParser.RULE_block_parameters = 47;
ObjCParser.RULE_block_expression = 48;
ObjCParser.RULE_message_expression = 49;
ObjCParser.RULE_receiver = 50;
ObjCParser.RULE_message_selector = 51;
ObjCParser.RULE_keyword_argument = 52;
ObjCParser.RULE_selector_expression = 53;
ObjCParser.RULE_selector_name = 54;
ObjCParser.RULE_protocol_expression = 55;
ObjCParser.RULE_encode_expression = 56;
ObjCParser.RULE_type_variable_declarator = 57;
ObjCParser.RULE_try_statement = 58;
ObjCParser.RULE_catch_statement = 59;
ObjCParser.RULE_finally_statement = 60;
ObjCParser.RULE_throw_statement = 61;
ObjCParser.RULE_try_block = 62;
ObjCParser.RULE_synchronized_statement = 63;
ObjCParser.RULE_autorelease_statement = 64;
ObjCParser.RULE_function_definition = 65;
ObjCParser.RULE_declaration = 66;
ObjCParser.RULE_declaration_specifiers = 67;
ObjCParser.RULE_arc_behaviour_specifier = 68;
ObjCParser.RULE_storage_class_specifier = 69;
ObjCParser.RULE_init_declarator_list = 70;
ObjCParser.RULE_init_declarator = 71;
ObjCParser.RULE_struct_or_union_specifier = 72;
ObjCParser.RULE_struct_declaration = 73;
ObjCParser.RULE_specifier_qualifier_list = 74;
ObjCParser.RULE_struct_declarator_list = 75;
ObjCParser.RULE_struct_declarator = 76;
ObjCParser.RULE_enum_specifier = 77;
ObjCParser.RULE_enumerator_list = 78;
ObjCParser.RULE_enumerator = 79;
ObjCParser.RULE_pointer = 80;
ObjCParser.RULE_declarator = 81;
ObjCParser.RULE_direct_declarator = 82;
ObjCParser.RULE_declarator_suffix = 83;
ObjCParser.RULE_parameter_list = 84;
ObjCParser.RULE_parameter_declaration = 85;
ObjCParser.RULE_initializer = 86;
ObjCParser.RULE_type_name = 87;
ObjCParser.RULE_abstract_declarator = 88;
ObjCParser.RULE_abstract_declarator_suffix = 89;
ObjCParser.RULE_parameter_declaration_list = 90;
ObjCParser.RULE_statement_list = 91;
ObjCParser.RULE_statement = 92;
ObjCParser.RULE_labeled_statement = 93;
ObjCParser.RULE_compound_statement = 94;
ObjCParser.RULE_selection_statement = 95;
ObjCParser.RULE_for_in_statement = 96;
ObjCParser.RULE_for_statement = 97;
ObjCParser.RULE_while_statement = 98;
ObjCParser.RULE_do_statement = 99;
ObjCParser.RULE_iteration_statement = 100;
ObjCParser.RULE_jump_statement = 101;
ObjCParser.RULE_expression = 102;
ObjCParser.RULE_assignment_expression = 103;
ObjCParser.RULE_assignment_operator = 104;
ObjCParser.RULE_conditional_expression = 105;
ObjCParser.RULE_constant_expression = 106;
ObjCParser.RULE_logical_or_expression = 107;
ObjCParser.RULE_logical_and_expression = 108;
ObjCParser.RULE_inclusive_or_expression = 109;
ObjCParser.RULE_exclusive_or_expression = 110;
ObjCParser.RULE_and_expression = 111;
ObjCParser.RULE_equality_expression = 112;
ObjCParser.RULE_relational_expression = 113;
ObjCParser.RULE_shift_expression = 114;
ObjCParser.RULE_additive_expression = 115;
ObjCParser.RULE_multiplicative_expression = 116;
ObjCParser.RULE_cast_expression = 117;
ObjCParser.RULE_unary_expression = 118;
ObjCParser.RULE_unary_operator = 119;
ObjCParser.RULE_postfix_expression = 120;
ObjCParser.RULE_argument_expression_list = 121;
ObjCParser.RULE_identifier = 122;
ObjCParser.RULE_constant = 123;

function Translation_unitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_translation_unit;
    return this;
}

Translation_unitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Translation_unitContext.prototype.constructor = Translation_unitContext;

Translation_unitContext.prototype.EOF = function() {
    return this.getToken(ObjCParser.EOF, 0);
};

Translation_unitContext.prototype.external_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(External_declarationContext);
    } else {
        return this.getTypedRuleContext(External_declarationContext,i);
    }
};

Translation_unitContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterTranslation_unit(this);
	}
};

Translation_unitContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitTranslation_unit(this);
	}
};




ObjCParser.Translation_unitContext = Translation_unitContext;

ObjCParser.prototype.translation_unit = function() {

    var localctx = new Translation_unitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, ObjCParser.RULE_translation_unit);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 249; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 248;
            this.external_declaration();
            this.state = 251; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(((((_la - 3)) & ~0x1f) == 0 && ((1 << (_la - 3)) & ((1 << (ObjCParser.CLASS - 3)) | (1 << (ObjCParser.IMPLEMENTATION - 3)) | (1 << (ObjCParser.INTERFACE - 3)) | (1 << (ObjCParser.PROTOCOL - 3)) | (1 << (ObjCParser.AUTO - 3)) | (1 << (ObjCParser.BYCOPY - 3)) | (1 << (ObjCParser.BYREF - 3)) | (1 << (ObjCParser.CHAR - 3)) | (1 << (ObjCParser.CONST - 3)))) !== 0) || ((((_la - 36)) & ~0x1f) == 0 && ((1 << (_la - 36)) & ((1 << (ObjCParser.DOUBLE - 36)) | (1 << (ObjCParser.ENUM - 36)) | (1 << (ObjCParser.EXTERN - 36)) | (1 << (ObjCParser.FLOAT - 36)) | (1 << (ObjCParser.ID - 36)) | (1 << (ObjCParser.IN - 36)) | (1 << (ObjCParser.INOUT - 36)) | (1 << (ObjCParser.INT - 36)) | (1 << (ObjCParser.LONG - 36)) | (1 << (ObjCParser.ONEWAY - 36)) | (1 << (ObjCParser.OUT - 36)) | (1 << (ObjCParser.REGISTER - 36)) | (1 << (ObjCParser.SHORT - 36)) | (1 << (ObjCParser.SIGNED - 36)) | (1 << (ObjCParser.STATIC - 36)) | (1 << (ObjCParser.STRUCT - 36)) | (1 << (ObjCParser.TYPEDEF - 36)) | (1 << (ObjCParser.UNION - 36)) | (1 << (ObjCParser.UNSIGNED - 36)) | (1 << (ObjCParser.VOID - 36)) | (1 << (ObjCParser.VOLATILE - 36)) | (1 << (ObjCParser.NS_OPTIONS - 36)) | (1 << (ObjCParser.NS_ENUM - 36)) | (1 << (ObjCParser.WWEAK - 36)))) !== 0) || ((((_la - 68)) & ~0x1f) == 0 && ((1 << (_la - 68)) & ((1 << (ObjCParser.WUNSAFE_UNRETAINED - 68)) | (1 << (ObjCParser.LPAREN - 68)) | (1 << (ObjCParser.MUL - 68)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.IMPORT - 125)) | (1 << (ObjCParser.INCLUDE - 125)) | (1 << (ObjCParser.COMMENT - 125)) | (1 << (ObjCParser.LINE_COMMENT - 125)))) !== 0));
        this.state = 253;
        this.match(ObjCParser.EOF);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function External_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_external_declaration;
    return this;
}

External_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
External_declarationContext.prototype.constructor = External_declarationContext;

External_declarationContext.prototype.COMMENT = function() {
    return this.getToken(ObjCParser.COMMENT, 0);
};

External_declarationContext.prototype.LINE_COMMENT = function() {
    return this.getToken(ObjCParser.LINE_COMMENT, 0);
};

External_declarationContext.prototype.preprocessor_declaration = function() {
    return this.getTypedRuleContext(Preprocessor_declarationContext,0);
};

External_declarationContext.prototype.function_definition = function() {
    return this.getTypedRuleContext(Function_definitionContext,0);
};

External_declarationContext.prototype.declaration = function() {
    return this.getTypedRuleContext(DeclarationContext,0);
};

External_declarationContext.prototype.class_interface = function() {
    return this.getTypedRuleContext(Class_interfaceContext,0);
};

External_declarationContext.prototype.class_implementation = function() {
    return this.getTypedRuleContext(Class_implementationContext,0);
};

External_declarationContext.prototype.category_interface = function() {
    return this.getTypedRuleContext(Category_interfaceContext,0);
};

External_declarationContext.prototype.category_implementation = function() {
    return this.getTypedRuleContext(Category_implementationContext,0);
};

External_declarationContext.prototype.protocol_declaration = function() {
    return this.getTypedRuleContext(Protocol_declarationContext,0);
};

External_declarationContext.prototype.protocol_declaration_list = function() {
    return this.getTypedRuleContext(Protocol_declaration_listContext,0);
};

External_declarationContext.prototype.class_declaration_list = function() {
    return this.getTypedRuleContext(Class_declaration_listContext,0);
};

External_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterExternal_declaration(this);
	}
};

External_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitExternal_declaration(this);
	}
};




ObjCParser.External_declarationContext = External_declarationContext;

ObjCParser.prototype.external_declaration = function() {

    var localctx = new External_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, ObjCParser.RULE_external_declaration);
    try {
        this.state = 267;
        var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 255;
            this.match(ObjCParser.COMMENT);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 256;
            this.match(ObjCParser.LINE_COMMENT);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 257;
            this.preprocessor_declaration();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 258;
            this.function_definition();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 259;
            this.declaration();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 260;
            this.class_interface();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 261;
            this.class_implementation();
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 262;
            this.category_interface();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 263;
            this.category_implementation();
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 264;
            this.protocol_declaration();
            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 265;
            this.protocol_declaration_list();
            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 266;
            this.class_declaration_list();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Preprocessor_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_preprocessor_declaration;
    return this;
}

Preprocessor_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Preprocessor_declarationContext.prototype.constructor = Preprocessor_declarationContext;

Preprocessor_declarationContext.prototype.IMPORT = function() {
    return this.getToken(ObjCParser.IMPORT, 0);
};

Preprocessor_declarationContext.prototype.INCLUDE = function() {
    return this.getToken(ObjCParser.INCLUDE, 0);
};

Preprocessor_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterPreprocessor_declaration(this);
	}
};

Preprocessor_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitPreprocessor_declaration(this);
	}
};




ObjCParser.Preprocessor_declarationContext = Preprocessor_declarationContext;

ObjCParser.prototype.preprocessor_declaration = function() {

    var localctx = new Preprocessor_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, ObjCParser.RULE_preprocessor_declaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 269;
        _la = this._input.LA(1);
        if(!(_la===ObjCParser.IMPORT || _la===ObjCParser.INCLUDE)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_interfaceContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_interface;
    return this;
}

Class_interfaceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_interfaceContext.prototype.constructor = Class_interfaceContext;

Class_interfaceContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

Class_interfaceContext.prototype.superclass_name = function() {
    return this.getTypedRuleContext(Superclass_nameContext,0);
};

Class_interfaceContext.prototype.protocol_reference_list = function() {
    return this.getTypedRuleContext(Protocol_reference_listContext,0);
};

Class_interfaceContext.prototype.instance_variables = function() {
    return this.getTypedRuleContext(Instance_variablesContext,0);
};

Class_interfaceContext.prototype.interface_declaration_list = function() {
    return this.getTypedRuleContext(Interface_declaration_listContext,0);
};

Class_interfaceContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_interface(this);
	}
};

Class_interfaceContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_interface(this);
	}
};




ObjCParser.Class_interfaceContext = Class_interfaceContext;

ObjCParser.prototype.class_interface = function() {

    var localctx = new Class_interfaceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, ObjCParser.RULE_class_interface);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 271;
        this.match(ObjCParser.INTERFACE);
        this.state = 272;
        this.class_name();
        this.state = 275;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COLON) {
            this.state = 273;
            this.match(ObjCParser.COLON);
            this.state = 274;
            this.superclass_name();
        }

        this.state = 278;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LT) {
            this.state = 277;
            this.protocol_reference_list();
        }

        this.state = 281;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LBRACE) {
            this.state = 280;
            this.instance_variables();
        }

        this.state = 284;
        _la = this._input.LA(1);
        if(((((_la - 14)) & ~0x1f) == 0 && ((1 << (_la - 14)) & ((1 << (ObjCParser.PROPERTY - 14)) | (1 << (ObjCParser.AUTO - 14)) | (1 << (ObjCParser.BYCOPY - 14)) | (1 << (ObjCParser.BYREF - 14)) | (1 << (ObjCParser.CHAR - 14)) | (1 << (ObjCParser.CONST - 14)) | (1 << (ObjCParser.DOUBLE - 14)) | (1 << (ObjCParser.ENUM - 14)) | (1 << (ObjCParser.EXTERN - 14)) | (1 << (ObjCParser.FLOAT - 14)) | (1 << (ObjCParser.ID - 14)) | (1 << (ObjCParser.IN - 14)) | (1 << (ObjCParser.INOUT - 14)))) !== 0) || ((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (ObjCParser.INT - 47)) | (1 << (ObjCParser.LONG - 47)) | (1 << (ObjCParser.ONEWAY - 47)) | (1 << (ObjCParser.OUT - 47)) | (1 << (ObjCParser.REGISTER - 47)) | (1 << (ObjCParser.SHORT - 47)) | (1 << (ObjCParser.SIGNED - 47)) | (1 << (ObjCParser.STATIC - 47)) | (1 << (ObjCParser.STRUCT - 47)) | (1 << (ObjCParser.TYPEDEF - 47)) | (1 << (ObjCParser.UNION - 47)) | (1 << (ObjCParser.UNSIGNED - 47)) | (1 << (ObjCParser.VOID - 47)) | (1 << (ObjCParser.VOLATILE - 47)) | (1 << (ObjCParser.NS_OPTIONS - 47)) | (1 << (ObjCParser.NS_ENUM - 47)) | (1 << (ObjCParser.WWEAK - 47)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 47)))) !== 0) || ((((_la - 95)) & ~0x1f) == 0 && ((1 << (_la - 95)) & ((1 << (ObjCParser.ADD - 95)) | (1 << (ObjCParser.SUB - 95)) | (1 << (ObjCParser.IDENTIFIER - 95)))) !== 0)) {
            this.state = 283;
            this.interface_declaration_list();
        }

        this.state = 286;
        this.match(ObjCParser.END);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Category_interfaceContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_category_interface;
    return this;
}

Category_interfaceContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Category_interfaceContext.prototype.constructor = Category_interfaceContext;

Category_interfaceContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

Category_interfaceContext.prototype.category_name = function() {
    return this.getTypedRuleContext(Category_nameContext,0);
};

Category_interfaceContext.prototype.protocol_reference_list = function() {
    return this.getTypedRuleContext(Protocol_reference_listContext,0);
};

Category_interfaceContext.prototype.instance_variables = function() {
    return this.getTypedRuleContext(Instance_variablesContext,0);
};

Category_interfaceContext.prototype.interface_declaration_list = function() {
    return this.getTypedRuleContext(Interface_declaration_listContext,0);
};

Category_interfaceContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCategory_interface(this);
	}
};

Category_interfaceContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCategory_interface(this);
	}
};




ObjCParser.Category_interfaceContext = Category_interfaceContext;

ObjCParser.prototype.category_interface = function() {

    var localctx = new Category_interfaceContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, ObjCParser.RULE_category_interface);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 288;
        this.match(ObjCParser.INTERFACE);
        this.state = 289;
        this.class_name();
        this.state = 290;
        this.match(ObjCParser.LPAREN);
        this.state = 292;
        _la = this._input.LA(1);
        if(_la===ObjCParser.IDENTIFIER) {
            this.state = 291;
            this.category_name();
        }

        this.state = 294;
        this.match(ObjCParser.RPAREN);
        this.state = 296;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LT) {
            this.state = 295;
            this.protocol_reference_list();
        }

        this.state = 299;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LBRACE) {
            this.state = 298;
            this.instance_variables();
        }

        this.state = 302;
        _la = this._input.LA(1);
        if(((((_la - 14)) & ~0x1f) == 0 && ((1 << (_la - 14)) & ((1 << (ObjCParser.PROPERTY - 14)) | (1 << (ObjCParser.AUTO - 14)) | (1 << (ObjCParser.BYCOPY - 14)) | (1 << (ObjCParser.BYREF - 14)) | (1 << (ObjCParser.CHAR - 14)) | (1 << (ObjCParser.CONST - 14)) | (1 << (ObjCParser.DOUBLE - 14)) | (1 << (ObjCParser.ENUM - 14)) | (1 << (ObjCParser.EXTERN - 14)) | (1 << (ObjCParser.FLOAT - 14)) | (1 << (ObjCParser.ID - 14)) | (1 << (ObjCParser.IN - 14)) | (1 << (ObjCParser.INOUT - 14)))) !== 0) || ((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (ObjCParser.INT - 47)) | (1 << (ObjCParser.LONG - 47)) | (1 << (ObjCParser.ONEWAY - 47)) | (1 << (ObjCParser.OUT - 47)) | (1 << (ObjCParser.REGISTER - 47)) | (1 << (ObjCParser.SHORT - 47)) | (1 << (ObjCParser.SIGNED - 47)) | (1 << (ObjCParser.STATIC - 47)) | (1 << (ObjCParser.STRUCT - 47)) | (1 << (ObjCParser.TYPEDEF - 47)) | (1 << (ObjCParser.UNION - 47)) | (1 << (ObjCParser.UNSIGNED - 47)) | (1 << (ObjCParser.VOID - 47)) | (1 << (ObjCParser.VOLATILE - 47)) | (1 << (ObjCParser.NS_OPTIONS - 47)) | (1 << (ObjCParser.NS_ENUM - 47)) | (1 << (ObjCParser.WWEAK - 47)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 47)))) !== 0) || ((((_la - 95)) & ~0x1f) == 0 && ((1 << (_la - 95)) & ((1 << (ObjCParser.ADD - 95)) | (1 << (ObjCParser.SUB - 95)) | (1 << (ObjCParser.IDENTIFIER - 95)))) !== 0)) {
            this.state = 301;
            this.interface_declaration_list();
        }

        this.state = 304;
        this.match(ObjCParser.END);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_implementationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_implementation;
    return this;
}

Class_implementationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_implementationContext.prototype.constructor = Class_implementationContext;

Class_implementationContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

Class_implementationContext.prototype.superclass_name = function() {
    return this.getTypedRuleContext(Superclass_nameContext,0);
};

Class_implementationContext.prototype.instance_variables = function() {
    return this.getTypedRuleContext(Instance_variablesContext,0);
};

Class_implementationContext.prototype.implementation_definition_list = function() {
    return this.getTypedRuleContext(Implementation_definition_listContext,0);
};

Class_implementationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_implementation(this);
	}
};

Class_implementationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_implementation(this);
	}
};




ObjCParser.Class_implementationContext = Class_implementationContext;

ObjCParser.prototype.class_implementation = function() {

    var localctx = new Class_implementationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, ObjCParser.RULE_class_implementation);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 306;
        this.match(ObjCParser.IMPLEMENTATION);

        this.state = 307;
        this.class_name();
        this.state = 310;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COLON) {
            this.state = 308;
            this.match(ObjCParser.COLON);
            this.state = 309;
            this.superclass_name();
        }

        this.state = 313;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LBRACE) {
            this.state = 312;
            this.instance_variables();
        }

        this.state = 316;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.DYNAMIC) | (1 << ObjCParser.SYNTHESIZE) | (1 << ObjCParser.AUTO) | (1 << ObjCParser.BYCOPY) | (1 << ObjCParser.BYREF) | (1 << ObjCParser.CHAR))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ObjCParser.CONST - 32)) | (1 << (ObjCParser.DOUBLE - 32)) | (1 << (ObjCParser.ENUM - 32)) | (1 << (ObjCParser.EXTERN - 32)) | (1 << (ObjCParser.FLOAT - 32)) | (1 << (ObjCParser.ID - 32)) | (1 << (ObjCParser.IN - 32)) | (1 << (ObjCParser.INOUT - 32)) | (1 << (ObjCParser.INT - 32)) | (1 << (ObjCParser.LONG - 32)) | (1 << (ObjCParser.ONEWAY - 32)) | (1 << (ObjCParser.OUT - 32)) | (1 << (ObjCParser.REGISTER - 32)) | (1 << (ObjCParser.SHORT - 32)) | (1 << (ObjCParser.SIGNED - 32)) | (1 << (ObjCParser.STATIC - 32)) | (1 << (ObjCParser.STRUCT - 32)) | (1 << (ObjCParser.TYPEDEF - 32)) | (1 << (ObjCParser.UNION - 32)) | (1 << (ObjCParser.UNSIGNED - 32)) | (1 << (ObjCParser.VOID - 32)) | (1 << (ObjCParser.VOLATILE - 32)))) !== 0) || ((((_la - 65)) & ~0x1f) == 0 && ((1 << (_la - 65)) & ((1 << (ObjCParser.NS_OPTIONS - 65)) | (1 << (ObjCParser.NS_ENUM - 65)) | (1 << (ObjCParser.WWEAK - 65)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParser.LPAREN - 65)) | (1 << (ObjCParser.ADD - 65)) | (1 << (ObjCParser.SUB - 65)))) !== 0) || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER) {
            this.state = 315;
            this.implementation_definition_list();
        }

        this.state = 318;
        this.match(ObjCParser.END);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Category_implementationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_category_implementation;
    return this;
}

Category_implementationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Category_implementationContext.prototype.constructor = Category_implementationContext;

Category_implementationContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

Category_implementationContext.prototype.category_name = function() {
    return this.getTypedRuleContext(Category_nameContext,0);
};

Category_implementationContext.prototype.implementation_definition_list = function() {
    return this.getTypedRuleContext(Implementation_definition_listContext,0);
};

Category_implementationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCategory_implementation(this);
	}
};

Category_implementationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCategory_implementation(this);
	}
};




ObjCParser.Category_implementationContext = Category_implementationContext;

ObjCParser.prototype.category_implementation = function() {

    var localctx = new Category_implementationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, ObjCParser.RULE_category_implementation);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 320;
        this.match(ObjCParser.IMPLEMENTATION);

        this.state = 321;
        this.class_name();
        this.state = 322;
        this.match(ObjCParser.LPAREN);
        this.state = 323;
        this.category_name();
        this.state = 324;
        this.match(ObjCParser.RPAREN);
        this.state = 326;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.DYNAMIC) | (1 << ObjCParser.SYNTHESIZE) | (1 << ObjCParser.AUTO) | (1 << ObjCParser.BYCOPY) | (1 << ObjCParser.BYREF) | (1 << ObjCParser.CHAR))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ObjCParser.CONST - 32)) | (1 << (ObjCParser.DOUBLE - 32)) | (1 << (ObjCParser.ENUM - 32)) | (1 << (ObjCParser.EXTERN - 32)) | (1 << (ObjCParser.FLOAT - 32)) | (1 << (ObjCParser.ID - 32)) | (1 << (ObjCParser.IN - 32)) | (1 << (ObjCParser.INOUT - 32)) | (1 << (ObjCParser.INT - 32)) | (1 << (ObjCParser.LONG - 32)) | (1 << (ObjCParser.ONEWAY - 32)) | (1 << (ObjCParser.OUT - 32)) | (1 << (ObjCParser.REGISTER - 32)) | (1 << (ObjCParser.SHORT - 32)) | (1 << (ObjCParser.SIGNED - 32)) | (1 << (ObjCParser.STATIC - 32)) | (1 << (ObjCParser.STRUCT - 32)) | (1 << (ObjCParser.TYPEDEF - 32)) | (1 << (ObjCParser.UNION - 32)) | (1 << (ObjCParser.UNSIGNED - 32)) | (1 << (ObjCParser.VOID - 32)) | (1 << (ObjCParser.VOLATILE - 32)))) !== 0) || ((((_la - 65)) & ~0x1f) == 0 && ((1 << (_la - 65)) & ((1 << (ObjCParser.NS_OPTIONS - 65)) | (1 << (ObjCParser.NS_ENUM - 65)) | (1 << (ObjCParser.WWEAK - 65)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParser.LPAREN - 65)) | (1 << (ObjCParser.ADD - 65)) | (1 << (ObjCParser.SUB - 65)))) !== 0) || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER) {
            this.state = 325;
            this.implementation_definition_list();
        }

        this.state = 328;
        this.match(ObjCParser.END);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_declaration;
    return this;
}

Protocol_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_declarationContext.prototype.constructor = Protocol_declarationContext;

Protocol_declarationContext.prototype.protocol_name = function() {
    return this.getTypedRuleContext(Protocol_nameContext,0);
};

Protocol_declarationContext.prototype.protocol_reference_list = function() {
    return this.getTypedRuleContext(Protocol_reference_listContext,0);
};

Protocol_declarationContext.prototype.interface_declaration_list = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Interface_declaration_listContext);
    } else {
        return this.getTypedRuleContext(Interface_declaration_listContext,i);
    }
};

Protocol_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_declaration(this);
	}
};

Protocol_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_declaration(this);
	}
};




ObjCParser.Protocol_declarationContext = Protocol_declarationContext;

ObjCParser.prototype.protocol_declaration = function() {

    var localctx = new Protocol_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, ObjCParser.RULE_protocol_declaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 330;
        this.match(ObjCParser.PROTOCOL);

        this.state = 331;
        this.protocol_name();
        this.state = 333;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LT) {
            this.state = 332;
            this.protocol_reference_list();
        }

        this.state = 336;
        var la_ = this._interp.adaptivePredict(this._input,15,this._ctx);
        if(la_===1) {
            this.state = 335;
            this.interface_declaration_list();

        }
        this.state = 339;
        _la = this._input.LA(1);
        if(_la===ObjCParser.OPTIONAL) {
            this.state = 338;
            this.match(ObjCParser.OPTIONAL);
        }

        this.state = 342;
        _la = this._input.LA(1);
        if(((((_la - 14)) & ~0x1f) == 0 && ((1 << (_la - 14)) & ((1 << (ObjCParser.PROPERTY - 14)) | (1 << (ObjCParser.AUTO - 14)) | (1 << (ObjCParser.BYCOPY - 14)) | (1 << (ObjCParser.BYREF - 14)) | (1 << (ObjCParser.CHAR - 14)) | (1 << (ObjCParser.CONST - 14)) | (1 << (ObjCParser.DOUBLE - 14)) | (1 << (ObjCParser.ENUM - 14)) | (1 << (ObjCParser.EXTERN - 14)) | (1 << (ObjCParser.FLOAT - 14)) | (1 << (ObjCParser.ID - 14)) | (1 << (ObjCParser.IN - 14)) | (1 << (ObjCParser.INOUT - 14)))) !== 0) || ((((_la - 47)) & ~0x1f) == 0 && ((1 << (_la - 47)) & ((1 << (ObjCParser.INT - 47)) | (1 << (ObjCParser.LONG - 47)) | (1 << (ObjCParser.ONEWAY - 47)) | (1 << (ObjCParser.OUT - 47)) | (1 << (ObjCParser.REGISTER - 47)) | (1 << (ObjCParser.SHORT - 47)) | (1 << (ObjCParser.SIGNED - 47)) | (1 << (ObjCParser.STATIC - 47)) | (1 << (ObjCParser.STRUCT - 47)) | (1 << (ObjCParser.TYPEDEF - 47)) | (1 << (ObjCParser.UNION - 47)) | (1 << (ObjCParser.UNSIGNED - 47)) | (1 << (ObjCParser.VOID - 47)) | (1 << (ObjCParser.VOLATILE - 47)) | (1 << (ObjCParser.NS_OPTIONS - 47)) | (1 << (ObjCParser.NS_ENUM - 47)) | (1 << (ObjCParser.WWEAK - 47)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 47)))) !== 0) || ((((_la - 95)) & ~0x1f) == 0 && ((1 << (_la - 95)) & ((1 << (ObjCParser.ADD - 95)) | (1 << (ObjCParser.SUB - 95)) | (1 << (ObjCParser.IDENTIFIER - 95)))) !== 0)) {
            this.state = 341;
            this.interface_declaration_list();
        }

        this.state = 344;
        this.match(ObjCParser.END);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_declaration_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_declaration_list;
    return this;
}

Protocol_declaration_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_declaration_listContext.prototype.constructor = Protocol_declaration_listContext;

Protocol_declaration_listContext.prototype.protocol_list = function() {
    return this.getTypedRuleContext(Protocol_listContext,0);
};

Protocol_declaration_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_declaration_list(this);
	}
};

Protocol_declaration_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_declaration_list(this);
	}
};




ObjCParser.Protocol_declaration_listContext = Protocol_declaration_listContext;

ObjCParser.prototype.protocol_declaration_list = function() {

    var localctx = new Protocol_declaration_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, ObjCParser.RULE_protocol_declaration_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 346;
        this.match(ObjCParser.PROTOCOL);
        this.state = 347;
        this.protocol_list();
        this.state = 348;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_declaration_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_declaration_list;
    return this;
}

Class_declaration_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_declaration_listContext.prototype.constructor = Class_declaration_listContext;

Class_declaration_listContext.prototype.class_list = function() {
    return this.getTypedRuleContext(Class_listContext,0);
};

Class_declaration_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_declaration_list(this);
	}
};

Class_declaration_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_declaration_list(this);
	}
};




ObjCParser.Class_declaration_listContext = Class_declaration_listContext;

ObjCParser.prototype.class_declaration_list = function() {

    var localctx = new Class_declaration_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, ObjCParser.RULE_class_declaration_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 350;
        this.match(ObjCParser.CLASS);
        this.state = 351;
        this.class_list();
        this.state = 352;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_list;
    return this;
}

Class_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_listContext.prototype.constructor = Class_listContext;

Class_listContext.prototype.class_name = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Class_nameContext);
    } else {
        return this.getTypedRuleContext(Class_nameContext,i);
    }
};

Class_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_list(this);
	}
};

Class_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_list(this);
	}
};




ObjCParser.Class_listContext = Class_listContext;

ObjCParser.prototype.class_list = function() {

    var localctx = new Class_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, ObjCParser.RULE_class_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 354;
        this.class_name();
        this.state = 359;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 355;
            this.match(ObjCParser.COMMA);
            this.state = 356;
            this.class_name();
            this.state = 361;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_reference_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_reference_list;
    return this;
}

Protocol_reference_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_reference_listContext.prototype.constructor = Protocol_reference_listContext;

Protocol_reference_listContext.prototype.protocol_list = function() {
    return this.getTypedRuleContext(Protocol_listContext,0);
};

Protocol_reference_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_reference_list(this);
	}
};

Protocol_reference_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_reference_list(this);
	}
};




ObjCParser.Protocol_reference_listContext = Protocol_reference_listContext;

ObjCParser.prototype.protocol_reference_list = function() {

    var localctx = new Protocol_reference_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, ObjCParser.RULE_protocol_reference_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 362;
        this.match(ObjCParser.LT);
        this.state = 363;
        this.protocol_list();
        this.state = 364;
        this.match(ObjCParser.GT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_list;
    return this;
}

Protocol_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_listContext.prototype.constructor = Protocol_listContext;

Protocol_listContext.prototype.protocol_name = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Protocol_nameContext);
    } else {
        return this.getTypedRuleContext(Protocol_nameContext,i);
    }
};

Protocol_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_list(this);
	}
};

Protocol_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_list(this);
	}
};




ObjCParser.Protocol_listContext = Protocol_listContext;

ObjCParser.prototype.protocol_list = function() {

    var localctx = new Protocol_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, ObjCParser.RULE_protocol_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 366;
        this.protocol_name();
        this.state = 371;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 367;
            this.match(ObjCParser.COMMA);
            this.state = 368;
            this.protocol_name();
            this.state = 373;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_declaration;
    return this;
}

Property_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_declarationContext.prototype.constructor = Property_declarationContext;

Property_declarationContext.prototype.struct_declaration = function() {
    return this.getTypedRuleContext(Struct_declarationContext,0);
};

Property_declarationContext.prototype.property_attributes_declaration = function() {
    return this.getTypedRuleContext(Property_attributes_declarationContext,0);
};

Property_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_declaration(this);
	}
};

Property_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_declaration(this);
	}
};




ObjCParser.Property_declarationContext = Property_declarationContext;

ObjCParser.prototype.property_declaration = function() {

    var localctx = new Property_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, ObjCParser.RULE_property_declaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 374;
        this.match(ObjCParser.PROPERTY);
        this.state = 376;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN) {
            this.state = 375;
            this.property_attributes_declaration();
        }

        this.state = 378;
        this.struct_declaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_attributes_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_attributes_declaration;
    return this;
}

Property_attributes_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_attributes_declarationContext.prototype.constructor = Property_attributes_declarationContext;

Property_attributes_declarationContext.prototype.property_attributes_list = function() {
    return this.getTypedRuleContext(Property_attributes_listContext,0);
};

Property_attributes_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_attributes_declaration(this);
	}
};

Property_attributes_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_attributes_declaration(this);
	}
};




ObjCParser.Property_attributes_declarationContext = Property_attributes_declarationContext;

ObjCParser.prototype.property_attributes_declaration = function() {

    var localctx = new Property_attributes_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, ObjCParser.RULE_property_attributes_declaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 380;
        this.match(ObjCParser.LPAREN);
        this.state = 381;
        this.property_attributes_list();
        this.state = 382;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_attributes_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_attributes_list;
    return this;
}

Property_attributes_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_attributes_listContext.prototype.constructor = Property_attributes_listContext;

Property_attributes_listContext.prototype.property_attribute = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Property_attributeContext);
    } else {
        return this.getTypedRuleContext(Property_attributeContext,i);
    }
};

Property_attributes_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_attributes_list(this);
	}
};

Property_attributes_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_attributes_list(this);
	}
};




ObjCParser.Property_attributes_listContext = Property_attributes_listContext;

ObjCParser.prototype.property_attributes_list = function() {

    var localctx = new Property_attributes_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, ObjCParser.RULE_property_attributes_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 384;
        this.property_attribute();
        this.state = 389;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 385;
            this.match(ObjCParser.COMMA);
            this.state = 386;
            this.property_attribute();
            this.state = 391;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_attributeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_attribute;
    return this;
}

Property_attributeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_attributeContext.prototype.constructor = Property_attributeContext;

Property_attributeContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Property_attributeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_attribute(this);
	}
};

Property_attributeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_attribute(this);
	}
};




ObjCParser.Property_attributeContext = Property_attributeContext;

ObjCParser.prototype.property_attribute = function() {

    var localctx = new Property_attributeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, ObjCParser.RULE_property_attribute);
    try {
        this.state = 408;
        switch(this._input.LA(1)) {
        case ObjCParser.NONATOMIC:
            this.enterOuterAlt(localctx, 1);
            this.state = 392;
            this.match(ObjCParser.NONATOMIC);
            break;
        case ObjCParser.ASSIGNPA:
            this.enterOuterAlt(localctx, 2);
            this.state = 393;
            this.match(ObjCParser.ASSIGNPA);
            break;
        case ObjCParser.WEAK:
            this.enterOuterAlt(localctx, 3);
            this.state = 394;
            this.match(ObjCParser.WEAK);
            break;
        case ObjCParser.STRONG:
            this.enterOuterAlt(localctx, 4);
            this.state = 395;
            this.match(ObjCParser.STRONG);
            break;
        case ObjCParser.RETAIN:
            this.enterOuterAlt(localctx, 5);
            this.state = 396;
            this.match(ObjCParser.RETAIN);
            break;
        case ObjCParser.READONLY:
            this.enterOuterAlt(localctx, 6);
            this.state = 397;
            this.match(ObjCParser.READONLY);
            break;
        case ObjCParser.READWRITE:
            this.enterOuterAlt(localctx, 7);
            this.state = 398;
            this.match(ObjCParser.READWRITE);
            break;
        case ObjCParser.RPAREN:
        case ObjCParser.COMMA:
            this.enterOuterAlt(localctx, 8);

            break;
        case ObjCParser.GETTER:
            this.enterOuterAlt(localctx, 9);
            this.state = 400;
            this.match(ObjCParser.GETTER);
            this.state = 401;
            this.match(ObjCParser.ASSIGN);
            this.state = 402;
            this.match(ObjCParser.IDENTIFIER);
            break;
        case ObjCParser.SETTER:
            this.enterOuterAlt(localctx, 10);
            this.state = 403;
            this.match(ObjCParser.SETTER);
            this.state = 404;
            this.match(ObjCParser.ASSIGN);
            this.state = 405;
            this.match(ObjCParser.IDENTIFIER);
            this.state = 406;
            this.match(ObjCParser.COLON);
            break;
        case ObjCParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 11);
            this.state = 407;
            this.match(ObjCParser.IDENTIFIER);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_name;
    return this;
}

Class_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_nameContext.prototype.constructor = Class_nameContext;

Class_nameContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Class_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_name(this);
	}
};

Class_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_name(this);
	}
};




ObjCParser.Class_nameContext = Class_nameContext;

ObjCParser.prototype.class_name = function() {

    var localctx = new Class_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, ObjCParser.RULE_class_name);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 410;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Superclass_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_superclass_name;
    return this;
}

Superclass_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Superclass_nameContext.prototype.constructor = Superclass_nameContext;

Superclass_nameContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Superclass_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSuperclass_name(this);
	}
};

Superclass_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSuperclass_name(this);
	}
};




ObjCParser.Superclass_nameContext = Superclass_nameContext;

ObjCParser.prototype.superclass_name = function() {

    var localctx = new Superclass_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, ObjCParser.RULE_superclass_name);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 412;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Category_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_category_name;
    return this;
}

Category_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Category_nameContext.prototype.constructor = Category_nameContext;

Category_nameContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Category_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCategory_name(this);
	}
};

Category_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCategory_name(this);
	}
};




ObjCParser.Category_nameContext = Category_nameContext;

ObjCParser.prototype.category_name = function() {

    var localctx = new Category_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, ObjCParser.RULE_category_name);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 414;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_name;
    return this;
}

Protocol_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_nameContext.prototype.constructor = Protocol_nameContext;

Protocol_nameContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Protocol_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_name(this);
	}
};

Protocol_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_name(this);
	}
};




ObjCParser.Protocol_nameContext = Protocol_nameContext;

ObjCParser.prototype.protocol_name = function() {

    var localctx = new Protocol_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 40, ObjCParser.RULE_protocol_name);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 416;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Instance_variablesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_instance_variables;
    return this;
}

Instance_variablesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Instance_variablesContext.prototype.constructor = Instance_variablesContext;

Instance_variablesContext.prototype.struct_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Struct_declarationContext);
    } else {
        return this.getTypedRuleContext(Struct_declarationContext,i);
    }
};

Instance_variablesContext.prototype.visibility_specification = function() {
    return this.getTypedRuleContext(Visibility_specificationContext,0);
};

Instance_variablesContext.prototype.instance_variables = function() {
    return this.getTypedRuleContext(Instance_variablesContext,0);
};

Instance_variablesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInstance_variables(this);
	}
};

Instance_variablesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInstance_variables(this);
	}
};




ObjCParser.Instance_variablesContext = Instance_variablesContext;

ObjCParser.prototype.instance_variables = function() {

    var localctx = new Instance_variablesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, ObjCParser.RULE_instance_variables);
    var _la = 0; // Token type
    try {
        this.state = 454;
        var la_ = this._interp.adaptivePredict(this._input,27,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 418;
            this.match(ObjCParser.LBRACE);
            this.state = 422;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.CHAR - 28)) | (1 << (ObjCParser.CONST - 28)) | (1 << (ObjCParser.DOUBLE - 28)) | (1 << (ObjCParser.ENUM - 28)) | (1 << (ObjCParser.FLOAT - 28)) | (1 << (ObjCParser.ID - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.INT - 28)) | (1 << (ObjCParser.LONG - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)) | (1 << (ObjCParser.SHORT - 28)) | (1 << (ObjCParser.SIGNED - 28)) | (1 << (ObjCParser.STRUCT - 28)))) !== 0) || ((((_la - 60)) & ~0x1f) == 0 && ((1 << (_la - 60)) & ((1 << (ObjCParser.UNION - 60)) | (1 << (ObjCParser.UNSIGNED - 60)) | (1 << (ObjCParser.VOID - 60)) | (1 << (ObjCParser.VOLATILE - 60)) | (1 << (ObjCParser.NS_OPTIONS - 60)) | (1 << (ObjCParser.NS_ENUM - 60)) | (1 << (ObjCParser.WWEAK - 60)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 60)))) !== 0) || _la===ObjCParser.IDENTIFIER) {
                this.state = 419;
                this.struct_declaration();
                this.state = 424;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 425;
            this.match(ObjCParser.RBRACE);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 426;
            this.match(ObjCParser.LBRACE);
            this.state = 427;
            this.visibility_specification();
            this.state = 429; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 428;
                this.struct_declaration();
                this.state = 431; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.CHAR - 28)) | (1 << (ObjCParser.CONST - 28)) | (1 << (ObjCParser.DOUBLE - 28)) | (1 << (ObjCParser.ENUM - 28)) | (1 << (ObjCParser.FLOAT - 28)) | (1 << (ObjCParser.ID - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.INT - 28)) | (1 << (ObjCParser.LONG - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)) | (1 << (ObjCParser.SHORT - 28)) | (1 << (ObjCParser.SIGNED - 28)) | (1 << (ObjCParser.STRUCT - 28)))) !== 0) || ((((_la - 60)) & ~0x1f) == 0 && ((1 << (_la - 60)) & ((1 << (ObjCParser.UNION - 60)) | (1 << (ObjCParser.UNSIGNED - 60)) | (1 << (ObjCParser.VOID - 60)) | (1 << (ObjCParser.VOLATILE - 60)) | (1 << (ObjCParser.NS_OPTIONS - 60)) | (1 << (ObjCParser.NS_ENUM - 60)) | (1 << (ObjCParser.WWEAK - 60)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 60)))) !== 0) || _la===ObjCParser.IDENTIFIER);
            this.state = 433;
            this.match(ObjCParser.RBRACE);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 435;
            this.match(ObjCParser.LBRACE);
            this.state = 437; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 436;
                this.struct_declaration();
                this.state = 439; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.CHAR - 28)) | (1 << (ObjCParser.CONST - 28)) | (1 << (ObjCParser.DOUBLE - 28)) | (1 << (ObjCParser.ENUM - 28)) | (1 << (ObjCParser.FLOAT - 28)) | (1 << (ObjCParser.ID - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.INT - 28)) | (1 << (ObjCParser.LONG - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)) | (1 << (ObjCParser.SHORT - 28)) | (1 << (ObjCParser.SIGNED - 28)) | (1 << (ObjCParser.STRUCT - 28)))) !== 0) || ((((_la - 60)) & ~0x1f) == 0 && ((1 << (_la - 60)) & ((1 << (ObjCParser.UNION - 60)) | (1 << (ObjCParser.UNSIGNED - 60)) | (1 << (ObjCParser.VOID - 60)) | (1 << (ObjCParser.VOLATILE - 60)) | (1 << (ObjCParser.NS_OPTIONS - 60)) | (1 << (ObjCParser.NS_ENUM - 60)) | (1 << (ObjCParser.WWEAK - 60)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 60)))) !== 0) || _la===ObjCParser.IDENTIFIER);
            this.state = 441;
            this.instance_variables();
            this.state = 442;
            this.match(ObjCParser.RBRACE);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 444;
            this.match(ObjCParser.LBRACE);
            this.state = 445;
            this.visibility_specification();
            this.state = 447; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 446;
                this.struct_declaration();
                this.state = 449; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.CHAR - 28)) | (1 << (ObjCParser.CONST - 28)) | (1 << (ObjCParser.DOUBLE - 28)) | (1 << (ObjCParser.ENUM - 28)) | (1 << (ObjCParser.FLOAT - 28)) | (1 << (ObjCParser.ID - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.INT - 28)) | (1 << (ObjCParser.LONG - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)) | (1 << (ObjCParser.SHORT - 28)) | (1 << (ObjCParser.SIGNED - 28)) | (1 << (ObjCParser.STRUCT - 28)))) !== 0) || ((((_la - 60)) & ~0x1f) == 0 && ((1 << (_la - 60)) & ((1 << (ObjCParser.UNION - 60)) | (1 << (ObjCParser.UNSIGNED - 60)) | (1 << (ObjCParser.VOID - 60)) | (1 << (ObjCParser.VOLATILE - 60)) | (1 << (ObjCParser.NS_OPTIONS - 60)) | (1 << (ObjCParser.NS_ENUM - 60)) | (1 << (ObjCParser.WWEAK - 60)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 60)))) !== 0) || _la===ObjCParser.IDENTIFIER);
            this.state = 451;
            this.instance_variables();
            this.state = 452;
            this.match(ObjCParser.RBRACE);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Visibility_specificationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_visibility_specification;
    return this;
}

Visibility_specificationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Visibility_specificationContext.prototype.constructor = Visibility_specificationContext;


Visibility_specificationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterVisibility_specification(this);
	}
};

Visibility_specificationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitVisibility_specification(this);
	}
};




ObjCParser.Visibility_specificationContext = Visibility_specificationContext;

ObjCParser.prototype.visibility_specification = function() {

    var localctx = new Visibility_specificationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, ObjCParser.RULE_visibility_specification);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 456;
        _la = this._input.LA(1);
        if(!((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.PACKAGE) | (1 << ObjCParser.PRIVATE) | (1 << ObjCParser.PROTECTED) | (1 << ObjCParser.PUBLIC))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Interface_declaration_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_interface_declaration_list;
    return this;
}

Interface_declaration_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Interface_declaration_listContext.prototype.constructor = Interface_declaration_listContext;

Interface_declaration_listContext.prototype.declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationContext);
    } else {
        return this.getTypedRuleContext(DeclarationContext,i);
    }
};

Interface_declaration_listContext.prototype.class_method_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Class_method_declarationContext);
    } else {
        return this.getTypedRuleContext(Class_method_declarationContext,i);
    }
};

Interface_declaration_listContext.prototype.instance_method_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Instance_method_declarationContext);
    } else {
        return this.getTypedRuleContext(Instance_method_declarationContext,i);
    }
};

Interface_declaration_listContext.prototype.property_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Property_declarationContext);
    } else {
        return this.getTypedRuleContext(Property_declarationContext,i);
    }
};

Interface_declaration_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInterface_declaration_list(this);
	}
};

Interface_declaration_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInterface_declaration_list(this);
	}
};




ObjCParser.Interface_declaration_listContext = Interface_declaration_listContext;

ObjCParser.prototype.interface_declaration_list = function() {

    var localctx = new Interface_declaration_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, ObjCParser.RULE_interface_declaration_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 462; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 462;
        		switch(this._input.LA(1)) {
        		case ObjCParser.AUTO:
        		case ObjCParser.BYCOPY:
        		case ObjCParser.BYREF:
        		case ObjCParser.CHAR:
        		case ObjCParser.CONST:
        		case ObjCParser.DOUBLE:
        		case ObjCParser.ENUM:
        		case ObjCParser.EXTERN:
        		case ObjCParser.FLOAT:
        		case ObjCParser.ID:
        		case ObjCParser.IN:
        		case ObjCParser.INOUT:
        		case ObjCParser.INT:
        		case ObjCParser.LONG:
        		case ObjCParser.ONEWAY:
        		case ObjCParser.OUT:
        		case ObjCParser.REGISTER:
        		case ObjCParser.SHORT:
        		case ObjCParser.SIGNED:
        		case ObjCParser.STATIC:
        		case ObjCParser.STRUCT:
        		case ObjCParser.TYPEDEF:
        		case ObjCParser.UNION:
        		case ObjCParser.UNSIGNED:
        		case ObjCParser.VOID:
        		case ObjCParser.VOLATILE:
        		case ObjCParser.NS_OPTIONS:
        		case ObjCParser.NS_ENUM:
        		case ObjCParser.WWEAK:
        		case ObjCParser.WUNSAFE_UNRETAINED:
        		case ObjCParser.IDENTIFIER:
        		    this.state = 458;
        		    this.declaration();
        		    break;
        		case ObjCParser.ADD:
        		    this.state = 459;
        		    this.class_method_declaration();
        		    break;
        		case ObjCParser.SUB:
        		    this.state = 460;
        		    this.instance_method_declaration();
        		    break;
        		case ObjCParser.PROPERTY:
        		    this.state = 461;
        		    this.property_declaration();
        		    break;
        		default:
        		    throw new antlr4.error.NoViableAltException(this);
        		}
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 464; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,29, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_method_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_method_declaration;
    return this;
}

Class_method_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_method_declarationContext.prototype.constructor = Class_method_declarationContext;

Class_method_declarationContext.prototype.method_declaration = function() {
    return this.getTypedRuleContext(Method_declarationContext,0);
};

Class_method_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_method_declaration(this);
	}
};

Class_method_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_method_declaration(this);
	}
};




ObjCParser.Class_method_declarationContext = Class_method_declarationContext;

ObjCParser.prototype.class_method_declaration = function() {

    var localctx = new Class_method_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 48, ObjCParser.RULE_class_method_declaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 466;
        this.match(ObjCParser.ADD);
        this.state = 467;
        this.method_declaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Instance_method_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_instance_method_declaration;
    return this;
}

Instance_method_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Instance_method_declarationContext.prototype.constructor = Instance_method_declarationContext;

Instance_method_declarationContext.prototype.method_declaration = function() {
    return this.getTypedRuleContext(Method_declarationContext,0);
};

Instance_method_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInstance_method_declaration(this);
	}
};

Instance_method_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInstance_method_declaration(this);
	}
};




ObjCParser.Instance_method_declarationContext = Instance_method_declarationContext;

ObjCParser.prototype.instance_method_declaration = function() {

    var localctx = new Instance_method_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, ObjCParser.RULE_instance_method_declaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 469;
        this.match(ObjCParser.SUB);
        this.state = 470;
        this.method_declaration();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Method_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_method_declaration;
    return this;
}

Method_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Method_declarationContext.prototype.constructor = Method_declarationContext;

Method_declarationContext.prototype.method_selector = function() {
    return this.getTypedRuleContext(Method_selectorContext,0);
};

Method_declarationContext.prototype.method_type = function() {
    return this.getTypedRuleContext(Method_typeContext,0);
};

Method_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMethod_declaration(this);
	}
};

Method_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMethod_declaration(this);
	}
};




ObjCParser.Method_declarationContext = Method_declarationContext;

ObjCParser.prototype.method_declaration = function() {

    var localctx = new Method_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, ObjCParser.RULE_method_declaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 473;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN) {
            this.state = 472;
            this.method_type();
        }

        this.state = 475;
        this.method_selector();
        this.state = 476;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Implementation_definition_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_implementation_definition_list;
    return this;
}

Implementation_definition_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Implementation_definition_listContext.prototype.constructor = Implementation_definition_listContext;

Implementation_definition_listContext.prototype.function_definition = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Function_definitionContext);
    } else {
        return this.getTypedRuleContext(Function_definitionContext,i);
    }
};

Implementation_definition_listContext.prototype.declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationContext);
    } else {
        return this.getTypedRuleContext(DeclarationContext,i);
    }
};

Implementation_definition_listContext.prototype.class_method_definition = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Class_method_definitionContext);
    } else {
        return this.getTypedRuleContext(Class_method_definitionContext,i);
    }
};

Implementation_definition_listContext.prototype.instance_method_definition = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Instance_method_definitionContext);
    } else {
        return this.getTypedRuleContext(Instance_method_definitionContext,i);
    }
};

Implementation_definition_listContext.prototype.property_implementation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Property_implementationContext);
    } else {
        return this.getTypedRuleContext(Property_implementationContext,i);
    }
};

Implementation_definition_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterImplementation_definition_list(this);
	}
};

Implementation_definition_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitImplementation_definition_list(this);
	}
};




ObjCParser.Implementation_definition_listContext = Implementation_definition_listContext;

ObjCParser.prototype.implementation_definition_list = function() {

    var localctx = new Implementation_definition_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, ObjCParser.RULE_implementation_definition_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 483; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 483;
            var la_ = this._interp.adaptivePredict(this._input,31,this._ctx);
            switch(la_) {
            case 1:
                this.state = 478;
                this.function_definition();
                break;

            case 2:
                this.state = 479;
                this.declaration();
                break;

            case 3:
                this.state = 480;
                this.class_method_definition();
                break;

            case 4:
                this.state = 481;
                this.instance_method_definition();
                break;

            case 5:
                this.state = 482;
                this.property_implementation();
                break;

            }
            this.state = 485; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.DYNAMIC) | (1 << ObjCParser.SYNTHESIZE) | (1 << ObjCParser.AUTO) | (1 << ObjCParser.BYCOPY) | (1 << ObjCParser.BYREF) | (1 << ObjCParser.CHAR))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ObjCParser.CONST - 32)) | (1 << (ObjCParser.DOUBLE - 32)) | (1 << (ObjCParser.ENUM - 32)) | (1 << (ObjCParser.EXTERN - 32)) | (1 << (ObjCParser.FLOAT - 32)) | (1 << (ObjCParser.ID - 32)) | (1 << (ObjCParser.IN - 32)) | (1 << (ObjCParser.INOUT - 32)) | (1 << (ObjCParser.INT - 32)) | (1 << (ObjCParser.LONG - 32)) | (1 << (ObjCParser.ONEWAY - 32)) | (1 << (ObjCParser.OUT - 32)) | (1 << (ObjCParser.REGISTER - 32)) | (1 << (ObjCParser.SHORT - 32)) | (1 << (ObjCParser.SIGNED - 32)) | (1 << (ObjCParser.STATIC - 32)) | (1 << (ObjCParser.STRUCT - 32)) | (1 << (ObjCParser.TYPEDEF - 32)) | (1 << (ObjCParser.UNION - 32)) | (1 << (ObjCParser.UNSIGNED - 32)) | (1 << (ObjCParser.VOID - 32)) | (1 << (ObjCParser.VOLATILE - 32)))) !== 0) || ((((_la - 65)) & ~0x1f) == 0 && ((1 << (_la - 65)) & ((1 << (ObjCParser.NS_OPTIONS - 65)) | (1 << (ObjCParser.NS_ENUM - 65)) | (1 << (ObjCParser.WWEAK - 65)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 65)) | (1 << (ObjCParser.LPAREN - 65)) | (1 << (ObjCParser.ADD - 65)) | (1 << (ObjCParser.SUB - 65)))) !== 0) || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Class_method_definitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_class_method_definition;
    return this;
}

Class_method_definitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Class_method_definitionContext.prototype.constructor = Class_method_definitionContext;

Class_method_definitionContext.prototype.method_definition = function() {
    return this.getTypedRuleContext(Method_definitionContext,0);
};

Class_method_definitionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterClass_method_definition(this);
	}
};

Class_method_definitionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitClass_method_definition(this);
	}
};




ObjCParser.Class_method_definitionContext = Class_method_definitionContext;

ObjCParser.prototype.class_method_definition = function() {

    var localctx = new Class_method_definitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, ObjCParser.RULE_class_method_definition);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 487;
        this.match(ObjCParser.ADD);
        this.state = 488;
        this.method_definition();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Instance_method_definitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_instance_method_definition;
    return this;
}

Instance_method_definitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Instance_method_definitionContext.prototype.constructor = Instance_method_definitionContext;

Instance_method_definitionContext.prototype.method_definition = function() {
    return this.getTypedRuleContext(Method_definitionContext,0);
};

Instance_method_definitionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInstance_method_definition(this);
	}
};

Instance_method_definitionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInstance_method_definition(this);
	}
};




ObjCParser.Instance_method_definitionContext = Instance_method_definitionContext;

ObjCParser.prototype.instance_method_definition = function() {

    var localctx = new Instance_method_definitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, ObjCParser.RULE_instance_method_definition);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 490;
        this.match(ObjCParser.SUB);
        this.state = 491;
        this.method_definition();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Method_definitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_method_definition;
    return this;
}

Method_definitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Method_definitionContext.prototype.constructor = Method_definitionContext;

Method_definitionContext.prototype.method_selector = function() {
    return this.getTypedRuleContext(Method_selectorContext,0);
};

Method_definitionContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Method_definitionContext.prototype.method_type = function() {
    return this.getTypedRuleContext(Method_typeContext,0);
};

Method_definitionContext.prototype.init_declarator_list = function() {
    return this.getTypedRuleContext(Init_declarator_listContext,0);
};

Method_definitionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMethod_definition(this);
	}
};

Method_definitionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMethod_definition(this);
	}
};




ObjCParser.Method_definitionContext = Method_definitionContext;

ObjCParser.prototype.method_definition = function() {

    var localctx = new Method_definitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, ObjCParser.RULE_method_definition);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 494;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN) {
            this.state = 493;
            this.method_type();
        }

        this.state = 496;
        this.method_selector();
        this.state = 498;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER) {
            this.state = 497;
            this.init_declarator_list();
        }

        this.state = 501;
        _la = this._input.LA(1);
        if(_la===ObjCParser.SEMI) {
            this.state = 500;
            this.match(ObjCParser.SEMI);
        }

        this.state = 503;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Method_selectorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_method_selector;
    return this;
}

Method_selectorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Method_selectorContext.prototype.constructor = Method_selectorContext;

Method_selectorContext.prototype.selector = function() {
    return this.getTypedRuleContext(SelectorContext,0);
};

Method_selectorContext.prototype.keyword_declarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Keyword_declaratorContext);
    } else {
        return this.getTypedRuleContext(Keyword_declaratorContext,i);
    }
};

Method_selectorContext.prototype.parameter_list = function() {
    return this.getTypedRuleContext(Parameter_listContext,0);
};

Method_selectorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMethod_selector(this);
	}
};

Method_selectorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMethod_selector(this);
	}
};




ObjCParser.Method_selectorContext = Method_selectorContext;

ObjCParser.prototype.method_selector = function() {

    var localctx = new Method_selectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, ObjCParser.RULE_method_selector);
    try {
        this.state = 514;
        var la_ = this._interp.adaptivePredict(this._input,38,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 505;
            this.selector();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 507; 
            this._errHandler.sync(this);
            var _alt = 1;
            do {
            	switch (_alt) {
            	case 1:
            		this.state = 506;
            		this.keyword_declarator();
            		break;
            	default:
            		throw new antlr4.error.NoViableAltException(this);
            	}
            	this.state = 509; 
            	this._errHandler.sync(this);
            	_alt = this._interp.adaptivePredict(this._input,36, this._ctx);
            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
            this.state = 512;
            var la_ = this._interp.adaptivePredict(this._input,37,this._ctx);
            if(la_===1) {
                this.state = 511;
                this.parameter_list();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Keyword_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_keyword_declarator;
    return this;
}

Keyword_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Keyword_declaratorContext.prototype.constructor = Keyword_declaratorContext;

Keyword_declaratorContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Keyword_declaratorContext.prototype.selector = function() {
    return this.getTypedRuleContext(SelectorContext,0);
};

Keyword_declaratorContext.prototype.method_type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Method_typeContext);
    } else {
        return this.getTypedRuleContext(Method_typeContext,i);
    }
};

Keyword_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterKeyword_declarator(this);
	}
};

Keyword_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitKeyword_declarator(this);
	}
};




ObjCParser.Keyword_declaratorContext = Keyword_declaratorContext;

ObjCParser.prototype.keyword_declarator = function() {

    var localctx = new Keyword_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, ObjCParser.RULE_keyword_declarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 517;
        _la = this._input.LA(1);
        if(_la===ObjCParser.IDENTIFIER) {
            this.state = 516;
            this.selector();
        }

        this.state = 519;
        this.match(ObjCParser.COLON);
        this.state = 523;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.LPAREN) {
            this.state = 520;
            this.method_type();
            this.state = 525;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 526;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SelectorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_selector;
    return this;
}

SelectorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SelectorContext.prototype.constructor = SelectorContext;

SelectorContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

SelectorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSelector(this);
	}
};

SelectorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSelector(this);
	}
};




ObjCParser.SelectorContext = SelectorContext;

ObjCParser.prototype.selector = function() {

    var localctx = new SelectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, ObjCParser.RULE_selector);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 528;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Method_typeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_method_type;
    return this;
}

Method_typeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Method_typeContext.prototype.constructor = Method_typeContext;

Method_typeContext.prototype.type_name = function() {
    return this.getTypedRuleContext(Type_nameContext,0);
};

Method_typeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMethod_type(this);
	}
};

Method_typeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMethod_type(this);
	}
};




ObjCParser.Method_typeContext = Method_typeContext;

ObjCParser.prototype.method_type = function() {

    var localctx = new Method_typeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, ObjCParser.RULE_method_type);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 530;
        this.match(ObjCParser.LPAREN);
        this.state = 531;
        this.type_name();
        this.state = 532;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_implementationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_implementation;
    return this;
}

Property_implementationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_implementationContext.prototype.constructor = Property_implementationContext;

Property_implementationContext.prototype.property_synthesize_list = function() {
    return this.getTypedRuleContext(Property_synthesize_listContext,0);
};

Property_implementationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_implementation(this);
	}
};

Property_implementationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_implementation(this);
	}
};




ObjCParser.Property_implementationContext = Property_implementationContext;

ObjCParser.prototype.property_implementation = function() {

    var localctx = new Property_implementationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, ObjCParser.RULE_property_implementation);
    try {
        this.state = 542;
        switch(this._input.LA(1)) {
        case ObjCParser.SYNTHESIZE:
            this.enterOuterAlt(localctx, 1);
            this.state = 534;
            this.match(ObjCParser.SYNTHESIZE);
            this.state = 535;
            this.property_synthesize_list();
            this.state = 536;
            this.match(ObjCParser.SEMI);
            break;
        case ObjCParser.DYNAMIC:
            this.enterOuterAlt(localctx, 2);
            this.state = 538;
            this.match(ObjCParser.DYNAMIC);
            this.state = 539;
            this.property_synthesize_list();
            this.state = 540;
            this.match(ObjCParser.SEMI);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_synthesize_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_synthesize_list;
    return this;
}

Property_synthesize_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_synthesize_listContext.prototype.constructor = Property_synthesize_listContext;

Property_synthesize_listContext.prototype.property_synthesize_item = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Property_synthesize_itemContext);
    } else {
        return this.getTypedRuleContext(Property_synthesize_itemContext,i);
    }
};

Property_synthesize_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_synthesize_list(this);
	}
};

Property_synthesize_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_synthesize_list(this);
	}
};




ObjCParser.Property_synthesize_listContext = Property_synthesize_listContext;

ObjCParser.prototype.property_synthesize_list = function() {

    var localctx = new Property_synthesize_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, ObjCParser.RULE_property_synthesize_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 544;
        this.property_synthesize_item();
        this.state = 549;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 545;
            this.match(ObjCParser.COMMA);
            this.state = 546;
            this.property_synthesize_item();
            this.state = 551;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Property_synthesize_itemContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_property_synthesize_item;
    return this;
}

Property_synthesize_itemContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Property_synthesize_itemContext.prototype.constructor = Property_synthesize_itemContext;

Property_synthesize_itemContext.prototype.IDENTIFIER = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ObjCParser.IDENTIFIER);
    } else {
        return this.getToken(ObjCParser.IDENTIFIER, i);
    }
};


Property_synthesize_itemContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProperty_synthesize_item(this);
	}
};

Property_synthesize_itemContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProperty_synthesize_item(this);
	}
};




ObjCParser.Property_synthesize_itemContext = Property_synthesize_itemContext;

ObjCParser.prototype.property_synthesize_item = function() {

    var localctx = new Property_synthesize_itemContext(this, this._ctx, this.state);
    this.enterRule(localctx, 74, ObjCParser.RULE_property_synthesize_item);
    try {
        this.state = 556;
        var la_ = this._interp.adaptivePredict(this._input,43,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 552;
            this.match(ObjCParser.IDENTIFIER);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 553;
            this.match(ObjCParser.IDENTIFIER);
            this.state = 554;
            this.match(ObjCParser.ASSIGN);
            this.state = 555;
            this.match(ObjCParser.IDENTIFIER);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Block_typeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_block_type;
    return this;
}

Block_typeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Block_typeContext.prototype.constructor = Block_typeContext;

Block_typeContext.prototype.type_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_specifierContext);
    } else {
        return this.getTypedRuleContext(Type_specifierContext,i);
    }
};

Block_typeContext.prototype.block_parameters = function() {
    return this.getTypedRuleContext(Block_parametersContext,0);
};

Block_typeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterBlock_type(this);
	}
};

Block_typeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitBlock_type(this);
	}
};




ObjCParser.Block_typeContext = Block_typeContext;

ObjCParser.prototype.block_type = function() {

    var localctx = new Block_typeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 76, ObjCParser.RULE_block_type);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 558;
        this.type_specifier();
        this.state = 559;
        this.match(ObjCParser.LPAREN);
        this.state = 560;
        this.match(ObjCParser.CARET);
        this.state = 562;
        _la = this._input.LA(1);
        if(((((_la - 31)) & ~0x1f) == 0 && ((1 << (_la - 31)) & ((1 << (ObjCParser.CHAR - 31)) | (1 << (ObjCParser.DOUBLE - 31)) | (1 << (ObjCParser.ENUM - 31)) | (1 << (ObjCParser.FLOAT - 31)) | (1 << (ObjCParser.ID - 31)) | (1 << (ObjCParser.INT - 31)) | (1 << (ObjCParser.LONG - 31)) | (1 << (ObjCParser.SHORT - 31)) | (1 << (ObjCParser.SIGNED - 31)) | (1 << (ObjCParser.STRUCT - 31)) | (1 << (ObjCParser.UNION - 31)) | (1 << (ObjCParser.UNSIGNED - 31)) | (1 << (ObjCParser.VOID - 31)))) !== 0) || _la===ObjCParser.NS_OPTIONS || _la===ObjCParser.NS_ENUM || _la===ObjCParser.IDENTIFIER) {
            this.state = 561;
            this.type_specifier();
        }

        this.state = 564;
        this.match(ObjCParser.RPAREN);
        this.state = 566;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN) {
            this.state = 565;
            this.block_parameters();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Type_specifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_type_specifier;
    return this;
}

Type_specifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Type_specifierContext.prototype.constructor = Type_specifierContext;

Type_specifierContext.prototype.protocol_reference_list = function() {
    return this.getTypedRuleContext(Protocol_reference_listContext,0);
};

Type_specifierContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

Type_specifierContext.prototype.struct_or_union_specifier = function() {
    return this.getTypedRuleContext(Struct_or_union_specifierContext,0);
};

Type_specifierContext.prototype.enum_specifier = function() {
    return this.getTypedRuleContext(Enum_specifierContext,0);
};

Type_specifierContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Type_specifierContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

Type_specifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterType_specifier(this);
	}
};

Type_specifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitType_specifier(this);
	}
};




ObjCParser.Type_specifierContext = Type_specifierContext;

ObjCParser.prototype.type_specifier = function() {

    var localctx = new Type_specifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 78, ObjCParser.RULE_type_specifier);
    var _la = 0; // Token type
    try {
        this.state = 590;
        var la_ = this._interp.adaptivePredict(this._input,48,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 568;
            this.match(ObjCParser.VOID);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 569;
            this.match(ObjCParser.CHAR);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 570;
            this.match(ObjCParser.SHORT);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 571;
            this.match(ObjCParser.INT);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 572;
            this.match(ObjCParser.LONG);
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 573;
            this.match(ObjCParser.FLOAT);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 574;
            this.match(ObjCParser.DOUBLE);
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 575;
            this.match(ObjCParser.SIGNED);
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 576;
            this.match(ObjCParser.UNSIGNED);
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 577;
            this.match(ObjCParser.ID);
            this.state = 579;
            _la = this._input.LA(1);
            if(_la===ObjCParser.LT) {
                this.state = 578;
                this.protocol_reference_list();
            }

            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 581;
            this.class_name();
            this.state = 583;
            _la = this._input.LA(1);
            if(_la===ObjCParser.LT) {
                this.state = 582;
                this.protocol_reference_list();
            }

            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 585;
            this.struct_or_union_specifier();
            break;

        case 13:
            this.enterOuterAlt(localctx, 13);
            this.state = 586;
            this.enum_specifier();
            break;

        case 14:
            this.enterOuterAlt(localctx, 14);
            this.state = 587;
            this.match(ObjCParser.IDENTIFIER);
            break;

        case 15:
            this.enterOuterAlt(localctx, 15);
            this.state = 588;
            this.match(ObjCParser.IDENTIFIER);
            this.state = 589;
            this.pointer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Type_qualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_type_qualifier;
    return this;
}

Type_qualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Type_qualifierContext.prototype.constructor = Type_qualifierContext;

Type_qualifierContext.prototype.protocol_qualifier = function() {
    return this.getTypedRuleContext(Protocol_qualifierContext,0);
};

Type_qualifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterType_qualifier(this);
	}
};

Type_qualifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitType_qualifier(this);
	}
};




ObjCParser.Type_qualifierContext = Type_qualifierContext;

ObjCParser.prototype.type_qualifier = function() {

    var localctx = new Type_qualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, ObjCParser.RULE_type_qualifier);
    try {
        this.state = 595;
        switch(this._input.LA(1)) {
        case ObjCParser.CONST:
            this.enterOuterAlt(localctx, 1);
            this.state = 592;
            this.match(ObjCParser.CONST);
            break;
        case ObjCParser.VOLATILE:
            this.enterOuterAlt(localctx, 2);
            this.state = 593;
            this.match(ObjCParser.VOLATILE);
            break;
        case ObjCParser.BYCOPY:
        case ObjCParser.BYREF:
        case ObjCParser.IN:
        case ObjCParser.INOUT:
        case ObjCParser.ONEWAY:
        case ObjCParser.OUT:
            this.enterOuterAlt(localctx, 3);
            this.state = 594;
            this.protocol_qualifier();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_qualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_qualifier;
    return this;
}

Protocol_qualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_qualifierContext.prototype.constructor = Protocol_qualifierContext;


Protocol_qualifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_qualifier(this);
	}
};

Protocol_qualifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_qualifier(this);
	}
};




ObjCParser.Protocol_qualifierContext = Protocol_qualifierContext;

ObjCParser.prototype.protocol_qualifier = function() {

    var localctx = new Protocol_qualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, ObjCParser.RULE_protocol_qualifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 597;
        _la = this._input.LA(1);
        if(!(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Primary_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_primary_expression;
    return this;
}

Primary_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Primary_expressionContext.prototype.constructor = Primary_expressionContext;

Primary_expressionContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Primary_expressionContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

Primary_expressionContext.prototype.STRING_LITERAL = function() {
    return this.getToken(ObjCParser.STRING_LITERAL, 0);
};

Primary_expressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

Primary_expressionContext.prototype.message_expression = function() {
    return this.getTypedRuleContext(Message_expressionContext,0);
};

Primary_expressionContext.prototype.selector_expression = function() {
    return this.getTypedRuleContext(Selector_expressionContext,0);
};

Primary_expressionContext.prototype.protocol_expression = function() {
    return this.getTypedRuleContext(Protocol_expressionContext,0);
};

Primary_expressionContext.prototype.encode_expression = function() {
    return this.getTypedRuleContext(Encode_expressionContext,0);
};

Primary_expressionContext.prototype.dictionary_expression = function() {
    return this.getTypedRuleContext(Dictionary_expressionContext,0);
};

Primary_expressionContext.prototype.array_expression = function() {
    return this.getTypedRuleContext(Array_expressionContext,0);
};

Primary_expressionContext.prototype.box_expression = function() {
    return this.getTypedRuleContext(Box_expressionContext,0);
};

Primary_expressionContext.prototype.block_expression = function() {
    return this.getTypedRuleContext(Block_expressionContext,0);
};

Primary_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterPrimary_expression(this);
	}
};

Primary_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitPrimary_expression(this);
	}
};




ObjCParser.Primary_expressionContext = Primary_expressionContext;

ObjCParser.prototype.primary_expression = function() {

    var localctx = new Primary_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, ObjCParser.RULE_primary_expression);
    try {
        this.state = 616;
        var la_ = this._interp.adaptivePredict(this._input,50,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 599;
            this.match(ObjCParser.IDENTIFIER);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 600;
            this.constant();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 601;
            this.match(ObjCParser.STRING_LITERAL);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 602;
            this.match(ObjCParser.LPAREN);
            this.state = 603;
            this.expression();
            this.state = 604;
            this.match(ObjCParser.RPAREN);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 606;
            this.match(ObjCParser.SELF);
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 607;
            this.match(ObjCParser.SUPER);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 608;
            this.message_expression();
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 609;
            this.selector_expression();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 610;
            this.protocol_expression();
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 611;
            this.encode_expression();
            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 612;
            this.dictionary_expression();
            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 613;
            this.array_expression();
            break;

        case 13:
            this.enterOuterAlt(localctx, 13);
            this.state = 614;
            this.box_expression();
            break;

        case 14:
            this.enterOuterAlt(localctx, 14);
            this.state = 615;
            this.block_expression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Dictionary_pairContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_dictionary_pair;
    return this;
}

Dictionary_pairContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Dictionary_pairContext.prototype.constructor = Dictionary_pairContext;

Dictionary_pairContext.prototype.postfix_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Postfix_expressionContext);
    } else {
        return this.getTypedRuleContext(Postfix_expressionContext,i);
    }
};

Dictionary_pairContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDictionary_pair(this);
	}
};

Dictionary_pairContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDictionary_pair(this);
	}
};




ObjCParser.Dictionary_pairContext = Dictionary_pairContext;

ObjCParser.prototype.dictionary_pair = function() {

    var localctx = new Dictionary_pairContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, ObjCParser.RULE_dictionary_pair);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 618;
        this.postfix_expression();
        this.state = 619;
        this.match(ObjCParser.COLON);
        this.state = 620;
        this.postfix_expression();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Dictionary_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_dictionary_expression;
    return this;
}

Dictionary_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Dictionary_expressionContext.prototype.constructor = Dictionary_expressionContext;

Dictionary_expressionContext.prototype.dictionary_pair = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Dictionary_pairContext);
    } else {
        return this.getTypedRuleContext(Dictionary_pairContext,i);
    }
};

Dictionary_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDictionary_expression(this);
	}
};

Dictionary_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDictionary_expression(this);
	}
};




ObjCParser.Dictionary_expressionContext = Dictionary_expressionContext;

ObjCParser.prototype.dictionary_expression = function() {

    var localctx = new Dictionary_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, ObjCParser.RULE_dictionary_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 622;
        this.match(ObjCParser.AT);
        this.state = 623;
        this.match(ObjCParser.LBRACE);
        this.state = 625;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (ObjCParser.LPAREN - 69)) | (1 << (ObjCParser.LBRACK - 69)) | (1 << (ObjCParser.AT - 69)))) !== 0) || ((((_la - 101)) & ~0x1f) == 0 && ((1 << (_la - 101)) & ((1 << (ObjCParser.CARET - 101)) | (1 << (ObjCParser.IDENTIFIER - 101)) | (1 << (ObjCParser.CHARACTER_LITERAL - 101)) | (1 << (ObjCParser.STRING_LITERAL - 101)) | (1 << (ObjCParser.HEX_LITERAL - 101)) | (1 << (ObjCParser.DECIMAL_LITERAL - 101)) | (1 << (ObjCParser.OCTAL_LITERAL - 101)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 101)))) !== 0)) {
            this.state = 624;
            this.dictionary_pair();
        }

        this.state = 631;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,52,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 627;
                this.match(ObjCParser.COMMA);
                this.state = 628;
                this.dictionary_pair(); 
            }
            this.state = 633;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,52,this._ctx);
        }

        this.state = 635;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COMMA) {
            this.state = 634;
            this.match(ObjCParser.COMMA);
        }

        this.state = 637;
        this.match(ObjCParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Array_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_array_expression;
    return this;
}

Array_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Array_expressionContext.prototype.constructor = Array_expressionContext;

Array_expressionContext.prototype.postfix_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Postfix_expressionContext);
    } else {
        return this.getTypedRuleContext(Postfix_expressionContext,i);
    }
};

Array_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterArray_expression(this);
	}
};

Array_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitArray_expression(this);
	}
};




ObjCParser.Array_expressionContext = Array_expressionContext;

ObjCParser.prototype.array_expression = function() {

    var localctx = new Array_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, ObjCParser.RULE_array_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 639;
        this.match(ObjCParser.AT);
        this.state = 640;
        this.match(ObjCParser.LBRACK);
        this.state = 642;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (ObjCParser.LPAREN - 69)) | (1 << (ObjCParser.LBRACK - 69)) | (1 << (ObjCParser.AT - 69)))) !== 0) || ((((_la - 101)) & ~0x1f) == 0 && ((1 << (_la - 101)) & ((1 << (ObjCParser.CARET - 101)) | (1 << (ObjCParser.IDENTIFIER - 101)) | (1 << (ObjCParser.CHARACTER_LITERAL - 101)) | (1 << (ObjCParser.STRING_LITERAL - 101)) | (1 << (ObjCParser.HEX_LITERAL - 101)) | (1 << (ObjCParser.DECIMAL_LITERAL - 101)) | (1 << (ObjCParser.OCTAL_LITERAL - 101)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 101)))) !== 0)) {
            this.state = 641;
            this.postfix_expression();
        }

        this.state = 648;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,55,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 644;
                this.match(ObjCParser.COMMA);
                this.state = 645;
                this.postfix_expression(); 
            }
            this.state = 650;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,55,this._ctx);
        }

        this.state = 652;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COMMA) {
            this.state = 651;
            this.match(ObjCParser.COMMA);
        }

        this.state = 654;
        this.match(ObjCParser.RBRACK);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Box_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_box_expression;
    return this;
}

Box_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Box_expressionContext.prototype.constructor = Box_expressionContext;

Box_expressionContext.prototype.postfix_expression = function() {
    return this.getTypedRuleContext(Postfix_expressionContext,0);
};

Box_expressionContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

Box_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterBox_expression(this);
	}
};

Box_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitBox_expression(this);
	}
};




ObjCParser.Box_expressionContext = Box_expressionContext;

ObjCParser.prototype.box_expression = function() {

    var localctx = new Box_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, ObjCParser.RULE_box_expression);
    try {
        this.state = 663;
        var la_ = this._interp.adaptivePredict(this._input,57,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 656;
            this.match(ObjCParser.AT);
            this.state = 657;
            this.match(ObjCParser.LPAREN);
            this.state = 658;
            this.postfix_expression();
            this.state = 659;
            this.match(ObjCParser.RPAREN);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 661;
            this.match(ObjCParser.AT);
            this.state = 662;
            this.constant();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Block_parametersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_block_parameters;
    return this;
}

Block_parametersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Block_parametersContext.prototype.constructor = Block_parametersContext;

Block_parametersContext.prototype.type_variable_declarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_variable_declaratorContext);
    } else {
        return this.getTypedRuleContext(Type_variable_declaratorContext,i);
    }
};

Block_parametersContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterBlock_parameters(this);
	}
};

Block_parametersContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitBlock_parameters(this);
	}
};




ObjCParser.Block_parametersContext = Block_parametersContext;

ObjCParser.prototype.block_parameters = function() {

    var localctx = new Block_parametersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, ObjCParser.RULE_block_parameters);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 665;
        this.match(ObjCParser.LPAREN);
        this.state = 668;
        var la_ = this._interp.adaptivePredict(this._input,58,this._ctx);
        if(la_===1) {
            this.state = 666;
            this.type_variable_declarator();

        } else if(la_===2) {
            this.state = 667;
            this.match(ObjCParser.VOID);

        }
        this.state = 674;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 670;
            this.match(ObjCParser.COMMA);
            this.state = 671;
            this.type_variable_declarator();
            this.state = 676;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 677;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Block_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_block_expression;
    return this;
}

Block_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Block_expressionContext.prototype.constructor = Block_expressionContext;

Block_expressionContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Block_expressionContext.prototype.type_specifier = function() {
    return this.getTypedRuleContext(Type_specifierContext,0);
};

Block_expressionContext.prototype.block_parameters = function() {
    return this.getTypedRuleContext(Block_parametersContext,0);
};

Block_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterBlock_expression(this);
	}
};

Block_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitBlock_expression(this);
	}
};




ObjCParser.Block_expressionContext = Block_expressionContext;

ObjCParser.prototype.block_expression = function() {

    var localctx = new Block_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, ObjCParser.RULE_block_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 679;
        this.match(ObjCParser.CARET);
        this.state = 681;
        _la = this._input.LA(1);
        if(((((_la - 31)) & ~0x1f) == 0 && ((1 << (_la - 31)) & ((1 << (ObjCParser.CHAR - 31)) | (1 << (ObjCParser.DOUBLE - 31)) | (1 << (ObjCParser.ENUM - 31)) | (1 << (ObjCParser.FLOAT - 31)) | (1 << (ObjCParser.ID - 31)) | (1 << (ObjCParser.INT - 31)) | (1 << (ObjCParser.LONG - 31)) | (1 << (ObjCParser.SHORT - 31)) | (1 << (ObjCParser.SIGNED - 31)) | (1 << (ObjCParser.STRUCT - 31)) | (1 << (ObjCParser.UNION - 31)) | (1 << (ObjCParser.UNSIGNED - 31)) | (1 << (ObjCParser.VOID - 31)))) !== 0) || _la===ObjCParser.NS_OPTIONS || _la===ObjCParser.NS_ENUM || _la===ObjCParser.IDENTIFIER) {
            this.state = 680;
            this.type_specifier();
        }

        this.state = 684;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN) {
            this.state = 683;
            this.block_parameters();
        }

        this.state = 686;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Message_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_message_expression;
    return this;
}

Message_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Message_expressionContext.prototype.constructor = Message_expressionContext;

Message_expressionContext.prototype.receiver = function() {
    return this.getTypedRuleContext(ReceiverContext,0);
};

Message_expressionContext.prototype.message_selector = function() {
    return this.getTypedRuleContext(Message_selectorContext,0);
};

Message_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMessage_expression(this);
	}
};

Message_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMessage_expression(this);
	}
};




ObjCParser.Message_expressionContext = Message_expressionContext;

ObjCParser.prototype.message_expression = function() {

    var localctx = new Message_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, ObjCParser.RULE_message_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 688;
        this.match(ObjCParser.LBRACK);
        this.state = 689;
        this.receiver();
        this.state = 690;
        this.message_selector();
        this.state = 691;
        this.match(ObjCParser.RBRACK);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ReceiverContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_receiver;
    return this;
}

ReceiverContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ReceiverContext.prototype.constructor = ReceiverContext;

ReceiverContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ReceiverContext.prototype.class_name = function() {
    return this.getTypedRuleContext(Class_nameContext,0);
};

ReceiverContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterReceiver(this);
	}
};

ReceiverContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitReceiver(this);
	}
};




ObjCParser.ReceiverContext = ReceiverContext;

ObjCParser.prototype.receiver = function() {

    var localctx = new ReceiverContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, ObjCParser.RULE_receiver);
    try {
        this.state = 696;
        var la_ = this._interp.adaptivePredict(this._input,62,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 693;
            this.expression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 694;
            this.class_name();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 695;
            this.match(ObjCParser.SUPER);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Message_selectorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_message_selector;
    return this;
}

Message_selectorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Message_selectorContext.prototype.constructor = Message_selectorContext;

Message_selectorContext.prototype.selector = function() {
    return this.getTypedRuleContext(SelectorContext,0);
};

Message_selectorContext.prototype.keyword_argument = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Keyword_argumentContext);
    } else {
        return this.getTypedRuleContext(Keyword_argumentContext,i);
    }
};

Message_selectorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMessage_selector(this);
	}
};

Message_selectorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMessage_selector(this);
	}
};




ObjCParser.Message_selectorContext = Message_selectorContext;

ObjCParser.prototype.message_selector = function() {

    var localctx = new Message_selectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, ObjCParser.RULE_message_selector);
    var _la = 0; // Token type
    try {
        this.state = 704;
        var la_ = this._interp.adaptivePredict(this._input,64,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 698;
            this.selector();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 700; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 699;
                this.keyword_argument();
                this.state = 702; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===ObjCParser.COLON || _la===ObjCParser.IDENTIFIER);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Keyword_argumentContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_keyword_argument;
    return this;
}

Keyword_argumentContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Keyword_argumentContext.prototype.constructor = Keyword_argumentContext;

Keyword_argumentContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

Keyword_argumentContext.prototype.selector = function() {
    return this.getTypedRuleContext(SelectorContext,0);
};

Keyword_argumentContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterKeyword_argument(this);
	}
};

Keyword_argumentContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitKeyword_argument(this);
	}
};




ObjCParser.Keyword_argumentContext = Keyword_argumentContext;

ObjCParser.prototype.keyword_argument = function() {

    var localctx = new Keyword_argumentContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, ObjCParser.RULE_keyword_argument);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 707;
        _la = this._input.LA(1);
        if(_la===ObjCParser.IDENTIFIER) {
            this.state = 706;
            this.selector();
        }

        this.state = 709;
        this.match(ObjCParser.COLON);
        this.state = 710;
        this.expression();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Selector_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_selector_expression;
    return this;
}

Selector_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Selector_expressionContext.prototype.constructor = Selector_expressionContext;

Selector_expressionContext.prototype.selector_name = function() {
    return this.getTypedRuleContext(Selector_nameContext,0);
};

Selector_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSelector_expression(this);
	}
};

Selector_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSelector_expression(this);
	}
};




ObjCParser.Selector_expressionContext = Selector_expressionContext;

ObjCParser.prototype.selector_expression = function() {

    var localctx = new Selector_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, ObjCParser.RULE_selector_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 712;
        this.match(ObjCParser.SELECTOR);
        this.state = 713;
        this.match(ObjCParser.LPAREN);
        this.state = 714;
        this.selector_name();
        this.state = 715;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Selector_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_selector_name;
    return this;
}

Selector_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Selector_nameContext.prototype.constructor = Selector_nameContext;

Selector_nameContext.prototype.selector = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SelectorContext);
    } else {
        return this.getTypedRuleContext(SelectorContext,i);
    }
};

Selector_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSelector_name(this);
	}
};

Selector_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSelector_name(this);
	}
};




ObjCParser.Selector_nameContext = Selector_nameContext;

ObjCParser.prototype.selector_name = function() {

    var localctx = new Selector_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, ObjCParser.RULE_selector_name);
    var _la = 0; // Token type
    try {
        this.state = 726;
        var la_ = this._interp.adaptivePredict(this._input,68,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 717;
            this.selector();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 722; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 719;
                _la = this._input.LA(1);
                if(_la===ObjCParser.IDENTIFIER) {
                    this.state = 718;
                    this.selector();
                }

                this.state = 721;
                this.match(ObjCParser.COLON);
                this.state = 724; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===ObjCParser.COLON || _la===ObjCParser.IDENTIFIER);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Protocol_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_protocol_expression;
    return this;
}

Protocol_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Protocol_expressionContext.prototype.constructor = Protocol_expressionContext;

Protocol_expressionContext.prototype.protocol_name = function() {
    return this.getTypedRuleContext(Protocol_nameContext,0);
};

Protocol_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterProtocol_expression(this);
	}
};

Protocol_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitProtocol_expression(this);
	}
};




ObjCParser.Protocol_expressionContext = Protocol_expressionContext;

ObjCParser.prototype.protocol_expression = function() {

    var localctx = new Protocol_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, ObjCParser.RULE_protocol_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 728;
        this.match(ObjCParser.PROTOCOL);
        this.state = 729;
        this.match(ObjCParser.LPAREN);
        this.state = 730;
        this.protocol_name();
        this.state = 731;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Encode_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_encode_expression;
    return this;
}

Encode_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Encode_expressionContext.prototype.constructor = Encode_expressionContext;

Encode_expressionContext.prototype.type_name = function() {
    return this.getTypedRuleContext(Type_nameContext,0);
};

Encode_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterEncode_expression(this);
	}
};

Encode_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitEncode_expression(this);
	}
};




ObjCParser.Encode_expressionContext = Encode_expressionContext;

ObjCParser.prototype.encode_expression = function() {

    var localctx = new Encode_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, ObjCParser.RULE_encode_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 733;
        this.match(ObjCParser.ENCODE);
        this.state = 734;
        this.match(ObjCParser.LPAREN);
        this.state = 735;
        this.type_name();
        this.state = 736;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Type_variable_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_type_variable_declarator;
    return this;
}

Type_variable_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Type_variable_declaratorContext.prototype.constructor = Type_variable_declaratorContext;

Type_variable_declaratorContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

Type_variable_declaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Type_variable_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterType_variable_declarator(this);
	}
};

Type_variable_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitType_variable_declarator(this);
	}
};




ObjCParser.Type_variable_declaratorContext = Type_variable_declaratorContext;

ObjCParser.prototype.type_variable_declarator = function() {

    var localctx = new Type_variable_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, ObjCParser.RULE_type_variable_declarator);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 738;
        this.declaration_specifiers();
        this.state = 739;
        this.declarator();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Try_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_try_statement;
    return this;
}

Try_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Try_statementContext.prototype.constructor = Try_statementContext;

Try_statementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Try_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterTry_statement(this);
	}
};

Try_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitTry_statement(this);
	}
};




ObjCParser.Try_statementContext = Try_statementContext;

ObjCParser.prototype.try_statement = function() {

    var localctx = new Try_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, ObjCParser.RULE_try_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 741;
        this.match(ObjCParser.TRY);
        this.state = 742;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Catch_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_catch_statement;
    return this;
}

Catch_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Catch_statementContext.prototype.constructor = Catch_statementContext;

Catch_statementContext.prototype.type_variable_declarator = function() {
    return this.getTypedRuleContext(Type_variable_declaratorContext,0);
};

Catch_statementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Catch_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCatch_statement(this);
	}
};

Catch_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCatch_statement(this);
	}
};




ObjCParser.Catch_statementContext = Catch_statementContext;

ObjCParser.prototype.catch_statement = function() {

    var localctx = new Catch_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 118, ObjCParser.RULE_catch_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 744;
        this.match(ObjCParser.CATCH);
        this.state = 745;
        this.match(ObjCParser.LPAREN);
        this.state = 746;
        this.type_variable_declarator();
        this.state = 747;
        this.match(ObjCParser.RPAREN);
        this.state = 748;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Finally_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_finally_statement;
    return this;
}

Finally_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Finally_statementContext.prototype.constructor = Finally_statementContext;

Finally_statementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Finally_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterFinally_statement(this);
	}
};

Finally_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitFinally_statement(this);
	}
};




ObjCParser.Finally_statementContext = Finally_statementContext;

ObjCParser.prototype.finally_statement = function() {

    var localctx = new Finally_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, ObjCParser.RULE_finally_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 750;
        this.match(ObjCParser.FINALLY);
        this.state = 751;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Throw_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_throw_statement;
    return this;
}

Throw_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Throw_statementContext.prototype.constructor = Throw_statementContext;

Throw_statementContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Throw_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterThrow_statement(this);
	}
};

Throw_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitThrow_statement(this);
	}
};




ObjCParser.Throw_statementContext = Throw_statementContext;

ObjCParser.prototype.throw_statement = function() {

    var localctx = new Throw_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, ObjCParser.RULE_throw_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 753;
        this.match(ObjCParser.THROW);
        this.state = 754;
        this.match(ObjCParser.LPAREN);
        this.state = 755;
        this.match(ObjCParser.IDENTIFIER);
        this.state = 756;
        this.match(ObjCParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Try_blockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_try_block;
    return this;
}

Try_blockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Try_blockContext.prototype.constructor = Try_blockContext;

Try_blockContext.prototype.try_statement = function() {
    return this.getTypedRuleContext(Try_statementContext,0);
};

Try_blockContext.prototype.catch_statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Catch_statementContext);
    } else {
        return this.getTypedRuleContext(Catch_statementContext,i);
    }
};

Try_blockContext.prototype.finally_statement = function() {
    return this.getTypedRuleContext(Finally_statementContext,0);
};

Try_blockContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterTry_block(this);
	}
};

Try_blockContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitTry_block(this);
	}
};




ObjCParser.Try_blockContext = Try_blockContext;

ObjCParser.prototype.try_block = function() {

    var localctx = new Try_blockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 124, ObjCParser.RULE_try_block);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 758;
        this.try_statement();
        this.state = 762;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.CATCH) {
            this.state = 759;
            this.catch_statement();
            this.state = 764;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 766;
        _la = this._input.LA(1);
        if(_la===ObjCParser.FINALLY) {
            this.state = 765;
            this.finally_statement();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Synchronized_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_synchronized_statement;
    return this;
}

Synchronized_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Synchronized_statementContext.prototype.constructor = Synchronized_statementContext;

Synchronized_statementContext.prototype.primary_expression = function() {
    return this.getTypedRuleContext(Primary_expressionContext,0);
};

Synchronized_statementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Synchronized_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSynchronized_statement(this);
	}
};

Synchronized_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSynchronized_statement(this);
	}
};




ObjCParser.Synchronized_statementContext = Synchronized_statementContext;

ObjCParser.prototype.synchronized_statement = function() {

    var localctx = new Synchronized_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, ObjCParser.RULE_synchronized_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 768;
        this.match(ObjCParser.SYNCHRONIZED);
        this.state = 769;
        this.match(ObjCParser.LPAREN);
        this.state = 770;
        this.primary_expression();
        this.state = 771;
        this.match(ObjCParser.RPAREN);
        this.state = 772;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Autorelease_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_autorelease_statement;
    return this;
}

Autorelease_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Autorelease_statementContext.prototype.constructor = Autorelease_statementContext;

Autorelease_statementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Autorelease_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAutorelease_statement(this);
	}
};

Autorelease_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAutorelease_statement(this);
	}
};




ObjCParser.Autorelease_statementContext = Autorelease_statementContext;

ObjCParser.prototype.autorelease_statement = function() {

    var localctx = new Autorelease_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, ObjCParser.RULE_autorelease_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 774;
        this.match(ObjCParser.AUTORELEASEPOOL);
        this.state = 775;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Function_definitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_function_definition;
    return this;
}

Function_definitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Function_definitionContext.prototype.constructor = Function_definitionContext;

Function_definitionContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Function_definitionContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

Function_definitionContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

Function_definitionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterFunction_definition(this);
	}
};

Function_definitionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitFunction_definition(this);
	}
};




ObjCParser.Function_definitionContext = Function_definitionContext;

ObjCParser.prototype.function_definition = function() {

    var localctx = new Function_definitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 130, ObjCParser.RULE_function_definition);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 778;
        var la_ = this._interp.adaptivePredict(this._input,71,this._ctx);
        if(la_===1) {
            this.state = 777;
            this.declaration_specifiers();

        }
        this.state = 780;
        this.declarator();
        this.state = 781;
        this.compound_statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_declaration;
    return this;
}

DeclarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclarationContext.prototype.constructor = DeclarationContext;

DeclarationContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

DeclarationContext.prototype.init_declarator_list = function() {
    return this.getTypedRuleContext(Init_declarator_listContext,0);
};

DeclarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDeclaration(this);
	}
};

DeclarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDeclaration(this);
	}
};




ObjCParser.DeclarationContext = DeclarationContext;

ObjCParser.prototype.declaration = function() {

    var localctx = new DeclarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 132, ObjCParser.RULE_declaration);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 783;
        this.declaration_specifiers();
        this.state = 785;
        _la = this._input.LA(1);
        if(_la===ObjCParser.LPAREN || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER) {
            this.state = 784;
            this.init_declarator_list();
        }

        this.state = 787;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Declaration_specifiersContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_declaration_specifiers;
    return this;
}

Declaration_specifiersContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Declaration_specifiersContext.prototype.constructor = Declaration_specifiersContext;

Declaration_specifiersContext.prototype.arc_behaviour_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Arc_behaviour_specifierContext);
    } else {
        return this.getTypedRuleContext(Arc_behaviour_specifierContext,i);
    }
};

Declaration_specifiersContext.prototype.storage_class_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Storage_class_specifierContext);
    } else {
        return this.getTypedRuleContext(Storage_class_specifierContext,i);
    }
};

Declaration_specifiersContext.prototype.type_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_specifierContext);
    } else {
        return this.getTypedRuleContext(Type_specifierContext,i);
    }
};

Declaration_specifiersContext.prototype.type_qualifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_qualifierContext);
    } else {
        return this.getTypedRuleContext(Type_qualifierContext,i);
    }
};

Declaration_specifiersContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDeclaration_specifiers(this);
	}
};

Declaration_specifiersContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDeclaration_specifiers(this);
	}
};




ObjCParser.Declaration_specifiersContext = Declaration_specifiersContext;

ObjCParser.prototype.declaration_specifiers = function() {

    var localctx = new Declaration_specifiersContext(this, this._ctx, this.state);
    this.enterRule(localctx, 134, ObjCParser.RULE_declaration_specifiers);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 793; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 793;
        		switch(this._input.LA(1)) {
        		case ObjCParser.WWEAK:
        		case ObjCParser.WUNSAFE_UNRETAINED:
        		    this.state = 789;
        		    this.arc_behaviour_specifier();
        		    break;
        		case ObjCParser.AUTO:
        		case ObjCParser.EXTERN:
        		case ObjCParser.REGISTER:
        		case ObjCParser.STATIC:
        		case ObjCParser.TYPEDEF:
        		    this.state = 790;
        		    this.storage_class_specifier();
        		    break;
        		case ObjCParser.CHAR:
        		case ObjCParser.DOUBLE:
        		case ObjCParser.ENUM:
        		case ObjCParser.FLOAT:
        		case ObjCParser.ID:
        		case ObjCParser.INT:
        		case ObjCParser.LONG:
        		case ObjCParser.SHORT:
        		case ObjCParser.SIGNED:
        		case ObjCParser.STRUCT:
        		case ObjCParser.UNION:
        		case ObjCParser.UNSIGNED:
        		case ObjCParser.VOID:
        		case ObjCParser.NS_OPTIONS:
        		case ObjCParser.NS_ENUM:
        		case ObjCParser.IDENTIFIER:
        		    this.state = 791;
        		    this.type_specifier();
        		    break;
        		case ObjCParser.BYCOPY:
        		case ObjCParser.BYREF:
        		case ObjCParser.CONST:
        		case ObjCParser.IN:
        		case ObjCParser.INOUT:
        		case ObjCParser.ONEWAY:
        		case ObjCParser.OUT:
        		case ObjCParser.VOLATILE:
        		    this.state = 792;
        		    this.type_qualifier();
        		    break;
        		default:
        		    throw new antlr4.error.NoViableAltException(this);
        		}
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 795; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,74, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Arc_behaviour_specifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_arc_behaviour_specifier;
    return this;
}

Arc_behaviour_specifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Arc_behaviour_specifierContext.prototype.constructor = Arc_behaviour_specifierContext;


Arc_behaviour_specifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterArc_behaviour_specifier(this);
	}
};

Arc_behaviour_specifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitArc_behaviour_specifier(this);
	}
};




ObjCParser.Arc_behaviour_specifierContext = Arc_behaviour_specifierContext;

ObjCParser.prototype.arc_behaviour_specifier = function() {

    var localctx = new Arc_behaviour_specifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, ObjCParser.RULE_arc_behaviour_specifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 797;
        _la = this._input.LA(1);
        if(!(_la===ObjCParser.WWEAK || _la===ObjCParser.WUNSAFE_UNRETAINED)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Storage_class_specifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_storage_class_specifier;
    return this;
}

Storage_class_specifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Storage_class_specifierContext.prototype.constructor = Storage_class_specifierContext;


Storage_class_specifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStorage_class_specifier(this);
	}
};

Storage_class_specifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStorage_class_specifier(this);
	}
};




ObjCParser.Storage_class_specifierContext = Storage_class_specifierContext;

ObjCParser.prototype.storage_class_specifier = function() {

    var localctx = new Storage_class_specifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, ObjCParser.RULE_storage_class_specifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 799;
        _la = this._input.LA(1);
        if(!(_la===ObjCParser.AUTO || ((((_la - 39)) & ~0x1f) == 0 && ((1 << (_la - 39)) & ((1 << (ObjCParser.EXTERN - 39)) | (1 << (ObjCParser.REGISTER - 39)) | (1 << (ObjCParser.STATIC - 39)) | (1 << (ObjCParser.TYPEDEF - 39)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Init_declarator_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_init_declarator_list;
    return this;
}

Init_declarator_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Init_declarator_listContext.prototype.constructor = Init_declarator_listContext;

Init_declarator_listContext.prototype.init_declarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Init_declaratorContext);
    } else {
        return this.getTypedRuleContext(Init_declaratorContext,i);
    }
};

Init_declarator_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInit_declarator_list(this);
	}
};

Init_declarator_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInit_declarator_list(this);
	}
};




ObjCParser.Init_declarator_listContext = Init_declarator_listContext;

ObjCParser.prototype.init_declarator_list = function() {

    var localctx = new Init_declarator_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, ObjCParser.RULE_init_declarator_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 801;
        this.init_declarator();
        this.state = 806;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 802;
            this.match(ObjCParser.COMMA);
            this.state = 803;
            this.init_declarator();
            this.state = 808;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Init_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_init_declarator;
    return this;
}

Init_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Init_declaratorContext.prototype.constructor = Init_declaratorContext;

Init_declaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Init_declaratorContext.prototype.initializer = function() {
    return this.getTypedRuleContext(InitializerContext,0);
};

Init_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInit_declarator(this);
	}
};

Init_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInit_declarator(this);
	}
};




ObjCParser.Init_declaratorContext = Init_declaratorContext;

ObjCParser.prototype.init_declarator = function() {

    var localctx = new Init_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, ObjCParser.RULE_init_declarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 809;
        this.declarator();
        this.state = 812;
        _la = this._input.LA(1);
        if(_la===ObjCParser.ASSIGN) {
            this.state = 810;
            this.match(ObjCParser.ASSIGN);
            this.state = 811;
            this.initializer();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Struct_or_union_specifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_struct_or_union_specifier;
    return this;
}

Struct_or_union_specifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Struct_or_union_specifierContext.prototype.constructor = Struct_or_union_specifierContext;

Struct_or_union_specifierContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

Struct_or_union_specifierContext.prototype.struct_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Struct_declarationContext);
    } else {
        return this.getTypedRuleContext(Struct_declarationContext,i);
    }
};

Struct_or_union_specifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStruct_or_union_specifier(this);
	}
};

Struct_or_union_specifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStruct_or_union_specifier(this);
	}
};




ObjCParser.Struct_or_union_specifierContext = Struct_or_union_specifierContext;

ObjCParser.prototype.struct_or_union_specifier = function() {

    var localctx = new Struct_or_union_specifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, ObjCParser.RULE_struct_or_union_specifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 814;
        _la = this._input.LA(1);
        if(!(_la===ObjCParser.STRUCT || _la===ObjCParser.UNION)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
        this.state = 827;
        var la_ = this._interp.adaptivePredict(this._input,79,this._ctx);
        switch(la_) {
        case 1:
            this.state = 815;
            this.match(ObjCParser.IDENTIFIER);
            break;

        case 2:
            this.state = 817;
            _la = this._input.LA(1);
            if(_la===ObjCParser.IDENTIFIER) {
                this.state = 816;
                this.match(ObjCParser.IDENTIFIER);
            }

            this.state = 819;
            this.match(ObjCParser.LBRACE);
            this.state = 821; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 820;
                this.struct_declaration();
                this.state = 823; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(((((_la - 28)) & ~0x1f) == 0 && ((1 << (_la - 28)) & ((1 << (ObjCParser.BYCOPY - 28)) | (1 << (ObjCParser.BYREF - 28)) | (1 << (ObjCParser.CHAR - 28)) | (1 << (ObjCParser.CONST - 28)) | (1 << (ObjCParser.DOUBLE - 28)) | (1 << (ObjCParser.ENUM - 28)) | (1 << (ObjCParser.FLOAT - 28)) | (1 << (ObjCParser.ID - 28)) | (1 << (ObjCParser.IN - 28)) | (1 << (ObjCParser.INOUT - 28)) | (1 << (ObjCParser.INT - 28)) | (1 << (ObjCParser.LONG - 28)) | (1 << (ObjCParser.ONEWAY - 28)) | (1 << (ObjCParser.OUT - 28)) | (1 << (ObjCParser.SHORT - 28)) | (1 << (ObjCParser.SIGNED - 28)) | (1 << (ObjCParser.STRUCT - 28)))) !== 0) || ((((_la - 60)) & ~0x1f) == 0 && ((1 << (_la - 60)) & ((1 << (ObjCParser.UNION - 60)) | (1 << (ObjCParser.UNSIGNED - 60)) | (1 << (ObjCParser.VOID - 60)) | (1 << (ObjCParser.VOLATILE - 60)) | (1 << (ObjCParser.NS_OPTIONS - 60)) | (1 << (ObjCParser.NS_ENUM - 60)) | (1 << (ObjCParser.WWEAK - 60)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 60)))) !== 0) || _la===ObjCParser.IDENTIFIER);
            this.state = 825;
            this.match(ObjCParser.RBRACE);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Struct_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_struct_declaration;
    return this;
}

Struct_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Struct_declarationContext.prototype.constructor = Struct_declarationContext;

Struct_declarationContext.prototype.specifier_qualifier_list = function() {
    return this.getTypedRuleContext(Specifier_qualifier_listContext,0);
};

Struct_declarationContext.prototype.struct_declarator_list = function() {
    return this.getTypedRuleContext(Struct_declarator_listContext,0);
};

Struct_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStruct_declaration(this);
	}
};

Struct_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStruct_declaration(this);
	}
};




ObjCParser.Struct_declarationContext = Struct_declarationContext;

ObjCParser.prototype.struct_declaration = function() {

    var localctx = new Struct_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 146, ObjCParser.RULE_struct_declaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 829;
        this.specifier_qualifier_list();
        this.state = 830;
        this.struct_declarator_list();
        this.state = 831;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Specifier_qualifier_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_specifier_qualifier_list;
    return this;
}

Specifier_qualifier_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Specifier_qualifier_listContext.prototype.constructor = Specifier_qualifier_listContext;

Specifier_qualifier_listContext.prototype.arc_behaviour_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Arc_behaviour_specifierContext);
    } else {
        return this.getTypedRuleContext(Arc_behaviour_specifierContext,i);
    }
};

Specifier_qualifier_listContext.prototype.type_specifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_specifierContext);
    } else {
        return this.getTypedRuleContext(Type_specifierContext,i);
    }
};

Specifier_qualifier_listContext.prototype.type_qualifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Type_qualifierContext);
    } else {
        return this.getTypedRuleContext(Type_qualifierContext,i);
    }
};

Specifier_qualifier_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSpecifier_qualifier_list(this);
	}
};

Specifier_qualifier_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSpecifier_qualifier_list(this);
	}
};




ObjCParser.Specifier_qualifier_listContext = Specifier_qualifier_listContext;

ObjCParser.prototype.specifier_qualifier_list = function() {

    var localctx = new Specifier_qualifier_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, ObjCParser.RULE_specifier_qualifier_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 836; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 836;
        		switch(this._input.LA(1)) {
        		case ObjCParser.WWEAK:
        		case ObjCParser.WUNSAFE_UNRETAINED:
        		    this.state = 833;
        		    this.arc_behaviour_specifier();
        		    break;
        		case ObjCParser.CHAR:
        		case ObjCParser.DOUBLE:
        		case ObjCParser.ENUM:
        		case ObjCParser.FLOAT:
        		case ObjCParser.ID:
        		case ObjCParser.INT:
        		case ObjCParser.LONG:
        		case ObjCParser.SHORT:
        		case ObjCParser.SIGNED:
        		case ObjCParser.STRUCT:
        		case ObjCParser.UNION:
        		case ObjCParser.UNSIGNED:
        		case ObjCParser.VOID:
        		case ObjCParser.NS_OPTIONS:
        		case ObjCParser.NS_ENUM:
        		case ObjCParser.IDENTIFIER:
        		    this.state = 834;
        		    this.type_specifier();
        		    break;
        		case ObjCParser.BYCOPY:
        		case ObjCParser.BYREF:
        		case ObjCParser.CONST:
        		case ObjCParser.IN:
        		case ObjCParser.INOUT:
        		case ObjCParser.ONEWAY:
        		case ObjCParser.OUT:
        		case ObjCParser.VOLATILE:
        		    this.state = 835;
        		    this.type_qualifier();
        		    break;
        		default:
        		    throw new antlr4.error.NoViableAltException(this);
        		}
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 838; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,81, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Struct_declarator_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_struct_declarator_list;
    return this;
}

Struct_declarator_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Struct_declarator_listContext.prototype.constructor = Struct_declarator_listContext;

Struct_declarator_listContext.prototype.struct_declarator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Struct_declaratorContext);
    } else {
        return this.getTypedRuleContext(Struct_declaratorContext,i);
    }
};

Struct_declarator_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStruct_declarator_list(this);
	}
};

Struct_declarator_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStruct_declarator_list(this);
	}
};




ObjCParser.Struct_declarator_listContext = Struct_declarator_listContext;

ObjCParser.prototype.struct_declarator_list = function() {

    var localctx = new Struct_declarator_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, ObjCParser.RULE_struct_declarator_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 840;
        this.struct_declarator();
        this.state = 845;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 841;
            this.match(ObjCParser.COMMA);
            this.state = 842;
            this.struct_declarator();
            this.state = 847;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Struct_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_struct_declarator;
    return this;
}

Struct_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Struct_declaratorContext.prototype.constructor = Struct_declaratorContext;

Struct_declaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Struct_declaratorContext.prototype.constant = function() {
    return this.getTypedRuleContext(ConstantContext,0);
};

Struct_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStruct_declarator(this);
	}
};

Struct_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStruct_declarator(this);
	}
};




ObjCParser.Struct_declaratorContext = Struct_declaratorContext;

ObjCParser.prototype.struct_declarator = function() {

    var localctx = new Struct_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, ObjCParser.RULE_struct_declarator);
    var _la = 0; // Token type
    try {
        this.state = 854;
        var la_ = this._interp.adaptivePredict(this._input,84,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 848;
            this.declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 850;
            _la = this._input.LA(1);
            if(_la===ObjCParser.LPAREN || _la===ObjCParser.MUL || _la===ObjCParser.IDENTIFIER) {
                this.state = 849;
                this.declarator();
            }

            this.state = 852;
            this.match(ObjCParser.COLON);
            this.state = 853;
            this.constant();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Enum_specifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_enum_specifier;
    return this;
}

Enum_specifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Enum_specifierContext.prototype.constructor = Enum_specifierContext;

Enum_specifierContext.prototype.identifier = function() {
    return this.getTypedRuleContext(IdentifierContext,0);
};

Enum_specifierContext.prototype.enumerator_list = function() {
    return this.getTypedRuleContext(Enumerator_listContext,0);
};

Enum_specifierContext.prototype.type_name = function() {
    return this.getTypedRuleContext(Type_nameContext,0);
};

Enum_specifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterEnum_specifier(this);
	}
};

Enum_specifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitEnum_specifier(this);
	}
};




ObjCParser.Enum_specifierContext = Enum_specifierContext;

ObjCParser.prototype.enum_specifier = function() {

    var localctx = new Enum_specifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, ObjCParser.RULE_enum_specifier);
    var _la = 0; // Token type
    try {
        this.state = 894;
        switch(this._input.LA(1)) {
        case ObjCParser.ENUM:
            this.enterOuterAlt(localctx, 1);
            this.state = 856;
            this.match(ObjCParser.ENUM);
            this.state = 859;
            _la = this._input.LA(1);
            if(_la===ObjCParser.COLON) {
                this.state = 857;
                this.match(ObjCParser.COLON);
                this.state = 858;
                this.type_name();
            }

            this.state = 872;
            switch(this._input.LA(1)) {
            case ObjCParser.IDENTIFIER:
                this.state = 861;
                this.identifier();
                this.state = 866;
                var la_ = this._interp.adaptivePredict(this._input,86,this._ctx);
                if(la_===1) {
                    this.state = 862;
                    this.match(ObjCParser.LBRACE);
                    this.state = 863;
                    this.enumerator_list();
                    this.state = 864;
                    this.match(ObjCParser.RBRACE);

                }
                break;
            case ObjCParser.LBRACE:
                this.state = 868;
                this.match(ObjCParser.LBRACE);
                this.state = 869;
                this.enumerator_list();
                this.state = 870;
                this.match(ObjCParser.RBRACE);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            break;
        case ObjCParser.NS_OPTIONS:
            this.enterOuterAlt(localctx, 2);
            this.state = 874;
            this.match(ObjCParser.NS_OPTIONS);
            this.state = 875;
            this.match(ObjCParser.LPAREN);
            this.state = 876;
            this.type_name();
            this.state = 877;
            this.match(ObjCParser.COMMA);
            this.state = 878;
            this.identifier();
            this.state = 879;
            this.match(ObjCParser.RPAREN);
            this.state = 880;
            this.match(ObjCParser.LBRACE);
            this.state = 881;
            this.enumerator_list();
            this.state = 882;
            this.match(ObjCParser.RBRACE);
            break;
        case ObjCParser.NS_ENUM:
            this.enterOuterAlt(localctx, 3);
            this.state = 884;
            this.match(ObjCParser.NS_ENUM);
            this.state = 885;
            this.match(ObjCParser.LPAREN);
            this.state = 886;
            this.type_name();
            this.state = 887;
            this.match(ObjCParser.COMMA);
            this.state = 888;
            this.identifier();
            this.state = 889;
            this.match(ObjCParser.RPAREN);
            this.state = 890;
            this.match(ObjCParser.LBRACE);
            this.state = 891;
            this.enumerator_list();
            this.state = 892;
            this.match(ObjCParser.RBRACE);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Enumerator_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_enumerator_list;
    return this;
}

Enumerator_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Enumerator_listContext.prototype.constructor = Enumerator_listContext;

Enumerator_listContext.prototype.enumerator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(EnumeratorContext);
    } else {
        return this.getTypedRuleContext(EnumeratorContext,i);
    }
};

Enumerator_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterEnumerator_list(this);
	}
};

Enumerator_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitEnumerator_list(this);
	}
};




ObjCParser.Enumerator_listContext = Enumerator_listContext;

ObjCParser.prototype.enumerator_list = function() {

    var localctx = new Enumerator_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, ObjCParser.RULE_enumerator_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 896;
        this.enumerator();
        this.state = 901;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,89,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 897;
                this.match(ObjCParser.COMMA);
                this.state = 898;
                this.enumerator(); 
            }
            this.state = 903;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,89,this._ctx);
        }

        this.state = 905;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COMMA) {
            this.state = 904;
            this.match(ObjCParser.COMMA);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumeratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_enumerator;
    return this;
}

EnumeratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorContext.prototype.constructor = EnumeratorContext;

EnumeratorContext.prototype.identifier = function() {
    return this.getTypedRuleContext(IdentifierContext,0);
};

EnumeratorContext.prototype.constant_expression = function() {
    return this.getTypedRuleContext(Constant_expressionContext,0);
};

EnumeratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterEnumerator(this);
	}
};

EnumeratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitEnumerator(this);
	}
};




ObjCParser.EnumeratorContext = EnumeratorContext;

ObjCParser.prototype.enumerator = function() {

    var localctx = new EnumeratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, ObjCParser.RULE_enumerator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 907;
        this.identifier();
        this.state = 910;
        _la = this._input.LA(1);
        if(_la===ObjCParser.ASSIGN) {
            this.state = 908;
            this.match(ObjCParser.ASSIGN);
            this.state = 909;
            this.constant_expression();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PointerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_pointer;
    return this;
}

PointerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PointerContext.prototype.constructor = PointerContext;

PointerContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

PointerContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

PointerContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterPointer(this);
	}
};

PointerContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitPointer(this);
	}
};




ObjCParser.PointerContext = PointerContext;

ObjCParser.prototype.pointer = function() {

    var localctx = new PointerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 160, ObjCParser.RULE_pointer);
    var _la = 0; // Token type
    try {
        this.state = 921;
        var la_ = this._interp.adaptivePredict(this._input,94,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 912;
            this.match(ObjCParser.MUL);
            this.state = 914;
            var la_ = this._interp.adaptivePredict(this._input,92,this._ctx);
            if(la_===1) {
                this.state = 913;
                this.declaration_specifiers();

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 916;
            this.match(ObjCParser.MUL);
            this.state = 918;
            _la = this._input.LA(1);
            if(((((_la - 25)) & ~0x1f) == 0 && ((1 << (_la - 25)) & ((1 << (ObjCParser.AUTO - 25)) | (1 << (ObjCParser.BYCOPY - 25)) | (1 << (ObjCParser.BYREF - 25)) | (1 << (ObjCParser.CHAR - 25)) | (1 << (ObjCParser.CONST - 25)) | (1 << (ObjCParser.DOUBLE - 25)) | (1 << (ObjCParser.ENUM - 25)) | (1 << (ObjCParser.EXTERN - 25)) | (1 << (ObjCParser.FLOAT - 25)) | (1 << (ObjCParser.ID - 25)) | (1 << (ObjCParser.IN - 25)) | (1 << (ObjCParser.INOUT - 25)) | (1 << (ObjCParser.INT - 25)) | (1 << (ObjCParser.LONG - 25)) | (1 << (ObjCParser.ONEWAY - 25)) | (1 << (ObjCParser.OUT - 25)) | (1 << (ObjCParser.REGISTER - 25)) | (1 << (ObjCParser.SHORT - 25)) | (1 << (ObjCParser.SIGNED - 25)) | (1 << (ObjCParser.STATIC - 25)))) !== 0) || ((((_la - 57)) & ~0x1f) == 0 && ((1 << (_la - 57)) & ((1 << (ObjCParser.STRUCT - 57)) | (1 << (ObjCParser.TYPEDEF - 57)) | (1 << (ObjCParser.UNION - 57)) | (1 << (ObjCParser.UNSIGNED - 57)) | (1 << (ObjCParser.VOID - 57)) | (1 << (ObjCParser.VOLATILE - 57)) | (1 << (ObjCParser.NS_OPTIONS - 57)) | (1 << (ObjCParser.NS_ENUM - 57)) | (1 << (ObjCParser.WWEAK - 57)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 57)))) !== 0) || _la===ObjCParser.IDENTIFIER) {
                this.state = 917;
                this.declaration_specifiers();
            }

            this.state = 920;
            this.pointer();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DeclaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_declarator;
    return this;
}

DeclaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DeclaratorContext.prototype.constructor = DeclaratorContext;

DeclaratorContext.prototype.direct_declarator = function() {
    return this.getTypedRuleContext(Direct_declaratorContext,0);
};

DeclaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

DeclaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDeclarator(this);
	}
};

DeclaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDeclarator(this);
	}
};




ObjCParser.DeclaratorContext = DeclaratorContext;

ObjCParser.prototype.declarator = function() {

    var localctx = new DeclaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, ObjCParser.RULE_declarator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 924;
        _la = this._input.LA(1);
        if(_la===ObjCParser.MUL) {
            this.state = 923;
            this.pointer();
        }

        this.state = 926;
        this.direct_declarator();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Direct_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_direct_declarator;
    return this;
}

Direct_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Direct_declaratorContext.prototype.constructor = Direct_declaratorContext;

Direct_declaratorContext.prototype.identifier = function() {
    return this.getTypedRuleContext(IdentifierContext,0);
};

Direct_declaratorContext.prototype.declarator_suffix = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Declarator_suffixContext);
    } else {
        return this.getTypedRuleContext(Declarator_suffixContext,i);
    }
};

Direct_declaratorContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Direct_declaratorContext.prototype.block_parameters = function() {
    return this.getTypedRuleContext(Block_parametersContext,0);
};

Direct_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDirect_declarator(this);
	}
};

Direct_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDirect_declarator(this);
	}
};




ObjCParser.Direct_declaratorContext = Direct_declaratorContext;

ObjCParser.prototype.direct_declarator = function() {

    var localctx = new Direct_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, ObjCParser.RULE_direct_declarator);
    var _la = 0; // Token type
    try {
        this.state = 951;
        var la_ = this._interp.adaptivePredict(this._input,99,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 928;
            this.identifier();
            this.state = 932;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,96,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 929;
                    this.declarator_suffix(); 
                }
                this.state = 934;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,96,this._ctx);
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 935;
            this.match(ObjCParser.LPAREN);
            this.state = 936;
            this.declarator();
            this.state = 937;
            this.match(ObjCParser.RPAREN);
            this.state = 941;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,97,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 938;
                    this.declarator_suffix(); 
                }
                this.state = 943;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,97,this._ctx);
            }

            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 944;
            this.match(ObjCParser.LPAREN);
            this.state = 945;
            this.match(ObjCParser.CARET);
            this.state = 947;
            _la = this._input.LA(1);
            if(_la===ObjCParser.IDENTIFIER) {
                this.state = 946;
                this.identifier();
            }

            this.state = 949;
            this.match(ObjCParser.RPAREN);
            this.state = 950;
            this.block_parameters();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Declarator_suffixContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_declarator_suffix;
    return this;
}

Declarator_suffixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Declarator_suffixContext.prototype.constructor = Declarator_suffixContext;

Declarator_suffixContext.prototype.constant_expression = function() {
    return this.getTypedRuleContext(Constant_expressionContext,0);
};

Declarator_suffixContext.prototype.parameter_list = function() {
    return this.getTypedRuleContext(Parameter_listContext,0);
};

Declarator_suffixContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDeclarator_suffix(this);
	}
};

Declarator_suffixContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDeclarator_suffix(this);
	}
};




ObjCParser.Declarator_suffixContext = Declarator_suffixContext;

ObjCParser.prototype.declarator_suffix = function() {

    var localctx = new Declarator_suffixContext(this, this._ctx, this.state);
    this.enterRule(localctx, 166, ObjCParser.RULE_declarator_suffix);
    var _la = 0; // Token type
    try {
        this.state = 963;
        switch(this._input.LA(1)) {
        case ObjCParser.LBRACK:
            this.enterOuterAlt(localctx, 1);
            this.state = 953;
            this.match(ObjCParser.LBRACK);
            this.state = 955;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
                this.state = 954;
                this.constant_expression();
            }

            this.state = 957;
            this.match(ObjCParser.RBRACK);
            break;
        case ObjCParser.LPAREN:
            this.enterOuterAlt(localctx, 2);
            this.state = 958;
            this.match(ObjCParser.LPAREN);
            this.state = 960;
            _la = this._input.LA(1);
            if(((((_la - 25)) & ~0x1f) == 0 && ((1 << (_la - 25)) & ((1 << (ObjCParser.AUTO - 25)) | (1 << (ObjCParser.BYCOPY - 25)) | (1 << (ObjCParser.BYREF - 25)) | (1 << (ObjCParser.CHAR - 25)) | (1 << (ObjCParser.CONST - 25)) | (1 << (ObjCParser.DOUBLE - 25)) | (1 << (ObjCParser.ENUM - 25)) | (1 << (ObjCParser.EXTERN - 25)) | (1 << (ObjCParser.FLOAT - 25)) | (1 << (ObjCParser.ID - 25)) | (1 << (ObjCParser.IN - 25)) | (1 << (ObjCParser.INOUT - 25)) | (1 << (ObjCParser.INT - 25)) | (1 << (ObjCParser.LONG - 25)) | (1 << (ObjCParser.ONEWAY - 25)) | (1 << (ObjCParser.OUT - 25)) | (1 << (ObjCParser.REGISTER - 25)) | (1 << (ObjCParser.SHORT - 25)) | (1 << (ObjCParser.SIGNED - 25)) | (1 << (ObjCParser.STATIC - 25)))) !== 0) || ((((_la - 57)) & ~0x1f) == 0 && ((1 << (_la - 57)) & ((1 << (ObjCParser.STRUCT - 57)) | (1 << (ObjCParser.TYPEDEF - 57)) | (1 << (ObjCParser.UNION - 57)) | (1 << (ObjCParser.UNSIGNED - 57)) | (1 << (ObjCParser.VOID - 57)) | (1 << (ObjCParser.VOLATILE - 57)) | (1 << (ObjCParser.NS_OPTIONS - 57)) | (1 << (ObjCParser.NS_ENUM - 57)) | (1 << (ObjCParser.WWEAK - 57)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 57)))) !== 0) || _la===ObjCParser.IDENTIFIER) {
                this.state = 959;
                this.parameter_list();
            }

            this.state = 962;
            this.match(ObjCParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Parameter_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_parameter_list;
    return this;
}

Parameter_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Parameter_listContext.prototype.constructor = Parameter_listContext;

Parameter_listContext.prototype.parameter_declaration_list = function() {
    return this.getTypedRuleContext(Parameter_declaration_listContext,0);
};

Parameter_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterParameter_list(this);
	}
};

Parameter_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitParameter_list(this);
	}
};




ObjCParser.Parameter_listContext = Parameter_listContext;

ObjCParser.prototype.parameter_list = function() {

    var localctx = new Parameter_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, ObjCParser.RULE_parameter_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 965;
        this.parameter_declaration_list();
        this.state = 968;
        _la = this._input.LA(1);
        if(_la===ObjCParser.COMMA) {
            this.state = 966;
            this.match(ObjCParser.COMMA);
            this.state = 967;
            this.match(ObjCParser.ELIPSIS);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Parameter_declarationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_parameter_declaration;
    return this;
}

Parameter_declarationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Parameter_declarationContext.prototype.constructor = Parameter_declarationContext;

Parameter_declarationContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

Parameter_declarationContext.prototype.abstract_declarator = function() {
    return this.getTypedRuleContext(Abstract_declaratorContext,0);
};

Parameter_declarationContext.prototype.declarator = function() {
    return this.getTypedRuleContext(DeclaratorContext,0);
};

Parameter_declarationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterParameter_declaration(this);
	}
};

Parameter_declarationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitParameter_declaration(this);
	}
};




ObjCParser.Parameter_declarationContext = Parameter_declarationContext;

ObjCParser.prototype.parameter_declaration = function() {

    var localctx = new Parameter_declarationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, ObjCParser.RULE_parameter_declaration);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 970;
        this.declaration_specifiers();
        this.state = 975;
        var la_ = this._interp.adaptivePredict(this._input,105,this._ctx);
        switch(la_) {
        case 1:
            this.state = 972;
            var la_ = this._interp.adaptivePredict(this._input,104,this._ctx);
            if(la_===1) {
                this.state = 971;
                this.declarator();

            }
            break;

        case 2:
            this.state = 974;
            this.abstract_declarator();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InitializerContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_initializer;
    return this;
}

InitializerContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitializerContext.prototype.constructor = InitializerContext;

InitializerContext.prototype.assignment_expression = function() {
    return this.getTypedRuleContext(Assignment_expressionContext,0);
};

InitializerContext.prototype.initializer = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(InitializerContext);
    } else {
        return this.getTypedRuleContext(InitializerContext,i);
    }
};

InitializerContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInitializer(this);
	}
};

InitializerContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInitializer(this);
	}
};




ObjCParser.InitializerContext = InitializerContext;

ObjCParser.prototype.initializer = function() {

    var localctx = new InitializerContext(this, this._ctx, this.state);
    this.enterRule(localctx, 172, ObjCParser.RULE_initializer);
    var _la = 0; // Token type
    try {
        this.state = 992;
        switch(this._input.LA(1)) {
        case ObjCParser.ENCODE:
        case ObjCParser.PROTOCOL:
        case ObjCParser.SELECTOR:
        case ObjCParser.SUPER:
        case ObjCParser.SELF:
        case ObjCParser.SIZEOF:
        case ObjCParser.LPAREN:
        case ObjCParser.LBRACK:
        case ObjCParser.AT:
        case ObjCParser.BANG:
        case ObjCParser.TILDE:
        case ObjCParser.INC:
        case ObjCParser.DEC:
        case ObjCParser.SUB:
        case ObjCParser.MUL:
        case ObjCParser.BITAND:
        case ObjCParser.CARET:
        case ObjCParser.IDENTIFIER:
        case ObjCParser.CHARACTER_LITERAL:
        case ObjCParser.STRING_LITERAL:
        case ObjCParser.HEX_LITERAL:
        case ObjCParser.DECIMAL_LITERAL:
        case ObjCParser.OCTAL_LITERAL:
        case ObjCParser.FLOATING_POINT_LITERAL:
            this.enterOuterAlt(localctx, 1);
            this.state = 977;
            this.assignment_expression();
            break;
        case ObjCParser.LBRACE:
            this.enterOuterAlt(localctx, 2);
            this.state = 978;
            this.match(ObjCParser.LBRACE);
            this.state = 979;
            this.initializer();
            this.state = 984;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,106,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 980;
                    this.match(ObjCParser.COMMA);
                    this.state = 981;
                    this.initializer(); 
                }
                this.state = 986;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,106,this._ctx);
            }

            this.state = 988;
            _la = this._input.LA(1);
            if(_la===ObjCParser.COMMA) {
                this.state = 987;
                this.match(ObjCParser.COMMA);
            }

            this.state = 990;
            this.match(ObjCParser.RBRACE);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Type_nameContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_type_name;
    return this;
}

Type_nameContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Type_nameContext.prototype.constructor = Type_nameContext;

Type_nameContext.prototype.specifier_qualifier_list = function() {
    return this.getTypedRuleContext(Specifier_qualifier_listContext,0);
};

Type_nameContext.prototype.abstract_declarator = function() {
    return this.getTypedRuleContext(Abstract_declaratorContext,0);
};

Type_nameContext.prototype.block_type = function() {
    return this.getTypedRuleContext(Block_typeContext,0);
};

Type_nameContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterType_name(this);
	}
};

Type_nameContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitType_name(this);
	}
};




ObjCParser.Type_nameContext = Type_nameContext;

ObjCParser.prototype.type_name = function() {

    var localctx = new Type_nameContext(this, this._ctx, this.state);
    this.enterRule(localctx, 174, ObjCParser.RULE_type_name);
    try {
        this.state = 998;
        var la_ = this._interp.adaptivePredict(this._input,109,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 994;
            this.specifier_qualifier_list();
            this.state = 995;
            this.abstract_declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 997;
            this.block_type();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Abstract_declaratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_abstract_declarator;
    return this;
}

Abstract_declaratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Abstract_declaratorContext.prototype.constructor = Abstract_declaratorContext;

Abstract_declaratorContext.prototype.pointer = function() {
    return this.getTypedRuleContext(PointerContext,0);
};

Abstract_declaratorContext.prototype.abstract_declarator = function() {
    return this.getTypedRuleContext(Abstract_declaratorContext,0);
};

Abstract_declaratorContext.prototype.abstract_declarator_suffix = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Abstract_declarator_suffixContext);
    } else {
        return this.getTypedRuleContext(Abstract_declarator_suffixContext,i);
    }
};

Abstract_declaratorContext.prototype.constant_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Constant_expressionContext);
    } else {
        return this.getTypedRuleContext(Constant_expressionContext,i);
    }
};

Abstract_declaratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAbstract_declarator(this);
	}
};

Abstract_declaratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAbstract_declarator(this);
	}
};




ObjCParser.Abstract_declaratorContext = Abstract_declaratorContext;

ObjCParser.prototype.abstract_declarator = function() {

    var localctx = new Abstract_declaratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 176, ObjCParser.RULE_abstract_declarator);
    var _la = 0; // Token type
    try {
        this.state = 1021;
        var la_ = this._interp.adaptivePredict(this._input,113,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1000;
            this.pointer();
            this.state = 1001;
            this.abstract_declarator();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1003;
            this.match(ObjCParser.LPAREN);
            this.state = 1004;
            this.abstract_declarator();
            this.state = 1005;
            this.match(ObjCParser.RPAREN);
            this.state = 1007; 
            this._errHandler.sync(this);
            var _alt = 1;
            do {
            	switch (_alt) {
            	case 1:
            		this.state = 1006;
            		this.abstract_declarator_suffix();
            		break;
            	default:
            		throw new antlr4.error.NoViableAltException(this);
            	}
            	this.state = 1009; 
            	this._errHandler.sync(this);
            	_alt = this._interp.adaptivePredict(this._input,110, this._ctx);
            } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1016; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 1011;
                this.match(ObjCParser.LBRACK);
                this.state = 1013;
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
                    this.state = 1012;
                    this.constant_expression();
                }

                this.state = 1015;
                this.match(ObjCParser.RBRACK);
                this.state = 1018; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===ObjCParser.LBRACK);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Abstract_declarator_suffixContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_abstract_declarator_suffix;
    return this;
}

Abstract_declarator_suffixContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Abstract_declarator_suffixContext.prototype.constructor = Abstract_declarator_suffixContext;

Abstract_declarator_suffixContext.prototype.constant_expression = function() {
    return this.getTypedRuleContext(Constant_expressionContext,0);
};

Abstract_declarator_suffixContext.prototype.parameter_declaration_list = function() {
    return this.getTypedRuleContext(Parameter_declaration_listContext,0);
};

Abstract_declarator_suffixContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAbstract_declarator_suffix(this);
	}
};

Abstract_declarator_suffixContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAbstract_declarator_suffix(this);
	}
};




ObjCParser.Abstract_declarator_suffixContext = Abstract_declarator_suffixContext;

ObjCParser.prototype.abstract_declarator_suffix = function() {

    var localctx = new Abstract_declarator_suffixContext(this, this._ctx, this.state);
    this.enterRule(localctx, 178, ObjCParser.RULE_abstract_declarator_suffix);
    var _la = 0; // Token type
    try {
        this.state = 1033;
        switch(this._input.LA(1)) {
        case ObjCParser.LBRACK:
            this.enterOuterAlt(localctx, 1);
            this.state = 1023;
            this.match(ObjCParser.LBRACK);
            this.state = 1025;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
                this.state = 1024;
                this.constant_expression();
            }

            this.state = 1027;
            this.match(ObjCParser.RBRACK);
            break;
        case ObjCParser.LPAREN:
            this.enterOuterAlt(localctx, 2);
            this.state = 1028;
            this.match(ObjCParser.LPAREN);
            this.state = 1030;
            _la = this._input.LA(1);
            if(((((_la - 25)) & ~0x1f) == 0 && ((1 << (_la - 25)) & ((1 << (ObjCParser.AUTO - 25)) | (1 << (ObjCParser.BYCOPY - 25)) | (1 << (ObjCParser.BYREF - 25)) | (1 << (ObjCParser.CHAR - 25)) | (1 << (ObjCParser.CONST - 25)) | (1 << (ObjCParser.DOUBLE - 25)) | (1 << (ObjCParser.ENUM - 25)) | (1 << (ObjCParser.EXTERN - 25)) | (1 << (ObjCParser.FLOAT - 25)) | (1 << (ObjCParser.ID - 25)) | (1 << (ObjCParser.IN - 25)) | (1 << (ObjCParser.INOUT - 25)) | (1 << (ObjCParser.INT - 25)) | (1 << (ObjCParser.LONG - 25)) | (1 << (ObjCParser.ONEWAY - 25)) | (1 << (ObjCParser.OUT - 25)) | (1 << (ObjCParser.REGISTER - 25)) | (1 << (ObjCParser.SHORT - 25)) | (1 << (ObjCParser.SIGNED - 25)) | (1 << (ObjCParser.STATIC - 25)))) !== 0) || ((((_la - 57)) & ~0x1f) == 0 && ((1 << (_la - 57)) & ((1 << (ObjCParser.STRUCT - 57)) | (1 << (ObjCParser.TYPEDEF - 57)) | (1 << (ObjCParser.UNION - 57)) | (1 << (ObjCParser.UNSIGNED - 57)) | (1 << (ObjCParser.VOID - 57)) | (1 << (ObjCParser.VOLATILE - 57)) | (1 << (ObjCParser.NS_OPTIONS - 57)) | (1 << (ObjCParser.NS_ENUM - 57)) | (1 << (ObjCParser.WWEAK - 57)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 57)))) !== 0) || _la===ObjCParser.IDENTIFIER) {
                this.state = 1029;
                this.parameter_declaration_list();
            }

            this.state = 1032;
            this.match(ObjCParser.RPAREN);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Parameter_declaration_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_parameter_declaration_list;
    return this;
}

Parameter_declaration_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Parameter_declaration_listContext.prototype.constructor = Parameter_declaration_listContext;

Parameter_declaration_listContext.prototype.parameter_declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Parameter_declarationContext);
    } else {
        return this.getTypedRuleContext(Parameter_declarationContext,i);
    }
};

Parameter_declaration_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterParameter_declaration_list(this);
	}
};

Parameter_declaration_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitParameter_declaration_list(this);
	}
};




ObjCParser.Parameter_declaration_listContext = Parameter_declaration_listContext;

ObjCParser.prototype.parameter_declaration_list = function() {

    var localctx = new Parameter_declaration_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 180, ObjCParser.RULE_parameter_declaration_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1035;
        this.parameter_declaration();
        this.state = 1040;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,117,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1036;
                this.match(ObjCParser.COMMA);
                this.state = 1037;
                this.parameter_declaration(); 
            }
            this.state = 1042;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,117,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Statement_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_statement_list;
    return this;
}

Statement_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Statement_listContext.prototype.constructor = Statement_listContext;

Statement_listContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

Statement_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStatement_list(this);
	}
};

Statement_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStatement_list(this);
	}
};




ObjCParser.Statement_listContext = Statement_listContext;

ObjCParser.prototype.statement_list = function() {

    var localctx = new Statement_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 182, ObjCParser.RULE_statement_list);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1044; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 1043;
        		this.statement();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 1046; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,118, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_statement;
    return this;
}

StatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StatementContext.prototype.constructor = StatementContext;

StatementContext.prototype.labeled_statement = function() {
    return this.getTypedRuleContext(Labeled_statementContext,0);
};

StatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

StatementContext.prototype.compound_statement = function() {
    return this.getTypedRuleContext(Compound_statementContext,0);
};

StatementContext.prototype.selection_statement = function() {
    return this.getTypedRuleContext(Selection_statementContext,0);
};

StatementContext.prototype.iteration_statement = function() {
    return this.getTypedRuleContext(Iteration_statementContext,0);
};

StatementContext.prototype.jump_statement = function() {
    return this.getTypedRuleContext(Jump_statementContext,0);
};

StatementContext.prototype.synchronized_statement = function() {
    return this.getTypedRuleContext(Synchronized_statementContext,0);
};

StatementContext.prototype.autorelease_statement = function() {
    return this.getTypedRuleContext(Autorelease_statementContext,0);
};

StatementContext.prototype.try_block = function() {
    return this.getTypedRuleContext(Try_blockContext,0);
};

StatementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterStatement(this);
	}
};

StatementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitStatement(this);
	}
};




ObjCParser.StatementContext = StatementContext;

ObjCParser.prototype.statement = function() {

    var localctx = new StatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 184, ObjCParser.RULE_statement);
    try {
        this.state = 1060;
        var la_ = this._interp.adaptivePredict(this._input,119,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1048;
            this.labeled_statement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1049;
            this.expression();
            this.state = 1050;
            this.match(ObjCParser.SEMI);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1052;
            this.compound_statement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1053;
            this.selection_statement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 1054;
            this.iteration_statement();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 1055;
            this.jump_statement();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 1056;
            this.synchronized_statement();
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 1057;
            this.autorelease_statement();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 1058;
            this.try_block();
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 1059;
            this.match(ObjCParser.SEMI);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Labeled_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_labeled_statement;
    return this;
}

Labeled_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Labeled_statementContext.prototype.constructor = Labeled_statementContext;

Labeled_statementContext.prototype.identifier = function() {
    return this.getTypedRuleContext(IdentifierContext,0);
};

Labeled_statementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

Labeled_statementContext.prototype.constant_expression = function() {
    return this.getTypedRuleContext(Constant_expressionContext,0);
};

Labeled_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterLabeled_statement(this);
	}
};

Labeled_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitLabeled_statement(this);
	}
};




ObjCParser.Labeled_statementContext = Labeled_statementContext;

ObjCParser.prototype.labeled_statement = function() {

    var localctx = new Labeled_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 186, ObjCParser.RULE_labeled_statement);
    try {
        this.state = 1074;
        switch(this._input.LA(1)) {
        case ObjCParser.IDENTIFIER:
            this.enterOuterAlt(localctx, 1);
            this.state = 1062;
            this.identifier();
            this.state = 1063;
            this.match(ObjCParser.COLON);
            this.state = 1064;
            this.statement();
            break;
        case ObjCParser.CASE:
            this.enterOuterAlt(localctx, 2);
            this.state = 1066;
            this.match(ObjCParser.CASE);
            this.state = 1067;
            this.constant_expression();
            this.state = 1068;
            this.match(ObjCParser.COLON);
            this.state = 1069;
            this.statement();
            break;
        case ObjCParser.DEFAULT:
            this.enterOuterAlt(localctx, 3);
            this.state = 1071;
            this.match(ObjCParser.DEFAULT);
            this.state = 1072;
            this.match(ObjCParser.COLON);
            this.state = 1073;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Compound_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_compound_statement;
    return this;
}

Compound_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Compound_statementContext.prototype.constructor = Compound_statementContext;

Compound_statementContext.prototype.declaration = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DeclarationContext);
    } else {
        return this.getTypedRuleContext(DeclarationContext,i);
    }
};

Compound_statementContext.prototype.statement_list = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Statement_listContext);
    } else {
        return this.getTypedRuleContext(Statement_listContext,i);
    }
};

Compound_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCompound_statement(this);
	}
};

Compound_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCompound_statement(this);
	}
};




ObjCParser.Compound_statementContext = Compound_statementContext;

ObjCParser.prototype.compound_statement = function() {

    var localctx = new Compound_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 188, ObjCParser.RULE_compound_statement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1076;
        this.match(ObjCParser.LBRACE);
        this.state = 1081;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.AUTORELEASEPOOL) | (1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SYNCHRONIZED) | (1 << ObjCParser.TRY) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF) | (1 << ObjCParser.AUTO) | (1 << ObjCParser.BREAK) | (1 << ObjCParser.BYCOPY) | (1 << ObjCParser.BYREF) | (1 << ObjCParser.CASE) | (1 << ObjCParser.CHAR))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ObjCParser.CONST - 32)) | (1 << (ObjCParser.CONTINUE - 32)) | (1 << (ObjCParser.DEFAULT - 32)) | (1 << (ObjCParser.DO - 32)) | (1 << (ObjCParser.DOUBLE - 32)) | (1 << (ObjCParser.ENUM - 32)) | (1 << (ObjCParser.EXTERN - 32)) | (1 << (ObjCParser.FLOAT - 32)) | (1 << (ObjCParser.FOR - 32)) | (1 << (ObjCParser.ID - 32)) | (1 << (ObjCParser.IF - 32)) | (1 << (ObjCParser.IN - 32)) | (1 << (ObjCParser.INOUT - 32)) | (1 << (ObjCParser.GOTO - 32)) | (1 << (ObjCParser.INT - 32)) | (1 << (ObjCParser.LONG - 32)) | (1 << (ObjCParser.ONEWAY - 32)) | (1 << (ObjCParser.OUT - 32)) | (1 << (ObjCParser.REGISTER - 32)) | (1 << (ObjCParser.RETURN - 32)) | (1 << (ObjCParser.SHORT - 32)) | (1 << (ObjCParser.SIGNED - 32)) | (1 << (ObjCParser.SIZEOF - 32)) | (1 << (ObjCParser.STATIC - 32)) | (1 << (ObjCParser.STRUCT - 32)) | (1 << (ObjCParser.SWITCH - 32)) | (1 << (ObjCParser.TYPEDEF - 32)) | (1 << (ObjCParser.UNION - 32)) | (1 << (ObjCParser.UNSIGNED - 32)) | (1 << (ObjCParser.VOID - 32)) | (1 << (ObjCParser.VOLATILE - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (ObjCParser.WHILE - 64)) | (1 << (ObjCParser.NS_OPTIONS - 64)) | (1 << (ObjCParser.NS_ENUM - 64)) | (1 << (ObjCParser.WWEAK - 64)) | (1 << (ObjCParser.WUNSAFE_UNRETAINED - 64)) | (1 << (ObjCParser.LPAREN - 64)) | (1 << (ObjCParser.LBRACE - 64)) | (1 << (ObjCParser.LBRACK - 64)) | (1 << (ObjCParser.SEMI - 64)) | (1 << (ObjCParser.AT - 64)) | (1 << (ObjCParser.BANG - 64)) | (1 << (ObjCParser.TILDE - 64)) | (1 << (ObjCParser.INC - 64)) | (1 << (ObjCParser.DEC - 64)))) !== 0) || ((((_la - 96)) & ~0x1f) == 0 && ((1 << (_la - 96)) & ((1 << (ObjCParser.SUB - 96)) | (1 << (ObjCParser.MUL - 96)) | (1 << (ObjCParser.BITAND - 96)) | (1 << (ObjCParser.CARET - 96)) | (1 << (ObjCParser.IDENTIFIER - 96)) | (1 << (ObjCParser.CHARACTER_LITERAL - 96)) | (1 << (ObjCParser.STRING_LITERAL - 96)))) !== 0) || ((((_la - 128)) & ~0x1f) == 0 && ((1 << (_la - 128)) & ((1 << (ObjCParser.HEX_LITERAL - 128)) | (1 << (ObjCParser.DECIMAL_LITERAL - 128)) | (1 << (ObjCParser.OCTAL_LITERAL - 128)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 128)))) !== 0)) {
            this.state = 1079;
            var la_ = this._interp.adaptivePredict(this._input,121,this._ctx);
            switch(la_) {
            case 1:
                this.state = 1077;
                this.declaration();
                break;

            case 2:
                this.state = 1078;
                this.statement_list();
                break;

            }
            this.state = 1083;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1084;
        this.match(ObjCParser.RBRACE);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Selection_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_selection_statement;
    return this;
}

Selection_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Selection_statementContext.prototype.constructor = Selection_statementContext;

Selection_statementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

Selection_statementContext.prototype.statement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StatementContext);
    } else {
        return this.getTypedRuleContext(StatementContext,i);
    }
};

Selection_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterSelection_statement(this);
	}
};

Selection_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitSelection_statement(this);
	}
};




ObjCParser.Selection_statementContext = Selection_statementContext;

ObjCParser.prototype.selection_statement = function() {

    var localctx = new Selection_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 190, ObjCParser.RULE_selection_statement);
    try {
        this.state = 1101;
        switch(this._input.LA(1)) {
        case ObjCParser.IF:
            this.enterOuterAlt(localctx, 1);
            this.state = 1086;
            this.match(ObjCParser.IF);
            this.state = 1087;
            this.match(ObjCParser.LPAREN);
            this.state = 1088;
            this.expression();
            this.state = 1089;
            this.match(ObjCParser.RPAREN);
            this.state = 1090;
            this.statement();
            this.state = 1093;
            var la_ = this._interp.adaptivePredict(this._input,123,this._ctx);
            if(la_===1) {
                this.state = 1091;
                this.match(ObjCParser.ELSE);
                this.state = 1092;
                this.statement();

            }
            break;
        case ObjCParser.SWITCH:
            this.enterOuterAlt(localctx, 2);
            this.state = 1095;
            this.match(ObjCParser.SWITCH);
            this.state = 1096;
            this.match(ObjCParser.LPAREN);
            this.state = 1097;
            this.expression();
            this.state = 1098;
            this.match(ObjCParser.RPAREN);
            this.state = 1099;
            this.statement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function For_in_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_for_in_statement;
    return this;
}

For_in_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
For_in_statementContext.prototype.constructor = For_in_statementContext;

For_in_statementContext.prototype.type_variable_declarator = function() {
    return this.getTypedRuleContext(Type_variable_declaratorContext,0);
};

For_in_statementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

For_in_statementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

For_in_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterFor_in_statement(this);
	}
};

For_in_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitFor_in_statement(this);
	}
};




ObjCParser.For_in_statementContext = For_in_statementContext;

ObjCParser.prototype.for_in_statement = function() {

    var localctx = new For_in_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 192, ObjCParser.RULE_for_in_statement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1103;
        this.match(ObjCParser.FOR);
        this.state = 1104;
        this.match(ObjCParser.LPAREN);
        this.state = 1105;
        this.type_variable_declarator();
        this.state = 1106;
        this.match(ObjCParser.IN);
        this.state = 1108;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
            this.state = 1107;
            this.expression();
        }

        this.state = 1110;
        this.match(ObjCParser.RPAREN);
        this.state = 1111;
        this.statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function For_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_for_statement;
    return this;
}

For_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
For_statementContext.prototype.constructor = For_statementContext;

For_statementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

For_statementContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

For_statementContext.prototype.declaration_specifiers = function() {
    return this.getTypedRuleContext(Declaration_specifiersContext,0);
};

For_statementContext.prototype.init_declarator_list = function() {
    return this.getTypedRuleContext(Init_declarator_listContext,0);
};

For_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterFor_statement(this);
	}
};

For_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitFor_statement(this);
	}
};




ObjCParser.For_statementContext = For_statementContext;

ObjCParser.prototype.for_statement = function() {

    var localctx = new For_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 194, ObjCParser.RULE_for_statement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1113;
        this.match(ObjCParser.FOR);
        this.state = 1114;
        this.match(ObjCParser.LPAREN);
        this.state = 1119;
        var la_ = this._interp.adaptivePredict(this._input,126,this._ctx);
        if(la_===1) {
            this.state = 1115;
            this.declaration_specifiers();
            this.state = 1116;
            this.init_declarator_list();

        } else if(la_===2) {
            this.state = 1118;
            this.expression();

        }
        this.state = 1121;
        this.match(ObjCParser.SEMI);
        this.state = 1123;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
            this.state = 1122;
            this.expression();
        }

        this.state = 1125;
        this.match(ObjCParser.SEMI);
        this.state = 1127;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
            this.state = 1126;
            this.expression();
        }

        this.state = 1129;
        this.match(ObjCParser.RPAREN);
        this.state = 1130;
        this.statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function While_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_while_statement;
    return this;
}

While_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
While_statementContext.prototype.constructor = While_statementContext;

While_statementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

While_statementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

While_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterWhile_statement(this);
	}
};

While_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitWhile_statement(this);
	}
};




ObjCParser.While_statementContext = While_statementContext;

ObjCParser.prototype.while_statement = function() {

    var localctx = new While_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 196, ObjCParser.RULE_while_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1132;
        this.match(ObjCParser.WHILE);
        this.state = 1133;
        this.match(ObjCParser.LPAREN);
        this.state = 1134;
        this.expression();
        this.state = 1135;
        this.match(ObjCParser.RPAREN);
        this.state = 1136;
        this.statement();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Do_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_do_statement;
    return this;
}

Do_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Do_statementContext.prototype.constructor = Do_statementContext;

Do_statementContext.prototype.statement = function() {
    return this.getTypedRuleContext(StatementContext,0);
};

Do_statementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

Do_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterDo_statement(this);
	}
};

Do_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitDo_statement(this);
	}
};




ObjCParser.Do_statementContext = Do_statementContext;

ObjCParser.prototype.do_statement = function() {

    var localctx = new Do_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 198, ObjCParser.RULE_do_statement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1138;
        this.match(ObjCParser.DO);
        this.state = 1139;
        this.statement();
        this.state = 1140;
        this.match(ObjCParser.WHILE);
        this.state = 1141;
        this.match(ObjCParser.LPAREN);
        this.state = 1142;
        this.expression();
        this.state = 1143;
        this.match(ObjCParser.RPAREN);
        this.state = 1144;
        this.match(ObjCParser.SEMI);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Iteration_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_iteration_statement;
    return this;
}

Iteration_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Iteration_statementContext.prototype.constructor = Iteration_statementContext;

Iteration_statementContext.prototype.while_statement = function() {
    return this.getTypedRuleContext(While_statementContext,0);
};

Iteration_statementContext.prototype.do_statement = function() {
    return this.getTypedRuleContext(Do_statementContext,0);
};

Iteration_statementContext.prototype.for_statement = function() {
    return this.getTypedRuleContext(For_statementContext,0);
};

Iteration_statementContext.prototype.for_in_statement = function() {
    return this.getTypedRuleContext(For_in_statementContext,0);
};

Iteration_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterIteration_statement(this);
	}
};

Iteration_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitIteration_statement(this);
	}
};




ObjCParser.Iteration_statementContext = Iteration_statementContext;

ObjCParser.prototype.iteration_statement = function() {

    var localctx = new Iteration_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 200, ObjCParser.RULE_iteration_statement);
    try {
        this.state = 1150;
        var la_ = this._interp.adaptivePredict(this._input,129,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1146;
            this.while_statement();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1147;
            this.do_statement();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1148;
            this.for_statement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1149;
            this.for_in_statement();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Jump_statementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_jump_statement;
    return this;
}

Jump_statementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Jump_statementContext.prototype.constructor = Jump_statementContext;

Jump_statementContext.prototype.identifier = function() {
    return this.getTypedRuleContext(IdentifierContext,0);
};

Jump_statementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

Jump_statementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterJump_statement(this);
	}
};

Jump_statementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitJump_statement(this);
	}
};




ObjCParser.Jump_statementContext = Jump_statementContext;

ObjCParser.prototype.jump_statement = function() {

    var localctx = new Jump_statementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 202, ObjCParser.RULE_jump_statement);
    var _la = 0; // Token type
    try {
        this.state = 1165;
        switch(this._input.LA(1)) {
        case ObjCParser.GOTO:
            this.enterOuterAlt(localctx, 1);
            this.state = 1152;
            this.match(ObjCParser.GOTO);
            this.state = 1153;
            this.identifier();
            this.state = 1154;
            this.match(ObjCParser.SEMI);
            break;
        case ObjCParser.CONTINUE:
            this.enterOuterAlt(localctx, 2);
            this.state = 1156;
            this.match(ObjCParser.CONTINUE);
            this.state = 1157;
            this.match(ObjCParser.SEMI);
            break;
        case ObjCParser.BREAK:
            this.enterOuterAlt(localctx, 3);
            this.state = 1158;
            this.match(ObjCParser.BREAK);
            this.state = 1159;
            this.match(ObjCParser.SEMI);
            break;
        case ObjCParser.RETURN:
            this.enterOuterAlt(localctx, 4);
            this.state = 1160;
            this.match(ObjCParser.RETURN);
            this.state = 1162;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
                this.state = 1161;
                this.expression();
            }

            this.state = 1164;
            this.match(ObjCParser.SEMI);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;

ExpressionContext.prototype.assignment_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Assignment_expressionContext);
    } else {
        return this.getTypedRuleContext(Assignment_expressionContext,i);
    }
};

ExpressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterExpression(this);
	}
};

ExpressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitExpression(this);
	}
};




ObjCParser.ExpressionContext = ExpressionContext;

ObjCParser.prototype.expression = function() {

    var localctx = new ExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 204, ObjCParser.RULE_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1167;
        this.assignment_expression();
        this.state = 1172;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 1168;
            this.match(ObjCParser.COMMA);
            this.state = 1169;
            this.assignment_expression();
            this.state = 1174;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Assignment_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_assignment_expression;
    return this;
}

Assignment_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Assignment_expressionContext.prototype.constructor = Assignment_expressionContext;

Assignment_expressionContext.prototype.conditional_expression = function() {
    return this.getTypedRuleContext(Conditional_expressionContext,0);
};

Assignment_expressionContext.prototype.unary_expression = function() {
    return this.getTypedRuleContext(Unary_expressionContext,0);
};

Assignment_expressionContext.prototype.assignment_operator = function() {
    return this.getTypedRuleContext(Assignment_operatorContext,0);
};

Assignment_expressionContext.prototype.assignment_expression = function() {
    return this.getTypedRuleContext(Assignment_expressionContext,0);
};

Assignment_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAssignment_expression(this);
	}
};

Assignment_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAssignment_expression(this);
	}
};




ObjCParser.Assignment_expressionContext = Assignment_expressionContext;

ObjCParser.prototype.assignment_expression = function() {

    var localctx = new Assignment_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 206, ObjCParser.RULE_assignment_expression);
    try {
        this.state = 1180;
        var la_ = this._interp.adaptivePredict(this._input,133,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1175;
            this.conditional_expression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1176;
            this.unary_expression();
            this.state = 1177;
            this.assignment_operator();
            this.state = 1178;
            this.assignment_expression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Assignment_operatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_assignment_operator;
    return this;
}

Assignment_operatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Assignment_operatorContext.prototype.constructor = Assignment_operatorContext;


Assignment_operatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAssignment_operator(this);
	}
};

Assignment_operatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAssignment_operator(this);
	}
};




ObjCParser.Assignment_operatorContext = Assignment_operatorContext;

ObjCParser.prototype.assignment_operator = function() {

    var localctx = new Assignment_operatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 208, ObjCParser.RULE_assignment_operator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1182;
        _la = this._input.LA(1);
        if(!(((((_la - 80)) & ~0x1f) == 0 && ((1 << (_la - 80)) & ((1 << (ObjCParser.ASSIGN - 80)) | (1 << (ObjCParser.ADD_ASSIGN - 80)) | (1 << (ObjCParser.SUB_ASSIGN - 80)) | (1 << (ObjCParser.MUL_ASSIGN - 80)) | (1 << (ObjCParser.DIV_ASSIGN - 80)) | (1 << (ObjCParser.AND_ASSIGN - 80)) | (1 << (ObjCParser.OR_ASSIGN - 80)) | (1 << (ObjCParser.XOR_ASSIGN - 80)))) !== 0) || ((((_la - 112)) & ~0x1f) == 0 && ((1 << (_la - 112)) & ((1 << (ObjCParser.MOD_ASSIGN - 112)) | (1 << (ObjCParser.LSHIFT_ASSIGN - 112)) | (1 << (ObjCParser.RSHIFT_ASSIGN - 112)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Conditional_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_conditional_expression;
    return this;
}

Conditional_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Conditional_expressionContext.prototype.constructor = Conditional_expressionContext;

Conditional_expressionContext.prototype.logical_or_expression = function() {
    return this.getTypedRuleContext(Logical_or_expressionContext,0);
};

Conditional_expressionContext.prototype.conditional_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Conditional_expressionContext);
    } else {
        return this.getTypedRuleContext(Conditional_expressionContext,i);
    }
};

Conditional_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterConditional_expression(this);
	}
};

Conditional_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitConditional_expression(this);
	}
};




ObjCParser.Conditional_expressionContext = Conditional_expressionContext;

ObjCParser.prototype.conditional_expression = function() {

    var localctx = new Conditional_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 210, ObjCParser.RULE_conditional_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1184;
        this.logical_or_expression();
        this.state = 1190;
        _la = this._input.LA(1);
        if(_la===ObjCParser.QUESTION) {
            this.state = 1185;
            this.match(ObjCParser.QUESTION);
            this.state = 1186;
            this.conditional_expression();
            this.state = 1187;
            this.match(ObjCParser.COLON);
            this.state = 1188;
            this.conditional_expression();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Constant_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_constant_expression;
    return this;
}

Constant_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Constant_expressionContext.prototype.constructor = Constant_expressionContext;

Constant_expressionContext.prototype.conditional_expression = function() {
    return this.getTypedRuleContext(Conditional_expressionContext,0);
};

Constant_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterConstant_expression(this);
	}
};

Constant_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitConstant_expression(this);
	}
};




ObjCParser.Constant_expressionContext = Constant_expressionContext;

ObjCParser.prototype.constant_expression = function() {

    var localctx = new Constant_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 212, ObjCParser.RULE_constant_expression);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1192;
        this.conditional_expression();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Logical_or_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_logical_or_expression;
    return this;
}

Logical_or_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Logical_or_expressionContext.prototype.constructor = Logical_or_expressionContext;

Logical_or_expressionContext.prototype.logical_and_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Logical_and_expressionContext);
    } else {
        return this.getTypedRuleContext(Logical_and_expressionContext,i);
    }
};

Logical_or_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterLogical_or_expression(this);
	}
};

Logical_or_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitLogical_or_expression(this);
	}
};




ObjCParser.Logical_or_expressionContext = Logical_or_expressionContext;

ObjCParser.prototype.logical_or_expression = function() {

    var localctx = new Logical_or_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 214, ObjCParser.RULE_logical_or_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1194;
        this.logical_and_expression();
        this.state = 1199;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.OR) {
            this.state = 1195;
            this.match(ObjCParser.OR);
            this.state = 1196;
            this.logical_and_expression();
            this.state = 1201;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Logical_and_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_logical_and_expression;
    return this;
}

Logical_and_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Logical_and_expressionContext.prototype.constructor = Logical_and_expressionContext;

Logical_and_expressionContext.prototype.inclusive_or_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Inclusive_or_expressionContext);
    } else {
        return this.getTypedRuleContext(Inclusive_or_expressionContext,i);
    }
};

Logical_and_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterLogical_and_expression(this);
	}
};

Logical_and_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitLogical_and_expression(this);
	}
};




ObjCParser.Logical_and_expressionContext = Logical_and_expressionContext;

ObjCParser.prototype.logical_and_expression = function() {

    var localctx = new Logical_and_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 216, ObjCParser.RULE_logical_and_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1202;
        this.inclusive_or_expression();
        this.state = 1207;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.AND) {
            this.state = 1203;
            this.match(ObjCParser.AND);
            this.state = 1204;
            this.inclusive_or_expression();
            this.state = 1209;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Inclusive_or_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_inclusive_or_expression;
    return this;
}

Inclusive_or_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Inclusive_or_expressionContext.prototype.constructor = Inclusive_or_expressionContext;

Inclusive_or_expressionContext.prototype.exclusive_or_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Exclusive_or_expressionContext);
    } else {
        return this.getTypedRuleContext(Exclusive_or_expressionContext,i);
    }
};

Inclusive_or_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterInclusive_or_expression(this);
	}
};

Inclusive_or_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitInclusive_or_expression(this);
	}
};




ObjCParser.Inclusive_or_expressionContext = Inclusive_or_expressionContext;

ObjCParser.prototype.inclusive_or_expression = function() {

    var localctx = new Inclusive_or_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 218, ObjCParser.RULE_inclusive_or_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1210;
        this.exclusive_or_expression();
        this.state = 1215;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.BITOR) {
            this.state = 1211;
            this.match(ObjCParser.BITOR);
            this.state = 1212;
            this.exclusive_or_expression();
            this.state = 1217;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Exclusive_or_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_exclusive_or_expression;
    return this;
}

Exclusive_or_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Exclusive_or_expressionContext.prototype.constructor = Exclusive_or_expressionContext;

Exclusive_or_expressionContext.prototype.and_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(And_expressionContext);
    } else {
        return this.getTypedRuleContext(And_expressionContext,i);
    }
};

Exclusive_or_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterExclusive_or_expression(this);
	}
};

Exclusive_or_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitExclusive_or_expression(this);
	}
};




ObjCParser.Exclusive_or_expressionContext = Exclusive_or_expressionContext;

ObjCParser.prototype.exclusive_or_expression = function() {

    var localctx = new Exclusive_or_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 220, ObjCParser.RULE_exclusive_or_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1218;
        this.and_expression();
        this.state = 1223;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.CARET) {
            this.state = 1219;
            this.match(ObjCParser.CARET);
            this.state = 1220;
            this.and_expression();
            this.state = 1225;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function And_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_and_expression;
    return this;
}

And_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
And_expressionContext.prototype.constructor = And_expressionContext;

And_expressionContext.prototype.equality_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Equality_expressionContext);
    } else {
        return this.getTypedRuleContext(Equality_expressionContext,i);
    }
};

And_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAnd_expression(this);
	}
};

And_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAnd_expression(this);
	}
};




ObjCParser.And_expressionContext = And_expressionContext;

ObjCParser.prototype.and_expression = function() {

    var localctx = new And_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 222, ObjCParser.RULE_and_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1226;
        this.equality_expression();
        this.state = 1231;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.BITAND) {
            this.state = 1227;
            this.match(ObjCParser.BITAND);
            this.state = 1228;
            this.equality_expression();
            this.state = 1233;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Equality_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_equality_expression;
    return this;
}

Equality_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Equality_expressionContext.prototype.constructor = Equality_expressionContext;

Equality_expressionContext.prototype.relational_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Relational_expressionContext);
    } else {
        return this.getTypedRuleContext(Relational_expressionContext,i);
    }
};

Equality_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterEquality_expression(this);
	}
};

Equality_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitEquality_expression(this);
	}
};




ObjCParser.Equality_expressionContext = Equality_expressionContext;

ObjCParser.prototype.equality_expression = function() {

    var localctx = new Equality_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 224, ObjCParser.RULE_equality_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1234;
        this.relational_expression();
        this.state = 1239;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.EQUAL || _la===ObjCParser.NOTEQUAL) {
            this.state = 1235;
            _la = this._input.LA(1);
            if(!(_la===ObjCParser.EQUAL || _la===ObjCParser.NOTEQUAL)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1236;
            this.relational_expression();
            this.state = 1241;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Relational_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_relational_expression;
    return this;
}

Relational_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Relational_expressionContext.prototype.constructor = Relational_expressionContext;

Relational_expressionContext.prototype.shift_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Shift_expressionContext);
    } else {
        return this.getTypedRuleContext(Shift_expressionContext,i);
    }
};

Relational_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterRelational_expression(this);
	}
};

Relational_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitRelational_expression(this);
	}
};




ObjCParser.Relational_expressionContext = Relational_expressionContext;

ObjCParser.prototype.relational_expression = function() {

    var localctx = new Relational_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 226, ObjCParser.RULE_relational_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1242;
        this.shift_expression();
        this.state = 1247;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (ObjCParser.GT - 81)) | (1 << (ObjCParser.LT - 81)) | (1 << (ObjCParser.LE - 81)) | (1 << (ObjCParser.GE - 81)))) !== 0)) {
            this.state = 1243;
            _la = this._input.LA(1);
            if(!(((((_la - 81)) & ~0x1f) == 0 && ((1 << (_la - 81)) & ((1 << (ObjCParser.GT - 81)) | (1 << (ObjCParser.LT - 81)) | (1 << (ObjCParser.LE - 81)) | (1 << (ObjCParser.GE - 81)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1244;
            this.shift_expression();
            this.state = 1249;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Shift_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_shift_expression;
    return this;
}

Shift_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Shift_expressionContext.prototype.constructor = Shift_expressionContext;

Shift_expressionContext.prototype.additive_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Additive_expressionContext);
    } else {
        return this.getTypedRuleContext(Additive_expressionContext,i);
    }
};

Shift_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterShift_expression(this);
	}
};

Shift_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitShift_expression(this);
	}
};




ObjCParser.Shift_expressionContext = Shift_expressionContext;

ObjCParser.prototype.shift_expression = function() {

    var localctx = new Shift_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 228, ObjCParser.RULE_shift_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1250;
        this.additive_expression();
        this.state = 1255;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.SHIFT_R || _la===ObjCParser.SHIFT_L) {
            this.state = 1251;
            _la = this._input.LA(1);
            if(!(_la===ObjCParser.SHIFT_R || _la===ObjCParser.SHIFT_L)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1252;
            this.additive_expression();
            this.state = 1257;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Additive_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_additive_expression;
    return this;
}

Additive_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Additive_expressionContext.prototype.constructor = Additive_expressionContext;

Additive_expressionContext.prototype.multiplicative_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Multiplicative_expressionContext);
    } else {
        return this.getTypedRuleContext(Multiplicative_expressionContext,i);
    }
};

Additive_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterAdditive_expression(this);
	}
};

Additive_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitAdditive_expression(this);
	}
};




ObjCParser.Additive_expressionContext = Additive_expressionContext;

ObjCParser.prototype.additive_expression = function() {

    var localctx = new Additive_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 230, ObjCParser.RULE_additive_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1258;
        this.multiplicative_expression();
        this.state = 1263;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.ADD || _la===ObjCParser.SUB) {
            this.state = 1259;
            _la = this._input.LA(1);
            if(!(_la===ObjCParser.ADD || _la===ObjCParser.SUB)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1260;
            this.multiplicative_expression();
            this.state = 1265;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Multiplicative_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_multiplicative_expression;
    return this;
}

Multiplicative_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Multiplicative_expressionContext.prototype.constructor = Multiplicative_expressionContext;

Multiplicative_expressionContext.prototype.cast_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Cast_expressionContext);
    } else {
        return this.getTypedRuleContext(Cast_expressionContext,i);
    }
};

Multiplicative_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterMultiplicative_expression(this);
	}
};

Multiplicative_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitMultiplicative_expression(this);
	}
};




ObjCParser.Multiplicative_expressionContext = Multiplicative_expressionContext;

ObjCParser.prototype.multiplicative_expression = function() {

    var localctx = new Multiplicative_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 232, ObjCParser.RULE_multiplicative_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1266;
        this.cast_expression();
        this.state = 1271;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(((((_la - 97)) & ~0x1f) == 0 && ((1 << (_la - 97)) & ((1 << (ObjCParser.MUL - 97)) | (1 << (ObjCParser.DIV - 97)) | (1 << (ObjCParser.MOD - 97)))) !== 0)) {
            this.state = 1267;
            _la = this._input.LA(1);
            if(!(((((_la - 97)) & ~0x1f) == 0 && ((1 << (_la - 97)) & ((1 << (ObjCParser.MUL - 97)) | (1 << (ObjCParser.DIV - 97)) | (1 << (ObjCParser.MOD - 97)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
            this.state = 1268;
            this.cast_expression();
            this.state = 1273;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Cast_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_cast_expression;
    return this;
}

Cast_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Cast_expressionContext.prototype.constructor = Cast_expressionContext;

Cast_expressionContext.prototype.type_name = function() {
    return this.getTypedRuleContext(Type_nameContext,0);
};

Cast_expressionContext.prototype.cast_expression = function() {
    return this.getTypedRuleContext(Cast_expressionContext,0);
};

Cast_expressionContext.prototype.unary_expression = function() {
    return this.getTypedRuleContext(Unary_expressionContext,0);
};

Cast_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterCast_expression(this);
	}
};

Cast_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitCast_expression(this);
	}
};




ObjCParser.Cast_expressionContext = Cast_expressionContext;

ObjCParser.prototype.cast_expression = function() {

    var localctx = new Cast_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 234, ObjCParser.RULE_cast_expression);
    try {
        this.state = 1280;
        var la_ = this._interp.adaptivePredict(this._input,145,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1274;
            this.match(ObjCParser.LPAREN);
            this.state = 1275;
            this.type_name();
            this.state = 1276;
            this.match(ObjCParser.RPAREN);
            this.state = 1277;
            this.cast_expression();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1279;
            this.unary_expression();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Unary_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_unary_expression;
    return this;
}

Unary_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Unary_expressionContext.prototype.constructor = Unary_expressionContext;

Unary_expressionContext.prototype.postfix_expression = function() {
    return this.getTypedRuleContext(Postfix_expressionContext,0);
};

Unary_expressionContext.prototype.unary_expression = function() {
    return this.getTypedRuleContext(Unary_expressionContext,0);
};

Unary_expressionContext.prototype.unary_operator = function() {
    return this.getTypedRuleContext(Unary_operatorContext,0);
};

Unary_expressionContext.prototype.cast_expression = function() {
    return this.getTypedRuleContext(Cast_expressionContext,0);
};

Unary_expressionContext.prototype.type_name = function() {
    return this.getTypedRuleContext(Type_nameContext,0);
};

Unary_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterUnary_expression(this);
	}
};

Unary_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitUnary_expression(this);
	}
};




ObjCParser.Unary_expressionContext = Unary_expressionContext;

ObjCParser.prototype.unary_expression = function() {

    var localctx = new Unary_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 236, ObjCParser.RULE_unary_expression);
    try {
        this.state = 1298;
        switch(this._input.LA(1)) {
        case ObjCParser.ENCODE:
        case ObjCParser.PROTOCOL:
        case ObjCParser.SELECTOR:
        case ObjCParser.SUPER:
        case ObjCParser.SELF:
        case ObjCParser.LPAREN:
        case ObjCParser.LBRACK:
        case ObjCParser.AT:
        case ObjCParser.CARET:
        case ObjCParser.IDENTIFIER:
        case ObjCParser.CHARACTER_LITERAL:
        case ObjCParser.STRING_LITERAL:
        case ObjCParser.HEX_LITERAL:
        case ObjCParser.DECIMAL_LITERAL:
        case ObjCParser.OCTAL_LITERAL:
        case ObjCParser.FLOATING_POINT_LITERAL:
            this.enterOuterAlt(localctx, 1);
            this.state = 1282;
            this.postfix_expression();
            break;
        case ObjCParser.INC:
            this.enterOuterAlt(localctx, 2);
            this.state = 1283;
            this.match(ObjCParser.INC);
            this.state = 1284;
            this.unary_expression();
            break;
        case ObjCParser.DEC:
            this.enterOuterAlt(localctx, 3);
            this.state = 1285;
            this.match(ObjCParser.DEC);
            this.state = 1286;
            this.unary_expression();
            break;
        case ObjCParser.BANG:
        case ObjCParser.TILDE:
        case ObjCParser.SUB:
        case ObjCParser.MUL:
        case ObjCParser.BITAND:
            this.enterOuterAlt(localctx, 4);
            this.state = 1287;
            this.unary_operator();
            this.state = 1288;
            this.cast_expression();
            break;
        case ObjCParser.SIZEOF:
            this.enterOuterAlt(localctx, 5);
            this.state = 1290;
            this.match(ObjCParser.SIZEOF);
            this.state = 1296;
            var la_ = this._interp.adaptivePredict(this._input,146,this._ctx);
            switch(la_) {
            case 1:
                this.state = 1291;
                this.match(ObjCParser.LPAREN);
                this.state = 1292;
                this.type_name();
                this.state = 1293;
                this.match(ObjCParser.RPAREN);
                break;

            case 2:
                this.state = 1295;
                this.unary_expression();
                break;

            }
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Unary_operatorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_unary_operator;
    return this;
}

Unary_operatorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Unary_operatorContext.prototype.constructor = Unary_operatorContext;


Unary_operatorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterUnary_operator(this);
	}
};

Unary_operatorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitUnary_operator(this);
	}
};




ObjCParser.Unary_operatorContext = Unary_operatorContext;

ObjCParser.prototype.unary_operator = function() {

    var localctx = new Unary_operatorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 238, ObjCParser.RULE_unary_operator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1300;
        _la = this._input.LA(1);
        if(!(((((_la - 83)) & ~0x1f) == 0 && ((1 << (_la - 83)) & ((1 << (ObjCParser.BANG - 83)) | (1 << (ObjCParser.TILDE - 83)) | (1 << (ObjCParser.SUB - 83)) | (1 << (ObjCParser.MUL - 83)) | (1 << (ObjCParser.BITAND - 83)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Postfix_expressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_postfix_expression;
    return this;
}

Postfix_expressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Postfix_expressionContext.prototype.constructor = Postfix_expressionContext;

Postfix_expressionContext.prototype.primary_expression = function() {
    return this.getTypedRuleContext(Primary_expressionContext,0);
};

Postfix_expressionContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

Postfix_expressionContext.prototype.identifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(IdentifierContext);
    } else {
        return this.getTypedRuleContext(IdentifierContext,i);
    }
};

Postfix_expressionContext.prototype.argument_expression_list = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Argument_expression_listContext);
    } else {
        return this.getTypedRuleContext(Argument_expression_listContext,i);
    }
};

Postfix_expressionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterPostfix_expression(this);
	}
};

Postfix_expressionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitPostfix_expression(this);
	}
};




ObjCParser.Postfix_expressionContext = Postfix_expressionContext;

ObjCParser.prototype.postfix_expression = function() {

    var localctx = new Postfix_expressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 240, ObjCParser.RULE_postfix_expression);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1302;
        this.primary_expression();
        this.state = 1320;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(((((_la - 69)) & ~0x1f) == 0 && ((1 << (_la - 69)) & ((1 << (ObjCParser.LPAREN - 69)) | (1 << (ObjCParser.LBRACK - 69)) | (1 << (ObjCParser.DOT - 69)) | (1 << (ObjCParser.STRUCTACCESS - 69)) | (1 << (ObjCParser.INC - 69)) | (1 << (ObjCParser.DEC - 69)))) !== 0)) {
            this.state = 1318;
            switch(this._input.LA(1)) {
            case ObjCParser.LBRACK:
                this.state = 1303;
                this.match(ObjCParser.LBRACK);
                this.state = 1304;
                this.expression();
                this.state = 1305;
                this.match(ObjCParser.RBRACK);
                break;
            case ObjCParser.LPAREN:
                this.state = 1307;
                this.match(ObjCParser.LPAREN);
                this.state = 1309;
                _la = this._input.LA(1);
                if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ObjCParser.ENCODE) | (1 << ObjCParser.PROTOCOL) | (1 << ObjCParser.SELECTOR) | (1 << ObjCParser.SUPER) | (1 << ObjCParser.SELF))) !== 0) || ((((_la - 55)) & ~0x1f) == 0 && ((1 << (_la - 55)) & ((1 << (ObjCParser.SIZEOF - 55)) | (1 << (ObjCParser.LPAREN - 55)) | (1 << (ObjCParser.LBRACK - 55)) | (1 << (ObjCParser.AT - 55)) | (1 << (ObjCParser.BANG - 55)) | (1 << (ObjCParser.TILDE - 55)))) !== 0) || ((((_la - 93)) & ~0x1f) == 0 && ((1 << (_la - 93)) & ((1 << (ObjCParser.INC - 93)) | (1 << (ObjCParser.DEC - 93)) | (1 << (ObjCParser.SUB - 93)) | (1 << (ObjCParser.MUL - 93)) | (1 << (ObjCParser.BITAND - 93)) | (1 << (ObjCParser.CARET - 93)))) !== 0) || ((((_la - 125)) & ~0x1f) == 0 && ((1 << (_la - 125)) & ((1 << (ObjCParser.IDENTIFIER - 125)) | (1 << (ObjCParser.CHARACTER_LITERAL - 125)) | (1 << (ObjCParser.STRING_LITERAL - 125)) | (1 << (ObjCParser.HEX_LITERAL - 125)) | (1 << (ObjCParser.DECIMAL_LITERAL - 125)) | (1 << (ObjCParser.OCTAL_LITERAL - 125)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 125)))) !== 0)) {
                    this.state = 1308;
                    this.argument_expression_list();
                }

                this.state = 1311;
                this.match(ObjCParser.RPAREN);
                break;
            case ObjCParser.DOT:
                this.state = 1312;
                this.match(ObjCParser.DOT);
                this.state = 1313;
                this.identifier();
                break;
            case ObjCParser.STRUCTACCESS:
                this.state = 1314;
                this.match(ObjCParser.STRUCTACCESS);
                this.state = 1315;
                this.identifier();
                break;
            case ObjCParser.INC:
                this.state = 1316;
                this.match(ObjCParser.INC);
                break;
            case ObjCParser.DEC:
                this.state = 1317;
                this.match(ObjCParser.DEC);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 1322;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Argument_expression_listContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_argument_expression_list;
    return this;
}

Argument_expression_listContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Argument_expression_listContext.prototype.constructor = Argument_expression_listContext;

Argument_expression_listContext.prototype.assignment_expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Assignment_expressionContext);
    } else {
        return this.getTypedRuleContext(Assignment_expressionContext,i);
    }
};

Argument_expression_listContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterArgument_expression_list(this);
	}
};

Argument_expression_listContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitArgument_expression_list(this);
	}
};




ObjCParser.Argument_expression_listContext = Argument_expression_listContext;

ObjCParser.prototype.argument_expression_list = function() {

    var localctx = new Argument_expression_listContext(this, this._ctx, this.state);
    this.enterRule(localctx, 242, ObjCParser.RULE_argument_expression_list);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1323;
        this.assignment_expression();
        this.state = 1328;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ObjCParser.COMMA) {
            this.state = 1324;
            this.match(ObjCParser.COMMA);
            this.state = 1325;
            this.assignment_expression();
            this.state = 1330;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IdentifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_identifier;
    return this;
}

IdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IdentifierContext.prototype.constructor = IdentifierContext;

IdentifierContext.prototype.IDENTIFIER = function() {
    return this.getToken(ObjCParser.IDENTIFIER, 0);
};

IdentifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterIdentifier(this);
	}
};

IdentifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitIdentifier(this);
	}
};




ObjCParser.IdentifierContext = IdentifierContext;

ObjCParser.prototype.identifier = function() {

    var localctx = new IdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 244, ObjCParser.RULE_identifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1331;
        this.match(ObjCParser.IDENTIFIER);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstantContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ObjCParser.RULE_constant;
    return this;
}

ConstantContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantContext.prototype.constructor = ConstantContext;

ConstantContext.prototype.DECIMAL_LITERAL = function() {
    return this.getToken(ObjCParser.DECIMAL_LITERAL, 0);
};

ConstantContext.prototype.HEX_LITERAL = function() {
    return this.getToken(ObjCParser.HEX_LITERAL, 0);
};

ConstantContext.prototype.OCTAL_LITERAL = function() {
    return this.getToken(ObjCParser.OCTAL_LITERAL, 0);
};

ConstantContext.prototype.CHARACTER_LITERAL = function() {
    return this.getToken(ObjCParser.CHARACTER_LITERAL, 0);
};

ConstantContext.prototype.FLOATING_POINT_LITERAL = function() {
    return this.getToken(ObjCParser.FLOATING_POINT_LITERAL, 0);
};

ConstantContext.prototype.enterRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.enterConstant(this);
	}
};

ConstantContext.prototype.exitRule = function(listener) {
    if(listener instanceof ObjCListener ) {
        listener.exitConstant(this);
	}
};




ObjCParser.ConstantContext = ConstantContext;

ObjCParser.prototype.constant = function() {

    var localctx = new ConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 246, ObjCParser.RULE_constant);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1333;
        _la = this._input.LA(1);
        if(!(((((_la - 126)) & ~0x1f) == 0 && ((1 << (_la - 126)) & ((1 << (ObjCParser.CHARACTER_LITERAL - 126)) | (1 << (ObjCParser.HEX_LITERAL - 126)) | (1 << (ObjCParser.DECIMAL_LITERAL - 126)) | (1 << (ObjCParser.OCTAL_LITERAL - 126)) | (1 << (ObjCParser.FLOATING_POINT_LITERAL - 126)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


exports.ObjCParser = ObjCParser;

},{"./ObjCListener":8,"antlr4/index":54}],10:[function(require,module,exports){
// Generated from Scala.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');


var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\2L\u02d4\b\1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t",
    "\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20",
    "\t\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4",
    "\27\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35",
    "\4\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'",
    "\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61",
    "\t\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\4",
    "8\t8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C",
    "\tC\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\t",
    "N\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY",
    "\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3",
    "\4\3\4\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3",
    "\t\3\t\3\n\3\n\3\n\3\13\3\13\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r",
    "\3\16\3\16\3\17\3\17\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3",
    "\22\3\22\3\22\3\22\3\22\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27",
    "\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\27\3\30\3\30\3\30\3\31\3\31\3",
    "\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\32\3\33\3\33\3\33\3\33\3\34",
    "\3\34\3\34\3\34\3\34\3\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3",
    "\36\3\36\3\36\3\37\3\37\3\37\3\37\3 \3 \3 \3 \3 \3 \3!\3!\3!\3!\3!\3",
    "!\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3$\3$\3%\3%\3%\3%\3%\3%\3",
    "&\3&\3\'\3\'\3(\3(\3)\3)\3)\3)\3)\3*\3*\3*\3+\3+\3+\3+\3+\3,\3,\3-\3",
    "-\3.\3.\3.\3/\3/\3/\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\62\3\62\3\62",
    "\3\62\3\62\3\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\3\63\3\63\3",
    "\63\3\63\3\64\3\64\3\64\3\64\3\64\3\64\3\65\3\65\3\65\3\65\3\65\3\65",
    "\3\65\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\67\3\67\3\67\3\67\3",
    "\67\3\67\3\67\3\67\3\67\3\67\38\38\38\38\38\38\38\39\39\39\39\3:\3:",
    "\3:\3:\3:\3:\3;\3;\3;\3;\3;\3;\3;\3<\3<\3<\3<\3<\3<\3=\3=\3=\3=\3=\3",
    "=\3=\3=\3>\3>\3>\3>\3>\3>\3>\3>\3?\3?\3?\3?\3?\3?\3?\3?\3?\5?\u01de",
    "\n?\3@\3@\3@\5@\u01e3\n@\3@\3@\3A\3A\7A\u01e9\nA\fA\16A\u01ec\13A\3",
    "A\3A\3A\3A\3A\3A\3A\3A\3A\3A\5A\u01f8\nA\3B\3B\3B\3C\3C\5C\u01ff\nC",
    "\3C\3C\3D\6D\u0204\nD\rD\16D\u0205\3D\3D\6D\u020a\nD\rD\16D\u020b\3",
    "D\5D\u020f\nD\3D\5D\u0212\nD\3D\3D\6D\u0216\nD\rD\16D\u0217\3D\5D\u021b",
    "\nD\3D\5D\u021e\nD\3D\3D\3D\5D\u0223\nD\3D\6D\u0226\nD\rD\16D\u0227",
    "\3D\5D\u022b\nD\3D\3D\5D\u022f\nD\3E\3E\3E\3E\3E\5E\u0236\nE\3F\3F\3",
    "F\3G\5G\u023c\nG\3G\3G\3H\3H\6H\u0242\nH\rH\16H\u0243\5H\u0246\nH\3",
    "I\3I\3J\3J\3K\3K\3K\3K\7K\u0250\nK\fK\16K\u0253\13K\3K\3K\3K\3K\3K\3",
    "K\7K\u025b\nK\fK\16K\u025e\13K\3K\5K\u0261\nK\3L\3L\3L\5L\u0266\nL\3",
    "L\3L\3L\3L\3L\3M\3M\3N\3N\3O\6O\u0272\nO\rO\16O\u0273\3P\3P\3P\3P\3",
    "P\5P\u027b\nP\3Q\3Q\7Q\u027f\nQ\fQ\16Q\u0282\13Q\3Q\3Q\5Q\u0286\nQ\3",
    "R\3R\5R\u028a\nR\3S\5S\u028d\nS\3S\5S\u0290\nS\3S\7S\u0293\nS\fS\16",
    "S\u0296\13S\7S\u0298\nS\fS\16S\u029b\13S\3S\7S\u029e\nS\fS\16S\u02a1",
    "\13S\3T\3T\3U\3U\3V\3V\3W\3W\3X\3X\5X\u02ad\nX\3Y\3Y\5Y\u02b1\nY\3Y",
    "\6Y\u02b4\nY\rY\16Y\u02b5\3Z\3Z\3[\3[\3[\3\\\3\\\3\\\7\\\u02c0\n\\\f",
    "\\\16\\\u02c3\13\\\5\\\u02c5\n\\\3]\3]\3]\3]\6]\u02cb\n]\r]\16]\u02cc",
    "\3^\3^\5^\u02d1\n^\3_\3_\5\u0251\u025c\u0294\2`\3\3\5\4\7\5\t\6\13\7",
    "\r\b\17\t\21\n\23\13\25\f\27\r\31\16\33\17\35\20\37\21!\22#\23%\24\'",
    "\25)\26+\27-\30/\31\61\32\63\33\65\34\67\359\36;\37= ?!A\"C#E$G%I&K",
    "\'M(O)Q*S+U,W-Y.[/]\60_\61a\62c\63e\64g\65i\66k\67m8o9q:s;u<w=y>{?}",
    "@\177A\u0081B\u0083C\u0085D\u0087E\u0089F\u008bG\u008dH\u008fI\u0091",
    "J\u0093K\u0095L\u0097\2\u0099\2\u009b\2\u009d\2\u009f\2\u00a1\2\u00a3",
    "\2\u00a5\2\u00a7\2\u00a9\2\u00ab\2\u00ad\2\u00af\2\u00b1\2\u00b3\2\u00b5",
    "\2\u00b7\2\u00b9\2\u00bb\2\u00bd\2\3\2\r\4\2NNnn\7\2*+]]__}}\177\177",
    "\b\2$$))..\60\60==bb\5\2\13\f\17\17\"\"\4\2\"#%\u0081\5\2\62;C\\c|\6",
    "\2FFHHffhh\5\2&&C\\aa\4\2GGgg\4\2--//\n\2$$))^^ddhhppttvv\u02ec\2\3",
    "\3\2\2\2\2\5\3\2\2\2\2\7\3\2\2\2\2\t\3\2\2\2\2\13\3\2\2\2\2\r\3\2\2",
    "\2\2\17\3\2\2\2\2\21\3\2\2\2\2\23\3\2\2\2\2\25\3\2\2\2\2\27\3\2\2\2",
    "\2\31\3\2\2\2\2\33\3\2\2\2\2\35\3\2\2\2\2\37\3\2\2\2\2!\3\2\2\2\2#\3",
    "\2\2\2\2%\3\2\2\2\2\'\3\2\2\2\2)\3\2\2\2\2+\3\2\2\2\2-\3\2\2\2\2/\3",
    "\2\2\2\2\61\3\2\2\2\2\63\3\2\2\2\2\65\3\2\2\2\2\67\3\2\2\2\29\3\2\2",
    "\2\2;\3\2\2\2\2=\3\2\2\2\2?\3\2\2\2\2A\3\2\2\2\2C\3\2\2\2\2E\3\2\2\2",
    "\2G\3\2\2\2\2I\3\2\2\2\2K\3\2\2\2\2M\3\2\2\2\2O\3\2\2\2\2Q\3\2\2\2\2",
    "S\3\2\2\2\2U\3\2\2\2\2W\3\2\2\2\2Y\3\2\2\2\2[\3\2\2\2\2]\3\2\2\2\2_",
    "\3\2\2\2\2a\3\2\2\2\2c\3\2\2\2\2e\3\2\2\2\2g\3\2\2\2\2i\3\2\2\2\2k\3",
    "\2\2\2\2m\3\2\2\2\2o\3\2\2\2\2q\3\2\2\2\2s\3\2\2\2\2u\3\2\2\2\2w\3\2",
    "\2\2\2y\3\2\2\2\2{\3\2\2\2\2}\3\2\2\2\2\177\3\2\2\2\2\u0081\3\2\2\2",
    "\2\u0083\3\2\2\2\2\u0085\3\2\2\2\2\u0087\3\2\2\2\2\u0089\3\2\2\2\2\u008b",
    "\3\2\2\2\2\u008d\3\2\2\2\2\u008f\3\2\2\2\2\u0091\3\2\2\2\2\u0093\3\2",
    "\2\2\2\u0095\3\2\2\2\3\u00bf\3\2\2\2\5\u00c1\3\2\2\2\7\u00c6\3\2\2\2",
    "\t\u00c8\3\2\2\2\13\u00ca\3\2\2\2\r\u00cf\3\2\2\2\17\u00d5\3\2\2\2\21",
    "\u00d7\3\2\2\2\23\u00d9\3\2\2\2\25\u00dc\3\2\2\2\27\u00de\3\2\2\2\31",
    "\u00e0\3\2\2\2\33\u00e8\3\2\2\2\35\u00ea\3\2\2\2\37\u00ec\3\2\2\2!\u00f1",
    "\3\2\2\2#\u00f5\3\2\2\2%\u00fa\3\2\2\2\'\u00fc\3\2\2\2)\u00fe\3\2\2",
    "\2+\u0100\3\2\2\2-\u0102\3\2\2\2/\u010b\3\2\2\2\61\u010e\3\2\2\2\63",
    "\u0113\3\2\2\2\65\u0119\3\2\2\2\67\u011d\3\2\2\29\u0123\3\2\2\2;\u012b",
    "\3\2\2\2=\u012e\3\2\2\2?\u0132\3\2\2\2A\u0138\3\2\2\2C\u013e\3\2\2\2",
    "E\u0145\3\2\2\2G\u0149\3\2\2\2I\u014b\3\2\2\2K\u0151\3\2\2\2M\u0153",
    "\3\2\2\2O\u0155\3\2\2\2Q\u0157\3\2\2\2S\u015c\3\2\2\2U\u015f\3\2\2\2",
    "W\u0164\3\2\2\2Y\u0166\3\2\2\2[\u0168\3\2\2\2]\u016b\3\2\2\2_\u016e",
    "\3\2\2\2a\u0171\3\2\2\2c\u0175\3\2\2\2e\u017e\3\2\2\2g\u0187\3\2\2\2",
    "i\u018d\3\2\2\2k\u0194\3\2\2\2m\u019c\3\2\2\2o\u01a6\3\2\2\2q\u01ad",
    "\3\2\2\2s\u01b1\3\2\2\2u\u01b7\3\2\2\2w\u01be\3\2\2\2y\u01c4\3\2\2\2",
    "{\u01cc\3\2\2\2}\u01dd\3\2\2\2\177\u01df\3\2\2\2\u0081\u01f7\3\2\2\2",
    "\u0083\u01f9\3\2\2\2\u0085\u01fe\3\2\2\2\u0087\u022e\3\2\2\2\u0089\u0235",
    "\3\2\2\2\u008b\u0237\3\2\2\2\u008d\u023b\3\2\2\2\u008f\u0245\3\2\2\2",
    "\u0091\u0247\3\2\2\2\u0093\u0249\3\2\2\2\u0095\u0260\3\2\2\2\u0097\u0262",
    "\3\2\2\2\u0099\u026c\3\2\2\2\u009b\u026e\3\2\2\2\u009d\u0271\3\2\2\2",
    "\u009f\u027a\3\2\2\2\u00a1\u0280\3\2\2\2\u00a3\u0289\3\2\2\2\u00a5\u0299",
    "\3\2\2\2\u00a7\u02a2\3\2\2\2\u00a9\u02a4\3\2\2\2\u00ab\u02a6\3\2\2\2",
    "\u00ad\u02a8\3\2\2\2\u00af\u02ac\3\2\2\2\u00b1\u02ae\3\2\2\2\u00b3\u02b7",
    "\3\2\2\2\u00b5\u02b9\3\2\2\2\u00b7\u02c4\3\2\2\2\u00b9\u02c6\3\2\2\2",
    "\u00bb\u02d0\3\2\2\2\u00bd\u02d2\3\2\2\2\u00bf\u00c0\7/\2\2\u00c0\4",
    "\3\2\2\2\u00c1\u00c2\7p\2\2\u00c2\u00c3\7w\2\2\u00c3\u00c4\7n\2\2\u00c4",
    "\u00c5\7n\2\2\u00c5\6\3\2\2\2\u00c6\u00c7\7\60\2\2\u00c7\b\3\2\2\2\u00c8",
    "\u00c9\7.\2\2\u00c9\n\3\2\2\2\u00ca\u00cb\7v\2\2\u00cb\u00cc\7j\2\2",
    "\u00cc\u00cd\7k\2\2\u00cd\u00ce\7u\2\2\u00ce\f\3\2\2\2\u00cf\u00d0\7",
    "u\2\2\u00d0\u00d1\7w\2\2\u00d1\u00d2\7r\2\2\u00d2\u00d3\7g\2\2\u00d3",
    "\u00d4\7t\2\2\u00d4\16\3\2\2\2\u00d5\u00d6\7]\2\2\u00d6\20\3\2\2\2\u00d7",
    "\u00d8\7_\2\2\u00d8\22\3\2\2\2\u00d9\u00da\7?\2\2\u00da\u00db\7@\2\2",
    "\u00db\24\3\2\2\2\u00dc\u00dd\7*\2\2\u00dd\26\3\2\2\2\u00de\u00df\7",
    "+\2\2\u00df\30\3\2\2\2\u00e0\u00e1\7h\2\2\u00e1\u00e2\7q\2\2\u00e2\u00e3",
    "\7t\2\2\u00e3\u00e4\7U\2\2\u00e4\u00e5\7q\2\2\u00e5\u00e6\7o\2\2\u00e6",
    "\u00e7\7g\2\2\u00e7\32\3\2\2\2\u00e8\u00e9\7}\2\2\u00e9\34\3\2\2\2\u00ea",
    "\u00eb\7\177\2\2\u00eb\36\3\2\2\2\u00ec\u00ed\7v\2\2\u00ed\u00ee\7{",
    "\2\2\u00ee\u00ef\7r\2\2\u00ef\u00f0\7g\2\2\u00f0 \3\2\2\2\u00f1\u00f2",
    "\7x\2\2\u00f2\u00f3\7c\2\2\u00f3\u00f4\7n\2\2\u00f4\"\3\2\2\2\u00f5",
    "\u00f6\7y\2\2\u00f6\u00f7\7k\2\2\u00f7\u00f8\7v\2\2\u00f8\u00f9\7j\2",
    "\2\u00f9$\3\2\2\2\u00fa\u00fb\7%\2\2\u00fb&\3\2\2\2\u00fc\u00fd\7<\2",
    "\2\u00fd(\3\2\2\2\u00fe\u00ff\7a\2\2\u00ff*\3\2\2\2\u0100\u0101\7,\2",
    "\2\u0101,\3\2\2\2\u0102\u0103\7k\2\2\u0103\u0104\7o\2\2\u0104\u0105",
    "\7r\2\2\u0105\u0106\7n\2\2\u0106\u0107\7k\2\2\u0107\u0108\7e\2\2\u0108",
    "\u0109\7k\2\2\u0109\u010a\7v\2\2\u010a.\3\2\2\2\u010b\u010c\7k\2\2\u010c",
    "\u010d\7h\2\2\u010d\60\3\2\2\2\u010e\u010f\7g\2\2\u010f\u0110\7n\2\2",
    "\u0110\u0111\7u\2\2\u0111\u0112\7g\2\2\u0112\62\3\2\2\2\u0113\u0114",
    "\7y\2\2\u0114\u0115\7j\2\2\u0115\u0116\7k\2\2\u0116\u0117\7n\2\2\u0117",
    "\u0118\7g\2\2\u0118\64\3\2\2\2\u0119\u011a\7v\2\2\u011a\u011b\7t\2\2",
    "\u011b\u011c\7{\2\2\u011c\66\3\2\2\2\u011d\u011e\7e\2\2\u011e\u011f",
    "\7c\2\2\u011f\u0120\7v\2\2\u0120\u0121\7e\2\2\u0121\u0122\7j\2\2\u0122",
    "8\3\2\2\2\u0123\u0124\7h\2\2\u0124\u0125\7k\2\2\u0125\u0126\7p\2\2\u0126",
    "\u0127\7c\2\2\u0127\u0128\7n\2\2\u0128\u0129\7n\2\2\u0129\u012a\7{\2",
    "\2\u012a:\3\2\2\2\u012b\u012c\7f\2\2\u012c\u012d\7q\2\2\u012d<\3\2\2",
    "\2\u012e\u012f\7h\2\2\u012f\u0130\7q\2\2\u0130\u0131\7t\2\2\u0131>\3",
    "\2\2\2\u0132\u0133\7{\2\2\u0133\u0134\7k\2\2\u0134\u0135\7g\2\2\u0135",
    "\u0136\7n\2\2\u0136\u0137\7f\2\2\u0137@\3\2\2\2\u0138\u0139\7v\2\2\u0139",
    "\u013a\7j\2\2\u013a\u013b\7t\2\2\u013b\u013c\7q\2\2\u013c\u013d\7y\2",
    "\2\u013dB\3\2\2\2\u013e\u013f\7t\2\2\u013f\u0140\7g\2\2\u0140\u0141",
    "\7v\2\2\u0141\u0142\7w\2\2\u0142\u0143\7t\2\2\u0143\u0144\7p\2\2\u0144",
    "D\3\2\2\2\u0145\u0146\7p\2\2\u0146\u0147\7g\2\2\u0147\u0148\7y\2\2\u0148",
    "F\3\2\2\2\u0149\u014a\7?\2\2\u014aH\3\2\2\2\u014b\u014c\7o\2\2\u014c",
    "\u014d\7c\2\2\u014d\u014e\7v\2\2\u014e\u014f\7e\2\2\u014f\u0150\7j\2",
    "\2\u0150J\3\2\2\2\u0151\u0152\7-\2\2\u0152L\3\2\2\2\u0153\u0154\7\u0080",
    "\2\2\u0154N\3\2\2\2\u0155\u0156\7#\2\2\u0156P\3\2\2\2\u0157\u0158\7",
    "n\2\2\u0158\u0159\7c\2\2\u0159\u015a\7|\2\2\u015a\u015b\7{\2\2\u015b",
    "R\3\2\2\2\u015c\u015d\7>\2\2\u015d\u015e\7/\2\2\u015eT\3\2\2\2\u015f",
    "\u0160\7e\2\2\u0160\u0161\7c\2\2\u0161\u0162\7u\2\2\u0162\u0163\7g\2",
    "\2\u0163V\3\2\2\2\u0164\u0165\7~\2\2\u0165X\3\2\2\2\u0166\u0167\7B\2",
    "\2\u0167Z\3\2\2\2\u0168\u0169\7@\2\2\u0169\u016a\7<\2\2\u016a\\\3\2",
    "\2\2\u016b\u016c\7>\2\2\u016c\u016d\7<\2\2\u016d^\3\2\2\2\u016e\u016f",
    "\7>\2\2\u016f\u0170\7\'\2\2\u0170`\3\2\2\2\u0171\u0172\7x\2\2\u0172",
    "\u0173\7c\2\2\u0173\u0174\7t\2\2\u0174b\3\2\2\2\u0175\u0176\7q\2\2\u0176",
    "\u0177\7x\2\2\u0177\u0178\7g\2\2\u0178\u0179\7t\2\2\u0179\u017a\7t\2",
    "\2\u017a\u017b\7k\2\2\u017b\u017c\7f\2\2\u017c\u017d\7g\2\2\u017dd\3",
    "\2\2\2\u017e\u017f\7c\2\2\u017f\u0180\7d\2\2\u0180\u0181\7u\2\2\u0181",
    "\u0182\7v\2\2\u0182\u0183\7t\2\2\u0183\u0184\7c\2\2\u0184\u0185\7e\2",
    "\2\u0185\u0186\7v\2\2\u0186f\3\2\2\2\u0187\u0188\7h\2\2\u0188\u0189",
    "\7k\2\2\u0189\u018a\7p\2\2\u018a\u018b\7c\2\2\u018b\u018c\7n\2\2\u018c",
    "h\3\2\2\2\u018d\u018e\7u\2\2\u018e\u018f\7g\2\2\u018f\u0190\7c\2\2\u0190",
    "\u0191\7n\2\2\u0191\u0192\7g\2\2\u0192\u0193\7f\2\2\u0193j\3\2\2\2\u0194",
    "\u0195\7r\2\2\u0195\u0196\7t\2\2\u0196\u0197\7k\2\2\u0197\u0198\7x\2",
    "\2\u0198\u0199\7c\2\2\u0199\u019a\7v\2\2\u019a\u019b\7g\2\2\u019bl\3",
    "\2\2\2\u019c\u019d\7r\2\2\u019d\u019e\7t\2\2\u019e\u019f\7q\2\2\u019f",
    "\u01a0\7v\2\2\u01a0\u01a1\7g\2\2\u01a1\u01a2\7e\2\2\u01a2\u01a3\7v\2",
    "\2\u01a3\u01a4\7g\2\2\u01a4\u01a5\7f\2\2\u01a5n\3\2\2\2\u01a6\u01a7",
    "\7k\2\2\u01a7\u01a8\7o\2\2\u01a8\u01a9\7r\2\2\u01a9\u01aa\7q\2\2\u01aa",
    "\u01ab\7t\2\2\u01ab\u01ac\7v\2\2\u01acp\3\2\2\2\u01ad\u01ae\7f\2\2\u01ae",
    "\u01af\7g\2\2\u01af\u01b0\7h\2\2\u01b0r\3\2\2\2\u01b1\u01b2\7e\2\2\u01b2",
    "\u01b3\7n\2\2\u01b3\u01b4\7c\2\2\u01b4\u01b5\7u\2\2\u01b5\u01b6\7u\2",
    "\2\u01b6t\3\2\2\2\u01b7\u01b8\7q\2\2\u01b8\u01b9\7d\2\2\u01b9\u01ba",
    "\7l\2\2\u01ba\u01bb\7g\2\2\u01bb\u01bc\7e\2\2\u01bc\u01bd\7v\2\2\u01bd",
    "v\3\2\2\2\u01be\u01bf\7v\2\2\u01bf\u01c0\7t\2\2\u01c0\u01c1\7c\2\2\u01c1",
    "\u01c2\7k\2\2\u01c2\u01c3\7v\2\2\u01c3x\3\2\2\2\u01c4\u01c5\7g\2\2\u01c5",
    "\u01c6\7z\2\2\u01c6\u01c7\7v\2\2\u01c7\u01c8\7g\2\2\u01c8\u01c9\7p\2",
    "\2\u01c9\u01ca\7f\2\2\u01ca\u01cb\7u\2\2\u01cbz\3\2\2\2\u01cc\u01cd",
    "\7r\2\2\u01cd\u01ce\7c\2\2\u01ce\u01cf\7e\2\2\u01cf\u01d0\7m\2\2\u01d0",
    "\u01d1\7c\2\2\u01d1\u01d2\7i\2\2\u01d2\u01d3\7g\2\2\u01d3|\3\2\2\2\u01d4",
    "\u01d5\7v\2\2\u01d5\u01d6\7t\2\2\u01d6\u01d7\7w\2\2\u01d7\u01de\7g\2",
    "\2\u01d8\u01d9\7h\2\2\u01d9\u01da\7c\2\2\u01da\u01db\7n\2\2\u01db\u01dc",
    "\7u\2\2\u01dc\u01de\7g\2\2\u01dd\u01d4\3\2\2\2\u01dd\u01d8\3\2\2\2\u01de",
    "~\3\2\2\2\u01df\u01e2\7)\2\2\u01e0\u01e3\5\u00b3Z\2\u01e1\u01e3\5\u00b5",
    "[\2\u01e2\u01e0\3\2\2\2\u01e2\u01e1\3\2\2\2\u01e3\u01e4\3\2\2\2\u01e4",
    "\u01e5\7)\2\2\u01e5\u0080\3\2\2\2\u01e6\u01ea\7$\2\2\u01e7\u01e9\5\u00a3",
    "R\2\u01e8\u01e7\3\2\2\2\u01e9\u01ec\3\2\2\2\u01ea\u01e8\3\2\2\2\u01ea",
    "\u01eb\3\2\2\2\u01eb\u01ed\3\2\2\2\u01ec\u01ea\3\2\2\2\u01ed\u01f8\7",
    "$\2\2\u01ee\u01ef\7$\2\2\u01ef\u01f0\7$\2\2\u01f0\u01f1\7$\2\2\u01f1",
    "\u01f2\3\2\2\2\u01f2\u01f3\5\u00a5S\2\u01f3\u01f4\7$\2\2\u01f4\u01f5",
    "\7$\2\2\u01f5\u01f6\7$\2\2\u01f6\u01f8\3\2\2\2\u01f7\u01e6\3\2\2\2\u01f7",
    "\u01ee\3\2\2\2\u01f8\u0082\3\2\2\2\u01f9\u01fa\7)\2\2\u01fa\u01fb\5",
    "\u009fP\2\u01fb\u0084\3\2\2\2\u01fc\u01ff\5\u00b7\\\2\u01fd\u01ff\5",
    "\u00b9]\2\u01fe\u01fc\3\2\2\2\u01fe\u01fd\3\2\2\2\u01ff\u0200\3\2\2",
    "\2\u0200\u0201\t\2\2\2\u0201\u0086\3\2\2\2\u0202\u0204\5\u00bb^\2\u0203",
    "\u0202\3\2\2\2\u0204\u0205\3\2\2\2\u0205\u0203\3\2\2\2\u0205\u0206\3",
    "\2\2\2\u0206\u0207\3\2\2\2\u0207\u0209\7\60\2\2\u0208\u020a\5\u00bb",
    "^\2\u0209\u0208\3\2\2\2\u020a\u020b\3\2\2\2\u020b\u0209\3\2\2\2\u020b",
    "\u020c\3\2\2\2\u020c\u020e\3\2\2\2\u020d\u020f\5\u00b1Y\2\u020e\u020d",
    "\3\2\2\2\u020e\u020f\3\2\2\2\u020f\u0211\3\2\2\2\u0210\u0212\5\u00a9",
    "U\2\u0211\u0210\3\2\2\2\u0211\u0212\3\2\2\2\u0212\u022f\3\2\2\2\u0213",
    "\u0215\7\60\2\2\u0214\u0216\5\u00bb^\2\u0215\u0214\3\2\2\2\u0216\u0217",
    "\3\2\2\2\u0217\u0215\3\2\2\2\u0217\u0218\3\2\2\2\u0218\u021a\3\2\2\2",
    "\u0219\u021b\5\u00b1Y\2\u021a\u0219\3\2\2\2\u021a\u021b\3\2\2\2\u021b",
    "\u021d\3\2\2\2\u021c\u021e\5\u00a9U\2\u021d\u021c\3\2\2\2\u021d\u021e",
    "\3\2\2\2\u021e\u022f\3\2\2\2\u021f\u0220\5\u00bb^\2\u0220\u0222\5\u00b1",
    "Y\2\u0221\u0223\5\u00a9U\2\u0222\u0221\3\2\2\2\u0222\u0223\3\2\2\2\u0223",
    "\u022f\3\2\2\2\u0224\u0226\5\u00bb^\2\u0225\u0224\3\2\2\2\u0226\u0227",
    "\3\2\2\2\u0227\u0225\3\2\2\2\u0227\u0228\3\2\2\2\u0228\u022a\3\2\2\2",
    "\u0229\u022b\5\u00b1Y\2\u022a\u0229\3\2\2\2\u022a\u022b\3\2\2\2\u022b",
    "\u022c\3\2\2\2\u022c\u022d\5\u00a9U\2\u022d\u022f\3\2\2\2\u022e\u0203",
    "\3\2\2\2\u022e\u0213\3\2\2\2\u022e\u021f\3\2\2\2\u022e\u0225\3\2\2\2",
    "\u022f\u0088\3\2\2\2\u0230\u0236\5\u009fP\2\u0231\u0232\7b\2\2\u0232",
    "\u0233\5\u0081A\2\u0233\u0234\7b\2\2\u0234\u0236\3\2\2\2\u0235\u0230",
    "\3\2\2\2\u0235\u0231\3\2\2\2\u0236\u008a\3\2\2\2\u0237\u0238\5\u00ad",
    "W\2\u0238\u0239\5\u00a1Q\2\u0239\u008c\3\2\2\2\u023a\u023c\7\17\2\2",
    "\u023b\u023a\3\2\2\2\u023b\u023c\3\2\2\2\u023c\u023d\3\2\2\2\u023d\u023e",
    "\7\f\2\2\u023e\u008e\3\2\2\2\u023f\u0246\7=\2\2\u0240\u0242\5\u008d",
    "G\2\u0241\u0240\3\2\2\2\u0242\u0243\3\2\2\2\u0243\u0241\3\2\2\2\u0243",
    "\u0244\3\2\2\2\u0244\u0246\3\2\2\2\u0245\u023f\3\2\2\2\u0245\u0241\3",
    "\2\2\2\u0246\u0090\3\2\2\2\u0247\u0248\t\3\2\2\u0248\u0092\3\2\2\2\u0249",
    "\u024a\t\4\2\2\u024a\u0094\3\2\2\2\u024b\u024c\7\61\2\2\u024c\u024d",
    "\7,\2\2\u024d\u0251\3\2\2\2\u024e\u0250\13\2\2\2\u024f\u024e\3\2\2\2",
    "\u0250\u0253\3\2\2\2\u0251\u0252\3\2\2\2\u0251\u024f\3\2\2\2\u0252\u0254",
    "\3\2\2\2\u0253\u0251\3\2\2\2\u0254\u0255\7,\2\2\u0255\u0261\7\61\2\2",
    "\u0256\u0257\7\61\2\2\u0257\u0258\7\61\2\2\u0258\u025c\3\2\2\2\u0259",
    "\u025b\13\2\2\2\u025a\u0259\3\2\2\2\u025b\u025e\3\2\2\2\u025c\u025d",
    "\3\2\2\2\u025c\u025a\3\2\2\2\u025d\u025f\3\2\2\2\u025e\u025c\3\2\2\2",
    "\u025f\u0261\5\u008dG\2\u0260\u024b\3\2\2\2\u0260\u0256\3\2\2\2\u0261",
    "\u0096\3\2\2\2\u0262\u0263\7^\2\2\u0263\u0265\7w\2\2\u0264\u0266\7w",
    "\2\2\u0265\u0264\3\2\2\2\u0265\u0266\3\2\2\2\u0266\u0267\3\2\2\2\u0267",
    "\u0268\5\u00a7T\2\u0268\u0269\5\u00a7T\2\u0269\u026a\5\u00a7T\2\u026a",
    "\u026b\5\u00a7T\2\u026b\u0098\3\2\2\2\u026c\u026d\t\5\2\2\u026d\u009a",
    "\3\2\2\2\u026e\u026f\5\u00b3Z\2\u026f\u009c\3\2\2\2\u0270\u0272\5\u009b",
    "N\2\u0271\u0270\3\2\2\2\u0272\u0273\3\2\2\2\u0273\u0271\3\2\2\2\u0273",
    "\u0274\3\2\2\2\u0274\u009e\3\2\2\2\u0275\u0276\5\u00abV\2\u0276\u0277",
    "\5\u00a1Q\2\u0277\u027b\3\2\2\2\u0278\u027b\5\u008bF\2\u0279\u027b\5",
    "\u009dO\2\u027a\u0275\3\2\2\2\u027a\u0278\3\2\2\2\u027a\u0279\3\2\2",
    "\2\u027b\u00a0\3\2\2\2\u027c\u027f\5\u00afX\2\u027d\u027f\5\u00bb^\2",
    "\u027e\u027c\3\2\2\2\u027e\u027d\3\2\2\2\u027f\u0282\3\2\2\2\u0280\u027e",
    "\3\2\2\2\u0280\u0281\3\2\2\2\u0281\u0285\3\2\2\2\u0282\u0280\3\2\2\2",
    "\u0283\u0284\7a\2\2\u0284\u0286\5\u009dO\2\u0285\u0283\3\2\2\2\u0285",
    "\u0286\3\2\2\2\u0286\u00a2\3\2\2\2\u0287\u028a\t\6\2\2\u0288\u028a\5",
    "\u00b5[\2\u0289\u0287\3\2\2\2\u0289\u0288\3\2\2\2\u028a\u00a4\3\2\2",
    "\2\u028b\u028d\7$\2\2\u028c\u028b\3\2\2\2\u028c\u028d\3\2\2\2\u028d",
    "\u028f\3\2\2\2\u028e\u0290\7$\2\2\u028f\u028e\3\2\2\2\u028f\u0290\3",
    "\2\2\2\u0290\u0294\3\2\2\2\u0291\u0293\13\2\2\2\u0292\u0291\3\2\2\2",
    "\u0293\u0296\3\2\2\2\u0294\u0295\3\2\2\2\u0294\u0292\3\2\2\2\u0295\u0298",
    "\3\2\2\2\u0296\u0294\3\2\2\2\u0297\u028c\3\2\2\2\u0298\u029b\3\2\2\2",
    "\u0299\u0297\3\2\2\2\u0299\u029a\3\2\2\2\u029a\u029f\3\2\2\2\u029b\u0299",
    "\3\2\2\2\u029c\u029e\7$\2\2\u029d\u029c\3\2\2\2\u029e\u02a1\3\2\2\2",
    "\u029f\u029d\3\2\2\2\u029f\u02a0\3\2\2\2\u02a0\u00a6\3\2\2\2\u02a1\u029f",
    "\3\2\2\2\u02a2\u02a3\t\7\2\2\u02a3\u00a8\3\2\2\2\u02a4\u02a5\t\b\2\2",
    "\u02a5\u00aa\3\2\2\2\u02a6\u02a7\t\t\2\2\u02a7\u00ac\3\2\2\2\u02a8\u02a9",
    "\4c|\2\u02a9\u00ae\3\2\2\2\u02aa\u02ad\5\u00abV\2\u02ab\u02ad\5\u00ad",
    "W\2\u02ac\u02aa\3\2\2\2\u02ac\u02ab\3\2\2\2\u02ad\u00b0\3\2\2\2\u02ae",
    "\u02b0\t\n\2\2\u02af\u02b1\t\13\2\2\u02b0\u02af\3\2\2\2\u02b0\u02b1",
    "\3\2\2\2\u02b1\u02b3\3\2\2\2\u02b2\u02b4\5\u00bb^\2\u02b3\u02b2\3\2",
    "\2\2\u02b4\u02b5\3\2\2\2\u02b5\u02b3\3\2\2\2\u02b5\u02b6\3\2\2\2\u02b6",
    "\u00b2\3\2\2\2\u02b7\u02b8\4\"\u0081\2\u02b8\u00b4\3\2\2\2\u02b9\u02ba",
    "\7^\2\2\u02ba\u02bb\t\f\2\2\u02bb\u00b6\3\2\2\2\u02bc\u02c5\7\62\2\2",
    "\u02bd\u02c1\5\u00bd_\2\u02be\u02c0\5\u00bb^\2\u02bf\u02be\3\2\2\2\u02c0",
    "\u02c3\3\2\2\2\u02c1\u02bf\3\2\2\2\u02c1\u02c2\3\2\2\2\u02c2\u02c5\3",
    "\2\2\2\u02c3\u02c1\3\2\2\2\u02c4\u02bc\3\2\2\2\u02c4\u02bd\3\2\2\2\u02c5",
    "\u00b8\3\2\2\2\u02c6\u02c7\7\62\2\2\u02c7\u02c8\7z\2\2\u02c8\u02ca\5",
    "\u00a7T\2\u02c9\u02cb\5\u00a7T\2\u02ca\u02c9\3\2\2\2\u02cb\u02cc\3\2",
    "\2\2\u02cc\u02ca\3\2\2\2\u02cc\u02cd\3\2\2\2\u02cd\u00ba\3\2\2\2\u02ce",
    "\u02d1\7\62\2\2\u02cf\u02d1\5\u00bd_\2\u02d0\u02ce\3\2\2\2\u02d0\u02cf",
    "\3\2\2\2\u02d1\u00bc\3\2\2\2\u02d2\u02d3\4\63;\2\u02d3\u00be\3\2\2\2",
    "-\2\u01dd\u01e2\u01ea\u01f7\u01fe\u0205\u020b\u020e\u0211\u0217\u021a",
    "\u021d\u0222\u0227\u022a\u022e\u0235\u023b\u0243\u0245\u0251\u025c\u0260",
    "\u0265\u0273\u027a\u027e\u0280\u0285\u0289\u028c\u028f\u0294\u0299\u029f",
    "\u02ac\u02b0\u02b5\u02c1\u02c4\u02cc\u02d0\2"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function ScalaLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

ScalaLexer.prototype = Object.create(antlr4.Lexer.prototype);
ScalaLexer.prototype.constructor = ScalaLexer;

ScalaLexer.EOF = antlr4.Token.EOF;
ScalaLexer.T__0 = 1;
ScalaLexer.T__1 = 2;
ScalaLexer.T__2 = 3;
ScalaLexer.T__3 = 4;
ScalaLexer.T__4 = 5;
ScalaLexer.T__5 = 6;
ScalaLexer.T__6 = 7;
ScalaLexer.T__7 = 8;
ScalaLexer.T__8 = 9;
ScalaLexer.T__9 = 10;
ScalaLexer.T__10 = 11;
ScalaLexer.T__11 = 12;
ScalaLexer.T__12 = 13;
ScalaLexer.T__13 = 14;
ScalaLexer.T__14 = 15;
ScalaLexer.T__15 = 16;
ScalaLexer.T__16 = 17;
ScalaLexer.T__17 = 18;
ScalaLexer.T__18 = 19;
ScalaLexer.T__19 = 20;
ScalaLexer.T__20 = 21;
ScalaLexer.T__21 = 22;
ScalaLexer.T__22 = 23;
ScalaLexer.T__23 = 24;
ScalaLexer.T__24 = 25;
ScalaLexer.T__25 = 26;
ScalaLexer.T__26 = 27;
ScalaLexer.T__27 = 28;
ScalaLexer.T__28 = 29;
ScalaLexer.T__29 = 30;
ScalaLexer.T__30 = 31;
ScalaLexer.T__31 = 32;
ScalaLexer.T__32 = 33;
ScalaLexer.T__33 = 34;
ScalaLexer.T__34 = 35;
ScalaLexer.T__35 = 36;
ScalaLexer.T__36 = 37;
ScalaLexer.T__37 = 38;
ScalaLexer.T__38 = 39;
ScalaLexer.T__39 = 40;
ScalaLexer.T__40 = 41;
ScalaLexer.T__41 = 42;
ScalaLexer.T__42 = 43;
ScalaLexer.T__43 = 44;
ScalaLexer.T__44 = 45;
ScalaLexer.T__45 = 46;
ScalaLexer.T__46 = 47;
ScalaLexer.T__47 = 48;
ScalaLexer.T__48 = 49;
ScalaLexer.T__49 = 50;
ScalaLexer.T__50 = 51;
ScalaLexer.T__51 = 52;
ScalaLexer.T__52 = 53;
ScalaLexer.T__53 = 54;
ScalaLexer.T__54 = 55;
ScalaLexer.T__55 = 56;
ScalaLexer.T__56 = 57;
ScalaLexer.T__57 = 58;
ScalaLexer.T__58 = 59;
ScalaLexer.T__59 = 60;
ScalaLexer.T__60 = 61;
ScalaLexer.BooleanLiteral = 62;
ScalaLexer.CharacterLiteral = 63;
ScalaLexer.StringLiteral = 64;
ScalaLexer.SymbolLiteral = 65;
ScalaLexer.IntegerLiteral = 66;
ScalaLexer.FloatingPointLiteral = 67;
ScalaLexer.Id = 68;
ScalaLexer.Varid = 69;
ScalaLexer.Nl = 70;
ScalaLexer.Semi = 71;
ScalaLexer.Paren = 72;
ScalaLexer.Delim = 73;
ScalaLexer.Comment = 74;


ScalaLexer.modeNames = [ "DEFAULT_MODE" ];

ScalaLexer.literalNames = [ 'null', "'-'", "'null'", "'.'", "','", "'this'", 
                            "'super'", "'['", "']'", "'=>'", "'('", "')'", 
                            "'forSome'", "'{'", "'}'", "'type'", "'val'", 
                            "'with'", "'#'", "':'", "'_'", "'*'", "'implicit'", 
                            "'if'", "'else'", "'while'", "'try'", "'catch'", 
                            "'finally'", "'do'", "'for'", "'yield'", "'throw'", 
                            "'return'", "'new'", "'='", "'match'", "'+'", 
                            "'~'", "'!'", "'lazy'", "'<-'", "'case'", "'|'", 
                            "'@'", "'>:'", "'<:'", "'<%'", "'var'", "'override'", 
                            "'abstract'", "'final'", "'sealed'", "'private'", 
                            "'protected'", "'import'", "'def'", "'class'", 
                            "'object'", "'trait'", "'extends'", "'package'" ];

ScalaLexer.symbolicNames = [ 'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', 'null', 'null', 'null', 'null', 
                             'null', 'null', "BooleanLiteral", "CharacterLiteral", 
                             "StringLiteral", "SymbolLiteral", "IntegerLiteral", 
                             "FloatingPointLiteral", "Id", "Varid", "Nl", 
                             "Semi", "Paren", "Delim", "Comment" ];

ScalaLexer.ruleNames = [ "T__0", "T__1", "T__2", "T__3", "T__4", "T__5", 
                         "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", 
                         "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", 
                         "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", 
                         "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", 
                         "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", 
                         "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", 
                         "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", 
                         "T__48", "T__49", "T__50", "T__51", "T__52", "T__53", 
                         "T__54", "T__55", "T__56", "T__57", "T__58", "T__59", 
                         "T__60", "BooleanLiteral", "CharacterLiteral", 
                         "StringLiteral", "SymbolLiteral", "IntegerLiteral", 
                         "FloatingPointLiteral", "Id", "Varid", "Nl", "Semi", 
                         "Paren", "Delim", "Comment", "UnicodeEscape", "WhiteSpace", 
                         "Opchar", "Op", "Plainid", "Idrest", "StringElement", 
                         "MultiLineChars", "HexDigit", "FloatType", "Upper", 
                         "Lower", "Letter", "ExponentPart", "PrintableChar", 
                         "CharEscapeSeq", "DecimalNumeral", "HexNumeral", 
                         "Digit", "NonZeroDigit" ];

ScalaLexer.grammarFileName = "Scala.g4";



exports.ScalaLexer = ScalaLexer;


},{"antlr4/index":54}],11:[function(require,module,exports){
// Generated from Scala.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');

// This class defines a complete listener for a parse tree produced by ScalaParser.
function ScalaListener() {
	antlr4.tree.ParseTreeListener.call(this);
	return this;
}

ScalaListener.prototype = Object.create(antlr4.tree.ParseTreeListener.prototype);
ScalaListener.prototype.constructor = ScalaListener;

// Enter a parse tree produced by ScalaParser#literal.
ScalaListener.prototype.enterLiteral = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#literal.
ScalaListener.prototype.exitLiteral = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#qualId.
ScalaListener.prototype.enterQualId = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#qualId.
ScalaListener.prototype.exitQualId = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#ids.
ScalaListener.prototype.enterIds = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#ids.
ScalaListener.prototype.exitIds = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#stableId.
ScalaListener.prototype.enterStableId = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#stableId.
ScalaListener.prototype.exitStableId = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classQualifier.
ScalaListener.prototype.enterClassQualifier = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classQualifier.
ScalaListener.prototype.exitClassQualifier = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#type.
ScalaListener.prototype.enterType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#type.
ScalaListener.prototype.exitType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#functionArgTypes.
ScalaListener.prototype.enterFunctionArgTypes = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#functionArgTypes.
ScalaListener.prototype.exitFunctionArgTypes = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#existentialClause.
ScalaListener.prototype.enterExistentialClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#existentialClause.
ScalaListener.prototype.exitExistentialClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#existentialDcl.
ScalaListener.prototype.enterExistentialDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#existentialDcl.
ScalaListener.prototype.exitExistentialDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#infixType.
ScalaListener.prototype.enterInfixType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#infixType.
ScalaListener.prototype.exitInfixType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#compoundType.
ScalaListener.prototype.enterCompoundType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#compoundType.
ScalaListener.prototype.exitCompoundType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#annotType.
ScalaListener.prototype.enterAnnotType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#annotType.
ScalaListener.prototype.exitAnnotType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#simpleType.
ScalaListener.prototype.enterSimpleType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#simpleType.
ScalaListener.prototype.exitSimpleType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typeArgs.
ScalaListener.prototype.enterTypeArgs = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typeArgs.
ScalaListener.prototype.exitTypeArgs = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#types.
ScalaListener.prototype.enterTypes = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#types.
ScalaListener.prototype.exitTypes = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#refinement.
ScalaListener.prototype.enterRefinement = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#refinement.
ScalaListener.prototype.exitRefinement = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#refineStat.
ScalaListener.prototype.enterRefineStat = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#refineStat.
ScalaListener.prototype.exitRefineStat = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typePat.
ScalaListener.prototype.enterTypePat = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typePat.
ScalaListener.prototype.exitTypePat = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#ascription.
ScalaListener.prototype.enterAscription = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#ascription.
ScalaListener.prototype.exitAscription = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#expr.
ScalaListener.prototype.enterExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#expr.
ScalaListener.prototype.exitExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#expr1.
ScalaListener.prototype.enterExpr1 = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#expr1.
ScalaListener.prototype.exitExpr1 = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#postfixExpr.
ScalaListener.prototype.enterPostfixExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#postfixExpr.
ScalaListener.prototype.exitPostfixExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#infixExpr.
ScalaListener.prototype.enterInfixExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#infixExpr.
ScalaListener.prototype.exitInfixExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#prefixExpr.
ScalaListener.prototype.enterPrefixExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#prefixExpr.
ScalaListener.prototype.exitPrefixExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#simpleExpr1.
ScalaListener.prototype.enterSimpleExpr1 = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#simpleExpr1.
ScalaListener.prototype.exitSimpleExpr1 = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#exprs.
ScalaListener.prototype.enterExprs = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#exprs.
ScalaListener.prototype.exitExprs = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#argumentExprs.
ScalaListener.prototype.enterArgumentExprs = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#argumentExprs.
ScalaListener.prototype.exitArgumentExprs = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#blockExpr.
ScalaListener.prototype.enterBlockExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#blockExpr.
ScalaListener.prototype.exitBlockExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#block.
ScalaListener.prototype.enterBlock = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#block.
ScalaListener.prototype.exitBlock = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#blockStat.
ScalaListener.prototype.enterBlockStat = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#blockStat.
ScalaListener.prototype.exitBlockStat = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#resultExpr.
ScalaListener.prototype.enterResultExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#resultExpr.
ScalaListener.prototype.exitResultExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#enumerators.
ScalaListener.prototype.enterEnumerators = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#enumerators.
ScalaListener.prototype.exitEnumerators = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#generator.
ScalaListener.prototype.enterGenerator = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#generator.
ScalaListener.prototype.exitGenerator = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#caseClauses.
ScalaListener.prototype.enterCaseClauses = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#caseClauses.
ScalaListener.prototype.exitCaseClauses = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#caseClause.
ScalaListener.prototype.enterCaseClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#caseClause.
ScalaListener.prototype.exitCaseClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#guard.
ScalaListener.prototype.enterGuard = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#guard.
ScalaListener.prototype.exitGuard = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#pattern.
ScalaListener.prototype.enterPattern = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#pattern.
ScalaListener.prototype.exitPattern = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#pattern1.
ScalaListener.prototype.enterPattern1 = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#pattern1.
ScalaListener.prototype.exitPattern1 = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#pattern2.
ScalaListener.prototype.enterPattern2 = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#pattern2.
ScalaListener.prototype.exitPattern2 = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#pattern3.
ScalaListener.prototype.enterPattern3 = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#pattern3.
ScalaListener.prototype.exitPattern3 = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#simplePattern.
ScalaListener.prototype.enterSimplePattern = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#simplePattern.
ScalaListener.prototype.exitSimplePattern = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#patterns.
ScalaListener.prototype.enterPatterns = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#patterns.
ScalaListener.prototype.exitPatterns = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typeParamClause.
ScalaListener.prototype.enterTypeParamClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typeParamClause.
ScalaListener.prototype.exitTypeParamClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#funTypeParamClause.
ScalaListener.prototype.enterFunTypeParamClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#funTypeParamClause.
ScalaListener.prototype.exitFunTypeParamClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#variantTypeParam.
ScalaListener.prototype.enterVariantTypeParam = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#variantTypeParam.
ScalaListener.prototype.exitVariantTypeParam = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typeParam.
ScalaListener.prototype.enterTypeParam = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typeParam.
ScalaListener.prototype.exitTypeParam = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#paramClauses.
ScalaListener.prototype.enterParamClauses = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#paramClauses.
ScalaListener.prototype.exitParamClauses = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#paramClause.
ScalaListener.prototype.enterParamClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#paramClause.
ScalaListener.prototype.exitParamClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#params.
ScalaListener.prototype.enterParams = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#params.
ScalaListener.prototype.exitParams = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#param.
ScalaListener.prototype.enterParam = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#param.
ScalaListener.prototype.exitParam = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#paramType.
ScalaListener.prototype.enterParamType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#paramType.
ScalaListener.prototype.exitParamType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classParamClauses.
ScalaListener.prototype.enterClassParamClauses = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classParamClauses.
ScalaListener.prototype.exitClassParamClauses = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classParamClause.
ScalaListener.prototype.enterClassParamClause = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classParamClause.
ScalaListener.prototype.exitClassParamClause = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classParams.
ScalaListener.prototype.enterClassParams = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classParams.
ScalaListener.prototype.exitClassParams = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classParam.
ScalaListener.prototype.enterClassParam = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classParam.
ScalaListener.prototype.exitClassParam = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#bindings.
ScalaListener.prototype.enterBindings = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#bindings.
ScalaListener.prototype.exitBindings = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#binding.
ScalaListener.prototype.enterBinding = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#binding.
ScalaListener.prototype.exitBinding = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#modifier.
ScalaListener.prototype.enterModifier = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#modifier.
ScalaListener.prototype.exitModifier = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#localModifier.
ScalaListener.prototype.enterLocalModifier = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#localModifier.
ScalaListener.prototype.exitLocalModifier = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#accessModifier.
ScalaListener.prototype.enterAccessModifier = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#accessModifier.
ScalaListener.prototype.exitAccessModifier = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#accessQualifier.
ScalaListener.prototype.enterAccessQualifier = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#accessQualifier.
ScalaListener.prototype.exitAccessQualifier = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#annotation.
ScalaListener.prototype.enterAnnotation = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#annotation.
ScalaListener.prototype.exitAnnotation = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#constrAnnotation.
ScalaListener.prototype.enterConstrAnnotation = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#constrAnnotation.
ScalaListener.prototype.exitConstrAnnotation = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#templateBody.
ScalaListener.prototype.enterTemplateBody = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#templateBody.
ScalaListener.prototype.exitTemplateBody = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#templateStat.
ScalaListener.prototype.enterTemplateStat = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#templateStat.
ScalaListener.prototype.exitTemplateStat = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#selfType.
ScalaListener.prototype.enterSelfType = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#selfType.
ScalaListener.prototype.exitSelfType = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#import_.
ScalaListener.prototype.enterImport_ = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#import_.
ScalaListener.prototype.exitImport_ = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#importExpr.
ScalaListener.prototype.enterImportExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#importExpr.
ScalaListener.prototype.exitImportExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#importSelectors.
ScalaListener.prototype.enterImportSelectors = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#importSelectors.
ScalaListener.prototype.exitImportSelectors = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#importSelector.
ScalaListener.prototype.enterImportSelector = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#importSelector.
ScalaListener.prototype.exitImportSelector = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#dcl.
ScalaListener.prototype.enterDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#dcl.
ScalaListener.prototype.exitDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#valDcl.
ScalaListener.prototype.enterValDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#valDcl.
ScalaListener.prototype.exitValDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#varDcl.
ScalaListener.prototype.enterVarDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#varDcl.
ScalaListener.prototype.exitVarDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#funDcl.
ScalaListener.prototype.enterFunDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#funDcl.
ScalaListener.prototype.exitFunDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#funSig.
ScalaListener.prototype.enterFunSig = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#funSig.
ScalaListener.prototype.exitFunSig = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typeDcl.
ScalaListener.prototype.enterTypeDcl = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typeDcl.
ScalaListener.prototype.exitTypeDcl = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#patVarDef.
ScalaListener.prototype.enterPatVarDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#patVarDef.
ScalaListener.prototype.exitPatVarDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#def.
ScalaListener.prototype.enterDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#def.
ScalaListener.prototype.exitDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#patDef.
ScalaListener.prototype.enterPatDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#patDef.
ScalaListener.prototype.exitPatDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#varDef.
ScalaListener.prototype.enterVarDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#varDef.
ScalaListener.prototype.exitVarDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#funDef.
ScalaListener.prototype.enterFunDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#funDef.
ScalaListener.prototype.exitFunDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#typeDef.
ScalaListener.prototype.enterTypeDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#typeDef.
ScalaListener.prototype.exitTypeDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#tmplDef.
ScalaListener.prototype.enterTmplDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#tmplDef.
ScalaListener.prototype.exitTmplDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classDef.
ScalaListener.prototype.enterClassDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classDef.
ScalaListener.prototype.exitClassDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#traitDef.
ScalaListener.prototype.enterTraitDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#traitDef.
ScalaListener.prototype.exitTraitDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#objectDef.
ScalaListener.prototype.enterObjectDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#objectDef.
ScalaListener.prototype.exitObjectDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classTemplateOpt.
ScalaListener.prototype.enterClassTemplateOpt = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classTemplateOpt.
ScalaListener.prototype.exitClassTemplateOpt = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#traitTemplateOpt.
ScalaListener.prototype.enterTraitTemplateOpt = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#traitTemplateOpt.
ScalaListener.prototype.exitTraitTemplateOpt = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classTemplate.
ScalaListener.prototype.enterClassTemplate = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classTemplate.
ScalaListener.prototype.exitClassTemplate = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#traitTemplate.
ScalaListener.prototype.enterTraitTemplate = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#traitTemplate.
ScalaListener.prototype.exitTraitTemplate = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#classParents.
ScalaListener.prototype.enterClassParents = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#classParents.
ScalaListener.prototype.exitClassParents = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#traitParents.
ScalaListener.prototype.enterTraitParents = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#traitParents.
ScalaListener.prototype.exitTraitParents = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#constr.
ScalaListener.prototype.enterConstr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#constr.
ScalaListener.prototype.exitConstr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#earlyDefs.
ScalaListener.prototype.enterEarlyDefs = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#earlyDefs.
ScalaListener.prototype.exitEarlyDefs = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#earlyDef.
ScalaListener.prototype.enterEarlyDef = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#earlyDef.
ScalaListener.prototype.exitEarlyDef = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#constrExpr.
ScalaListener.prototype.enterConstrExpr = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#constrExpr.
ScalaListener.prototype.exitConstrExpr = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#constrBlock.
ScalaListener.prototype.enterConstrBlock = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#constrBlock.
ScalaListener.prototype.exitConstrBlock = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#selfInvocation.
ScalaListener.prototype.enterSelfInvocation = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#selfInvocation.
ScalaListener.prototype.exitSelfInvocation = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#topStatSeq.
ScalaListener.prototype.enterTopStatSeq = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#topStatSeq.
ScalaListener.prototype.exitTopStatSeq = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#topStat.
ScalaListener.prototype.enterTopStat = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#topStat.
ScalaListener.prototype.exitTopStat = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#packaging.
ScalaListener.prototype.enterPackaging = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#packaging.
ScalaListener.prototype.exitPackaging = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#packageObject.
ScalaListener.prototype.enterPackageObject = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#packageObject.
ScalaListener.prototype.exitPackageObject = function(ctx) {
};


// Enter a parse tree produced by ScalaParser#compilationUnit.
ScalaListener.prototype.enterCompilationUnit = function(ctx) {
};

// Exit a parse tree produced by ScalaParser#compilationUnit.
ScalaListener.prototype.exitCompilationUnit = function(ctx) {
};



exports.ScalaListener = ScalaListener;
},{"antlr4/index":54}],12:[function(require,module,exports){
// Generated from Scala.g4 by ANTLR 4.5
// jshint ignore: start
var antlr4 = require('antlr4/index');
var ScalaListener = require('./ScalaListener').ScalaListener;
var grammarFileName = "Scala.g4";

var serializedATN = ["\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd",
    "\3L\u05dc\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b\t\b\4",
    "\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t\16\4\17\t\17\4\20\t",
    "\20\4\21\t\21\4\22\t\22\4\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27",
    "\t\27\4\30\t\30\4\31\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4",
    "\36\t\36\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t&\4\'\t",
    "\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4/\t/\4\60\t\60\4\61\t",
    "\61\4\62\t\62\4\63\t\63\4\64\t\64\4\65\t\65\4\66\t\66\4\67\t\67\48\t",
    "8\49\t9\4:\t:\4;\t;\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC",
    "\4D\tD\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\tM\4N\tN\4",
    "O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\tV\4W\tW\4X\tX\4Y\tY\4Z",
    "\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4",
    "e\te\4f\tf\4g\tg\4h\th\3\2\5\2\u00d2\n\2\3\2\3\2\5\2\u00d6\n\2\3\2\3",
    "\2\3\2\3\2\3\2\3\2\5\2\u00de\n\2\3\3\3\3\3\3\7\3\u00e3\n\3\f\3\16\3",
    "\u00e6\13\3\3\4\3\4\3\4\7\4\u00eb\n\4\f\4\16\4\u00ee\13\4\3\5\3\5\3",
    "\5\5\5\u00f3\n\5\3\5\5\5\u00f6\n\5\3\5\3\5\3\5\3\5\5\5\u00fc\n\5\3\5",
    "\3\5\5\5\u0100\n\5\3\5\3\5\5\5\u0104\n\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7",
    "\3\7\3\7\3\7\5\7\u0110\n\7\5\7\u0112\n\7\3\b\3\b\3\b\3\b\3\b\7\b\u0119",
    "\n\b\f\b\16\b\u011c\13\b\5\b\u011e\n\b\3\b\5\b\u0121\n\b\3\t\3\t\3\t",
    "\3\t\3\t\7\t\u0128\n\t\f\t\16\t\u012b\13\t\3\t\3\t\3\n\3\n\3\n\3\n\5",
    "\n\u0133\n\n\3\13\3\13\3\13\5\13\u0138\n\13\3\13\7\13\u013b\n\13\f\13",
    "\16\13\u013e\13\13\3\f\3\f\3\f\7\f\u0143\n\f\f\f\16\f\u0146\13\f\3\f",
    "\5\f\u0149\n\f\3\f\5\f\u014c\n\f\3\r\3\r\7\r\u0150\n\r\f\r\16\r\u0153",
    "\13\r\3\16\3\16\3\16\3\16\3\16\5\16\u015a\n\16\3\16\5\16\u015d\n\16",
    "\3\16\3\16\3\16\3\16\3\16\3\16\5\16\u0165\n\16\3\16\3\16\3\16\3\16\3",
    "\16\7\16\u016c\n\16\f\16\16\16\u016f\13\16\3\17\3\17\3\17\3\17\3\20",
    "\3\20\3\20\7\20\u0178\n\20\f\20\16\20\u017b\13\20\3\21\5\21\u017e\n",
    "\21\3\21\3\21\3\21\3\21\7\21\u0184\n\21\f\21\16\21\u0187\13\21\3\21",
    "\3\21\3\22\3\22\3\22\3\22\5\22\u018f\n\22\3\23\3\23\3\24\3\24\3\24\3",
    "\24\6\24\u0197\n\24\r\24\16\24\u0198\3\24\3\24\3\24\5\24\u019e\n\24",
    "\3\25\3\25\5\25\u01a2\n\25\3\25\3\25\5\25\u01a6\n\25\3\25\3\25\3\25",
    "\5\25\u01ab\n\25\3\26\3\26\3\26\3\26\3\26\7\26\u01b2\n\26\f\26\16\26",
    "\u01b5\13\26\3\26\3\26\5\26\u01b9\n\26\3\26\3\26\5\26\u01bd\n\26\3\26",
    "\3\26\3\26\3\26\3\26\7\26\u01c4\n\26\f\26\16\26\u01c7\13\26\3\26\3\26",
    "\3\26\3\26\3\26\3\26\3\26\3\26\5\26\u01d1\n\26\3\26\3\26\3\26\3\26\3",
    "\26\5\26\u01d8\n\26\3\26\3\26\5\26\u01dc\n\26\3\26\3\26\3\26\5\26\u01e1",
    "\n\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3",
    "\26\3\26\5\26\u01f1\n\26\3\26\7\26\u01f4\n\26\f\26\16\26\u01f7\13\26",
    "\3\26\5\26\u01fa\n\26\3\26\3\26\3\26\3\26\3\26\3\26\5\26\u0202\n\26",
    "\3\26\3\26\3\26\5\26\u0207\n\26\3\26\3\26\3\26\5\26\u020c\n\26\5\26",
    "\u020e\n\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3",
    "\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\3\26\5\26\u0225\n\26\3\27",
    "\3\27\3\27\5\27\u022a\n\27\5\27\u022c\n\27\3\30\3\30\3\30\3\30\3\30",
    "\3\30\5\30\u0234\n\30\3\30\7\30\u0237\n\30\f\30\16\30\u023a\13\30\3",
    "\31\5\31\u023d\n\31\3\31\3\31\3\31\5\31\u0242\n\31\3\31\3\31\3\31\5",
    "\31\u0247\n\31\5\31\u0249\n\31\3\32\3\32\3\32\3\32\3\32\5\32\u0250\n",
    "\32\3\32\3\32\3\32\3\32\5\32\u0256\n\32\3\32\3\32\3\32\3\32\5\32\u025c",
    "\n\32\3\32\5\32\u025f\n\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u0267",
    "\n\32\3\32\5\32\u026a\n\32\3\32\3\32\5\32\u026e\n\32\3\32\3\32\7\32",
    "\u0272\n\32\f\32\16\32\u0275\13\32\3\33\3\33\3\33\7\33\u027a\n\33\f",
    "\33\16\33\u027d\13\33\3\34\3\34\5\34\u0281\n\34\3\34\3\34\3\34\3\34",
    "\3\34\5\34\u0288\n\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5\34\u0291",
    "\n\34\3\34\5\34\u0294\n\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\5",
    "\35\u029e\n\35\3\36\3\36\3\36\7\36\u02a3\n\36\f\36\16\36\u02a6\13\36",
    "\3\36\5\36\u02a9\n\36\3\37\3\37\7\37\u02ad\n\37\f\37\16\37\u02b0\13",
    "\37\3\37\5\37\u02b3\n\37\3\37\3\37\7\37\u02b7\n\37\f\37\16\37\u02ba",
    "\13\37\3\37\7\37\u02bd\n\37\f\37\16\37\u02c0\13\37\3\37\3\37\3\37\5",
    "\37\u02c5\n\37\3 \3 \3 \5 \u02ca\n \3 \3 \5 \u02ce\n \3 \3 \5 \u02d2",
    "\n \3 \3 \3 \5 \u02d7\n \3!\3!\3!\7!\u02dc\n!\f!\16!\u02df\13!\3\"\3",
    "\"\3\"\3\"\5\"\u02e5\n\"\3\"\3\"\3\"\3\"\3\"\3\"\7\"\u02ed\n\"\f\"\16",
    "\"\u02f0\13\"\3#\6#\u02f3\n#\r#\16#\u02f4\3$\3$\3$\5$\u02fa\n$\3$\3",
    "$\3$\3%\3%\3%\3&\3&\3&\7&\u0305\n&\f&\16&\u0308\13&\3\'\3\'\3\'\3\'",
    "\3\'\3\'\3\'\5\'\u0311\n\'\3(\3(\3(\5(\u0316\n(\3(\5(\u0319\n(\3)\3",
    ")\3)\3)\5)\u031f\n)\3)\7)\u0322\n)\f)\16)\u0325\13)\5)\u0327\n)\3*\3",
    "*\3*\3*\3*\3*\3*\3*\5*\u0331\n*\3*\3*\3*\3*\3*\5*\u0338\n*\3*\3*\5*",
    "\u033c\n*\3*\3*\3*\3*\3*\3*\5*\u0344\n*\3*\5*\u0347\n*\3+\3+\3+\7+\u034c",
    "\n+\f+\16+\u034f\13+\3+\7+\u0352\n+\f+\16+\u0355\13+\5+\u0357\n+\3,",
    "\3,\3,\3,\7,\u035d\n,\f,\16,\u0360\13,\3,\3,\3-\3-\3-\3-\7-\u0368\n",
    "-\f-\16-\u036b\13-\3-\3-\3.\5.\u0370\n.\3.\5.\u0373\n.\3.\3.\3/\3/\5",
    "/\u0379\n/\3/\3/\5/\u037d\n/\3/\3/\5/\u0381\n/\3/\3/\7/\u0385\n/\f/",
    "\16/\u0388\13/\3/\3/\7/\u038c\n/\f/\16/\u038f\13/\3\60\7\60\u0392\n",
    "\60\f\60\16\60\u0395\13\60\3\60\5\60\u0398\n\60\3\60\3\60\3\60\3\60",
    "\3\60\5\60\u039f\n\60\3\61\5\61\u03a2\n\61\3\61\3\61\5\61\u03a6\n\61",
    "\3\61\3\61\3\62\3\62\3\62\7\62\u03ad\n\62\f\62\16\62\u03b0\13\62\3\63",
    "\7\63\u03b3\n\63\f\63\16\63\u03b6\13\63\3\63\3\63\3\63\5\63\u03bb\n",
    "\63\3\63\3\63\5\63\u03bf\n\63\3\64\3\64\3\64\3\64\3\64\3\64\5\64\u03c7",
    "\n\64\3\65\7\65\u03ca\n\65\f\65\16\65\u03cd\13\65\3\65\5\65\u03d0\n",
    "\65\3\65\3\65\3\65\3\65\3\65\5\65\u03d7\n\65\3\66\5\66\u03da\n\66\3",
    "\66\3\66\5\66\u03de\n\66\3\66\3\66\3\67\3\67\3\67\7\67\u03e5\n\67\f",
    "\67\16\67\u03e8\13\67\38\78\u03eb\n8\f8\168\u03ee\138\38\78\u03f1\n",
    "8\f8\168\u03f4\138\38\58\u03f7\n8\38\38\38\38\38\58\u03fe\n8\39\39\3",
    "9\39\79\u0404\n9\f9\169\u0407\139\39\39\3:\3:\3:\5:\u040e\n:\3;\3;\3",
    ";\5;\u0413\n;\3<\3<\3=\3=\5=\u0419\n=\3>\3>\3>\3>\3?\3?\3?\7?\u0422",
    "\n?\f?\16?\u0425\13?\3@\3@\3@\3@\3A\5A\u042c\nA\3A\3A\5A\u0430\nA\3",
    "A\3A\3A\7A\u0435\nA\fA\16A\u0438\13A\3A\3A\3B\3B\3B\5B\u043f\nB\7B\u0441",
    "\nB\fB\16B\u0444\13B\3B\7B\u0447\nB\fB\16B\u044a\13B\3B\3B\3B\5B\u044f",
    "\nB\7B\u0451\nB\fB\16B\u0454\13B\3B\7B\u0457\nB\fB\16B\u045a\13B\3B",
    "\3B\3B\5B\u045f\nB\3C\3C\3C\5C\u0464\nC\3C\3C\3C\3C\3C\3C\5C\u046c\n",
    "C\3D\3D\3D\3D\7D\u0472\nD\fD\16D\u0475\13D\3E\3E\3E\3E\3E\5E\u047c\n",
    "E\3F\3F\3F\3F\7F\u0482\nF\fF\16F\u0485\13F\3F\3F\5F\u0489\nF\3F\3F\3",
    "G\3G\3G\3G\3G\5G\u0492\nG\3H\3H\3H\3H\3H\3H\3H\3H\7H\u049c\nH\fH\16",
    "H\u049f\13H\3H\5H\u04a2\nH\3I\3I\3I\3I\3J\3J\3J\3J\3K\3K\3K\5K\u04af",
    "\nK\3L\3L\5L\u04b3\nL\3L\3L\3M\3M\5M\u04b9\nM\3M\3M\5M\u04bd\nM\3M\3",
    "M\5M\u04c1\nM\3N\3N\3N\3N\5N\u04c7\nN\3O\3O\3O\3O\3O\7O\u04ce\nO\fO",
    "\16O\u04d1\13O\3O\3O\5O\u04d5\nO\3P\3P\3P\7P\u04da\nP\fP\16P\u04dd\13",
    "P\3P\3P\7P\u04e1\nP\fP\16P\u04e4\13P\3P\3P\3P\3Q\3Q\3Q\3Q\3Q\3Q\3Q\5",
    "Q\u04f0\nQ\3R\3R\3R\5R\u04f5\nR\3R\3R\3R\3R\3R\5R\u04fc\nR\3R\3R\3R",
    "\3R\3R\3R\3R\3R\3R\3R\3R\5R\u0509\nR\5R\u050b\nR\3S\3S\5S\u050f\nS\3",
    "S\3S\3S\3T\5T\u0515\nT\3T\3T\3T\3T\3T\3T\3T\5T\u051e\nT\3U\3U\5U\u0522",
    "\nU\3U\7U\u0525\nU\fU\16U\u0528\13U\3U\5U\u052b\nU\3U\3U\3U\3V\3V\5",
    "V\u0532\nV\3V\3V\3W\3W\3W\3X\3X\3X\5X\u053c\nX\3X\5X\u053f\nX\5X\u0541",
    "\nX\3Y\3Y\3Y\5Y\u0546\nY\3Y\5Y\u0549\nY\5Y\u054b\nY\3Z\5Z\u054e\nZ\3",
    "Z\3Z\5Z\u0552\nZ\3[\5[\u0555\n[\3[\3[\5[\u0559\n[\3\\\3\\\3\\\7\\\u055e",
    "\n\\\f\\\16\\\u0561\13\\\3]\3]\3]\7]\u0566\n]\f]\16]\u0569\13]\3^\3",
    "^\7^\u056d\n^\f^\16^\u0570\13^\3_\3_\3_\3_\7_\u0576\n_\f_\16_\u0579",
    "\13_\5_\u057b\n_\3_\3_\3_\3`\3`\5`\u0582\n`\7`\u0584\n`\f`\16`\u0587",
    "\13`\3`\7`\u058a\n`\f`\16`\u058d\13`\3`\3`\3a\3a\5a\u0593\na\3b\3b\3",
    "b\3b\7b\u0599\nb\fb\16b\u059c\13b\3b\3b\3c\3c\6c\u05a2\nc\rc\16c\u05a3",
    "\3d\3d\3d\7d\u05a9\nd\fd\16d\u05ac\13d\3e\3e\5e\u05b0\ne\7e\u05b2\n",
    "e\fe\16e\u05b5\13e\3e\7e\u05b8\ne\fe\16e\u05bb\13e\3e\3e\3e\3e\3e\5",
    "e\u05c2\ne\3f\3f\3f\5f\u05c7\nf\3f\3f\3f\3f\3g\3g\3g\3g\3h\3h\3h\3h",
    "\7h\u05d5\nh\fh\16h\u05d8\13h\3h\3h\3h\2\5\32.\62i\2\4\6\b\n\f\16\20",
    "\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdf",
    "hjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092",
    "\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa",
    "\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2",
    "\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\2\n\4\2\3\3\')\4\2\30\30**\4\2",
    "\3\3\'\'\4\2\26\26FF\4\2\22\22\62\62\5\2\30\30**\64\66\3\2\678\4\2\7",
    "\7FF\u0678\2\u00dd\3\2\2\2\4\u00df\3\2\2\2\6\u00e7\3\2\2\2\b\u0103\3",
    "\2\2\2\n\u0105\3\2\2\2\f\u0111\3\2\2\2\16\u0120\3\2\2\2\20\u0122\3\2",
    "\2\2\22\u0132\3\2\2\2\24\u0134\3\2\2\2\26\u014b\3\2\2\2\30\u014d\3\2",
    "\2\2\32\u0164\3\2\2\2\34\u0170\3\2\2\2\36\u0174\3\2\2\2 \u017d\3\2\2",
    "\2\"\u018e\3\2\2\2$\u0190\3\2\2\2&\u019d\3\2\2\2(\u01aa\3\2\2\2*\u0224",
    "\3\2\2\2,\u0226\3\2\2\2.\u022d\3\2\2\2\60\u023c\3\2\2\2\62\u026d\3\2",
    "\2\2\64\u0276\3\2\2\2\66\u0293\3\2\2\28\u029d\3\2\2\2:\u029f\3\2\2\2",
    "<\u02c4\3\2\2\2>\u02d6\3\2\2\2@\u02d8\3\2\2\2B\u02e0\3\2\2\2D\u02f2",
    "\3\2\2\2F\u02f6\3\2\2\2H\u02fe\3\2\2\2J\u0301\3\2\2\2L\u0310\3\2\2\2",
    "N\u0318\3\2\2\2P\u0326\3\2\2\2R\u0346\3\2\2\2T\u0356\3\2\2\2V\u0358",
    "\3\2\2\2X\u0363\3\2\2\2Z\u036f\3\2\2\2\\\u0376\3\2\2\2^\u0393\3\2\2",
    "\2`\u03a1\3\2\2\2b\u03a9\3\2\2\2d\u03b4\3\2\2\2f\u03c6\3\2\2\2h\u03cb",
    "\3\2\2\2j\u03d9\3\2\2\2l\u03e1\3\2\2\2n\u03ec\3\2\2\2p\u03ff\3\2\2\2",
    "r\u040a\3\2\2\2t\u0412\3\2\2\2v\u0414\3\2\2\2x\u0416\3\2\2\2z\u041a",
    "\3\2\2\2|\u041e\3\2\2\2~\u0426\3\2\2\2\u0080\u042b\3\2\2\2\u0082\u045e",
    "\3\2\2\2\u0084\u046b\3\2\2\2\u0086\u046d\3\2\2\2\u0088\u0476\3\2\2\2",
    "\u008a\u047d\3\2\2\2\u008c\u048c\3\2\2\2\u008e\u04a1\3\2\2\2\u0090\u04a3",
    "\3\2\2\2\u0092\u04a7\3\2\2\2\u0094\u04ab\3\2\2\2\u0096\u04b0\3\2\2\2",
    "\u0098\u04b6\3\2\2\2\u009a\u04c6\3\2\2\2\u009c\u04d4\3\2\2\2\u009e\u04d6",
    "\3\2\2\2\u00a0\u04ef\3\2\2\2\u00a2\u050a\3\2\2\2\u00a4\u050c\3\2\2\2",
    "\u00a6\u051d\3\2\2\2\u00a8\u051f\3\2\2\2\u00aa\u052f\3\2\2\2\u00ac\u0535",
    "\3\2\2\2\u00ae\u0540\3\2\2\2\u00b0\u054a\3\2\2\2\u00b2\u054d\3\2\2\2",
    "\u00b4\u0554\3\2\2\2\u00b6\u055a\3\2\2\2\u00b8\u0562\3\2\2\2\u00ba\u056a",
    "\3\2\2\2\u00bc\u0571\3\2\2\2\u00be\u0585\3\2\2\2\u00c0\u0592\3\2\2\2",
    "\u00c2\u0594\3\2\2\2\u00c4\u059f\3\2\2\2\u00c6\u05a5\3\2\2\2\u00c8\u05c1",
    "\3\2\2\2\u00ca\u05c3\3\2\2\2\u00cc\u05cc\3\2\2\2\u00ce\u05d6\3\2\2\2",
    "\u00d0\u00d2\7\3\2\2\u00d1\u00d0\3\2\2\2\u00d1\u00d2\3\2\2\2\u00d2\u00d3",
    "\3\2\2\2\u00d3\u00de\7D\2\2\u00d4\u00d6\7\3\2\2\u00d5\u00d4\3\2\2\2",
    "\u00d5\u00d6\3\2\2\2\u00d6\u00d7\3\2\2\2\u00d7\u00de\7E\2\2\u00d8\u00de",
    "\7@\2\2\u00d9\u00de\7A\2\2\u00da\u00de\7B\2\2\u00db\u00de\7C\2\2\u00dc",
    "\u00de\7\4\2\2\u00dd\u00d1\3\2\2\2\u00dd\u00d5\3\2\2\2\u00dd\u00d8\3",
    "\2\2\2\u00dd\u00d9\3\2\2\2\u00dd\u00da\3\2\2\2\u00dd\u00db\3\2\2\2\u00dd",
    "\u00dc\3\2\2\2\u00de\3\3\2\2\2\u00df\u00e4\7F\2\2\u00e0\u00e1\7\5\2",
    "\2\u00e1\u00e3\7F\2\2\u00e2\u00e0\3\2\2\2\u00e3\u00e6\3\2\2\2\u00e4",
    "\u00e2\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5\5\3\2\2\2\u00e6\u00e4\3\2\2",
    "\2\u00e7\u00ec\7F\2\2\u00e8\u00e9\7\6\2\2\u00e9\u00eb\7F\2\2\u00ea\u00e8",
    "\3\2\2\2\u00eb\u00ee\3\2\2\2\u00ec\u00ea\3\2\2\2\u00ec\u00ed\3\2\2\2",
    "\u00ed\7\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ef\u00f6\7F\2\2\u00f0\u00f1",
    "\7F\2\2\u00f1\u00f3\7\5\2\2\u00f2\u00f0\3\2\2\2\u00f2\u00f3\3\2\2\2",
    "\u00f3\u00f4\3\2\2\2\u00f4\u00f6\7\7\2\2\u00f5\u00ef\3\2\2\2\u00f5\u00f2",
    "\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u00f8\7\5\2\2\u00f8\u0104\7F\2\2",
    "\u00f9\u00fa\7F\2\2\u00fa\u00fc\7\5\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc",
    "\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u00ff\7\b\2\2\u00fe\u0100\5\n\6\2",
    "\u00ff\u00fe\3\2\2\2\u00ff\u0100\3\2\2\2\u0100\u0101\3\2\2\2\u0101\u0102",
    "\7\5\2\2\u0102\u0104\7F\2\2\u0103\u00f5\3\2\2\2\u0103\u00fb\3\2\2\2",
    "\u0104\t\3\2\2\2\u0105\u0106\7\t\2\2\u0106\u0107\7F\2\2\u0107\u0108",
    "\7\n\2\2\u0108\13\3\2\2\2\u0109\u010a\5\16\b\2\u010a\u010b\7\13\2\2",
    "\u010b\u010c\5\f\7\2\u010c\u0112\3\2\2\2\u010d\u010f\5\24\13\2\u010e",
    "\u0110\5\20\t\2\u010f\u010e\3\2\2\2\u010f\u0110\3\2\2\2\u0110\u0112",
    "\3\2\2\2\u0111\u0109\3\2\2\2\u0111\u010d\3\2\2\2\u0112\r\3\2\2\2\u0113",
    "\u0121\5\24\13\2\u0114\u011d\7\f\2\2\u0115\u011a\5f\64\2\u0116\u0117",
    "\7\6\2\2\u0117\u0119\5f\64\2\u0118\u0116\3\2\2\2\u0119\u011c\3\2\2\2",
    "\u011a\u0118\3\2\2\2\u011a\u011b\3\2\2\2\u011b\u011e\3\2\2\2\u011c\u011a",
    "\3\2\2\2\u011d\u0115\3\2\2\2\u011d\u011e\3\2\2\2\u011e\u011f\3\2\2\2",
    "\u011f\u0121\7\r\2\2\u0120\u0113\3\2\2\2\u0120\u0114\3\2\2\2\u0121\17",
    "\3\2\2\2\u0122\u0123\7\16\2\2\u0123\u0124\7\17\2\2\u0124\u0129\5\22",
    "\n\2\u0125\u0126\7I\2\2\u0126\u0128\5\22\n\2\u0127\u0125\3\2\2\2\u0128",
    "\u012b\3\2\2\2\u0129\u0127\3\2\2\2\u0129\u012a\3\2\2\2\u012a\u012c\3",
    "\2\2\2\u012b\u0129\3\2\2\2\u012c\u012d\7\20\2\2\u012d\21\3\2\2\2\u012e",
    "\u012f\7\21\2\2\u012f\u0133\5\u0098M\2\u0130\u0131\7\22\2\2\u0131\u0133",
    "\5\u0090I\2\u0132\u012e\3\2\2\2\u0132\u0130\3\2\2\2\u0133\23\3\2\2\2",
    "\u0134\u013c\5\26\f\2\u0135\u0137\7F\2\2\u0136\u0138\7H\2\2\u0137\u0136",
    "\3\2\2\2\u0137\u0138\3\2\2\2\u0138\u0139\3\2\2\2\u0139\u013b\5\26\f",
    "\2\u013a\u0135\3\2\2\2\u013b\u013e\3\2\2\2\u013c\u013a\3\2\2\2\u013c",
    "\u013d\3\2\2\2\u013d\25\3\2\2\2\u013e\u013c\3\2\2\2\u013f\u0144\5\30",
    "\r\2\u0140\u0141\7\23\2\2\u0141\u0143\5\30\r\2\u0142\u0140\3\2\2\2\u0143",
    "\u0146\3\2\2\2\u0144\u0142\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0148\3",
    "\2\2\2\u0146\u0144\3\2\2\2\u0147\u0149\5 \21\2\u0148\u0147\3\2\2\2\u0148",
    "\u0149\3\2\2\2\u0149\u014c\3\2\2\2\u014a\u014c\5 \21\2\u014b\u013f\3",
    "\2\2\2\u014b\u014a\3\2\2\2\u014c\27\3\2\2\2\u014d\u0151\5\32\16\2\u014e",
    "\u0150\5|?\2\u014f\u014e\3\2\2\2\u0150\u0153\3\2\2\2\u0151\u014f\3\2",
    "\2\2\u0151\u0152\3\2\2\2\u0152\31\3\2\2\2\u0153\u0151\3\2\2\2\u0154",
    "\u0155\b\16\1\2\u0155\u0165\5\b\5\2\u0156\u015d\5\b\5\2\u0157\u0158",
    "\7F\2\2\u0158\u015a\7\5\2\2\u0159\u0157\3\2\2\2\u0159\u015a\3\2\2\2",
    "\u015a\u015b\3\2\2\2\u015b\u015d\7\7\2\2\u015c\u0156\3\2\2\2\u015c\u0159",
    "\3\2\2\2\u015d\u015e\3\2\2\2\u015e\u015f\7\5\2\2\u015f\u0165\7\21\2",
    "\2\u0160\u0161\7\f\2\2\u0161\u0162\5\36\20\2\u0162\u0163\7\r\2\2\u0163",
    "\u0165\3\2\2\2\u0164\u0154\3\2\2\2\u0164\u015c\3\2\2\2\u0164\u0160\3",
    "\2\2\2\u0165\u016d\3\2\2\2\u0166\u0167\f\7\2\2\u0167\u016c\5\34\17\2",
    "\u0168\u0169\f\6\2\2\u0169\u016a\7\24\2\2\u016a\u016c\7F\2\2\u016b\u0166",
    "\3\2\2\2\u016b\u0168\3\2\2\2\u016c\u016f\3\2\2\2\u016d\u016b\3\2\2\2",
    "\u016d\u016e\3\2\2\2\u016e\33\3\2\2\2\u016f\u016d\3\2\2\2\u0170\u0171",
    "\7\t\2\2\u0171\u0172\5\36\20\2\u0172\u0173\7\n\2\2\u0173\35\3\2\2\2",
    "\u0174\u0179\5\f\7\2\u0175\u0176\7\6\2\2\u0176\u0178\5\f\7\2\u0177\u0175",
    "\3\2\2\2\u0178\u017b\3\2\2\2\u0179\u0177\3\2\2\2\u0179\u017a\3\2\2\2",
    "\u017a\37\3\2\2\2\u017b\u0179\3\2\2\2\u017c\u017e\7H\2\2\u017d\u017c",
    "\3\2\2\2\u017d\u017e\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0180\7\17\2",
    "\2\u0180\u0185\5\"\22\2\u0181\u0182\7I\2\2\u0182\u0184\5\"\22\2\u0183",
    "\u0181\3\2\2\2\u0184\u0187\3\2\2\2\u0185\u0183\3\2\2\2\u0185\u0186\3",
    "\2\2\2\u0186\u0188\3\2\2\2\u0187\u0185\3\2\2\2\u0188\u0189\7\20\2\2",
    "\u0189!\3\2\2\2\u018a\u018f\5\u008eH\2\u018b\u018c\7\21\2\2\u018c\u018f",
    "\5\u00a4S\2\u018d\u018f\3\2\2\2\u018e\u018a\3\2\2\2\u018e\u018b\3\2",
    "\2\2\u018e\u018d\3\2\2\2\u018f#\3\2\2\2\u0190\u0191\5\f\7\2\u0191%\3",
    "\2\2\2\u0192\u0193\7\25\2\2\u0193\u019e\5\24\13\2\u0194\u0196\7\25\2",
    "\2\u0195\u0197\5|?\2\u0196\u0195\3\2\2\2\u0197\u0198\3\2\2\2\u0198\u0196",
    "\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019e\3\2\2\2\u019a\u019b\7\25\2",
    "\2\u019b\u019c\7\26\2\2\u019c\u019e\7\27\2\2\u019d\u0192\3\2\2\2\u019d",
    "\u0194\3\2\2\2\u019d\u019a\3\2\2\2\u019e\'\3\2\2\2\u019f\u01a6\5p9\2",
    "\u01a0\u01a2\7\30\2\2\u01a1\u01a0\3\2\2\2\u01a1\u01a2\3\2\2\2\u01a2",
    "\u01a3\3\2\2\2\u01a3\u01a6\7F\2\2\u01a4\u01a6\7\26\2\2\u01a5\u019f\3",
    "\2\2\2\u01a5\u01a1\3\2\2\2\u01a5\u01a4\3\2\2\2\u01a6\u01a7\3\2\2\2\u01a7",
    "\u01a8\7\13\2\2\u01a8\u01ab\5(\25\2\u01a9\u01ab\5*\26\2\u01aa\u01a5",
    "\3\2\2\2\u01aa\u01a9\3\2\2\2\u01ab)\3\2\2\2\u01ac\u01ad\7\31\2\2\u01ad",
    "\u01ae\7\f\2\2\u01ae\u01af\5(\25\2\u01af\u01b3\7\r\2\2\u01b0\u01b2\7",
    "H\2\2\u01b1\u01b0\3\2\2\2\u01b2\u01b5\3\2\2\2\u01b3\u01b1\3\2\2\2\u01b3",
    "\u01b4\3\2\2\2\u01b4\u01b6\3\2\2\2\u01b5\u01b3\3\2\2\2\u01b6\u01bc\5",
    "(\25\2\u01b7\u01b9\7I\2\2\u01b8\u01b7\3\2\2\2\u01b8\u01b9\3\2\2\2\u01b9",
    "\u01ba\3\2\2\2\u01ba\u01bb\7\32\2\2\u01bb\u01bd\5(\25\2\u01bc\u01b8",
    "\3\2\2\2\u01bc\u01bd\3\2\2\2\u01bd\u0225\3\2\2\2\u01be\u01bf\7\33\2",
    "\2\u01bf\u01c0\7\f\2\2\u01c0\u01c1\5(\25\2\u01c1\u01c5\7\r\2\2\u01c2",
    "\u01c4\7H\2\2\u01c3\u01c2\3\2\2\2\u01c4\u01c7\3\2\2\2\u01c5\u01c3\3",
    "\2\2\2\u01c5\u01c6\3\2\2\2\u01c6\u01c8\3\2\2\2\u01c7\u01c5\3\2\2\2\u01c8",
    "\u01c9\5(\25\2\u01c9\u0225\3\2\2\2\u01ca\u01d0\7\34\2\2\u01cb\u01cc",
    "\7\17\2\2\u01cc\u01cd\5:\36\2\u01cd\u01ce\7\20\2\2\u01ce\u01d1\3\2\2",
    "\2\u01cf\u01d1\5(\25\2\u01d0\u01cb\3\2\2\2\u01d0\u01cf\3\2\2\2\u01d1",
    "\u01d7\3\2\2\2\u01d2\u01d3\7\35\2\2\u01d3\u01d4\7\17\2\2\u01d4\u01d5",
    "\5D#\2\u01d5\u01d6\7\20\2\2\u01d6\u01d8\3\2\2\2\u01d7\u01d2\3\2\2\2",
    "\u01d7\u01d8\3\2\2\2\u01d8\u01db\3\2\2\2\u01d9\u01da\7\36\2\2\u01da",
    "\u01dc\5(\25\2\u01db\u01d9\3\2\2\2\u01db\u01dc\3\2\2\2\u01dc\u0225\3",
    "\2\2\2\u01dd\u01de\7\37\2\2\u01de\u01e0\5(\25\2\u01df\u01e1\7I\2\2\u01e0",
    "\u01df\3\2\2\2\u01e0\u01e1\3\2\2\2\u01e1\u01e2\3\2\2\2\u01e2\u01e3\7",
    "\33\2\2\u01e3\u01e4\7\f\2\2\u01e4\u01e5\5(\25\2\u01e5\u01e6\7\r\2\2",
    "\u01e6\u0225\3\2\2\2\u01e7\u01f0\7 \2\2\u01e8\u01e9\7\f\2\2\u01e9\u01ea",
    "\5@!\2\u01ea\u01eb\7\r\2\2\u01eb\u01f1\3\2\2\2\u01ec\u01ed\7\17\2\2",
    "\u01ed\u01ee\5@!\2\u01ee\u01ef\7\20\2\2\u01ef\u01f1\3\2\2\2\u01f0\u01e8",
    "\3\2\2\2\u01f0\u01ec\3\2\2\2\u01f1\u01f5\3\2\2\2\u01f2\u01f4\7H\2\2",
    "\u01f3\u01f2\3\2\2\2\u01f4\u01f7\3\2\2\2\u01f5\u01f3\3\2\2\2\u01f5\u01f6",
    "\3\2\2\2\u01f6\u01f9\3\2\2\2\u01f7\u01f5\3\2\2\2\u01f8\u01fa\7!\2\2",
    "\u01f9\u01f8\3\2\2\2\u01f9\u01fa\3\2\2\2\u01fa\u01fb\3\2\2\2\u01fb\u01fc",
    "\5(\25\2\u01fc\u0225\3\2\2\2\u01fd\u01fe\7\"\2\2\u01fe\u0225\5(\25\2",
    "\u01ff\u0201\7#\2\2\u0200\u0202\5(\25\2\u0201\u0200\3\2\2\2\u0201\u0202",
    "\3\2\2\2\u0202\u0225\3\2\2\2\u0203\u0206\7$\2\2\u0204\u0207\5\u00b2",
    "Z\2\u0205\u0207\5\u0080A\2\u0206\u0204\3\2\2\2\u0206\u0205\3\2\2\2\u0207",
    "\u020e\3\2\2\2\u0208\u020e\58\35\2\u0209\u020b\5\62\32\2\u020a\u020c",
    "\7\26\2\2\u020b\u020a\3\2\2\2\u020b\u020c\3\2\2\2\u020c\u020e\3\2\2",
    "\2\u020d\u0203\3\2\2\2\u020d\u0208\3\2\2\2\u020d\u0209\3\2\2\2\u020e",
    "\u020f\3\2\2\2\u020f\u0210\7\5\2\2\u0210\u0211\3\2\2\2\u0211\u0212\7",
    "F\2\2\u0212\u0213\7%\2\2\u0213\u0214\5(\25\2\u0214\u0225\3\2\2\2\u0215",
    "\u0216\5\62\32\2\u0216\u0217\5\66\34\2\u0217\u0218\7%\2\2\u0218\u0219",
    "\5(\25\2\u0219\u0225\3\2\2\2\u021a\u0225\5,\27\2\u021b\u021c\5,\27\2",
    "\u021c\u021d\5&\24\2\u021d\u0225\3\2\2\2\u021e\u021f\5,\27\2\u021f\u0220",
    "\7&\2\2\u0220\u0221\7\17\2\2\u0221\u0222\5D#\2\u0222\u0223\7\20\2\2",
    "\u0223\u0225\3\2\2\2\u0224\u01ac\3\2\2\2\u0224\u01be\3\2\2\2\u0224\u01ca",
    "\3\2\2\2\u0224\u01dd\3\2\2\2\u0224\u01e7\3\2\2\2\u0224\u01fd\3\2\2\2",
    "\u0224\u01ff\3\2\2\2\u0224\u020d\3\2\2\2\u0224\u0215\3\2\2\2\u0224\u021a",
    "\3\2\2\2\u0224\u021b\3\2\2\2\u0224\u021e\3\2\2\2\u0225+\3\2\2\2\u0226",
    "\u022b\5.\30\2\u0227\u0229\7F\2\2\u0228\u022a\7H\2\2\u0229\u0228\3\2",
    "\2\2\u0229\u022a\3\2\2\2\u022a\u022c\3\2\2\2\u022b\u0227\3\2\2\2\u022b",
    "\u022c\3\2\2\2\u022c-\3\2\2\2\u022d\u022e\b\30\1\2\u022e\u022f\5\60",
    "\31\2\u022f\u0238\3\2\2\2\u0230\u0231\f\3\2\2\u0231\u0233\7F\2\2\u0232",
    "\u0234\7H\2\2\u0233\u0232\3\2\2\2\u0233\u0234\3\2\2\2\u0234\u0235\3",
    "\2\2\2\u0235\u0237\5.\30\4\u0236\u0230\3\2\2\2\u0237\u023a\3\2\2\2\u0238",
    "\u0236\3\2\2\2\u0238\u0239\3\2\2\2\u0239/\3\2\2\2\u023a\u0238\3\2\2",
    "\2\u023b\u023d\t\2\2\2\u023c\u023b\3\2\2\2\u023c\u023d\3\2\2\2\u023d",
    "\u0248\3\2\2\2\u023e\u0241\7$\2\2\u023f\u0242\5\u00b2Z\2\u0240\u0242",
    "\5\u0080A\2\u0241\u023f\3\2\2\2\u0241\u0240\3\2\2\2\u0242\u0249\3\2",
    "\2\2\u0243\u0249\58\35\2\u0244\u0246\5\62\32\2\u0245\u0247\7\26\2\2",
    "\u0246\u0245\3\2\2\2\u0246\u0247\3\2\2\2\u0247\u0249\3\2\2\2\u0248\u023e",
    "\3\2\2\2\u0248\u0243\3\2\2\2\u0248\u0244\3\2\2\2\u0249\61\3\2\2\2\u024a",
    "\u024b\b\32\1\2\u024b\u026e\5\2\2\2\u024c\u026e\5\b\5\2\u024d\u024e",
    "\7F\2\2\u024e\u0250\7\5\2\2\u024f\u024d\3\2\2\2\u024f\u0250\3\2\2\2",
    "\u0250\u0251\3\2\2\2\u0251\u026e\7\7\2\2\u0252\u026e\7\26\2\2\u0253",
    "\u0255\7\f\2\2\u0254\u0256\5\64\33\2\u0255\u0254\3\2\2\2\u0255\u0256",
    "\3\2\2\2\u0256\u0257\3\2\2\2\u0257\u026e\7\r\2\2\u0258\u025b\7$\2\2",
    "\u0259\u025c\5\u00b2Z\2\u025a\u025c\5\u0080A\2\u025b\u0259\3\2\2\2\u025b",
    "\u025a\3\2\2\2\u025c\u025f\3\2\2\2\u025d\u025f\58\35\2\u025e\u0258\3",
    "\2\2\2\u025e\u025d\3\2\2\2\u025f\u0260\3\2\2\2\u0260\u0261\7\5\2\2\u0261",
    "\u0262\7F\2\2\u0262\u026e\3\2\2\2\u0263\u0266\7$\2\2\u0264\u0267\5\u00b2",
    "Z\2\u0265\u0267\5\u0080A\2\u0266\u0264\3\2\2\2\u0266\u0265\3\2\2\2\u0267",
    "\u026a\3\2\2\2\u0268\u026a\58\35\2\u0269\u0263\3\2\2\2\u0269\u0268\3",
    "\2\2\2\u026a\u026b\3\2\2\2\u026b\u026c\5\34\17\2\u026c\u026e\3\2\2\2",
    "\u026d\u024a\3\2\2\2\u026d\u024c\3\2\2\2\u026d\u024f\3\2\2\2\u026d\u0252",
    "\3\2\2\2\u026d\u0253\3\2\2\2\u026d\u025e\3\2\2\2\u026d\u0269\3\2\2\2",
    "\u026e\u0273\3\2\2\2\u026f\u0270\f\3\2\2\u0270\u0272\5\66\34\2\u0271",
    "\u026f\3\2\2\2\u0272\u0275\3\2\2\2\u0273\u0271\3\2\2\2\u0273\u0274\3",
    "\2\2\2\u0274\63\3\2\2\2\u0275\u0273\3\2\2\2\u0276\u027b\5(\25\2\u0277",
    "\u0278\7\6\2\2\u0278\u027a\5(\25\2\u0279\u0277\3\2\2\2\u027a\u027d\3",
    "\2\2\2\u027b\u0279\3\2\2\2\u027b\u027c\3\2\2\2\u027c\65\3\2\2\2\u027d",
    "\u027b\3\2\2\2\u027e\u0280\7\f\2\2\u027f\u0281\5\64\33\2\u0280\u027f",
    "\3\2\2\2\u0280\u0281\3\2\2\2\u0281\u0282\3\2\2\2\u0282\u0294\7\r\2\2",
    "\u0283\u0287\7\f\2\2\u0284\u0285\5\64\33\2\u0285\u0286\7\6\2\2\u0286",
    "\u0288\3\2\2\2\u0287\u0284\3\2\2\2\u0287\u0288\3\2\2\2\u0288\u0289\3",
    "\2\2\2\u0289\u028a\5,\27\2\u028a\u028b\7\25\2\2\u028b\u028c\7\26\2\2",
    "\u028c\u028d\7\27\2\2\u028d\u028e\7\r\2\2\u028e\u0294\3\2\2\2\u028f",
    "\u0291\7H\2\2\u0290\u028f\3\2\2\2\u0290\u0291\3\2\2\2\u0291\u0292\3",
    "\2\2\2\u0292\u0294\58\35\2\u0293\u027e\3\2\2\2\u0293\u0283\3\2\2\2\u0293",
    "\u0290\3\2\2\2\u0294\67\3\2\2\2\u0295\u0296\7\17\2\2\u0296\u0297\5D",
    "#\2\u0297\u0298\7\20\2\2\u0298\u029e\3\2\2\2\u0299\u029a\7\17\2\2\u029a",
    "\u029b\5:\36\2\u029b\u029c\7\20\2\2\u029c\u029e\3\2\2\2\u029d\u0295",
    "\3\2\2\2\u029d\u0299\3\2\2\2\u029e9\3\2\2\2\u029f\u02a4\5<\37\2\u02a0",
    "\u02a1\7I\2\2\u02a1\u02a3\5<\37\2\u02a2\u02a0\3\2\2\2\u02a3\u02a6\3",
    "\2\2\2\u02a4\u02a2\3\2\2\2\u02a4\u02a5\3\2\2\2\u02a5\u02a8\3\2\2\2\u02a6",
    "\u02a4\3\2\2\2\u02a7\u02a9\5> \2\u02a8\u02a7\3\2\2\2\u02a8\u02a9\3\2",
    "\2\2\u02a9;\3\2\2\2\u02aa\u02c5\5\u0086D\2\u02ab\u02ad\5|?\2\u02ac\u02ab",
    "\3\2\2\2\u02ad\u02b0\3\2\2\2\u02ae\u02ac\3\2\2\2\u02ae\u02af\3\2\2\2",
    "\u02af\u02b2\3\2\2\2\u02b0\u02ae\3\2\2\2\u02b1\u02b3\t\3\2\2\u02b2\u02b1",
    "\3\2\2\2\u02b2\u02b3\3\2\2\2\u02b3\u02b4\3\2\2\2\u02b4\u02c5\5\u009c",
    "O\2\u02b5\u02b7\5|?\2\u02b6\u02b5\3\2\2\2\u02b7\u02ba\3\2\2\2\u02b8",
    "\u02b6\3\2\2\2\u02b8\u02b9\3\2\2\2\u02b9\u02be\3\2\2\2\u02ba\u02b8\3",
    "\2\2\2\u02bb\u02bd\5v<\2\u02bc\u02bb\3\2\2\2\u02bd\u02c0\3\2\2\2\u02be",
    "\u02bc\3\2\2\2\u02be\u02bf\3\2\2\2\u02bf\u02c1\3\2\2\2\u02c0\u02be\3",
    "\2\2\2\u02c1\u02c5\5\u00a6T\2\u02c2\u02c5\5*\26\2\u02c3\u02c5\3\2\2",
    "\2\u02c4\u02aa\3\2\2\2\u02c4\u02ae\3\2\2\2\u02c4\u02b8\3\2\2\2\u02c4",
    "\u02c2\3\2\2\2\u02c4\u02c3\3\2\2\2\u02c5=\3\2\2\2\u02c6\u02d7\5*\26",
    "\2\u02c7\u02d2\5p9\2\u02c8\u02ca\7\30\2\2\u02c9\u02c8\3\2\2\2\u02c9",
    "\u02ca\3\2\2\2\u02ca\u02cb\3\2\2\2\u02cb\u02ce\7F\2\2\u02cc\u02ce\7",
    "\26\2\2\u02cd\u02c9\3\2\2\2\u02cd\u02cc\3\2\2\2\u02ce\u02cf\3\2\2\2",
    "\u02cf\u02d0\7\25\2\2\u02d0\u02d2\5\26\f\2\u02d1\u02c7\3\2\2\2\u02d1",
    "\u02cd\3\2\2\2\u02d2\u02d3\3\2\2\2\u02d3\u02d4\7\13\2\2\u02d4\u02d5",
    "\5:\36\2\u02d5\u02d7\3\2\2\2\u02d6\u02c6\3\2\2\2\u02d6\u02d1\3\2\2\2",
    "\u02d7?\3\2\2\2\u02d8\u02dd\5B\"\2\u02d9\u02da\7I\2\2\u02da\u02dc\5",
    "B\"\2\u02db\u02d9\3\2\2\2\u02dc\u02df\3\2\2\2\u02dd\u02db\3\2\2\2\u02dd",
    "\u02de\3\2\2\2\u02deA\3\2\2\2\u02df\u02dd\3\2\2\2\u02e0\u02e1\5L\'\2",
    "\u02e1\u02e2\7+\2\2\u02e2\u02ee\5(\25\2\u02e3\u02e5\7I\2\2\u02e4\u02e3",
    "\3\2\2\2\u02e4\u02e5\3\2\2\2\u02e5\u02e6\3\2\2\2\u02e6\u02ed\5H%\2\u02e7",
    "\u02e8\7I\2\2\u02e8\u02e9\5L\'\2\u02e9\u02ea\7%\2\2\u02ea\u02eb\5(\25",
    "\2\u02eb\u02ed\3\2\2\2\u02ec\u02e4\3\2\2\2\u02ec\u02e7\3\2\2\2\u02ed",
    "\u02f0\3\2\2\2\u02ee\u02ec\3\2\2\2\u02ee\u02ef\3\2\2\2\u02efC\3\2\2",
    "\2\u02f0\u02ee\3\2\2\2\u02f1\u02f3\5F$\2\u02f2\u02f1\3\2\2\2\u02f3\u02f4",
    "\3\2\2\2\u02f4\u02f2\3\2\2\2\u02f4\u02f5\3\2\2\2\u02f5E\3\2\2\2\u02f6",
    "\u02f7\7,\2\2\u02f7\u02f9\5J&\2\u02f8\u02fa\5H%\2\u02f9\u02f8\3\2\2",
    "\2\u02f9\u02fa\3\2\2\2\u02fa\u02fb\3\2\2\2\u02fb\u02fc\7\13\2\2\u02fc",
    "\u02fd\5:\36\2\u02fdG\3\2\2\2\u02fe\u02ff\7\31\2\2\u02ff\u0300\5,\27",
    "\2\u0300I\3\2\2\2\u0301\u0306\5L\'\2\u0302\u0303\7-\2\2\u0303\u0305",
    "\5L\'\2\u0304\u0302\3\2\2\2\u0305\u0308\3\2\2\2\u0306\u0304\3\2\2\2",
    "\u0306\u0307\3\2\2\2\u0307K\3\2\2\2\u0308\u0306\3\2\2\2\u0309\u030a",
    "\7G\2\2\u030a\u030b\7\25\2\2\u030b\u0311\5$\23\2\u030c\u030d\7\26\2",
    "\2\u030d\u030e\7\25\2\2\u030e\u0311\5$\23\2\u030f\u0311\5N(\2\u0310",
    "\u0309\3\2\2\2\u0310\u030c\3\2\2\2\u0310\u030f\3\2\2\2\u0311M\3\2\2",
    "\2\u0312\u0315\7G\2\2\u0313\u0314\7.\2\2\u0314\u0316\5P)\2\u0315\u0313",
    "\3\2\2\2\u0315\u0316\3\2\2\2\u0316\u0319\3\2\2\2\u0317\u0319\5P)\2\u0318",
    "\u0312\3\2\2\2\u0318\u0317\3\2\2\2\u0319O\3\2\2\2\u031a\u0327\5R*\2",
    "\u031b\u0323\5R*\2\u031c\u031e\7F\2\2\u031d\u031f\7H\2\2\u031e\u031d",
    "\3\2\2\2\u031e\u031f\3\2\2\2\u031f\u0320\3\2\2\2\u0320\u0322\5R*\2\u0321",
    "\u031c\3\2\2\2\u0322\u0325\3\2\2\2\u0323\u0321\3\2\2\2\u0323\u0324\3",
    "\2\2\2\u0324\u0327\3\2\2\2\u0325\u0323\3\2\2\2\u0326\u031a\3\2\2\2\u0326",
    "\u031b\3\2\2\2\u0327Q\3\2\2\2\u0328\u0347\7\26\2\2\u0329\u0347\7G\2",
    "\2\u032a\u0347\5\2\2\2\u032b\u0330\5\b\5\2\u032c\u032d\7\f\2\2\u032d",
    "\u032e\5T+\2\u032e\u032f\7\r\2\2\u032f\u0331\3\2\2\2\u0330\u032c\3\2",
    "\2\2\u0330\u0331\3\2\2\2\u0331\u0347\3\2\2\2\u0332\u0333\5\b\5\2\u0333",
    "\u0337\7\f\2\2\u0334\u0335\5T+\2\u0335\u0336\7\6\2\2\u0336\u0338\3\2",
    "\2\2\u0337\u0334\3\2\2\2\u0337\u0338\3\2\2\2\u0338\u033b\3\2\2\2\u0339",
    "\u033a\7G\2\2\u033a\u033c\7.\2\2\u033b\u0339\3\2\2\2\u033b\u033c\3\2",
    "\2\2\u033c\u033d\3\2\2\2\u033d\u033e\7\26\2\2\u033e\u033f\7\27\2\2\u033f",
    "\u0340\7\r\2\2\u0340\u0347\3\2\2\2\u0341\u0343\7\f\2\2\u0342\u0344\5",
    "T+\2\u0343\u0342\3\2\2\2\u0343\u0344\3\2\2\2\u0344\u0345\3\2\2\2\u0345",
    "\u0347\7\r\2\2\u0346\u0328\3\2\2\2\u0346\u0329\3\2\2\2\u0346\u032a\3",
    "\2\2\2\u0346\u032b\3\2\2\2\u0346\u0332\3\2\2\2\u0346\u0341\3\2\2\2\u0347",
    "S\3\2\2\2\u0348\u034d\5J&\2\u0349\u034a\7\6\2\2\u034a\u034c\5T+\2\u034b",
    "\u0349\3\2\2\2\u034c\u034f\3\2\2\2\u034d\u034b\3\2\2\2\u034d\u034e\3",
    "\2\2\2\u034e\u0357\3\2\2\2\u034f\u034d\3\2\2\2\u0350\u0352\7\26\2\2",
    "\u0351\u0350\3\2\2\2\u0352\u0355\3\2\2\2\u0353\u0351\3\2\2\2\u0353\u0354",
    "\3\2\2\2\u0354\u0357\3\2\2\2\u0355\u0353\3\2\2\2\u0356\u0348\3\2\2\2",
    "\u0356\u0353\3\2\2\2\u0357U\3\2\2\2\u0358\u0359\7\t\2\2\u0359\u035e",
    "\5Z.\2\u035a\u035b\7\6\2\2\u035b\u035d\5Z.\2\u035c\u035a\3\2\2\2\u035d",
    "\u0360\3\2\2\2\u035e\u035c\3\2\2\2\u035e\u035f\3\2\2\2\u035f\u0361\3",
    "\2\2\2\u0360\u035e\3\2\2\2\u0361\u0362\7\n\2\2\u0362W\3\2\2\2\u0363",
    "\u0364\7\t\2\2\u0364\u0369\5\\/\2\u0365\u0366\7\6\2\2\u0366\u0368\5",
    "\\/\2\u0367\u0365\3\2\2\2\u0368\u036b\3\2\2\2\u0369\u0367\3\2\2\2\u0369",
    "\u036a\3\2\2\2\u036a\u036c\3\2\2\2\u036b\u0369\3\2\2\2\u036c\u036d\7",
    "\n\2\2\u036dY\3\2\2\2\u036e\u0370\5|?\2\u036f\u036e\3\2\2\2\u036f\u0370",
    "\3\2\2\2\u0370\u0372\3\2\2\2\u0371\u0373\t\4\2\2\u0372\u0371\3\2\2\2",
    "\u0372\u0373\3\2\2\2\u0373\u0374\3\2\2\2\u0374\u0375\5\\/\2\u0375[\3",
    "\2\2\2\u0376\u0378\t\5\2\2\u0377\u0379\5V,\2\u0378\u0377\3\2\2\2\u0378",
    "\u0379\3\2\2\2\u0379\u037c\3\2\2\2\u037a\u037b\7/\2\2\u037b\u037d\5",
    "\f\7\2\u037c\u037a\3\2\2\2\u037c\u037d\3\2\2\2\u037d\u0380\3\2\2\2\u037e",
    "\u037f\7\60\2\2\u037f\u0381\5\f\7\2\u0380\u037e\3\2\2\2\u0380\u0381",
    "\3\2\2\2\u0381\u0386\3\2\2\2\u0382\u0383\7\61\2\2\u0383\u0385\5\f\7",
    "\2\u0384\u0382\3\2\2\2\u0385\u0388\3\2\2\2\u0386\u0384\3\2\2\2\u0386",
    "\u0387\3\2\2\2\u0387\u038d\3\2\2\2\u0388\u0386\3\2\2\2\u0389\u038a\7",
    "\25\2\2\u038a\u038c\5\f\7\2\u038b\u0389\3\2\2\2\u038c\u038f\3\2\2\2",
    "\u038d\u038b\3\2\2\2\u038d\u038e\3\2\2\2\u038e]\3\2\2\2\u038f\u038d",
    "\3\2\2\2\u0390\u0392\5`\61\2\u0391\u0390\3\2\2\2\u0392\u0395\3\2\2\2",
    "\u0393\u0391\3\2\2\2\u0393\u0394\3\2\2\2\u0394\u039e\3\2\2\2\u0395\u0393",
    "\3\2\2\2\u0396\u0398\7H\2\2\u0397\u0396\3\2\2\2\u0397\u0398\3\2\2\2",
    "\u0398\u0399\3\2\2\2\u0399\u039a\7\f\2\2\u039a\u039b\7\30\2\2\u039b",
    "\u039c\5b\62\2\u039c\u039d\7\r\2\2\u039d\u039f\3\2\2\2\u039e\u0397\3",
    "\2\2\2\u039e\u039f\3\2\2\2\u039f_\3\2\2\2\u03a0\u03a2\7H\2\2\u03a1\u03a0",
    "\3\2\2\2\u03a1\u03a2\3\2\2\2\u03a2\u03a3\3\2\2\2\u03a3\u03a5\7\f\2\2",
    "\u03a4\u03a6\5b\62\2\u03a5\u03a4\3\2\2\2\u03a5\u03a6\3\2\2\2\u03a6\u03a7",
    "\3\2\2\2\u03a7\u03a8\7\r\2\2\u03a8a\3\2\2\2\u03a9\u03ae\5d\63\2\u03aa",
    "\u03ab\7\6\2\2\u03ab\u03ad\5d\63\2\u03ac\u03aa\3\2\2\2\u03ad\u03b0\3",
    "\2\2\2\u03ae\u03ac\3\2\2\2\u03ae\u03af\3\2\2\2\u03afc\3\2\2\2\u03b0",
    "\u03ae\3\2\2\2\u03b1\u03b3\5|?\2\u03b2\u03b1\3\2\2\2\u03b3\u03b6\3\2",
    "\2\2\u03b4\u03b2\3\2\2\2\u03b4\u03b5\3\2\2\2\u03b5\u03b7\3\2\2\2\u03b6",
    "\u03b4\3\2\2\2\u03b7\u03ba\7F\2\2\u03b8\u03b9\7\25\2\2\u03b9\u03bb\5",
    "f\64\2\u03ba\u03b8\3\2\2\2\u03ba\u03bb\3\2\2\2\u03bb\u03be\3\2\2\2\u03bc",
    "\u03bd\7%\2\2\u03bd\u03bf\5(\25\2\u03be\u03bc\3\2\2\2\u03be\u03bf\3",
    "\2\2\2\u03bfe\3\2\2\2\u03c0\u03c7\5\f\7\2\u03c1\u03c2\7\13\2\2\u03c2",
    "\u03c7\5\f\7\2\u03c3\u03c4\5\f\7\2\u03c4\u03c5\7\27\2\2\u03c5\u03c7",
    "\3\2\2\2\u03c6\u03c0\3\2\2\2\u03c6\u03c1\3\2\2\2\u03c6\u03c3\3\2\2\2",
    "\u03c7g\3\2\2\2\u03c8\u03ca\5j\66\2\u03c9\u03c8\3\2\2\2\u03ca\u03cd",
    "\3\2\2\2\u03cb\u03c9\3\2\2\2\u03cb\u03cc\3\2\2\2\u03cc\u03d6\3\2\2\2",
    "\u03cd\u03cb\3\2\2\2\u03ce\u03d0\7H\2\2\u03cf\u03ce\3\2\2\2\u03cf\u03d0",
    "\3\2\2\2\u03d0\u03d1\3\2\2\2\u03d1\u03d2\7\f\2\2\u03d2\u03d3\7\30\2",
    "\2\u03d3\u03d4\5l\67\2\u03d4\u03d5\7\r\2\2\u03d5\u03d7\3\2\2\2\u03d6",
    "\u03cf\3\2\2\2\u03d6\u03d7\3\2\2\2\u03d7i\3\2\2\2\u03d8\u03da\7H\2\2",
    "\u03d9\u03d8\3\2\2\2\u03d9\u03da\3\2\2\2\u03da\u03db\3\2\2\2\u03db\u03dd",
    "\7\f\2\2\u03dc\u03de\5l\67\2\u03dd\u03dc\3\2\2\2\u03dd\u03de\3\2\2\2",
    "\u03de\u03df\3\2\2\2\u03df\u03e0\7\r\2\2\u03e0k\3\2\2\2\u03e1\u03e6",
    "\5n8\2\u03e2\u03e3\7\6\2\2\u03e3\u03e5\5n8\2\u03e4\u03e2\3\2\2\2\u03e5",
    "\u03e8\3\2\2\2\u03e6\u03e4\3\2\2\2\u03e6\u03e7\3\2\2\2\u03e7m\3\2\2",
    "\2\u03e8\u03e6\3\2\2\2\u03e9\u03eb\5|?\2\u03ea\u03e9\3\2\2\2\u03eb\u03ee",
    "\3\2\2\2\u03ec\u03ea\3\2\2\2\u03ec\u03ed\3\2\2\2\u03ed\u03f2\3\2\2\2",
    "\u03ee\u03ec\3\2\2\2\u03ef\u03f1\5t;\2\u03f0\u03ef\3\2\2\2\u03f1\u03f4",
    "\3\2\2\2\u03f2\u03f0\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u03f6\3\2\2\2",
    "\u03f4\u03f2\3\2\2\2\u03f5\u03f7\t\6\2\2\u03f6\u03f5\3\2\2\2\u03f6\u03f7",
    "\3\2\2\2\u03f7\u03f8\3\2\2\2\u03f8\u03f9\7F\2\2\u03f9\u03fa\7\25\2\2",
    "\u03fa\u03fd\5f\64\2\u03fb\u03fc\7%\2\2\u03fc\u03fe\5(\25\2\u03fd\u03fb",
    "\3\2\2\2\u03fd\u03fe\3\2\2\2\u03feo\3\2\2\2\u03ff\u0400\7\f\2\2\u0400",
    "\u0405\5r:\2\u0401\u0402\7\6\2\2\u0402\u0404\5r:\2\u0403\u0401\3\2\2",
    "\2\u0404\u0407\3\2\2\2\u0405\u0403\3\2\2\2\u0405\u0406\3\2\2\2\u0406",
    "\u0408\3\2\2\2\u0407\u0405\3\2\2\2\u0408\u0409\7\r\2\2\u0409q\3\2\2",
    "\2\u040a\u040d\t\5\2\2\u040b\u040c\7\25\2\2\u040c\u040e\5\f\7\2\u040d",
    "\u040b\3\2\2\2\u040d\u040e\3\2\2\2\u040es\3\2\2\2\u040f\u0413\5v<\2",
    "\u0410\u0413\5x=\2\u0411\u0413\7\63\2\2\u0412\u040f\3\2\2\2\u0412\u0410",
    "\3\2\2\2\u0412\u0411\3\2\2\2\u0413u\3\2\2\2\u0414\u0415\t\7\2\2\u0415",
    "w\3\2\2\2\u0416\u0418\t\b\2\2\u0417\u0419\5z>\2\u0418\u0417\3\2\2\2",
    "\u0418\u0419\3\2\2\2\u0419y\3\2\2\2\u041a\u041b\7\t\2\2\u041b\u041c",
    "\t\t\2\2\u041c\u041d\7\n\2\2\u041d{\3\2\2\2\u041e\u041f\7.\2\2\u041f",
    "\u0423\5\32\16\2\u0420\u0422\5\66\34\2\u0421\u0420\3\2\2\2\u0422\u0425",
    "\3\2\2\2\u0423\u0421\3\2\2\2\u0423\u0424\3\2\2\2\u0424}\3\2\2\2\u0425",
    "\u0423\3\2\2\2\u0426\u0427\7.\2\2\u0427\u0428\5\32\16\2\u0428\u0429",
    "\5\66\34\2\u0429\177\3\2\2\2\u042a\u042c\7H\2\2\u042b\u042a\3\2\2\2",
    "\u042b\u042c\3\2\2\2\u042c\u042d\3\2\2\2\u042d\u042f\7\17\2\2\u042e",
    "\u0430\5\u0084C\2\u042f\u042e\3\2\2\2\u042f\u0430\3\2\2\2\u0430\u0431",
    "\3\2\2\2\u0431\u0436\5\u0082B\2\u0432\u0433\7I\2\2\u0433\u0435\5\u0082",
    "B\2\u0434\u0432\3\2\2\2\u0435\u0438\3\2\2\2\u0436\u0434\3\2\2\2\u0436",
    "\u0437\3\2\2\2\u0437\u0439\3\2\2\2\u0438\u0436\3\2\2\2\u0439\u043a\7",
    "\20\2\2\u043a\u0081\3\2\2\2\u043b\u045f\5\u0086D\2\u043c\u043e\5|?\2",
    "\u043d\u043f\7H\2\2\u043e\u043d\3\2\2\2\u043e\u043f\3\2\2\2\u043f\u0441",
    "\3\2\2\2\u0440\u043c\3\2\2\2\u0441\u0444\3\2\2\2\u0442\u0440\3\2\2\2",
    "\u0442\u0443\3\2\2\2\u0443\u0448\3\2\2\2\u0444\u0442\3\2\2\2\u0445\u0447",
    "\5t;\2\u0446\u0445\3\2\2\2\u0447\u044a\3\2\2\2\u0448\u0446\3\2\2\2\u0448",
    "\u0449\3\2\2\2\u0449\u044b\3\2\2\2\u044a\u0448\3\2\2\2\u044b\u045f\5",
    "\u009cO\2\u044c\u044e\5|?\2\u044d\u044f\7H\2\2\u044e\u044d\3\2\2\2\u044e",
    "\u044f\3\2\2\2\u044f\u0451\3\2\2\2\u0450\u044c\3\2\2\2\u0451\u0454\3",
    "\2\2\2\u0452\u0450\3\2\2\2\u0452\u0453\3\2\2\2\u0453\u0458\3\2\2\2\u0454",
    "\u0452\3\2\2\2\u0455\u0457\5t;\2\u0456\u0455\3\2\2\2\u0457\u045a\3\2",
    "\2\2\u0458\u0456\3\2\2\2\u0458\u0459\3\2\2\2\u0459\u045b\3\2\2\2\u045a",
    "\u0458\3\2\2\2\u045b\u045f\5\u008eH\2\u045c\u045f\5(\25\2\u045d\u045f",
    "\3\2\2\2\u045e\u043b\3\2\2\2\u045e\u0442\3\2\2\2\u045e\u0452\3\2\2\2",
    "\u045e\u045c\3\2\2\2\u045e\u045d\3\2\2\2\u045f\u0083\3\2\2\2\u0460\u0463",
    "\7F\2\2\u0461\u0462\7\25\2\2\u0462\u0464\5\f\7\2\u0463\u0461\3\2\2\2",
    "\u0463\u0464\3\2\2\2\u0464\u0465\3\2\2\2\u0465\u046c\7\13\2\2\u0466",
    "\u0467\7\7\2\2\u0467\u0468\7\25\2\2\u0468\u0469\5\f\7\2\u0469\u046a",
    "\7\13\2\2\u046a\u046c\3\2\2\2\u046b\u0460\3\2\2\2\u046b\u0466\3\2\2",
    "\2\u046c\u0085\3\2\2\2\u046d\u046e\79\2\2\u046e\u0473\5\u0088E\2\u046f",
    "\u0470\7\6\2\2\u0470\u0472\5\u0088E\2\u0471\u046f\3\2\2\2\u0472\u0475",
    "\3\2\2\2\u0473\u0471\3\2\2\2\u0473\u0474\3\2\2\2\u0474\u0087\3\2\2\2",
    "\u0475\u0473\3\2\2\2\u0476\u0477\5\b\5\2\u0477\u047b\7\5\2\2\u0478\u047c",
    "\7F\2\2\u0479\u047c\7\26\2\2\u047a\u047c\5\u008aF\2\u047b\u0478\3\2",
    "\2\2\u047b\u0479\3\2\2\2\u047b\u047a\3\2\2\2\u047c\u0089\3\2\2\2\u047d",
    "\u0483\7\17\2\2\u047e\u047f\5\u008cG\2\u047f\u0480\7\6\2\2\u0480\u0482",
    "\3\2\2\2\u0481\u047e\3\2\2\2\u0482\u0485\3\2\2\2\u0483\u0481\3\2\2\2",
    "\u0483\u0484\3\2\2\2\u0484\u0488\3\2\2\2\u0485\u0483\3\2\2\2\u0486\u0489",
    "\5\u008cG\2\u0487\u0489\7\26\2\2\u0488\u0486\3\2\2\2\u0488\u0487\3\2",
    "\2\2\u0489\u048a\3\2\2\2\u048a\u048b\7\20\2\2\u048b\u008b\3\2\2\2\u048c",
    "\u0491\7F\2\2\u048d\u048e\7\13\2\2\u048e\u0492\7F\2\2\u048f\u0490\7",
    "\13\2\2\u0490\u0492\7\26\2\2\u0491\u048d\3\2\2\2\u0491\u048f\3\2\2\2",
    "\u0492\u008d\3\2\2\2\u0493\u0494\7\22\2\2\u0494\u04a2\5\u0090I\2\u0495",
    "\u0496\7\62\2\2\u0496\u04a2\5\u0092J\2\u0497\u0498\7:\2\2\u0498\u04a2",
    "\5\u0094K\2\u0499\u049d\7\21\2\2\u049a\u049c\7H\2\2\u049b\u049a\3\2",
    "\2\2\u049c\u049f\3\2\2\2\u049d\u049b\3\2\2\2\u049d\u049e\3\2\2\2\u049e",
    "\u04a0\3\2\2\2\u049f\u049d\3\2\2\2\u04a0\u04a2\5\u0098M\2\u04a1\u0493",
    "\3\2\2\2\u04a1\u0495\3\2\2\2\u04a1\u0497\3\2\2\2\u04a1\u0499\3\2\2\2",
    "\u04a2\u008f\3\2\2\2\u04a3\u04a4\5\6\4\2\u04a4\u04a5\7\25\2\2\u04a5",
    "\u04a6\5\f\7\2\u04a6\u0091\3\2\2\2\u04a7\u04a8\5\6\4\2\u04a8\u04a9\7",
    "\25\2\2\u04a9\u04aa\5\f\7\2\u04aa\u0093\3\2\2\2\u04ab\u04ae\5\u0096",
    "L\2\u04ac\u04ad\7\25\2\2\u04ad\u04af\5\f\7\2\u04ae\u04ac\3\2\2\2\u04ae",
    "\u04af\3\2\2\2\u04af\u0095\3\2\2\2\u04b0\u04b2\7F\2\2\u04b1\u04b3\5",
    "X-\2\u04b2\u04b1\3\2\2\2\u04b2\u04b3\3\2\2\2\u04b3\u04b4\3\2\2\2\u04b4",
    "\u04b5\5^\60\2\u04b5\u0097\3\2\2\2\u04b6\u04b8\7F\2\2\u04b7\u04b9\5",
    "V,\2\u04b8\u04b7\3\2\2\2\u04b8\u04b9\3\2\2\2\u04b9\u04bc\3\2\2\2\u04ba",
    "\u04bb\7/\2\2\u04bb\u04bd\5\f\7\2\u04bc\u04ba\3\2\2\2\u04bc\u04bd\3",
    "\2\2\2\u04bd\u04c0\3\2\2\2\u04be\u04bf\7\60\2\2\u04bf\u04c1\5\f\7\2",
    "\u04c0\u04be\3\2\2\2\u04c0\u04c1\3\2\2\2\u04c1\u0099\3\2\2\2\u04c2\u04c3",
    "\7\22\2\2\u04c3\u04c7\5\u009eP\2\u04c4\u04c5\7\62\2\2\u04c5\u04c7\5",
    "\u00a0Q\2\u04c6\u04c2\3\2\2\2\u04c6\u04c4\3\2\2\2\u04c7\u009b\3\2\2",
    "\2\u04c8\u04d5\5\u009aN\2\u04c9\u04ca\7:\2\2\u04ca\u04d5\5\u00a2R\2",
    "\u04cb\u04cf\7\21\2\2\u04cc\u04ce\7H\2\2\u04cd\u04cc\3\2\2\2\u04ce\u04d1",
    "\3\2\2\2\u04cf\u04cd\3\2\2\2\u04cf\u04d0\3\2\2\2\u04d0\u04d2\3\2\2\2",
    "\u04d1\u04cf\3\2\2\2\u04d2\u04d5\5\u00a4S\2\u04d3\u04d5\5\u00a6T\2\u04d4",
    "\u04c8\3\2\2\2\u04d4\u04c9\3\2\2\2\u04d4\u04cb\3\2\2\2\u04d4\u04d3\3",
    "\2\2\2\u04d5\u009d\3\2\2\2\u04d6\u04db\5N(\2\u04d7\u04d8\7\6\2\2\u04d8",
    "\u04da\5N(\2\u04d9\u04d7\3\2\2\2\u04da\u04dd\3\2\2\2\u04db\u04d9\3\2",
    "\2\2\u04db\u04dc\3\2\2\2\u04dc\u04e2\3\2\2\2\u04dd\u04db\3\2\2\2\u04de",
    "\u04df\7\25\2\2\u04df\u04e1\5\f\7\2\u04e0\u04de\3\2\2\2\u04e1\u04e4",
    "\3\2\2\2\u04e2\u04e0\3\2\2\2\u04e2\u04e3\3\2\2\2\u04e3\u04e5\3\2\2\2",
    "\u04e4\u04e2\3\2\2\2\u04e5\u04e6\7%\2\2\u04e6\u04e7\5(\25\2\u04e7\u009f",
    "\3\2\2\2\u04e8\u04f0\5\u009eP\2\u04e9\u04ea\5\6\4\2\u04ea\u04eb\7\25",
    "\2\2\u04eb\u04ec\5\f\7\2\u04ec\u04ed\7%\2\2\u04ed\u04ee\7\26\2\2\u04ee",
    "\u04f0\3\2\2\2\u04ef\u04e8\3\2\2\2\u04ef\u04e9\3\2\2\2\u04f0\u00a1\3",
    "\2\2\2\u04f1\u04f4\5\u0096L\2\u04f2\u04f3\7\25\2\2\u04f3\u04f5\5\f\7",
    "\2\u04f4\u04f2\3\2\2\2\u04f4\u04f5\3\2\2\2\u04f5\u04f6\3\2\2\2\u04f6",
    "\u04f7\7%\2\2\u04f7\u04f8\5(\25\2\u04f8\u050b\3\2\2\2\u04f9\u04fb\5",
    "\u0096L\2\u04fa\u04fc\7H\2\2\u04fb\u04fa\3\2\2\2\u04fb\u04fc\3\2\2\2",
    "\u04fc\u04fd\3\2\2\2\u04fd\u04fe\7\17\2\2\u04fe\u04ff\5:\36\2\u04ff",
    "\u0500\7\20\2\2\u0500\u050b\3\2\2\2\u0501\u0502\7\7\2\2\u0502\u0503",
    "\5`\61\2\u0503\u0508\5^\60\2\u0504\u0505\7%\2\2\u0505\u0509\5\u00c0",
    "a\2\u0506\u0507\7H\2\2\u0507\u0509\5\u00c2b\2\u0508\u0504\3\2\2\2\u0508",
    "\u0506\3\2\2\2\u0509\u050b\3\2\2\2\u050a\u04f1\3\2\2\2\u050a\u04f9\3",
    "\2\2\2\u050a\u0501\3\2\2\2\u050b\u00a3\3\2\2\2\u050c\u050e\7F\2\2\u050d",
    "\u050f\5V,\2\u050e\u050d\3\2\2\2\u050e\u050f\3\2\2\2\u050f\u0510\3\2",
    "\2\2\u0510\u0511\7%\2\2\u0511\u0512\5\f\7\2\u0512\u00a5\3\2\2\2\u0513",
    "\u0515\7,\2\2\u0514\u0513\3\2\2\2\u0514\u0515\3\2\2\2\u0515\u0516\3",
    "\2\2\2\u0516\u0517\7;\2\2\u0517\u051e\5\u00a8U\2\u0518\u0519\7,\2\2",
    "\u0519\u051a\7<\2\2\u051a\u051e\5\u00acW\2\u051b\u051c\7=\2\2\u051c",
    "\u051e\5\u00aaV\2\u051d\u0514\3\2\2\2\u051d\u0518\3\2\2\2\u051d\u051b",
    "\3\2\2\2\u051e\u00a7\3\2\2\2\u051f\u0521\7F\2\2\u0520\u0522\5V,\2\u0521",
    "\u0520\3\2\2\2\u0521\u0522\3\2\2\2\u0522\u0526\3\2\2\2\u0523\u0525\5",
    "~@\2\u0524\u0523\3\2\2\2\u0525\u0528\3\2\2\2\u0526\u0524\3\2\2\2\u0526",
    "\u0527\3\2\2\2\u0527\u052a\3\2\2\2\u0528\u0526\3\2\2\2\u0529\u052b\5",
    "x=\2\u052a\u0529\3\2\2\2\u052a\u052b\3\2\2\2\u052b\u052c\3\2\2\2\u052c",
    "\u052d\5h\65\2\u052d\u052e\5\u00aeX\2\u052e\u00a9\3\2\2\2\u052f\u0531",
    "\7F\2\2\u0530\u0532\5V,\2\u0531\u0530\3\2\2\2\u0531\u0532\3\2\2\2\u0532",
    "\u0533\3\2\2\2\u0533\u0534\5\u00b0Y\2\u0534\u00ab\3\2\2\2\u0535\u0536",
    "\7F\2\2\u0536\u0537\5\u00aeX\2\u0537\u00ad\3\2\2\2\u0538\u0539\7>\2",
    "\2\u0539\u0541\5\u00b2Z\2\u053a\u053c\7>\2\2\u053b\u053a\3\2\2\2\u053b",
    "\u053c\3\2\2\2\u053c\u053d\3\2\2\2\u053d\u053f\5\u0080A\2\u053e\u053b",
    "\3\2\2\2\u053e\u053f\3\2\2\2\u053f\u0541\3\2\2\2\u0540\u0538\3\2\2\2",
    "\u0540\u053e\3\2\2\2\u0541\u00af\3\2\2\2\u0542\u0543\7>\2\2\u0543\u054b",
    "\5\u00b4[\2\u0544\u0546\7>\2\2\u0545\u0544\3\2\2\2\u0545\u0546\3\2\2",
    "\2\u0546\u0547\3\2\2\2\u0547\u0549\5\u0080A\2\u0548\u0545\3\2\2\2\u0548",
    "\u0549\3\2\2\2\u0549\u054b\3\2\2\2\u054a\u0542\3\2\2\2\u054a\u0548\3",
    "\2\2\2\u054b\u00b1\3\2\2\2\u054c\u054e\5\u00bc_\2\u054d\u054c\3\2\2",
    "\2\u054d\u054e\3\2\2\2\u054e\u054f\3\2\2\2\u054f\u0551\5\u00b6\\\2\u0550",
    "\u0552\5\u0080A\2\u0551\u0550\3\2\2\2\u0551\u0552\3\2\2\2\u0552\u00b3",
    "\3\2\2\2\u0553\u0555\5\u00bc_\2\u0554\u0553\3\2\2\2\u0554\u0555\3\2",
    "\2\2\u0555\u0556\3\2\2\2\u0556\u0558\5\u00b8]\2\u0557\u0559\5\u0080",
    "A\2\u0558\u0557\3\2\2\2\u0558\u0559\3\2\2\2\u0559\u00b5\3\2\2\2\u055a",
    "\u055f\5\u00ba^\2\u055b\u055c\7\23\2\2\u055c\u055e\5\30\r\2\u055d\u055b",
    "\3\2\2\2\u055e\u0561\3\2\2\2\u055f\u055d\3\2\2\2\u055f\u0560\3\2\2\2",
    "\u0560\u00b7\3\2\2\2\u0561\u055f\3\2\2\2\u0562\u0567\5\30\r\2\u0563",
    "\u0564\7\23\2\2\u0564\u0566\5\30\r\2\u0565\u0563\3\2\2\2\u0566\u0569",
    "\3\2\2\2\u0567\u0565\3\2\2\2\u0567\u0568\3\2\2\2\u0568\u00b9\3\2\2\2",
    "\u0569\u0567\3\2\2\2\u056a\u056e\5\30\r\2\u056b\u056d\5\66\34\2\u056c",
    "\u056b\3\2\2\2\u056d\u0570\3\2\2\2\u056e\u056c\3\2\2\2\u056e\u056f\3",
    "\2\2\2\u056f\u00bb\3\2\2\2\u0570\u056e\3\2\2\2\u0571\u057a\7\17\2\2",
    "\u0572\u0577\5\u00be`\2\u0573\u0574\7I\2\2\u0574\u0576\5\u00be`\2\u0575",
    "\u0573\3\2\2\2\u0576\u0579\3\2\2\2\u0577\u0575\3\2\2\2\u0577\u0578\3",
    "\2\2\2\u0578\u057b\3\2\2\2\u0579\u0577\3\2\2\2\u057a\u0572\3\2\2\2\u057a",
    "\u057b\3\2\2\2\u057b\u057c\3\2\2\2\u057c\u057d\7\20\2\2\u057d\u057e",
    "\7\23\2\2\u057e\u00bd\3\2\2\2\u057f\u0581\5|?\2\u0580\u0582\7H\2\2\u0581",
    "\u0580\3\2\2\2\u0581\u0582\3\2\2\2\u0582\u0584\3\2\2\2\u0583\u057f\3",
    "\2\2\2\u0584\u0587\3\2\2\2\u0585\u0583\3\2\2\2\u0585\u0586\3\2\2\2\u0586",
    "\u058b\3\2\2\2\u0587\u0585\3\2\2\2\u0588\u058a\5t;\2\u0589\u0588\3\2",
    "\2\2\u058a\u058d\3\2\2\2\u058b\u0589\3\2\2\2\u058b\u058c\3\2\2\2\u058c",
    "\u058e\3\2\2\2\u058d\u058b\3\2\2\2\u058e\u058f\5\u009aN\2\u058f\u00bf",
    "\3\2\2\2\u0590\u0593\5\u00c4c\2\u0591\u0593\5\u00c2b\2\u0592\u0590\3",
    "\2\2\2\u0592\u0591\3\2\2\2\u0593\u00c1\3\2\2\2\u0594\u0595\7\17\2\2",
    "\u0595\u059a\5\u00c4c\2\u0596\u0597\7I\2\2\u0597\u0599\5<\37\2\u0598",
    "\u0596\3\2\2\2\u0599\u059c\3\2\2\2\u059a\u0598\3\2\2\2\u059a\u059b\3",
    "\2\2\2\u059b\u059d\3\2\2\2\u059c\u059a\3\2\2\2\u059d\u059e\7\20\2\2",
    "\u059e\u00c3\3\2\2\2\u059f\u05a1\7\7\2\2\u05a0\u05a2\5\66\34\2\u05a1",
    "\u05a0\3\2\2\2\u05a2\u05a3\3\2\2\2\u05a3\u05a1\3\2\2\2\u05a3\u05a4\3",
    "\2\2\2\u05a4\u00c5\3\2\2\2\u05a5\u05aa\5\u00c8e\2\u05a6\u05a7\7I\2\2",
    "\u05a7\u05a9\5\u00c8e\2\u05a8\u05a6\3\2\2\2\u05a9\u05ac\3\2\2\2\u05aa",
    "\u05a8\3\2\2\2\u05aa\u05ab\3\2\2\2\u05ab\u00c7\3\2\2\2\u05ac\u05aa\3",
    "\2\2\2\u05ad\u05af\5|?\2\u05ae\u05b0\7H\2\2\u05af\u05ae\3\2\2\2\u05af",
    "\u05b0\3\2\2\2\u05b0\u05b2\3\2\2\2\u05b1\u05ad\3\2\2\2\u05b2\u05b5\3",
    "\2\2\2\u05b3\u05b1\3\2\2\2\u05b3\u05b4\3\2\2\2\u05b4\u05b9\3\2\2\2\u05b5",
    "\u05b3\3\2\2\2\u05b6\u05b8\5t;\2\u05b7\u05b6\3\2\2\2\u05b8\u05bb\3\2",
    "\2\2\u05b9\u05b7\3\2\2\2\u05b9\u05ba\3\2\2\2\u05ba\u05bc\3\2\2\2\u05bb",
    "\u05b9\3\2\2\2\u05bc\u05c2\5\u00a6T\2\u05bd\u05c2\5\u0086D\2\u05be\u05c2",
    "\5\u00caf\2\u05bf\u05c2\5\u00ccg\2\u05c0\u05c2\3\2\2\2\u05c1\u05b3\3",
    "\2\2\2\u05c1\u05bd\3\2\2\2\u05c1\u05be\3\2\2\2\u05c1\u05bf\3\2\2\2\u05c1",
    "\u05c0\3\2\2\2\u05c2\u00c9\3\2\2\2\u05c3\u05c4\7?\2\2\u05c4\u05c6\5",
    "\4\3\2\u05c5\u05c7\7H\2\2\u05c6\u05c5\3\2\2\2\u05c6\u05c7\3\2\2\2\u05c7",
    "\u05c8\3\2\2\2\u05c8\u05c9\7\17\2\2\u05c9\u05ca\5\u00c6d\2\u05ca\u05cb",
    "\7\20\2\2\u05cb\u00cb\3\2\2\2\u05cc\u05cd\7?\2\2\u05cd\u05ce\7<\2\2",
    "\u05ce\u05cf\5\u00acW\2\u05cf\u00cd\3\2\2\2\u05d0\u05d1\7?\2\2\u05d1",
    "\u05d2\5\4\3\2\u05d2\u05d3\7I\2\2\u05d3\u05d5\3\2\2\2\u05d4\u05d0\3",
    "\2\2\2\u05d5\u05d8\3\2\2\2\u05d6\u05d4\3\2\2\2\u05d6\u05d7\3\2\2\2\u05d7",
    "\u05d9\3\2\2\2\u05d8\u05d6\3\2\2\2\u05d9\u05da\5\u00c6d\2\u05da\u00cf",
    "\3\2\2\2\u00d4\u00d1\u00d5\u00dd\u00e4\u00ec\u00f2\u00f5\u00fb\u00ff",
    "\u0103\u010f\u0111\u011a\u011d\u0120\u0129\u0132\u0137\u013c\u0144\u0148",
    "\u014b\u0151\u0159\u015c\u0164\u016b\u016d\u0179\u017d\u0185\u018e\u0198",
    "\u019d\u01a1\u01a5\u01aa\u01b3\u01b8\u01bc\u01c5\u01d0\u01d7\u01db\u01e0",
    "\u01f0\u01f5\u01f9\u0201\u0206\u020b\u020d\u0224\u0229\u022b\u0233\u0238",
    "\u023c\u0241\u0246\u0248\u024f\u0255\u025b\u025e\u0266\u0269\u026d\u0273",
    "\u027b\u0280\u0287\u0290\u0293\u029d\u02a4\u02a8\u02ae\u02b2\u02b8\u02be",
    "\u02c4\u02c9\u02cd\u02d1\u02d6\u02dd\u02e4\u02ec\u02ee\u02f4\u02f9\u0306",
    "\u0310\u0315\u0318\u031e\u0323\u0326\u0330\u0337\u033b\u0343\u0346\u034d",
    "\u0353\u0356\u035e\u0369\u036f\u0372\u0378\u037c\u0380\u0386\u038d\u0393",
    "\u0397\u039e\u03a1\u03a5\u03ae\u03b4\u03ba\u03be\u03c6\u03cb\u03cf\u03d6",
    "\u03d9\u03dd\u03e6\u03ec\u03f2\u03f6\u03fd\u0405\u040d\u0412\u0418\u0423",
    "\u042b\u042f\u0436\u043e\u0442\u0448\u044e\u0452\u0458\u045e\u0463\u046b",
    "\u0473\u047b\u0483\u0488\u0491\u049d\u04a1\u04ae\u04b2\u04b8\u04bc\u04c0",
    "\u04c6\u04cf\u04d4\u04db\u04e2\u04ef\u04f4\u04fb\u0508\u050a\u050e\u0514",
    "\u051d\u0521\u0526\u052a\u0531\u053b\u053e\u0540\u0545\u0548\u054a\u054d",
    "\u0551\u0554\u0558\u055f\u0567\u056e\u0577\u057a\u0581\u0585\u058b\u0592",
    "\u059a\u05a3\u05aa\u05af\u05b3\u05b9\u05c1\u05c6\u05d6"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ 'null', "'-'", "'null'", "'.'", "','", "'this'", "'super'", 
                     "'['", "']'", "'=>'", "'('", "')'", "'forSome'", "'{'", 
                     "'}'", "'type'", "'val'", "'with'", "'#'", "':'", "'_'", 
                     "'*'", "'implicit'", "'if'", "'else'", "'while'", "'try'", 
                     "'catch'", "'finally'", "'do'", "'for'", "'yield'", 
                     "'throw'", "'return'", "'new'", "'='", "'match'", "'+'", 
                     "'~'", "'!'", "'lazy'", "'<-'", "'case'", "'|'", "'@'", 
                     "'>:'", "'<:'", "'<%'", "'var'", "'override'", "'abstract'", 
                     "'final'", "'sealed'", "'private'", "'protected'", 
                     "'import'", "'def'", "'class'", "'object'", "'trait'", 
                     "'extends'", "'package'" ];

var symbolicNames = [ 'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', 'null', 
                      'null', 'null', 'null', 'null', 'null', 'null', "BooleanLiteral", 
                      "CharacterLiteral", "StringLiteral", "SymbolLiteral", 
                      "IntegerLiteral", "FloatingPointLiteral", "Id", "Varid", 
                      "Nl", "Semi", "Paren", "Delim", "Comment" ];

var ruleNames =  [ "literal", "qualId", "ids", "stableId", "classQualifier", 
                   "type", "functionArgTypes", "existentialClause", "existentialDcl", 
                   "infixType", "compoundType", "annotType", "simpleType", 
                   "typeArgs", "types", "refinement", "refineStat", "typePat", 
                   "ascription", "expr", "expr1", "postfixExpr", "infixExpr", 
                   "prefixExpr", "simpleExpr1", "exprs", "argumentExprs", 
                   "blockExpr", "block", "blockStat", "resultExpr", "enumerators", 
                   "generator", "caseClauses", "caseClause", "guard", "pattern", 
                   "pattern1", "pattern2", "pattern3", "simplePattern", 
                   "patterns", "typeParamClause", "funTypeParamClause", 
                   "variantTypeParam", "typeParam", "paramClauses", "paramClause", 
                   "params", "param", "paramType", "classParamClauses", 
                   "classParamClause", "classParams", "classParam", "bindings", 
                   "binding", "modifier", "localModifier", "accessModifier", 
                   "accessQualifier", "annotation", "constrAnnotation", 
                   "templateBody", "templateStat", "selfType", "import_", 
                   "importExpr", "importSelectors", "importSelector", "dcl", 
                   "valDcl", "varDcl", "funDcl", "funSig", "typeDcl", "patVarDef", 
                   "def", "patDef", "varDef", "funDef", "typeDef", "tmplDef", 
                   "classDef", "traitDef", "objectDef", "classTemplateOpt", 
                   "traitTemplateOpt", "classTemplate", "traitTemplate", 
                   "classParents", "traitParents", "constr", "earlyDefs", 
                   "earlyDef", "constrExpr", "constrBlock", "selfInvocation", 
                   "topStatSeq", "topStat", "packaging", "packageObject", 
                   "compilationUnit" ];

function ScalaParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

ScalaParser.prototype = Object.create(antlr4.Parser.prototype);
ScalaParser.prototype.constructor = ScalaParser;

Object.defineProperty(ScalaParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

ScalaParser.EOF = antlr4.Token.EOF;
ScalaParser.T__0 = 1;
ScalaParser.T__1 = 2;
ScalaParser.T__2 = 3;
ScalaParser.T__3 = 4;
ScalaParser.T__4 = 5;
ScalaParser.T__5 = 6;
ScalaParser.T__6 = 7;
ScalaParser.T__7 = 8;
ScalaParser.T__8 = 9;
ScalaParser.T__9 = 10;
ScalaParser.T__10 = 11;
ScalaParser.T__11 = 12;
ScalaParser.T__12 = 13;
ScalaParser.T__13 = 14;
ScalaParser.T__14 = 15;
ScalaParser.T__15 = 16;
ScalaParser.T__16 = 17;
ScalaParser.T__17 = 18;
ScalaParser.T__18 = 19;
ScalaParser.T__19 = 20;
ScalaParser.T__20 = 21;
ScalaParser.T__21 = 22;
ScalaParser.T__22 = 23;
ScalaParser.T__23 = 24;
ScalaParser.T__24 = 25;
ScalaParser.T__25 = 26;
ScalaParser.T__26 = 27;
ScalaParser.T__27 = 28;
ScalaParser.T__28 = 29;
ScalaParser.T__29 = 30;
ScalaParser.T__30 = 31;
ScalaParser.T__31 = 32;
ScalaParser.T__32 = 33;
ScalaParser.T__33 = 34;
ScalaParser.T__34 = 35;
ScalaParser.T__35 = 36;
ScalaParser.T__36 = 37;
ScalaParser.T__37 = 38;
ScalaParser.T__38 = 39;
ScalaParser.T__39 = 40;
ScalaParser.T__40 = 41;
ScalaParser.T__41 = 42;
ScalaParser.T__42 = 43;
ScalaParser.T__43 = 44;
ScalaParser.T__44 = 45;
ScalaParser.T__45 = 46;
ScalaParser.T__46 = 47;
ScalaParser.T__47 = 48;
ScalaParser.T__48 = 49;
ScalaParser.T__49 = 50;
ScalaParser.T__50 = 51;
ScalaParser.T__51 = 52;
ScalaParser.T__52 = 53;
ScalaParser.T__53 = 54;
ScalaParser.T__54 = 55;
ScalaParser.T__55 = 56;
ScalaParser.T__56 = 57;
ScalaParser.T__57 = 58;
ScalaParser.T__58 = 59;
ScalaParser.T__59 = 60;
ScalaParser.T__60 = 61;
ScalaParser.BooleanLiteral = 62;
ScalaParser.CharacterLiteral = 63;
ScalaParser.StringLiteral = 64;
ScalaParser.SymbolLiteral = 65;
ScalaParser.IntegerLiteral = 66;
ScalaParser.FloatingPointLiteral = 67;
ScalaParser.Id = 68;
ScalaParser.Varid = 69;
ScalaParser.Nl = 70;
ScalaParser.Semi = 71;
ScalaParser.Paren = 72;
ScalaParser.Delim = 73;
ScalaParser.Comment = 74;

ScalaParser.RULE_literal = 0;
ScalaParser.RULE_qualId = 1;
ScalaParser.RULE_ids = 2;
ScalaParser.RULE_stableId = 3;
ScalaParser.RULE_classQualifier = 4;
ScalaParser.RULE_type = 5;
ScalaParser.RULE_functionArgTypes = 6;
ScalaParser.RULE_existentialClause = 7;
ScalaParser.RULE_existentialDcl = 8;
ScalaParser.RULE_infixType = 9;
ScalaParser.RULE_compoundType = 10;
ScalaParser.RULE_annotType = 11;
ScalaParser.RULE_simpleType = 12;
ScalaParser.RULE_typeArgs = 13;
ScalaParser.RULE_types = 14;
ScalaParser.RULE_refinement = 15;
ScalaParser.RULE_refineStat = 16;
ScalaParser.RULE_typePat = 17;
ScalaParser.RULE_ascription = 18;
ScalaParser.RULE_expr = 19;
ScalaParser.RULE_expr1 = 20;
ScalaParser.RULE_postfixExpr = 21;
ScalaParser.RULE_infixExpr = 22;
ScalaParser.RULE_prefixExpr = 23;
ScalaParser.RULE_simpleExpr1 = 24;
ScalaParser.RULE_exprs = 25;
ScalaParser.RULE_argumentExprs = 26;
ScalaParser.RULE_blockExpr = 27;
ScalaParser.RULE_block = 28;
ScalaParser.RULE_blockStat = 29;
ScalaParser.RULE_resultExpr = 30;
ScalaParser.RULE_enumerators = 31;
ScalaParser.RULE_generator = 32;
ScalaParser.RULE_caseClauses = 33;
ScalaParser.RULE_caseClause = 34;
ScalaParser.RULE_guard = 35;
ScalaParser.RULE_pattern = 36;
ScalaParser.RULE_pattern1 = 37;
ScalaParser.RULE_pattern2 = 38;
ScalaParser.RULE_pattern3 = 39;
ScalaParser.RULE_simplePattern = 40;
ScalaParser.RULE_patterns = 41;
ScalaParser.RULE_typeParamClause = 42;
ScalaParser.RULE_funTypeParamClause = 43;
ScalaParser.RULE_variantTypeParam = 44;
ScalaParser.RULE_typeParam = 45;
ScalaParser.RULE_paramClauses = 46;
ScalaParser.RULE_paramClause = 47;
ScalaParser.RULE_params = 48;
ScalaParser.RULE_param = 49;
ScalaParser.RULE_paramType = 50;
ScalaParser.RULE_classParamClauses = 51;
ScalaParser.RULE_classParamClause = 52;
ScalaParser.RULE_classParams = 53;
ScalaParser.RULE_classParam = 54;
ScalaParser.RULE_bindings = 55;
ScalaParser.RULE_binding = 56;
ScalaParser.RULE_modifier = 57;
ScalaParser.RULE_localModifier = 58;
ScalaParser.RULE_accessModifier = 59;
ScalaParser.RULE_accessQualifier = 60;
ScalaParser.RULE_annotation = 61;
ScalaParser.RULE_constrAnnotation = 62;
ScalaParser.RULE_templateBody = 63;
ScalaParser.RULE_templateStat = 64;
ScalaParser.RULE_selfType = 65;
ScalaParser.RULE_import_ = 66;
ScalaParser.RULE_importExpr = 67;
ScalaParser.RULE_importSelectors = 68;
ScalaParser.RULE_importSelector = 69;
ScalaParser.RULE_dcl = 70;
ScalaParser.RULE_valDcl = 71;
ScalaParser.RULE_varDcl = 72;
ScalaParser.RULE_funDcl = 73;
ScalaParser.RULE_funSig = 74;
ScalaParser.RULE_typeDcl = 75;
ScalaParser.RULE_patVarDef = 76;
ScalaParser.RULE_def = 77;
ScalaParser.RULE_patDef = 78;
ScalaParser.RULE_varDef = 79;
ScalaParser.RULE_funDef = 80;
ScalaParser.RULE_typeDef = 81;
ScalaParser.RULE_tmplDef = 82;
ScalaParser.RULE_classDef = 83;
ScalaParser.RULE_traitDef = 84;
ScalaParser.RULE_objectDef = 85;
ScalaParser.RULE_classTemplateOpt = 86;
ScalaParser.RULE_traitTemplateOpt = 87;
ScalaParser.RULE_classTemplate = 88;
ScalaParser.RULE_traitTemplate = 89;
ScalaParser.RULE_classParents = 90;
ScalaParser.RULE_traitParents = 91;
ScalaParser.RULE_constr = 92;
ScalaParser.RULE_earlyDefs = 93;
ScalaParser.RULE_earlyDef = 94;
ScalaParser.RULE_constrExpr = 95;
ScalaParser.RULE_constrBlock = 96;
ScalaParser.RULE_selfInvocation = 97;
ScalaParser.RULE_topStatSeq = 98;
ScalaParser.RULE_topStat = 99;
ScalaParser.RULE_packaging = 100;
ScalaParser.RULE_packageObject = 101;
ScalaParser.RULE_compilationUnit = 102;

function LiteralContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_literal;
    return this;
}

LiteralContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LiteralContext.prototype.constructor = LiteralContext;

LiteralContext.prototype.IntegerLiteral = function() {
    return this.getToken(ScalaParser.IntegerLiteral, 0);
};

LiteralContext.prototype.FloatingPointLiteral = function() {
    return this.getToken(ScalaParser.FloatingPointLiteral, 0);
};

LiteralContext.prototype.BooleanLiteral = function() {
    return this.getToken(ScalaParser.BooleanLiteral, 0);
};

LiteralContext.prototype.CharacterLiteral = function() {
    return this.getToken(ScalaParser.CharacterLiteral, 0);
};

LiteralContext.prototype.StringLiteral = function() {
    return this.getToken(ScalaParser.StringLiteral, 0);
};

LiteralContext.prototype.SymbolLiteral = function() {
    return this.getToken(ScalaParser.SymbolLiteral, 0);
};

LiteralContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterLiteral(this);
	}
};

LiteralContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitLiteral(this);
	}
};




ScalaParser.LiteralContext = LiteralContext;

ScalaParser.prototype.literal = function() {

    var localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, ScalaParser.RULE_literal);
    var _la = 0; // Token type
    try {
        this.state = 219;
        var la_ = this._interp.adaptivePredict(this._input,2,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 207;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__0) {
                this.state = 206;
                this.match(ScalaParser.T__0);
            }

            this.state = 209;
            this.match(ScalaParser.IntegerLiteral);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 211;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__0) {
                this.state = 210;
                this.match(ScalaParser.T__0);
            }

            this.state = 213;
            this.match(ScalaParser.FloatingPointLiteral);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 214;
            this.match(ScalaParser.BooleanLiteral);
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 215;
            this.match(ScalaParser.CharacterLiteral);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 216;
            this.match(ScalaParser.StringLiteral);
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 217;
            this.match(ScalaParser.SymbolLiteral);
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 218;
            this.match(ScalaParser.T__1);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function QualIdContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_qualId;
    return this;
}

QualIdContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
QualIdContext.prototype.constructor = QualIdContext;

QualIdContext.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


QualIdContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterQualId(this);
	}
};

QualIdContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitQualId(this);
	}
};




ScalaParser.QualIdContext = QualIdContext;

ScalaParser.prototype.qualId = function() {

    var localctx = new QualIdContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, ScalaParser.RULE_qualId);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 221;
        this.match(ScalaParser.Id);
        this.state = 226;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__2) {
            this.state = 222;
            this.match(ScalaParser.T__2);
            this.state = 223;
            this.match(ScalaParser.Id);
            this.state = 228;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function IdsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_ids;
    return this;
}

IdsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IdsContext.prototype.constructor = IdsContext;

IdsContext.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


IdsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterIds(this);
	}
};

IdsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitIds(this);
	}
};




ScalaParser.IdsContext = IdsContext;

ScalaParser.prototype.ids = function() {

    var localctx = new IdsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, ScalaParser.RULE_ids);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 229;
        this.match(ScalaParser.Id);
        this.state = 234;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 230;
            this.match(ScalaParser.T__3);
            this.state = 231;
            this.match(ScalaParser.Id);
            this.state = 236;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function StableIdContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_stableId;
    return this;
}

StableIdContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StableIdContext.prototype.constructor = StableIdContext;

StableIdContext.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


StableIdContext.prototype.classQualifier = function() {
    return this.getTypedRuleContext(ClassQualifierContext,0);
};

StableIdContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterStableId(this);
	}
};

StableIdContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitStableId(this);
	}
};




ScalaParser.StableIdContext = StableIdContext;

ScalaParser.prototype.stableId = function() {

    var localctx = new StableIdContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, ScalaParser.RULE_stableId);
    var _la = 0; // Token type
    try {
        this.state = 257;
        var la_ = this._interp.adaptivePredict(this._input,9,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 243;
            var la_ = this._interp.adaptivePredict(this._input,6,this._ctx);
            switch(la_) {
            case 1:
                this.state = 237;
                this.match(ScalaParser.Id);
                break;

            case 2:
                this.state = 240;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Id) {
                    this.state = 238;
                    this.match(ScalaParser.Id);
                    this.state = 239;
                    this.match(ScalaParser.T__2);
                }

                this.state = 242;
                this.match(ScalaParser.T__4);
                break;

            }
            this.state = 245;
            this.match(ScalaParser.T__2);
            this.state = 246;
            this.match(ScalaParser.Id);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 249;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Id) {
                this.state = 247;
                this.match(ScalaParser.Id);
                this.state = 248;
                this.match(ScalaParser.T__2);
            }

            this.state = 251;
            this.match(ScalaParser.T__5);
            this.state = 253;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__6) {
                this.state = 252;
                this.classQualifier();
            }

            this.state = 255;
            this.match(ScalaParser.T__2);
            this.state = 256;
            this.match(ScalaParser.Id);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassQualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classQualifier;
    return this;
}

ClassQualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassQualifierContext.prototype.constructor = ClassQualifierContext;

ClassQualifierContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ClassQualifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassQualifier(this);
	}
};

ClassQualifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassQualifier(this);
	}
};




ScalaParser.ClassQualifierContext = ClassQualifierContext;

ScalaParser.prototype.classQualifier = function() {

    var localctx = new ClassQualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, ScalaParser.RULE_classQualifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 259;
        this.match(ScalaParser.T__6);
        this.state = 260;
        this.match(ScalaParser.Id);
        this.state = 261;
        this.match(ScalaParser.T__7);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_type;
    return this;
}

TypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeContext.prototype.constructor = TypeContext;

TypeContext.prototype.functionArgTypes = function() {
    return this.getTypedRuleContext(FunctionArgTypesContext,0);
};

TypeContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

TypeContext.prototype.infixType = function() {
    return this.getTypedRuleContext(InfixTypeContext,0);
};

TypeContext.prototype.existentialClause = function() {
    return this.getTypedRuleContext(ExistentialClauseContext,0);
};

TypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterType(this);
	}
};

TypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitType(this);
	}
};




ScalaParser.TypeContext = TypeContext;

ScalaParser.prototype.type = function() {

    var localctx = new TypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, ScalaParser.RULE_type);
    var _la = 0; // Token type
    try {
        this.state = 271;
        var la_ = this._interp.adaptivePredict(this._input,11,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 263;
            this.functionArgTypes();
            this.state = 264;
            this.match(ScalaParser.T__8);
            this.state = 265;
            this.type();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 267;
            this.infixType();
            this.state = 269;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__11) {
                this.state = 268;
                this.existentialClause();
            }

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunctionArgTypesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_functionArgTypes;
    return this;
}

FunctionArgTypesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionArgTypesContext.prototype.constructor = FunctionArgTypesContext;

FunctionArgTypesContext.prototype.infixType = function() {
    return this.getTypedRuleContext(InfixTypeContext,0);
};

FunctionArgTypesContext.prototype.paramType = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParamTypeContext);
    } else {
        return this.getTypedRuleContext(ParamTypeContext,i);
    }
};

FunctionArgTypesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterFunctionArgTypes(this);
	}
};

FunctionArgTypesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitFunctionArgTypes(this);
	}
};




ScalaParser.FunctionArgTypesContext = FunctionArgTypesContext;

ScalaParser.prototype.functionArgTypes = function() {

    var localctx = new FunctionArgTypesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, ScalaParser.RULE_functionArgTypes);
    var _la = 0; // Token type
    try {
        this.state = 286;
        var la_ = this._interp.adaptivePredict(this._input,14,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 273;
            this.infixType();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 274;
            this.match(ScalaParser.T__9);
            this.state = 283;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ScalaParser.T__4) | (1 << ScalaParser.T__5) | (1 << ScalaParser.T__8) | (1 << ScalaParser.T__9) | (1 << ScalaParser.T__12))) !== 0) || _la===ScalaParser.Id || _la===ScalaParser.Nl) {
                this.state = 275;
                this.paramType();
                this.state = 280;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while(_la===ScalaParser.T__3) {
                    this.state = 276;
                    this.match(ScalaParser.T__3);
                    this.state = 277;
                    this.paramType();
                    this.state = 282;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
            }

            this.state = 285;
            this.match(ScalaParser.T__10);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExistentialClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_existentialClause;
    return this;
}

ExistentialClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExistentialClauseContext.prototype.constructor = ExistentialClauseContext;

ExistentialClauseContext.prototype.existentialDcl = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExistentialDclContext);
    } else {
        return this.getTypedRuleContext(ExistentialDclContext,i);
    }
};

ExistentialClauseContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


ExistentialClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterExistentialClause(this);
	}
};

ExistentialClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitExistentialClause(this);
	}
};




ScalaParser.ExistentialClauseContext = ExistentialClauseContext;

ScalaParser.prototype.existentialClause = function() {

    var localctx = new ExistentialClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, ScalaParser.RULE_existentialClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 288;
        this.match(ScalaParser.T__11);
        this.state = 289;
        this.match(ScalaParser.T__12);
        this.state = 290;
        this.existentialDcl();
        this.state = 295;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 291;
            this.match(ScalaParser.Semi);
            this.state = 292;
            this.existentialDcl();
            this.state = 297;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 298;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExistentialDclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_existentialDcl;
    return this;
}

ExistentialDclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExistentialDclContext.prototype.constructor = ExistentialDclContext;

ExistentialDclContext.prototype.typeDcl = function() {
    return this.getTypedRuleContext(TypeDclContext,0);
};

ExistentialDclContext.prototype.valDcl = function() {
    return this.getTypedRuleContext(ValDclContext,0);
};

ExistentialDclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterExistentialDcl(this);
	}
};

ExistentialDclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitExistentialDcl(this);
	}
};




ScalaParser.ExistentialDclContext = ExistentialDclContext;

ScalaParser.prototype.existentialDcl = function() {

    var localctx = new ExistentialDclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, ScalaParser.RULE_existentialDcl);
    try {
        this.state = 304;
        switch(this._input.LA(1)) {
        case ScalaParser.T__14:
            this.enterOuterAlt(localctx, 1);
            this.state = 300;
            this.match(ScalaParser.T__14);
            this.state = 301;
            this.typeDcl();
            break;
        case ScalaParser.T__15:
            this.enterOuterAlt(localctx, 2);
            this.state = 302;
            this.match(ScalaParser.T__15);
            this.state = 303;
            this.valDcl();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InfixTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_infixType;
    return this;
}

InfixTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InfixTypeContext.prototype.constructor = InfixTypeContext;

InfixTypeContext.prototype.compoundType = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CompoundTypeContext);
    } else {
        return this.getTypedRuleContext(CompoundTypeContext,i);
    }
};

InfixTypeContext.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


InfixTypeContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


InfixTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterInfixType(this);
	}
};

InfixTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitInfixType(this);
	}
};




ScalaParser.InfixTypeContext = InfixTypeContext;

ScalaParser.prototype.infixType = function() {

    var localctx = new InfixTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, ScalaParser.RULE_infixType);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 306;
        this.compoundType();
        this.state = 314;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,18,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 307;
                this.match(ScalaParser.Id);
                this.state = 309;
                var la_ = this._interp.adaptivePredict(this._input,17,this._ctx);
                if(la_===1) {
                    this.state = 308;
                    this.match(ScalaParser.Nl);

                }
                this.state = 311;
                this.compoundType(); 
            }
            this.state = 316;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,18,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompoundTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_compoundType;
    return this;
}

CompoundTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompoundTypeContext.prototype.constructor = CompoundTypeContext;

CompoundTypeContext.prototype.annotType = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotTypeContext);
    } else {
        return this.getTypedRuleContext(AnnotTypeContext,i);
    }
};

CompoundTypeContext.prototype.refinement = function() {
    return this.getTypedRuleContext(RefinementContext,0);
};

CompoundTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterCompoundType(this);
	}
};

CompoundTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitCompoundType(this);
	}
};




ScalaParser.CompoundTypeContext = CompoundTypeContext;

ScalaParser.prototype.compoundType = function() {

    var localctx = new CompoundTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, ScalaParser.RULE_compoundType);
    var _la = 0; // Token type
    try {
        this.state = 329;
        switch(this._input.LA(1)) {
        case ScalaParser.T__4:
        case ScalaParser.T__5:
        case ScalaParser.T__9:
        case ScalaParser.Id:
            this.enterOuterAlt(localctx, 1);
            this.state = 317;
            this.annotType();
            this.state = 322;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__16) {
                this.state = 318;
                this.match(ScalaParser.T__16);
                this.state = 319;
                this.annotType();
                this.state = 324;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 326;
            var la_ = this._interp.adaptivePredict(this._input,20,this._ctx);
            if(la_===1) {
                this.state = 325;
                this.refinement();

            }
            break;
        case ScalaParser.T__12:
        case ScalaParser.Nl:
            this.enterOuterAlt(localctx, 2);
            this.state = 328;
            this.refinement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_annotType;
    return this;
}

AnnotTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotTypeContext.prototype.constructor = AnnotTypeContext;

AnnotTypeContext.prototype.simpleType = function() {
    return this.getTypedRuleContext(SimpleTypeContext,0);
};

AnnotTypeContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

AnnotTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterAnnotType(this);
	}
};

AnnotTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitAnnotType(this);
	}
};




ScalaParser.AnnotTypeContext = AnnotTypeContext;

ScalaParser.prototype.annotType = function() {

    var localctx = new AnnotTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, ScalaParser.RULE_annotType);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 331;
        this.simpleType(0);
        this.state = 335;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,22,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 332;
                this.annotation(); 
            }
            this.state = 337;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,22,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SimpleTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_simpleType;
    return this;
}

SimpleTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SimpleTypeContext.prototype.constructor = SimpleTypeContext;

SimpleTypeContext.prototype.stableId = function() {
    return this.getTypedRuleContext(StableIdContext,0);
};

SimpleTypeContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

SimpleTypeContext.prototype.types = function() {
    return this.getTypedRuleContext(TypesContext,0);
};

SimpleTypeContext.prototype.simpleType = function() {
    return this.getTypedRuleContext(SimpleTypeContext,0);
};

SimpleTypeContext.prototype.typeArgs = function() {
    return this.getTypedRuleContext(TypeArgsContext,0);
};

SimpleTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterSimpleType(this);
	}
};

SimpleTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitSimpleType(this);
	}
};



ScalaParser.prototype.simpleType = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new SimpleTypeContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 24;
    this.enterRecursionRule(localctx, 24, ScalaParser.RULE_simpleType, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 354;
        var la_ = this._interp.adaptivePredict(this._input,25,this._ctx);
        switch(la_) {
        case 1:
            this.state = 339;
            this.stableId();
            break;

        case 2:
            this.state = 346;
            var la_ = this._interp.adaptivePredict(this._input,24,this._ctx);
            switch(la_) {
            case 1:
                this.state = 340;
                this.stableId();
                break;

            case 2:
                this.state = 343;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Id) {
                    this.state = 341;
                    this.match(ScalaParser.Id);
                    this.state = 342;
                    this.match(ScalaParser.T__2);
                }

                this.state = 345;
                this.match(ScalaParser.T__4);
                break;

            }
            this.state = 348;
            this.match(ScalaParser.T__2);
            this.state = 349;
            this.match(ScalaParser.T__14);
            break;

        case 3:
            this.state = 350;
            this.match(ScalaParser.T__9);
            this.state = 351;
            this.types();
            this.state = 352;
            this.match(ScalaParser.T__10);
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 363;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,27,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 361;
                var la_ = this._interp.adaptivePredict(this._input,26,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new SimpleTypeContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, ScalaParser.RULE_simpleType);
                    this.state = 356;
                    if (!( this.precpred(this._ctx, 5))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
                    }
                    this.state = 357;
                    this.typeArgs();
                    break;

                case 2:
                    localctx = new SimpleTypeContext(this, _parentctx, _parentState);
                    this.pushNewRecursionContext(localctx, _startState, ScalaParser.RULE_simpleType);
                    this.state = 358;
                    if (!( this.precpred(this._ctx, 4))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
                    }
                    this.state = 359;
                    this.match(ScalaParser.T__17);
                    this.state = 360;
                    this.match(ScalaParser.Id);
                    break;

                } 
            }
            this.state = 365;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,27,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function TypeArgsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typeArgs;
    return this;
}

TypeArgsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeArgsContext.prototype.constructor = TypeArgsContext;

TypeArgsContext.prototype.types = function() {
    return this.getTypedRuleContext(TypesContext,0);
};

TypeArgsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypeArgs(this);
	}
};

TypeArgsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypeArgs(this);
	}
};




ScalaParser.TypeArgsContext = TypeArgsContext;

ScalaParser.prototype.typeArgs = function() {

    var localctx = new TypeArgsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, ScalaParser.RULE_typeArgs);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 366;
        this.match(ScalaParser.T__6);
        this.state = 367;
        this.types();
        this.state = 368;
        this.match(ScalaParser.T__7);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_types;
    return this;
}

TypesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypesContext.prototype.constructor = TypesContext;

TypesContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

TypesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypes(this);
	}
};

TypesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypes(this);
	}
};




ScalaParser.TypesContext = TypesContext;

ScalaParser.prototype.types = function() {

    var localctx = new TypesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, ScalaParser.RULE_types);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 370;
        this.type();
        this.state = 375;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 371;
            this.match(ScalaParser.T__3);
            this.state = 372;
            this.type();
            this.state = 377;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function RefinementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_refinement;
    return this;
}

RefinementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RefinementContext.prototype.constructor = RefinementContext;

RefinementContext.prototype.refineStat = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(RefineStatContext);
    } else {
        return this.getTypedRuleContext(RefineStatContext,i);
    }
};

RefinementContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

RefinementContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


RefinementContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterRefinement(this);
	}
};

RefinementContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitRefinement(this);
	}
};




ScalaParser.RefinementContext = RefinementContext;

ScalaParser.prototype.refinement = function() {

    var localctx = new RefinementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, ScalaParser.RULE_refinement);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 379;
        _la = this._input.LA(1);
        if(_la===ScalaParser.Nl) {
            this.state = 378;
            this.match(ScalaParser.Nl);
        }

        this.state = 381;
        this.match(ScalaParser.T__12);
        this.state = 382;
        this.refineStat();
        this.state = 387;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 383;
            this.match(ScalaParser.Semi);
            this.state = 384;
            this.refineStat();
            this.state = 389;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 390;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function RefineStatContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_refineStat;
    return this;
}

RefineStatContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
RefineStatContext.prototype.constructor = RefineStatContext;

RefineStatContext.prototype.dcl = function() {
    return this.getTypedRuleContext(DclContext,0);
};

RefineStatContext.prototype.typeDef = function() {
    return this.getTypedRuleContext(TypeDefContext,0);
};

RefineStatContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterRefineStat(this);
	}
};

RefineStatContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitRefineStat(this);
	}
};




ScalaParser.RefineStatContext = RefineStatContext;

ScalaParser.prototype.refineStat = function() {

    var localctx = new RefineStatContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, ScalaParser.RULE_refineStat);
    try {
        this.state = 396;
        var la_ = this._interp.adaptivePredict(this._input,31,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 392;
            this.dcl();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 393;
            this.match(ScalaParser.T__14);
            this.state = 394;
            this.typeDef();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypePatContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typePat;
    return this;
}

TypePatContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypePatContext.prototype.constructor = TypePatContext;

TypePatContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

TypePatContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypePat(this);
	}
};

TypePatContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypePat(this);
	}
};




ScalaParser.TypePatContext = TypePatContext;

ScalaParser.prototype.typePat = function() {

    var localctx = new TypePatContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, ScalaParser.RULE_typePat);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 398;
        this.type();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AscriptionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_ascription;
    return this;
}

AscriptionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AscriptionContext.prototype.constructor = AscriptionContext;

AscriptionContext.prototype.infixType = function() {
    return this.getTypedRuleContext(InfixTypeContext,0);
};

AscriptionContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

AscriptionContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterAscription(this);
	}
};

AscriptionContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitAscription(this);
	}
};




ScalaParser.AscriptionContext = AscriptionContext;

ScalaParser.prototype.ascription = function() {

    var localctx = new AscriptionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, ScalaParser.RULE_ascription);
    var _la = 0; // Token type
    try {
        this.state = 411;
        var la_ = this._interp.adaptivePredict(this._input,33,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 400;
            this.match(ScalaParser.T__18);
            this.state = 401;
            this.infixType();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 402;
            this.match(ScalaParser.T__18);
            this.state = 404; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            do {
                this.state = 403;
                this.annotation();
                this.state = 406; 
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            } while(_la===ScalaParser.T__43);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 408;
            this.match(ScalaParser.T__18);
            this.state = 409;
            this.match(ScalaParser.T__19);
            this.state = 410;
            this.match(ScalaParser.T__20);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_expr;
    return this;
}

ExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExprContext.prototype.constructor = ExprContext;

ExprContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ExprContext.prototype.bindings = function() {
    return this.getTypedRuleContext(BindingsContext,0);
};

ExprContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ExprContext.prototype.expr1 = function() {
    return this.getTypedRuleContext(Expr1Context,0);
};

ExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterExpr(this);
	}
};

ExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitExpr(this);
	}
};




ScalaParser.ExprContext = ExprContext;

ScalaParser.prototype.expr = function() {

    var localctx = new ExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, ScalaParser.RULE_expr);
    var _la = 0; // Token type
    try {
        this.state = 424;
        var la_ = this._interp.adaptivePredict(this._input,36,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 419;
            switch(this._input.LA(1)) {
            case ScalaParser.T__9:
                this.state = 413;
                this.bindings();
                break;
            case ScalaParser.T__21:
            case ScalaParser.Id:
                this.state = 415;
                _la = this._input.LA(1);
                if(_la===ScalaParser.T__21) {
                    this.state = 414;
                    this.match(ScalaParser.T__21);
                }

                this.state = 417;
                this.match(ScalaParser.Id);
                break;
            case ScalaParser.T__19:
                this.state = 418;
                this.match(ScalaParser.T__19);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 421;
            this.match(ScalaParser.T__8);
            this.state = 422;
            this.expr();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 423;
            this.expr1();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Expr1Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_expr1;
    return this;
}

Expr1Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Expr1Context.prototype.constructor = Expr1Context;

Expr1Context.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

Expr1Context.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


Expr1Context.prototype.Semi = function() {
    return this.getToken(ScalaParser.Semi, 0);
};

Expr1Context.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

Expr1Context.prototype.caseClauses = function() {
    return this.getTypedRuleContext(CaseClausesContext,0);
};

Expr1Context.prototype.enumerators = function() {
    return this.getTypedRuleContext(EnumeratorsContext,0);
};

Expr1Context.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

Expr1Context.prototype.blockExpr = function() {
    return this.getTypedRuleContext(BlockExprContext,0);
};

Expr1Context.prototype.simpleExpr1 = function() {
    return this.getTypedRuleContext(SimpleExpr1Context,0);
};

Expr1Context.prototype.classTemplate = function() {
    return this.getTypedRuleContext(ClassTemplateContext,0);
};

Expr1Context.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

Expr1Context.prototype.argumentExprs = function() {
    return this.getTypedRuleContext(ArgumentExprsContext,0);
};

Expr1Context.prototype.postfixExpr = function() {
    return this.getTypedRuleContext(PostfixExprContext,0);
};

Expr1Context.prototype.ascription = function() {
    return this.getTypedRuleContext(AscriptionContext,0);
};

Expr1Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterExpr1(this);
	}
};

Expr1Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitExpr1(this);
	}
};




ScalaParser.Expr1Context = Expr1Context;

ScalaParser.prototype.expr1 = function() {

    var localctx = new Expr1Context(this, this._ctx, this.state);
    this.enterRule(localctx, 40, ScalaParser.RULE_expr1);
    var _la = 0; // Token type
    try {
        this.state = 546;
        var la_ = this._interp.adaptivePredict(this._input,52,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 426;
            this.match(ScalaParser.T__22);
            this.state = 427;
            this.match(ScalaParser.T__9);
            this.state = 428;
            this.expr();
            this.state = 429;
            this.match(ScalaParser.T__10);
            this.state = 433;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Nl) {
                this.state = 430;
                this.match(ScalaParser.Nl);
                this.state = 435;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 436;
            this.expr();
            this.state = 442;
            var la_ = this._interp.adaptivePredict(this._input,39,this._ctx);
            if(la_===1) {
                this.state = 438;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Semi) {
                    this.state = 437;
                    this.match(ScalaParser.Semi);
                }

                this.state = 440;
                this.match(ScalaParser.T__23);
                this.state = 441;
                this.expr();

            }
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 444;
            this.match(ScalaParser.T__24);
            this.state = 445;
            this.match(ScalaParser.T__9);
            this.state = 446;
            this.expr();
            this.state = 447;
            this.match(ScalaParser.T__10);
            this.state = 451;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Nl) {
                this.state = 448;
                this.match(ScalaParser.Nl);
                this.state = 453;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 454;
            this.expr();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 456;
            this.match(ScalaParser.T__25);
            this.state = 462;
            var la_ = this._interp.adaptivePredict(this._input,41,this._ctx);
            switch(la_) {
            case 1:
                this.state = 457;
                this.match(ScalaParser.T__12);
                this.state = 458;
                this.block();
                this.state = 459;
                this.match(ScalaParser.T__13);
                break;

            case 2:
                this.state = 461;
                this.expr();
                break;

            }
            this.state = 469;
            var la_ = this._interp.adaptivePredict(this._input,42,this._ctx);
            if(la_===1) {
                this.state = 464;
                this.match(ScalaParser.T__26);
                this.state = 465;
                this.match(ScalaParser.T__12);
                this.state = 466;
                this.caseClauses();
                this.state = 467;
                this.match(ScalaParser.T__13);

            }
            this.state = 473;
            var la_ = this._interp.adaptivePredict(this._input,43,this._ctx);
            if(la_===1) {
                this.state = 471;
                this.match(ScalaParser.T__27);
                this.state = 472;
                this.expr();

            }
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 475;
            this.match(ScalaParser.T__28);
            this.state = 476;
            this.expr();
            this.state = 478;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Semi) {
                this.state = 477;
                this.match(ScalaParser.Semi);
            }

            this.state = 480;
            this.match(ScalaParser.T__24);
            this.state = 481;
            this.match(ScalaParser.T__9);
            this.state = 482;
            this.expr();
            this.state = 483;
            this.match(ScalaParser.T__10);
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 485;
            this.match(ScalaParser.T__29);
            this.state = 494;
            switch(this._input.LA(1)) {
            case ScalaParser.T__9:
                this.state = 486;
                this.match(ScalaParser.T__9);
                this.state = 487;
                this.enumerators();
                this.state = 488;
                this.match(ScalaParser.T__10);
                break;
            case ScalaParser.T__12:
                this.state = 490;
                this.match(ScalaParser.T__12);
                this.state = 491;
                this.enumerators();
                this.state = 492;
                this.match(ScalaParser.T__13);
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 499;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Nl) {
                this.state = 496;
                this.match(ScalaParser.Nl);
                this.state = 501;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 503;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__30) {
                this.state = 502;
                this.match(ScalaParser.T__30);
            }

            this.state = 505;
            this.expr();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 507;
            this.match(ScalaParser.T__31);
            this.state = 508;
            this.expr();
            break;

        case 7:
            this.enterOuterAlt(localctx, 7);
            this.state = 509;
            this.match(ScalaParser.T__32);
            this.state = 511;
            var la_ = this._interp.adaptivePredict(this._input,48,this._ctx);
            if(la_===1) {
                this.state = 510;
                this.expr();

            }
            break;

        case 8:
            this.enterOuterAlt(localctx, 8);
            this.state = 523;
            var la_ = this._interp.adaptivePredict(this._input,51,this._ctx);
            switch(la_) {
            case 1:
                this.state = 513;
                this.match(ScalaParser.T__33);
                this.state = 516;
                var la_ = this._interp.adaptivePredict(this._input,49,this._ctx);
                switch(la_) {
                case 1:
                    this.state = 514;
                    this.classTemplate();
                    break;

                case 2:
                    this.state = 515;
                    this.templateBody();
                    break;

                }
                break;

            case 2:
                this.state = 518;
                this.blockExpr();
                break;

            case 3:
                this.state = 519;
                this.simpleExpr1(0);
                this.state = 521;
                _la = this._input.LA(1);
                if(_la===ScalaParser.T__19) {
                    this.state = 520;
                    this.match(ScalaParser.T__19);
                }

                break;

            }
            this.state = 525;
            this.match(ScalaParser.T__2);
            this.state = 527;
            this.match(ScalaParser.Id);
            this.state = 528;
            this.match(ScalaParser.T__34);
            this.state = 529;
            this.expr();
            break;

        case 9:
            this.enterOuterAlt(localctx, 9);
            this.state = 531;
            this.simpleExpr1(0);
            this.state = 532;
            this.argumentExprs();
            this.state = 533;
            this.match(ScalaParser.T__34);
            this.state = 534;
            this.expr();
            break;

        case 10:
            this.enterOuterAlt(localctx, 10);
            this.state = 536;
            this.postfixExpr();
            break;

        case 11:
            this.enterOuterAlt(localctx, 11);
            this.state = 537;
            this.postfixExpr();
            this.state = 538;
            this.ascription();
            break;

        case 12:
            this.enterOuterAlt(localctx, 12);
            this.state = 540;
            this.postfixExpr();
            this.state = 541;
            this.match(ScalaParser.T__35);
            this.state = 542;
            this.match(ScalaParser.T__12);
            this.state = 543;
            this.caseClauses();
            this.state = 544;
            this.match(ScalaParser.T__13);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PostfixExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_postfixExpr;
    return this;
}

PostfixExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PostfixExprContext.prototype.constructor = PostfixExprContext;

PostfixExprContext.prototype.infixExpr = function() {
    return this.getTypedRuleContext(InfixExprContext,0);
};

PostfixExprContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

PostfixExprContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

PostfixExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPostfixExpr(this);
	}
};

PostfixExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPostfixExpr(this);
	}
};




ScalaParser.PostfixExprContext = PostfixExprContext;

ScalaParser.prototype.postfixExpr = function() {

    var localctx = new PostfixExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 42, ScalaParser.RULE_postfixExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 548;
        this.infixExpr(0);
        this.state = 553;
        var la_ = this._interp.adaptivePredict(this._input,54,this._ctx);
        if(la_===1) {
            this.state = 549;
            this.match(ScalaParser.Id);
            this.state = 551;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 550;
                this.match(ScalaParser.Nl);
            }


        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function InfixExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_infixExpr;
    return this;
}

InfixExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InfixExprContext.prototype.constructor = InfixExprContext;

InfixExprContext.prototype.prefixExpr = function() {
    return this.getTypedRuleContext(PrefixExprContext,0);
};

InfixExprContext.prototype.infixExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(InfixExprContext);
    } else {
        return this.getTypedRuleContext(InfixExprContext,i);
    }
};

InfixExprContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

InfixExprContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

InfixExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterInfixExpr(this);
	}
};

InfixExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitInfixExpr(this);
	}
};



ScalaParser.prototype.infixExpr = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new InfixExprContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 44;
    this.enterRecursionRule(localctx, 44, ScalaParser.RULE_infixExpr, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 556;
        this.prefixExpr();
        this._ctx.stop = this._input.LT(-1);
        this.state = 566;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,56,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new InfixExprContext(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, ScalaParser.RULE_infixExpr);
                this.state = 558;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 559;
                this.match(ScalaParser.Id);
                this.state = 561;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Nl) {
                    this.state = 560;
                    this.match(ScalaParser.Nl);
                }

                this.state = 563;
                this.infixExpr(2); 
            }
            this.state = 568;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,56,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function PrefixExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_prefixExpr;
    return this;
}

PrefixExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PrefixExprContext.prototype.constructor = PrefixExprContext;

PrefixExprContext.prototype.blockExpr = function() {
    return this.getTypedRuleContext(BlockExprContext,0);
};

PrefixExprContext.prototype.simpleExpr1 = function() {
    return this.getTypedRuleContext(SimpleExpr1Context,0);
};

PrefixExprContext.prototype.classTemplate = function() {
    return this.getTypedRuleContext(ClassTemplateContext,0);
};

PrefixExprContext.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

PrefixExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPrefixExpr(this);
	}
};

PrefixExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPrefixExpr(this);
	}
};




ScalaParser.PrefixExprContext = PrefixExprContext;

ScalaParser.prototype.prefixExpr = function() {

    var localctx = new PrefixExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 46, ScalaParser.RULE_prefixExpr);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 570;
        var la_ = this._interp.adaptivePredict(this._input,57,this._ctx);
        if(la_===1) {
            this.state = 569;
            _la = this._input.LA(1);
            if(!(_la===ScalaParser.T__0 || ((((_la - 37)) & ~0x1f) == 0 && ((1 << (_la - 37)) & ((1 << (ScalaParser.T__36 - 37)) | (1 << (ScalaParser.T__37 - 37)) | (1 << (ScalaParser.T__38 - 37)))) !== 0))) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }

        }
        this.state = 582;
        var la_ = this._interp.adaptivePredict(this._input,60,this._ctx);
        switch(la_) {
        case 1:
            this.state = 572;
            this.match(ScalaParser.T__33);
            this.state = 575;
            var la_ = this._interp.adaptivePredict(this._input,58,this._ctx);
            switch(la_) {
            case 1:
                this.state = 573;
                this.classTemplate();
                break;

            case 2:
                this.state = 574;
                this.templateBody();
                break;

            }
            break;

        case 2:
            this.state = 577;
            this.blockExpr();
            break;

        case 3:
            this.state = 578;
            this.simpleExpr1(0);
            this.state = 580;
            var la_ = this._interp.adaptivePredict(this._input,59,this._ctx);
            if(la_===1) {
                this.state = 579;
                this.match(ScalaParser.T__19);

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SimpleExpr1Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_simpleExpr1;
    return this;
}

SimpleExpr1Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SimpleExpr1Context.prototype.constructor = SimpleExpr1Context;

SimpleExpr1Context.prototype.literal = function() {
    return this.getTypedRuleContext(LiteralContext,0);
};

SimpleExpr1Context.prototype.stableId = function() {
    return this.getTypedRuleContext(StableIdContext,0);
};

SimpleExpr1Context.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

SimpleExpr1Context.prototype.exprs = function() {
    return this.getTypedRuleContext(ExprsContext,0);
};

SimpleExpr1Context.prototype.blockExpr = function() {
    return this.getTypedRuleContext(BlockExprContext,0);
};

SimpleExpr1Context.prototype.classTemplate = function() {
    return this.getTypedRuleContext(ClassTemplateContext,0);
};

SimpleExpr1Context.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

SimpleExpr1Context.prototype.typeArgs = function() {
    return this.getTypedRuleContext(TypeArgsContext,0);
};

SimpleExpr1Context.prototype.simpleExpr1 = function() {
    return this.getTypedRuleContext(SimpleExpr1Context,0);
};

SimpleExpr1Context.prototype.argumentExprs = function() {
    return this.getTypedRuleContext(ArgumentExprsContext,0);
};

SimpleExpr1Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterSimpleExpr1(this);
	}
};

SimpleExpr1Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitSimpleExpr1(this);
	}
};



ScalaParser.prototype.simpleExpr1 = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new SimpleExpr1Context(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 48;
    this.enterRecursionRule(localctx, 48, ScalaParser.RULE_simpleExpr1, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 619;
        var la_ = this._interp.adaptivePredict(this._input,67,this._ctx);
        switch(la_) {
        case 1:
            this.state = 585;
            this.literal();
            break;

        case 2:
            this.state = 586;
            this.stableId();
            break;

        case 3:
            this.state = 589;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Id) {
                this.state = 587;
                this.match(ScalaParser.Id);
                this.state = 588;
                this.match(ScalaParser.T__2);
            }

            this.state = 591;
            this.match(ScalaParser.T__4);
            break;

        case 4:
            this.state = 592;
            this.match(ScalaParser.T__19);
            break;

        case 5:
            this.state = 593;
            this.match(ScalaParser.T__9);
            this.state = 595;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ScalaParser.T__0) | (1 << ScalaParser.T__1) | (1 << ScalaParser.T__4) | (1 << ScalaParser.T__5) | (1 << ScalaParser.T__9) | (1 << ScalaParser.T__12) | (1 << ScalaParser.T__19) | (1 << ScalaParser.T__21) | (1 << ScalaParser.T__22) | (1 << ScalaParser.T__24) | (1 << ScalaParser.T__25) | (1 << ScalaParser.T__28) | (1 << ScalaParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ScalaParser.T__31 - 32)) | (1 << (ScalaParser.T__32 - 32)) | (1 << (ScalaParser.T__33 - 32)) | (1 << (ScalaParser.T__36 - 32)) | (1 << (ScalaParser.T__37 - 32)) | (1 << (ScalaParser.T__38 - 32)) | (1 << (ScalaParser.BooleanLiteral - 32)) | (1 << (ScalaParser.CharacterLiteral - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (ScalaParser.StringLiteral - 64)) | (1 << (ScalaParser.SymbolLiteral - 64)) | (1 << (ScalaParser.IntegerLiteral - 64)) | (1 << (ScalaParser.FloatingPointLiteral - 64)) | (1 << (ScalaParser.Id - 64)))) !== 0)) {
                this.state = 594;
                this.exprs();
            }

            this.state = 597;
            this.match(ScalaParser.T__10);
            break;

        case 6:
            this.state = 604;
            switch(this._input.LA(1)) {
            case ScalaParser.T__33:
                this.state = 598;
                this.match(ScalaParser.T__33);
                this.state = 601;
                var la_ = this._interp.adaptivePredict(this._input,63,this._ctx);
                switch(la_) {
                case 1:
                    this.state = 599;
                    this.classTemplate();
                    break;

                case 2:
                    this.state = 600;
                    this.templateBody();
                    break;

                }
                break;
            case ScalaParser.T__12:
                this.state = 603;
                this.blockExpr();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 606;
            this.match(ScalaParser.T__2);
            this.state = 607;
            this.match(ScalaParser.Id);
            break;

        case 7:
            this.state = 615;
            switch(this._input.LA(1)) {
            case ScalaParser.T__33:
                this.state = 609;
                this.match(ScalaParser.T__33);
                this.state = 612;
                var la_ = this._interp.adaptivePredict(this._input,65,this._ctx);
                switch(la_) {
                case 1:
                    this.state = 610;
                    this.classTemplate();
                    break;

                case 2:
                    this.state = 611;
                    this.templateBody();
                    break;

                }
                break;
            case ScalaParser.T__12:
                this.state = 614;
                this.blockExpr();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 617;
            this.typeArgs();
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 625;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,68,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                localctx = new SimpleExpr1Context(this, _parentctx, _parentState);
                this.pushNewRecursionContext(localctx, _startState, ScalaParser.RULE_simpleExpr1);
                this.state = 621;
                if (!( this.precpred(this._ctx, 1))) {
                    throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
                }
                this.state = 622;
                this.argumentExprs(); 
            }
            this.state = 627;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,68,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};

function ExprsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_exprs;
    return this;
}

ExprsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExprsContext.prototype.constructor = ExprsContext;

ExprsContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

ExprsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterExprs(this);
	}
};

ExprsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitExprs(this);
	}
};




ScalaParser.ExprsContext = ExprsContext;

ScalaParser.prototype.exprs = function() {

    var localctx = new ExprsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 50, ScalaParser.RULE_exprs);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 628;
        this.expr();
        this.state = 633;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,69,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 629;
                this.match(ScalaParser.T__3);
                this.state = 630;
                this.expr(); 
            }
            this.state = 635;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,69,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ArgumentExprsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_argumentExprs;
    return this;
}

ArgumentExprsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ArgumentExprsContext.prototype.constructor = ArgumentExprsContext;

ArgumentExprsContext.prototype.exprs = function() {
    return this.getTypedRuleContext(ExprsContext,0);
};

ArgumentExprsContext.prototype.postfixExpr = function() {
    return this.getTypedRuleContext(PostfixExprContext,0);
};

ArgumentExprsContext.prototype.blockExpr = function() {
    return this.getTypedRuleContext(BlockExprContext,0);
};

ArgumentExprsContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

ArgumentExprsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterArgumentExprs(this);
	}
};

ArgumentExprsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitArgumentExprs(this);
	}
};




ScalaParser.ArgumentExprsContext = ArgumentExprsContext;

ScalaParser.prototype.argumentExprs = function() {

    var localctx = new ArgumentExprsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 52, ScalaParser.RULE_argumentExprs);
    var _la = 0; // Token type
    try {
        this.state = 657;
        var la_ = this._interp.adaptivePredict(this._input,73,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 636;
            this.match(ScalaParser.T__9);
            this.state = 638;
            _la = this._input.LA(1);
            if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ScalaParser.T__0) | (1 << ScalaParser.T__1) | (1 << ScalaParser.T__4) | (1 << ScalaParser.T__5) | (1 << ScalaParser.T__9) | (1 << ScalaParser.T__12) | (1 << ScalaParser.T__19) | (1 << ScalaParser.T__21) | (1 << ScalaParser.T__22) | (1 << ScalaParser.T__24) | (1 << ScalaParser.T__25) | (1 << ScalaParser.T__28) | (1 << ScalaParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ScalaParser.T__31 - 32)) | (1 << (ScalaParser.T__32 - 32)) | (1 << (ScalaParser.T__33 - 32)) | (1 << (ScalaParser.T__36 - 32)) | (1 << (ScalaParser.T__37 - 32)) | (1 << (ScalaParser.T__38 - 32)) | (1 << (ScalaParser.BooleanLiteral - 32)) | (1 << (ScalaParser.CharacterLiteral - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (ScalaParser.StringLiteral - 64)) | (1 << (ScalaParser.SymbolLiteral - 64)) | (1 << (ScalaParser.IntegerLiteral - 64)) | (1 << (ScalaParser.FloatingPointLiteral - 64)) | (1 << (ScalaParser.Id - 64)))) !== 0)) {
                this.state = 637;
                this.exprs();
            }

            this.state = 640;
            this.match(ScalaParser.T__10);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 641;
            this.match(ScalaParser.T__9);
            this.state = 645;
            var la_ = this._interp.adaptivePredict(this._input,71,this._ctx);
            if(la_===1) {
                this.state = 642;
                this.exprs();
                this.state = 643;
                this.match(ScalaParser.T__3);

            }
            this.state = 647;
            this.postfixExpr();
            this.state = 648;
            this.match(ScalaParser.T__18);
            this.state = 649;
            this.match(ScalaParser.T__19);
            this.state = 650;
            this.match(ScalaParser.T__20);
            this.state = 651;
            this.match(ScalaParser.T__10);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 654;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 653;
                this.match(ScalaParser.Nl);
            }

            this.state = 656;
            this.blockExpr();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_blockExpr;
    return this;
}

BlockExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockExprContext.prototype.constructor = BlockExprContext;

BlockExprContext.prototype.caseClauses = function() {
    return this.getTypedRuleContext(CaseClausesContext,0);
};

BlockExprContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

BlockExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterBlockExpr(this);
	}
};

BlockExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitBlockExpr(this);
	}
};




ScalaParser.BlockExprContext = BlockExprContext;

ScalaParser.prototype.blockExpr = function() {

    var localctx = new BlockExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 54, ScalaParser.RULE_blockExpr);
    try {
        this.state = 667;
        var la_ = this._interp.adaptivePredict(this._input,74,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 659;
            this.match(ScalaParser.T__12);
            this.state = 660;
            this.caseClauses();
            this.state = 661;
            this.match(ScalaParser.T__13);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 663;
            this.match(ScalaParser.T__12);
            this.state = 664;
            this.block();
            this.state = 665;
            this.match(ScalaParser.T__13);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_block;
    return this;
}

BlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockContext.prototype.constructor = BlockContext;

BlockContext.prototype.blockStat = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BlockStatContext);
    } else {
        return this.getTypedRuleContext(BlockStatContext,i);
    }
};

BlockContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


BlockContext.prototype.resultExpr = function() {
    return this.getTypedRuleContext(ResultExprContext,0);
};

BlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterBlock(this);
	}
};

BlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitBlock(this);
	}
};




ScalaParser.BlockContext = BlockContext;

ScalaParser.prototype.block = function() {

    var localctx = new BlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 56, ScalaParser.RULE_block);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 669;
        this.blockStat();
        this.state = 674;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 670;
            this.match(ScalaParser.Semi);
            this.state = 671;
            this.blockStat();
            this.state = 676;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 678;
        _la = this._input.LA(1);
        if((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << ScalaParser.T__0) | (1 << ScalaParser.T__1) | (1 << ScalaParser.T__4) | (1 << ScalaParser.T__5) | (1 << ScalaParser.T__9) | (1 << ScalaParser.T__12) | (1 << ScalaParser.T__19) | (1 << ScalaParser.T__21) | (1 << ScalaParser.T__22) | (1 << ScalaParser.T__24) | (1 << ScalaParser.T__25) | (1 << ScalaParser.T__28) | (1 << ScalaParser.T__29))) !== 0) || ((((_la - 32)) & ~0x1f) == 0 && ((1 << (_la - 32)) & ((1 << (ScalaParser.T__31 - 32)) | (1 << (ScalaParser.T__32 - 32)) | (1 << (ScalaParser.T__33 - 32)) | (1 << (ScalaParser.T__36 - 32)) | (1 << (ScalaParser.T__37 - 32)) | (1 << (ScalaParser.T__38 - 32)) | (1 << (ScalaParser.BooleanLiteral - 32)) | (1 << (ScalaParser.CharacterLiteral - 32)))) !== 0) || ((((_la - 64)) & ~0x1f) == 0 && ((1 << (_la - 64)) & ((1 << (ScalaParser.StringLiteral - 64)) | (1 << (ScalaParser.SymbolLiteral - 64)) | (1 << (ScalaParser.IntegerLiteral - 64)) | (1 << (ScalaParser.FloatingPointLiteral - 64)) | (1 << (ScalaParser.Id - 64)))) !== 0)) {
            this.state = 677;
            this.resultExpr();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BlockStatContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_blockStat;
    return this;
}

BlockStatContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BlockStatContext.prototype.constructor = BlockStatContext;

BlockStatContext.prototype.import_ = function() {
    return this.getTypedRuleContext(Import_Context,0);
};

BlockStatContext.prototype.def = function() {
    return this.getTypedRuleContext(DefContext,0);
};

BlockStatContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

BlockStatContext.prototype.tmplDef = function() {
    return this.getTypedRuleContext(TmplDefContext,0);
};

BlockStatContext.prototype.localModifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LocalModifierContext);
    } else {
        return this.getTypedRuleContext(LocalModifierContext,i);
    }
};

BlockStatContext.prototype.expr1 = function() {
    return this.getTypedRuleContext(Expr1Context,0);
};

BlockStatContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterBlockStat(this);
	}
};

BlockStatContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitBlockStat(this);
	}
};




ScalaParser.BlockStatContext = BlockStatContext;

ScalaParser.prototype.blockStat = function() {

    var localctx = new BlockStatContext(this, this._ctx, this.state);
    this.enterRule(localctx, 58, ScalaParser.RULE_blockStat);
    var _la = 0; // Token type
    try {
        this.state = 706;
        var la_ = this._interp.adaptivePredict(this._input,81,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 680;
            this.import_();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 684;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__43) {
                this.state = 681;
                this.annotation();
                this.state = 686;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 688;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__21 || _la===ScalaParser.T__39) {
                this.state = 687;
                _la = this._input.LA(1);
                if(!(_la===ScalaParser.T__21 || _la===ScalaParser.T__39)) {
                this._errHandler.recoverInline(this);
                }
                else {
                    this.consume();
                }
            }

            this.state = 690;
            this.def();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 694;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__43) {
                this.state = 691;
                this.annotation();
                this.state = 696;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 700;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(((((_la - 22)) & ~0x1f) == 0 && ((1 << (_la - 22)) & ((1 << (ScalaParser.T__21 - 22)) | (1 << (ScalaParser.T__39 - 22)) | (1 << (ScalaParser.T__49 - 22)) | (1 << (ScalaParser.T__50 - 22)) | (1 << (ScalaParser.T__51 - 22)))) !== 0)) {
                this.state = 697;
                this.localModifier();
                this.state = 702;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 703;
            this.tmplDef();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 704;
            this.expr1();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ResultExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_resultExpr;
    return this;
}

ResultExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ResultExprContext.prototype.constructor = ResultExprContext;

ResultExprContext.prototype.expr1 = function() {
    return this.getTypedRuleContext(Expr1Context,0);
};

ResultExprContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

ResultExprContext.prototype.bindings = function() {
    return this.getTypedRuleContext(BindingsContext,0);
};

ResultExprContext.prototype.compoundType = function() {
    return this.getTypedRuleContext(CompoundTypeContext,0);
};

ResultExprContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ResultExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterResultExpr(this);
	}
};

ResultExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitResultExpr(this);
	}
};




ScalaParser.ResultExprContext = ResultExprContext;

ScalaParser.prototype.resultExpr = function() {

    var localctx = new ResultExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 60, ScalaParser.RULE_resultExpr);
    var _la = 0; // Token type
    try {
        this.state = 724;
        var la_ = this._interp.adaptivePredict(this._input,85,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 708;
            this.expr1();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 719;
            switch(this._input.LA(1)) {
            case ScalaParser.T__9:
                this.state = 709;
                this.bindings();
                break;
            case ScalaParser.T__19:
            case ScalaParser.T__21:
            case ScalaParser.Id:
                this.state = 715;
                switch(this._input.LA(1)) {
                case ScalaParser.T__21:
                case ScalaParser.Id:
                    this.state = 711;
                    _la = this._input.LA(1);
                    if(_la===ScalaParser.T__21) {
                        this.state = 710;
                        this.match(ScalaParser.T__21);
                    }

                    this.state = 713;
                    this.match(ScalaParser.Id);
                    break;
                case ScalaParser.T__19:
                    this.state = 714;
                    this.match(ScalaParser.T__19);
                    break;
                default:
                    throw new antlr4.error.NoViableAltException(this);
                }
                this.state = 717;
                this.match(ScalaParser.T__18);
                this.state = 718;
                this.compoundType();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            this.state = 721;
            this.match(ScalaParser.T__8);
            this.state = 722;
            this.block();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EnumeratorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_enumerators;
    return this;
}

EnumeratorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EnumeratorsContext.prototype.constructor = EnumeratorsContext;

EnumeratorsContext.prototype.generator = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GeneratorContext);
    } else {
        return this.getTypedRuleContext(GeneratorContext,i);
    }
};

EnumeratorsContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


EnumeratorsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterEnumerators(this);
	}
};

EnumeratorsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitEnumerators(this);
	}
};




ScalaParser.EnumeratorsContext = EnumeratorsContext;

ScalaParser.prototype.enumerators = function() {

    var localctx = new EnumeratorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 62, ScalaParser.RULE_enumerators);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 726;
        this.generator();
        this.state = 731;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 727;
            this.match(ScalaParser.Semi);
            this.state = 728;
            this.generator();
            this.state = 733;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GeneratorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_generator;
    return this;
}

GeneratorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GeneratorContext.prototype.constructor = GeneratorContext;

GeneratorContext.prototype.pattern1 = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Pattern1Context);
    } else {
        return this.getTypedRuleContext(Pattern1Context,i);
    }
};

GeneratorContext.prototype.expr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExprContext);
    } else {
        return this.getTypedRuleContext(ExprContext,i);
    }
};

GeneratorContext.prototype.guard = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(GuardContext);
    } else {
        return this.getTypedRuleContext(GuardContext,i);
    }
};

GeneratorContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


GeneratorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterGenerator(this);
	}
};

GeneratorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitGenerator(this);
	}
};




ScalaParser.GeneratorContext = GeneratorContext;

ScalaParser.prototype.generator = function() {

    var localctx = new GeneratorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 64, ScalaParser.RULE_generator);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 734;
        this.pattern1();
        this.state = 735;
        this.match(ScalaParser.T__40);
        this.state = 736;
        this.expr();
        this.state = 748;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,89,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 746;
                var la_ = this._interp.adaptivePredict(this._input,88,this._ctx);
                switch(la_) {
                case 1:
                    this.state = 738;
                    _la = this._input.LA(1);
                    if(_la===ScalaParser.Semi) {
                        this.state = 737;
                        this.match(ScalaParser.Semi);
                    }

                    this.state = 740;
                    this.guard();
                    break;

                case 2:
                    this.state = 741;
                    this.match(ScalaParser.Semi);
                    this.state = 742;
                    this.pattern1();
                    this.state = 743;
                    this.match(ScalaParser.T__34);
                    this.state = 744;
                    this.expr();
                    break;

                } 
            }
            this.state = 750;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,89,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CaseClausesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_caseClauses;
    return this;
}

CaseClausesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CaseClausesContext.prototype.constructor = CaseClausesContext;

CaseClausesContext.prototype.caseClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(CaseClauseContext);
    } else {
        return this.getTypedRuleContext(CaseClauseContext,i);
    }
};

CaseClausesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterCaseClauses(this);
	}
};

CaseClausesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitCaseClauses(this);
	}
};




ScalaParser.CaseClausesContext = CaseClausesContext;

ScalaParser.prototype.caseClauses = function() {

    var localctx = new CaseClausesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 66, ScalaParser.RULE_caseClauses);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 752; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 751;
            this.caseClause();
            this.state = 754; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===ScalaParser.T__41);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CaseClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_caseClause;
    return this;
}

CaseClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CaseClauseContext.prototype.constructor = CaseClauseContext;

CaseClauseContext.prototype.pattern = function() {
    return this.getTypedRuleContext(PatternContext,0);
};

CaseClauseContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

CaseClauseContext.prototype.guard = function() {
    return this.getTypedRuleContext(GuardContext,0);
};

CaseClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterCaseClause(this);
	}
};

CaseClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitCaseClause(this);
	}
};




ScalaParser.CaseClauseContext = CaseClauseContext;

ScalaParser.prototype.caseClause = function() {

    var localctx = new CaseClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 68, ScalaParser.RULE_caseClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 756;
        this.match(ScalaParser.T__41);
        this.state = 757;
        this.pattern();
        this.state = 759;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__22) {
            this.state = 758;
            this.guard();
        }

        this.state = 761;
        this.match(ScalaParser.T__8);
        this.state = 762;
        this.block();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function GuardContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_guard;
    return this;
}

GuardContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
GuardContext.prototype.constructor = GuardContext;

GuardContext.prototype.postfixExpr = function() {
    return this.getTypedRuleContext(PostfixExprContext,0);
};

GuardContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterGuard(this);
	}
};

GuardContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitGuard(this);
	}
};




ScalaParser.GuardContext = GuardContext;

ScalaParser.prototype.guard = function() {

    var localctx = new GuardContext(this, this._ctx, this.state);
    this.enterRule(localctx, 70, ScalaParser.RULE_guard);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 764;
        this.match(ScalaParser.T__22);
        this.state = 765;
        this.postfixExpr();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PatternContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_pattern;
    return this;
}

PatternContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PatternContext.prototype.constructor = PatternContext;

PatternContext.prototype.pattern1 = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Pattern1Context);
    } else {
        return this.getTypedRuleContext(Pattern1Context,i);
    }
};

PatternContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPattern(this);
	}
};

PatternContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPattern(this);
	}
};




ScalaParser.PatternContext = PatternContext;

ScalaParser.prototype.pattern = function() {

    var localctx = new PatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 72, ScalaParser.RULE_pattern);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 767;
        this.pattern1();
        this.state = 772;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__42) {
            this.state = 768;
            this.match(ScalaParser.T__42);
            this.state = 769;
            this.pattern1();
            this.state = 774;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Pattern1Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_pattern1;
    return this;
}

Pattern1Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Pattern1Context.prototype.constructor = Pattern1Context;

Pattern1Context.prototype.Varid = function() {
    return this.getToken(ScalaParser.Varid, 0);
};

Pattern1Context.prototype.typePat = function() {
    return this.getTypedRuleContext(TypePatContext,0);
};

Pattern1Context.prototype.pattern2 = function() {
    return this.getTypedRuleContext(Pattern2Context,0);
};

Pattern1Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPattern1(this);
	}
};

Pattern1Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPattern1(this);
	}
};




ScalaParser.Pattern1Context = Pattern1Context;

ScalaParser.prototype.pattern1 = function() {

    var localctx = new Pattern1Context(this, this._ctx, this.state);
    this.enterRule(localctx, 74, ScalaParser.RULE_pattern1);
    try {
        this.state = 782;
        var la_ = this._interp.adaptivePredict(this._input,93,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 775;
            this.match(ScalaParser.Varid);
            this.state = 776;
            this.match(ScalaParser.T__18);
            this.state = 777;
            this.typePat();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 778;
            this.match(ScalaParser.T__19);
            this.state = 779;
            this.match(ScalaParser.T__18);
            this.state = 780;
            this.typePat();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 781;
            this.pattern2();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Pattern2Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_pattern2;
    return this;
}

Pattern2Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Pattern2Context.prototype.constructor = Pattern2Context;

Pattern2Context.prototype.Varid = function() {
    return this.getToken(ScalaParser.Varid, 0);
};

Pattern2Context.prototype.pattern3 = function() {
    return this.getTypedRuleContext(Pattern3Context,0);
};

Pattern2Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPattern2(this);
	}
};

Pattern2Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPattern2(this);
	}
};




ScalaParser.Pattern2Context = Pattern2Context;

ScalaParser.prototype.pattern2 = function() {

    var localctx = new Pattern2Context(this, this._ctx, this.state);
    this.enterRule(localctx, 76, ScalaParser.RULE_pattern2);
    var _la = 0; // Token type
    try {
        this.state = 790;
        var la_ = this._interp.adaptivePredict(this._input,95,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 784;
            this.match(ScalaParser.Varid);
            this.state = 787;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__43) {
                this.state = 785;
                this.match(ScalaParser.T__43);
                this.state = 786;
                this.pattern3();
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 789;
            this.pattern3();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Pattern3Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_pattern3;
    return this;
}

Pattern3Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Pattern3Context.prototype.constructor = Pattern3Context;

Pattern3Context.prototype.simplePattern = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(SimplePatternContext);
    } else {
        return this.getTypedRuleContext(SimplePatternContext,i);
    }
};

Pattern3Context.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


Pattern3Context.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


Pattern3Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPattern3(this);
	}
};

Pattern3Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPattern3(this);
	}
};




ScalaParser.Pattern3Context = Pattern3Context;

ScalaParser.prototype.pattern3 = function() {

    var localctx = new Pattern3Context(this, this._ctx, this.state);
    this.enterRule(localctx, 78, ScalaParser.RULE_pattern3);
    var _la = 0; // Token type
    try {
        this.state = 804;
        var la_ = this._interp.adaptivePredict(this._input,98,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 792;
            this.simplePattern();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 793;
            this.simplePattern();
            this.state = 801;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Id) {
                this.state = 794;
                this.match(ScalaParser.Id);
                this.state = 796;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Nl) {
                    this.state = 795;
                    this.match(ScalaParser.Nl);
                }

                this.state = 798;
                this.simplePattern();
                this.state = 803;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SimplePatternContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_simplePattern;
    return this;
}

SimplePatternContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SimplePatternContext.prototype.constructor = SimplePatternContext;

SimplePatternContext.prototype.Varid = function() {
    return this.getToken(ScalaParser.Varid, 0);
};

SimplePatternContext.prototype.literal = function() {
    return this.getTypedRuleContext(LiteralContext,0);
};

SimplePatternContext.prototype.stableId = function() {
    return this.getTypedRuleContext(StableIdContext,0);
};

SimplePatternContext.prototype.patterns = function() {
    return this.getTypedRuleContext(PatternsContext,0);
};

SimplePatternContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterSimplePattern(this);
	}
};

SimplePatternContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitSimplePattern(this);
	}
};




ScalaParser.SimplePatternContext = SimplePatternContext;

ScalaParser.prototype.simplePattern = function() {

    var localctx = new SimplePatternContext(this, this._ctx, this.state);
    this.enterRule(localctx, 80, ScalaParser.RULE_simplePattern);
    var _la = 0; // Token type
    try {
        this.state = 836;
        var la_ = this._interp.adaptivePredict(this._input,103,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 806;
            this.match(ScalaParser.T__19);
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 807;
            this.match(ScalaParser.Varid);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 808;
            this.literal();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 809;
            this.stableId();
            this.state = 814;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__9) {
                this.state = 810;
                this.match(ScalaParser.T__9);
                this.state = 811;
                this.patterns();
                this.state = 812;
                this.match(ScalaParser.T__10);
            }

            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 816;
            this.stableId();
            this.state = 817;
            this.match(ScalaParser.T__9);
            this.state = 821;
            var la_ = this._interp.adaptivePredict(this._input,100,this._ctx);
            if(la_===1) {
                this.state = 818;
                this.patterns();
                this.state = 819;
                this.match(ScalaParser.T__3);

            }
            this.state = 825;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Varid) {
                this.state = 823;
                this.match(ScalaParser.Varid);
                this.state = 824;
                this.match(ScalaParser.T__43);
            }

            this.state = 827;
            this.match(ScalaParser.T__19);
            this.state = 828;
            this.match(ScalaParser.T__20);
            this.state = 829;
            this.match(ScalaParser.T__10);
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 831;
            this.match(ScalaParser.T__9);
            this.state = 833;
            var la_ = this._interp.adaptivePredict(this._input,102,this._ctx);
            if(la_===1) {
                this.state = 832;
                this.patterns();

            }
            this.state = 835;
            this.match(ScalaParser.T__10);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PatternsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_patterns;
    return this;
}

PatternsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PatternsContext.prototype.constructor = PatternsContext;

PatternsContext.prototype.pattern = function() {
    return this.getTypedRuleContext(PatternContext,0);
};

PatternsContext.prototype.patterns = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(PatternsContext);
    } else {
        return this.getTypedRuleContext(PatternsContext,i);
    }
};

PatternsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPatterns(this);
	}
};

PatternsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPatterns(this);
	}
};




ScalaParser.PatternsContext = PatternsContext;

ScalaParser.prototype.patterns = function() {

    var localctx = new PatternsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 82, ScalaParser.RULE_patterns);
    var _la = 0; // Token type
    try {
        this.state = 852;
        var la_ = this._interp.adaptivePredict(this._input,106,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 838;
            this.pattern();
            this.state = 843;
            this._errHandler.sync(this);
            var _alt = this._interp.adaptivePredict(this._input,104,this._ctx)
            while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
                if(_alt===1) {
                    this.state = 839;
                    this.match(ScalaParser.T__3);
                    this.state = 840;
                    this.patterns(); 
                }
                this.state = 845;
                this._errHandler.sync(this);
                _alt = this._interp.adaptivePredict(this._input,104,this._ctx);
            }

            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 849;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__19) {
                this.state = 846;
                this.match(ScalaParser.T__19);
                this.state = 851;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeParamClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typeParamClause;
    return this;
}

TypeParamClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeParamClauseContext.prototype.constructor = TypeParamClauseContext;

TypeParamClauseContext.prototype.variantTypeParam = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(VariantTypeParamContext);
    } else {
        return this.getTypedRuleContext(VariantTypeParamContext,i);
    }
};

TypeParamClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypeParamClause(this);
	}
};

TypeParamClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypeParamClause(this);
	}
};




ScalaParser.TypeParamClauseContext = TypeParamClauseContext;

ScalaParser.prototype.typeParamClause = function() {

    var localctx = new TypeParamClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 84, ScalaParser.RULE_typeParamClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 854;
        this.match(ScalaParser.T__6);
        this.state = 855;
        this.variantTypeParam();
        this.state = 860;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 856;
            this.match(ScalaParser.T__3);
            this.state = 857;
            this.variantTypeParam();
            this.state = 862;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 863;
        this.match(ScalaParser.T__7);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunTypeParamClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_funTypeParamClause;
    return this;
}

FunTypeParamClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunTypeParamClauseContext.prototype.constructor = FunTypeParamClauseContext;

FunTypeParamClauseContext.prototype.typeParam = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeParamContext);
    } else {
        return this.getTypedRuleContext(TypeParamContext,i);
    }
};

FunTypeParamClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterFunTypeParamClause(this);
	}
};

FunTypeParamClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitFunTypeParamClause(this);
	}
};




ScalaParser.FunTypeParamClauseContext = FunTypeParamClauseContext;

ScalaParser.prototype.funTypeParamClause = function() {

    var localctx = new FunTypeParamClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 86, ScalaParser.RULE_funTypeParamClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 865;
        this.match(ScalaParser.T__6);
        this.state = 866;
        this.typeParam();
        this.state = 871;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 867;
            this.match(ScalaParser.T__3);
            this.state = 868;
            this.typeParam();
            this.state = 873;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 874;
        this.match(ScalaParser.T__7);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VariantTypeParamContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_variantTypeParam;
    return this;
}

VariantTypeParamContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VariantTypeParamContext.prototype.constructor = VariantTypeParamContext;

VariantTypeParamContext.prototype.typeParam = function() {
    return this.getTypedRuleContext(TypeParamContext,0);
};

VariantTypeParamContext.prototype.annotation = function() {
    return this.getTypedRuleContext(AnnotationContext,0);
};

VariantTypeParamContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterVariantTypeParam(this);
	}
};

VariantTypeParamContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitVariantTypeParam(this);
	}
};




ScalaParser.VariantTypeParamContext = VariantTypeParamContext;

ScalaParser.prototype.variantTypeParam = function() {

    var localctx = new VariantTypeParamContext(this, this._ctx, this.state);
    this.enterRule(localctx, 88, ScalaParser.RULE_variantTypeParam);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 877;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__43) {
            this.state = 876;
            this.annotation();
        }

        this.state = 880;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__0 || _la===ScalaParser.T__36) {
            this.state = 879;
            _la = this._input.LA(1);
            if(!(_la===ScalaParser.T__0 || _la===ScalaParser.T__36)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
        }

        this.state = 882;
        this.typeParam();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeParamContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typeParam;
    return this;
}

TypeParamContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeParamContext.prototype.constructor = TypeParamContext;

TypeParamContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

TypeParamContext.prototype.typeParamClause = function() {
    return this.getTypedRuleContext(TypeParamClauseContext,0);
};

TypeParamContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

TypeParamContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypeParam(this);
	}
};

TypeParamContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypeParam(this);
	}
};




ScalaParser.TypeParamContext = TypeParamContext;

ScalaParser.prototype.typeParam = function() {

    var localctx = new TypeParamContext(this, this._ctx, this.state);
    this.enterRule(localctx, 90, ScalaParser.RULE_typeParam);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 884;
        _la = this._input.LA(1);
        if(!(_la===ScalaParser.T__19 || _la===ScalaParser.Id)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
        this.state = 886;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 885;
            this.typeParamClause();
        }

        this.state = 890;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__44) {
            this.state = 888;
            this.match(ScalaParser.T__44);
            this.state = 889;
            this.type();
        }

        this.state = 894;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__45) {
            this.state = 892;
            this.match(ScalaParser.T__45);
            this.state = 893;
            this.type();
        }

        this.state = 900;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__46) {
            this.state = 896;
            this.match(ScalaParser.T__46);
            this.state = 897;
            this.type();
            this.state = 902;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 907;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__18) {
            this.state = 903;
            this.match(ScalaParser.T__18);
            this.state = 904;
            this.type();
            this.state = 909;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParamClausesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_paramClauses;
    return this;
}

ParamClausesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParamClausesContext.prototype.constructor = ParamClausesContext;

ParamClausesContext.prototype.paramClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParamClauseContext);
    } else {
        return this.getTypedRuleContext(ParamClauseContext,i);
    }
};

ParamClausesContext.prototype.params = function() {
    return this.getTypedRuleContext(ParamsContext,0);
};

ParamClausesContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

ParamClausesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterParamClauses(this);
	}
};

ParamClausesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitParamClauses(this);
	}
};




ScalaParser.ParamClausesContext = ParamClausesContext;

ScalaParser.prototype.paramClauses = function() {

    var localctx = new ParamClausesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 92, ScalaParser.RULE_paramClauses);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 913;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,116,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 910;
                this.paramClause(); 
            }
            this.state = 915;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,116,this._ctx);
        }

        this.state = 924;
        var la_ = this._interp.adaptivePredict(this._input,118,this._ctx);
        if(la_===1) {
            this.state = 917;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 916;
                this.match(ScalaParser.Nl);
            }

            this.state = 919;
            this.match(ScalaParser.T__9);
            this.state = 920;
            this.match(ScalaParser.T__21);
            this.state = 921;
            this.params();
            this.state = 922;
            this.match(ScalaParser.T__10);

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParamClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_paramClause;
    return this;
}

ParamClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParamClauseContext.prototype.constructor = ParamClauseContext;

ParamClauseContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

ParamClauseContext.prototype.params = function() {
    return this.getTypedRuleContext(ParamsContext,0);
};

ParamClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterParamClause(this);
	}
};

ParamClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitParamClause(this);
	}
};




ScalaParser.ParamClauseContext = ParamClauseContext;

ScalaParser.prototype.paramClause = function() {

    var localctx = new ParamClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 94, ScalaParser.RULE_paramClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 927;
        _la = this._input.LA(1);
        if(_la===ScalaParser.Nl) {
            this.state = 926;
            this.match(ScalaParser.Nl);
        }

        this.state = 929;
        this.match(ScalaParser.T__9);
        this.state = 931;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__43 || _la===ScalaParser.Id) {
            this.state = 930;
            this.params();
        }

        this.state = 933;
        this.match(ScalaParser.T__10);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParamsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_params;
    return this;
}

ParamsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParamsContext.prototype.constructor = ParamsContext;

ParamsContext.prototype.param = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ParamContext);
    } else {
        return this.getTypedRuleContext(ParamContext,i);
    }
};

ParamsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterParams(this);
	}
};

ParamsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitParams(this);
	}
};




ScalaParser.ParamsContext = ParamsContext;

ScalaParser.prototype.params = function() {

    var localctx = new ParamsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 96, ScalaParser.RULE_params);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 935;
        this.param();
        this.state = 940;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 936;
            this.match(ScalaParser.T__3);
            this.state = 937;
            this.param();
            this.state = 942;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParamContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_param;
    return this;
}

ParamContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParamContext.prototype.constructor = ParamContext;

ParamContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ParamContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

ParamContext.prototype.paramType = function() {
    return this.getTypedRuleContext(ParamTypeContext,0);
};

ParamContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ParamContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterParam(this);
	}
};

ParamContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitParam(this);
	}
};




ScalaParser.ParamContext = ParamContext;

ScalaParser.prototype.param = function() {

    var localctx = new ParamContext(this, this._ctx, this.state);
    this.enterRule(localctx, 98, ScalaParser.RULE_param);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 946;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__43) {
            this.state = 943;
            this.annotation();
            this.state = 948;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 949;
        this.match(ScalaParser.Id);
        this.state = 952;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__18) {
            this.state = 950;
            this.match(ScalaParser.T__18);
            this.state = 951;
            this.paramType();
        }

        this.state = 956;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__34) {
            this.state = 954;
            this.match(ScalaParser.T__34);
            this.state = 955;
            this.expr();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ParamTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_paramType;
    return this;
}

ParamTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ParamTypeContext.prototype.constructor = ParamTypeContext;

ParamTypeContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

ParamTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterParamType(this);
	}
};

ParamTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitParamType(this);
	}
};




ScalaParser.ParamTypeContext = ParamTypeContext;

ScalaParser.prototype.paramType = function() {

    var localctx = new ParamTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 100, ScalaParser.RULE_paramType);
    try {
        this.state = 964;
        var la_ = this._interp.adaptivePredict(this._input,125,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 958;
            this.type();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 959;
            this.match(ScalaParser.T__8);
            this.state = 960;
            this.type();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 961;
            this.type();
            this.state = 962;
            this.match(ScalaParser.T__20);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassParamClausesContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classParamClauses;
    return this;
}

ClassParamClausesContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassParamClausesContext.prototype.constructor = ClassParamClausesContext;

ClassParamClausesContext.prototype.classParamClause = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ClassParamClauseContext);
    } else {
        return this.getTypedRuleContext(ClassParamClauseContext,i);
    }
};

ClassParamClausesContext.prototype.classParams = function() {
    return this.getTypedRuleContext(ClassParamsContext,0);
};

ClassParamClausesContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

ClassParamClausesContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassParamClauses(this);
	}
};

ClassParamClausesContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassParamClauses(this);
	}
};




ScalaParser.ClassParamClausesContext = ClassParamClausesContext;

ScalaParser.prototype.classParamClauses = function() {

    var localctx = new ClassParamClausesContext(this, this._ctx, this.state);
    this.enterRule(localctx, 102, ScalaParser.RULE_classParamClauses);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 969;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,126,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 966;
                this.classParamClause(); 
            }
            this.state = 971;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,126,this._ctx);
        }

        this.state = 980;
        var la_ = this._interp.adaptivePredict(this._input,128,this._ctx);
        if(la_===1) {
            this.state = 973;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 972;
                this.match(ScalaParser.Nl);
            }

            this.state = 975;
            this.match(ScalaParser.T__9);
            this.state = 976;
            this.match(ScalaParser.T__21);
            this.state = 977;
            this.classParams();
            this.state = 978;
            this.match(ScalaParser.T__10);

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassParamClauseContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classParamClause;
    return this;
}

ClassParamClauseContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassParamClauseContext.prototype.constructor = ClassParamClauseContext;

ClassParamClauseContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

ClassParamClauseContext.prototype.classParams = function() {
    return this.getTypedRuleContext(ClassParamsContext,0);
};

ClassParamClauseContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassParamClause(this);
	}
};

ClassParamClauseContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassParamClause(this);
	}
};




ScalaParser.ClassParamClauseContext = ClassParamClauseContext;

ScalaParser.prototype.classParamClause = function() {

    var localctx = new ClassParamClauseContext(this, this._ctx, this.state);
    this.enterRule(localctx, 104, ScalaParser.RULE_classParamClause);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 983;
        _la = this._input.LA(1);
        if(_la===ScalaParser.Nl) {
            this.state = 982;
            this.match(ScalaParser.Nl);
        }

        this.state = 985;
        this.match(ScalaParser.T__9);
        this.state = 987;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__15 || _la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__43 - 40)) | (1 << (ScalaParser.T__47 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)) | (1 << (ScalaParser.Id - 40)))) !== 0)) {
            this.state = 986;
            this.classParams();
        }

        this.state = 989;
        this.match(ScalaParser.T__10);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassParamsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classParams;
    return this;
}

ClassParamsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassParamsContext.prototype.constructor = ClassParamsContext;

ClassParamsContext.prototype.classParam = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ClassParamContext);
    } else {
        return this.getTypedRuleContext(ClassParamContext,i);
    }
};

ClassParamsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassParams(this);
	}
};

ClassParamsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassParams(this);
	}
};




ScalaParser.ClassParamsContext = ClassParamsContext;

ScalaParser.prototype.classParams = function() {

    var localctx = new ClassParamsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 106, ScalaParser.RULE_classParams);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 991;
        this.classParam();
        this.state = 996;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 992;
            this.match(ScalaParser.T__3);
            this.state = 993;
            this.classParam();
            this.state = 998;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassParamContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classParam;
    return this;
}

ClassParamContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassParamContext.prototype.constructor = ClassParamContext;

ClassParamContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ClassParamContext.prototype.paramType = function() {
    return this.getTypedRuleContext(ParamTypeContext,0);
};

ClassParamContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

ClassParamContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

ClassParamContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

ClassParamContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassParam(this);
	}
};

ClassParamContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassParam(this);
	}
};




ScalaParser.ClassParamContext = ClassParamContext;

ScalaParser.prototype.classParam = function() {

    var localctx = new ClassParamContext(this, this._ctx, this.state);
    this.enterRule(localctx, 108, ScalaParser.RULE_classParam);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1002;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__43) {
            this.state = 999;
            this.annotation();
            this.state = 1004;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1008;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
            this.state = 1005;
            this.modifier();
            this.state = 1010;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1012;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__15 || _la===ScalaParser.T__47) {
            this.state = 1011;
            _la = this._input.LA(1);
            if(!(_la===ScalaParser.T__15 || _la===ScalaParser.T__47)) {
            this._errHandler.recoverInline(this);
            }
            else {
                this.consume();
            }
        }

        this.state = 1014;
        this.match(ScalaParser.Id);
        this.state = 1015;
        this.match(ScalaParser.T__18);
        this.state = 1016;
        this.paramType();
        this.state = 1019;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__34) {
            this.state = 1017;
            this.match(ScalaParser.T__34);
            this.state = 1018;
            this.expr();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BindingsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_bindings;
    return this;
}

BindingsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BindingsContext.prototype.constructor = BindingsContext;

BindingsContext.prototype.binding = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BindingContext);
    } else {
        return this.getTypedRuleContext(BindingContext,i);
    }
};

BindingsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterBindings(this);
	}
};

BindingsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitBindings(this);
	}
};




ScalaParser.BindingsContext = BindingsContext;

ScalaParser.prototype.bindings = function() {

    var localctx = new BindingsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 110, ScalaParser.RULE_bindings);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1021;
        this.match(ScalaParser.T__9);
        this.state = 1022;
        this.binding();
        this.state = 1027;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 1023;
            this.match(ScalaParser.T__3);
            this.state = 1024;
            this.binding();
            this.state = 1029;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1030;
        this.match(ScalaParser.T__10);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function BindingContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_binding;
    return this;
}

BindingContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BindingContext.prototype.constructor = BindingContext;

BindingContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

BindingContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

BindingContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterBinding(this);
	}
};

BindingContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitBinding(this);
	}
};




ScalaParser.BindingContext = BindingContext;

ScalaParser.prototype.binding = function() {

    var localctx = new BindingContext(this, this._ctx, this.state);
    this.enterRule(localctx, 112, ScalaParser.RULE_binding);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1032;
        _la = this._input.LA(1);
        if(!(_la===ScalaParser.T__19 || _la===ScalaParser.Id)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
        this.state = 1035;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__18) {
            this.state = 1033;
            this.match(ScalaParser.T__18);
            this.state = 1034;
            this.type();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_modifier;
    return this;
}

ModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ModifierContext.prototype.constructor = ModifierContext;

ModifierContext.prototype.localModifier = function() {
    return this.getTypedRuleContext(LocalModifierContext,0);
};

ModifierContext.prototype.accessModifier = function() {
    return this.getTypedRuleContext(AccessModifierContext,0);
};

ModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterModifier(this);
	}
};

ModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitModifier(this);
	}
};




ScalaParser.ModifierContext = ModifierContext;

ScalaParser.prototype.modifier = function() {

    var localctx = new ModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 114, ScalaParser.RULE_modifier);
    try {
        this.state = 1040;
        switch(this._input.LA(1)) {
        case ScalaParser.T__21:
        case ScalaParser.T__39:
        case ScalaParser.T__49:
        case ScalaParser.T__50:
        case ScalaParser.T__51:
            this.enterOuterAlt(localctx, 1);
            this.state = 1037;
            this.localModifier();
            break;
        case ScalaParser.T__52:
        case ScalaParser.T__53:
            this.enterOuterAlt(localctx, 2);
            this.state = 1038;
            this.accessModifier();
            break;
        case ScalaParser.T__48:
            this.enterOuterAlt(localctx, 3);
            this.state = 1039;
            this.match(ScalaParser.T__48);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function LocalModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_localModifier;
    return this;
}

LocalModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LocalModifierContext.prototype.constructor = LocalModifierContext;


LocalModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterLocalModifier(this);
	}
};

LocalModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitLocalModifier(this);
	}
};




ScalaParser.LocalModifierContext = LocalModifierContext;

ScalaParser.prototype.localModifier = function() {

    var localctx = new LocalModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 116, ScalaParser.RULE_localModifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1042;
        _la = this._input.LA(1);
        if(!(((((_la - 22)) & ~0x1f) == 0 && ((1 << (_la - 22)) & ((1 << (ScalaParser.T__21 - 22)) | (1 << (ScalaParser.T__39 - 22)) | (1 << (ScalaParser.T__49 - 22)) | (1 << (ScalaParser.T__50 - 22)) | (1 << (ScalaParser.T__51 - 22)))) !== 0))) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AccessModifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_accessModifier;
    return this;
}

AccessModifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AccessModifierContext.prototype.constructor = AccessModifierContext;

AccessModifierContext.prototype.accessQualifier = function() {
    return this.getTypedRuleContext(AccessQualifierContext,0);
};

AccessModifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterAccessModifier(this);
	}
};

AccessModifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitAccessModifier(this);
	}
};




ScalaParser.AccessModifierContext = AccessModifierContext;

ScalaParser.prototype.accessModifier = function() {

    var localctx = new AccessModifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 118, ScalaParser.RULE_accessModifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1044;
        _la = this._input.LA(1);
        if(!(_la===ScalaParser.T__52 || _la===ScalaParser.T__53)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
        this.state = 1046;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1045;
            this.accessQualifier();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AccessQualifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_accessQualifier;
    return this;
}

AccessQualifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AccessQualifierContext.prototype.constructor = AccessQualifierContext;

AccessQualifierContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

AccessQualifierContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterAccessQualifier(this);
	}
};

AccessQualifierContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitAccessQualifier(this);
	}
};




ScalaParser.AccessQualifierContext = AccessQualifierContext;

ScalaParser.prototype.accessQualifier = function() {

    var localctx = new AccessQualifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 120, ScalaParser.RULE_accessQualifier);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1048;
        this.match(ScalaParser.T__6);
        this.state = 1049;
        _la = this._input.LA(1);
        if(!(_la===ScalaParser.T__4 || _la===ScalaParser.Id)) {
        this._errHandler.recoverInline(this);
        }
        else {
            this.consume();
        }
        this.state = 1050;
        this.match(ScalaParser.T__7);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function AnnotationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_annotation;
    return this;
}

AnnotationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
AnnotationContext.prototype.constructor = AnnotationContext;

AnnotationContext.prototype.simpleType = function() {
    return this.getTypedRuleContext(SimpleTypeContext,0);
};

AnnotationContext.prototype.argumentExprs = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ArgumentExprsContext);
    } else {
        return this.getTypedRuleContext(ArgumentExprsContext,i);
    }
};

AnnotationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterAnnotation(this);
	}
};

AnnotationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitAnnotation(this);
	}
};




ScalaParser.AnnotationContext = AnnotationContext;

ScalaParser.prototype.annotation = function() {

    var localctx = new AnnotationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 122, ScalaParser.RULE_annotation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1052;
        this.match(ScalaParser.T__43);
        this.state = 1053;
        this.simpleType(0);
        this.state = 1057;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,140,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1054;
                this.argumentExprs(); 
            }
            this.state = 1059;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,140,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstrAnnotationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_constrAnnotation;
    return this;
}

ConstrAnnotationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstrAnnotationContext.prototype.constructor = ConstrAnnotationContext;

ConstrAnnotationContext.prototype.simpleType = function() {
    return this.getTypedRuleContext(SimpleTypeContext,0);
};

ConstrAnnotationContext.prototype.argumentExprs = function() {
    return this.getTypedRuleContext(ArgumentExprsContext,0);
};

ConstrAnnotationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterConstrAnnotation(this);
	}
};

ConstrAnnotationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitConstrAnnotation(this);
	}
};




ScalaParser.ConstrAnnotationContext = ConstrAnnotationContext;

ScalaParser.prototype.constrAnnotation = function() {

    var localctx = new ConstrAnnotationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 124, ScalaParser.RULE_constrAnnotation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1060;
        this.match(ScalaParser.T__43);
        this.state = 1061;
        this.simpleType(0);
        this.state = 1062;
        this.argumentExprs();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TemplateBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_templateBody;
    return this;
}

TemplateBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TemplateBodyContext.prototype.constructor = TemplateBodyContext;

TemplateBodyContext.prototype.templateStat = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TemplateStatContext);
    } else {
        return this.getTypedRuleContext(TemplateStatContext,i);
    }
};

TemplateBodyContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

TemplateBodyContext.prototype.selfType = function() {
    return this.getTypedRuleContext(SelfTypeContext,0);
};

TemplateBodyContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


TemplateBodyContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTemplateBody(this);
	}
};

TemplateBodyContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTemplateBody(this);
	}
};




ScalaParser.TemplateBodyContext = TemplateBodyContext;

ScalaParser.prototype.templateBody = function() {

    var localctx = new TemplateBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 126, ScalaParser.RULE_templateBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1065;
        _la = this._input.LA(1);
        if(_la===ScalaParser.Nl) {
            this.state = 1064;
            this.match(ScalaParser.Nl);
        }

        this.state = 1067;
        this.match(ScalaParser.T__12);
        this.state = 1069;
        var la_ = this._interp.adaptivePredict(this._input,142,this._ctx);
        if(la_===1) {
            this.state = 1068;
            this.selfType();

        }
        this.state = 1071;
        this.templateStat();
        this.state = 1076;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 1072;
            this.match(ScalaParser.Semi);
            this.state = 1073;
            this.templateStat();
            this.state = 1078;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1079;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TemplateStatContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_templateStat;
    return this;
}

TemplateStatContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TemplateStatContext.prototype.constructor = TemplateStatContext;

TemplateStatContext.prototype.import_ = function() {
    return this.getTypedRuleContext(Import_Context,0);
};

TemplateStatContext.prototype.def = function() {
    return this.getTypedRuleContext(DefContext,0);
};

TemplateStatContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

TemplateStatContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

TemplateStatContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


TemplateStatContext.prototype.dcl = function() {
    return this.getTypedRuleContext(DclContext,0);
};

TemplateStatContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

TemplateStatContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTemplateStat(this);
	}
};

TemplateStatContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTemplateStat(this);
	}
};




ScalaParser.TemplateStatContext = TemplateStatContext;

ScalaParser.prototype.templateStat = function() {

    var localctx = new TemplateStatContext(this, this._ctx, this.state);
    this.enterRule(localctx, 128, ScalaParser.RULE_templateStat);
    var _la = 0; // Token type
    try {
        this.state = 1116;
        var la_ = this._interp.adaptivePredict(this._input,150,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1081;
            this.import_();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1088;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__43) {
                this.state = 1082;
                this.annotation();
                this.state = 1084;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Nl) {
                    this.state = 1083;
                    this.match(ScalaParser.Nl);
                }

                this.state = 1090;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1094;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
                this.state = 1091;
                this.modifier();
                this.state = 1096;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1097;
            this.def();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1104;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__43) {
                this.state = 1098;
                this.annotation();
                this.state = 1100;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Nl) {
                    this.state = 1099;
                    this.match(ScalaParser.Nl);
                }

                this.state = 1106;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1110;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
                this.state = 1107;
                this.modifier();
                this.state = 1112;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1113;
            this.dcl();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1114;
            this.expr();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SelfTypeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_selfType;
    return this;
}

SelfTypeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SelfTypeContext.prototype.constructor = SelfTypeContext;

SelfTypeContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

SelfTypeContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

SelfTypeContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterSelfType(this);
	}
};

SelfTypeContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitSelfType(this);
	}
};




ScalaParser.SelfTypeContext = SelfTypeContext;

ScalaParser.prototype.selfType = function() {

    var localctx = new SelfTypeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 130, ScalaParser.RULE_selfType);
    var _la = 0; // Token type
    try {
        this.state = 1129;
        switch(this._input.LA(1)) {
        case ScalaParser.Id:
            this.enterOuterAlt(localctx, 1);
            this.state = 1118;
            this.match(ScalaParser.Id);
            this.state = 1121;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__18) {
                this.state = 1119;
                this.match(ScalaParser.T__18);
                this.state = 1120;
                this.type();
            }

            this.state = 1123;
            this.match(ScalaParser.T__8);
            break;
        case ScalaParser.T__4:
            this.enterOuterAlt(localctx, 2);
            this.state = 1124;
            this.match(ScalaParser.T__4);
            this.state = 1125;
            this.match(ScalaParser.T__18);
            this.state = 1126;
            this.type();
            this.state = 1127;
            this.match(ScalaParser.T__8);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function Import_Context(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_import_;
    return this;
}

Import_Context.prototype = Object.create(antlr4.ParserRuleContext.prototype);
Import_Context.prototype.constructor = Import_Context;

Import_Context.prototype.importExpr = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ImportExprContext);
    } else {
        return this.getTypedRuleContext(ImportExprContext,i);
    }
};

Import_Context.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterImport_(this);
	}
};

Import_Context.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitImport_(this);
	}
};




ScalaParser.Import_Context = Import_Context;

ScalaParser.prototype.import_ = function() {

    var localctx = new Import_Context(this, this._ctx, this.state);
    this.enterRule(localctx, 132, ScalaParser.RULE_import_);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1131;
        this.match(ScalaParser.T__54);
        this.state = 1132;
        this.importExpr();
        this.state = 1137;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 1133;
            this.match(ScalaParser.T__3);
            this.state = 1134;
            this.importExpr();
            this.state = 1139;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ImportExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_importExpr;
    return this;
}

ImportExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ImportExprContext.prototype.constructor = ImportExprContext;

ImportExprContext.prototype.stableId = function() {
    return this.getTypedRuleContext(StableIdContext,0);
};

ImportExprContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ImportExprContext.prototype.importSelectors = function() {
    return this.getTypedRuleContext(ImportSelectorsContext,0);
};

ImportExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterImportExpr(this);
	}
};

ImportExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitImportExpr(this);
	}
};




ScalaParser.ImportExprContext = ImportExprContext;

ScalaParser.prototype.importExpr = function() {

    var localctx = new ImportExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 134, ScalaParser.RULE_importExpr);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1140;
        this.stableId();
        this.state = 1141;
        this.match(ScalaParser.T__2);
        this.state = 1145;
        switch(this._input.LA(1)) {
        case ScalaParser.Id:
            this.state = 1142;
            this.match(ScalaParser.Id);
            break;
        case ScalaParser.T__19:
            this.state = 1143;
            this.match(ScalaParser.T__19);
            break;
        case ScalaParser.T__12:
            this.state = 1144;
            this.importSelectors();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ImportSelectorsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_importSelectors;
    return this;
}

ImportSelectorsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ImportSelectorsContext.prototype.constructor = ImportSelectorsContext;

ImportSelectorsContext.prototype.importSelector = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ImportSelectorContext);
    } else {
        return this.getTypedRuleContext(ImportSelectorContext,i);
    }
};

ImportSelectorsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterImportSelectors(this);
	}
};

ImportSelectorsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitImportSelectors(this);
	}
};




ScalaParser.ImportSelectorsContext = ImportSelectorsContext;

ScalaParser.prototype.importSelectors = function() {

    var localctx = new ImportSelectorsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 136, ScalaParser.RULE_importSelectors);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1147;
        this.match(ScalaParser.T__12);
        this.state = 1153;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,155,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1148;
                this.importSelector();
                this.state = 1149;
                this.match(ScalaParser.T__3); 
            }
            this.state = 1155;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,155,this._ctx);
        }

        this.state = 1158;
        switch(this._input.LA(1)) {
        case ScalaParser.Id:
            this.state = 1156;
            this.importSelector();
            break;
        case ScalaParser.T__19:
            this.state = 1157;
            this.match(ScalaParser.T__19);
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
        this.state = 1160;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ImportSelectorContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_importSelector;
    return this;
}

ImportSelectorContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ImportSelectorContext.prototype.constructor = ImportSelectorContext;

ImportSelectorContext.prototype.Id = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Id);
    } else {
        return this.getToken(ScalaParser.Id, i);
    }
};


ImportSelectorContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterImportSelector(this);
	}
};

ImportSelectorContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitImportSelector(this);
	}
};




ScalaParser.ImportSelectorContext = ImportSelectorContext;

ScalaParser.prototype.importSelector = function() {

    var localctx = new ImportSelectorContext(this, this._ctx, this.state);
    this.enterRule(localctx, 138, ScalaParser.RULE_importSelector);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1162;
        this.match(ScalaParser.Id);
        this.state = 1167;
        var la_ = this._interp.adaptivePredict(this._input,157,this._ctx);
        switch(la_) {
        case 1:
            this.state = 1163;
            this.match(ScalaParser.T__8);
            this.state = 1164;
            this.match(ScalaParser.Id);
            break;

        case 2:
            this.state = 1165;
            this.match(ScalaParser.T__8);
            this.state = 1166;
            this.match(ScalaParser.T__19);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_dcl;
    return this;
}

DclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DclContext.prototype.constructor = DclContext;

DclContext.prototype.valDcl = function() {
    return this.getTypedRuleContext(ValDclContext,0);
};

DclContext.prototype.varDcl = function() {
    return this.getTypedRuleContext(VarDclContext,0);
};

DclContext.prototype.funDcl = function() {
    return this.getTypedRuleContext(FunDclContext,0);
};

DclContext.prototype.typeDcl = function() {
    return this.getTypedRuleContext(TypeDclContext,0);
};

DclContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


DclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterDcl(this);
	}
};

DclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitDcl(this);
	}
};




ScalaParser.DclContext = DclContext;

ScalaParser.prototype.dcl = function() {

    var localctx = new DclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 140, ScalaParser.RULE_dcl);
    var _la = 0; // Token type
    try {
        this.state = 1183;
        switch(this._input.LA(1)) {
        case ScalaParser.T__15:
            this.enterOuterAlt(localctx, 1);
            this.state = 1169;
            this.match(ScalaParser.T__15);
            this.state = 1170;
            this.valDcl();
            break;
        case ScalaParser.T__47:
            this.enterOuterAlt(localctx, 2);
            this.state = 1171;
            this.match(ScalaParser.T__47);
            this.state = 1172;
            this.varDcl();
            break;
        case ScalaParser.T__55:
            this.enterOuterAlt(localctx, 3);
            this.state = 1173;
            this.match(ScalaParser.T__55);
            this.state = 1174;
            this.funDcl();
            break;
        case ScalaParser.T__14:
            this.enterOuterAlt(localctx, 4);
            this.state = 1175;
            this.match(ScalaParser.T__14);
            this.state = 1179;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Nl) {
                this.state = 1176;
                this.match(ScalaParser.Nl);
                this.state = 1181;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1182;
            this.typeDcl();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ValDclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_valDcl;
    return this;
}

ValDclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ValDclContext.prototype.constructor = ValDclContext;

ValDclContext.prototype.ids = function() {
    return this.getTypedRuleContext(IdsContext,0);
};

ValDclContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

ValDclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterValDcl(this);
	}
};

ValDclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitValDcl(this);
	}
};




ScalaParser.ValDclContext = ValDclContext;

ScalaParser.prototype.valDcl = function() {

    var localctx = new ValDclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 142, ScalaParser.RULE_valDcl);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1185;
        this.ids();
        this.state = 1186;
        this.match(ScalaParser.T__18);
        this.state = 1187;
        this.type();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VarDclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_varDcl;
    return this;
}

VarDclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VarDclContext.prototype.constructor = VarDclContext;

VarDclContext.prototype.ids = function() {
    return this.getTypedRuleContext(IdsContext,0);
};

VarDclContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

VarDclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterVarDcl(this);
	}
};

VarDclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitVarDcl(this);
	}
};




ScalaParser.VarDclContext = VarDclContext;

ScalaParser.prototype.varDcl = function() {

    var localctx = new VarDclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 144, ScalaParser.RULE_varDcl);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1189;
        this.ids();
        this.state = 1190;
        this.match(ScalaParser.T__18);
        this.state = 1191;
        this.type();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunDclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_funDcl;
    return this;
}

FunDclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunDclContext.prototype.constructor = FunDclContext;

FunDclContext.prototype.funSig = function() {
    return this.getTypedRuleContext(FunSigContext,0);
};

FunDclContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

FunDclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterFunDcl(this);
	}
};

FunDclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitFunDcl(this);
	}
};




ScalaParser.FunDclContext = FunDclContext;

ScalaParser.prototype.funDcl = function() {

    var localctx = new FunDclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 146, ScalaParser.RULE_funDcl);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1193;
        this.funSig();
        this.state = 1196;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__18) {
            this.state = 1194;
            this.match(ScalaParser.T__18);
            this.state = 1195;
            this.type();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunSigContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_funSig;
    return this;
}

FunSigContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunSigContext.prototype.constructor = FunSigContext;

FunSigContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

FunSigContext.prototype.paramClauses = function() {
    return this.getTypedRuleContext(ParamClausesContext,0);
};

FunSigContext.prototype.funTypeParamClause = function() {
    return this.getTypedRuleContext(FunTypeParamClauseContext,0);
};

FunSigContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterFunSig(this);
	}
};

FunSigContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitFunSig(this);
	}
};




ScalaParser.FunSigContext = FunSigContext;

ScalaParser.prototype.funSig = function() {

    var localctx = new FunSigContext(this, this._ctx, this.state);
    this.enterRule(localctx, 148, ScalaParser.RULE_funSig);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1198;
        this.match(ScalaParser.Id);
        this.state = 1200;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1199;
            this.funTypeParamClause();
        }

        this.state = 1202;
        this.paramClauses();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeDclContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typeDcl;
    return this;
}

TypeDclContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeDclContext.prototype.constructor = TypeDclContext;

TypeDclContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

TypeDclContext.prototype.typeParamClause = function() {
    return this.getTypedRuleContext(TypeParamClauseContext,0);
};

TypeDclContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

TypeDclContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypeDcl(this);
	}
};

TypeDclContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypeDcl(this);
	}
};




ScalaParser.TypeDclContext = TypeDclContext;

ScalaParser.prototype.typeDcl = function() {

    var localctx = new TypeDclContext(this, this._ctx, this.state);
    this.enterRule(localctx, 150, ScalaParser.RULE_typeDcl);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1204;
        this.match(ScalaParser.Id);
        this.state = 1206;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1205;
            this.typeParamClause();
        }

        this.state = 1210;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__44) {
            this.state = 1208;
            this.match(ScalaParser.T__44);
            this.state = 1209;
            this.type();
        }

        this.state = 1214;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__45) {
            this.state = 1212;
            this.match(ScalaParser.T__45);
            this.state = 1213;
            this.type();
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PatVarDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_patVarDef;
    return this;
}

PatVarDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PatVarDefContext.prototype.constructor = PatVarDefContext;

PatVarDefContext.prototype.patDef = function() {
    return this.getTypedRuleContext(PatDefContext,0);
};

PatVarDefContext.prototype.varDef = function() {
    return this.getTypedRuleContext(VarDefContext,0);
};

PatVarDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPatVarDef(this);
	}
};

PatVarDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPatVarDef(this);
	}
};




ScalaParser.PatVarDefContext = PatVarDefContext;

ScalaParser.prototype.patVarDef = function() {

    var localctx = new PatVarDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 152, ScalaParser.RULE_patVarDef);
    try {
        this.state = 1220;
        switch(this._input.LA(1)) {
        case ScalaParser.T__15:
            this.enterOuterAlt(localctx, 1);
            this.state = 1216;
            this.match(ScalaParser.T__15);
            this.state = 1217;
            this.patDef();
            break;
        case ScalaParser.T__47:
            this.enterOuterAlt(localctx, 2);
            this.state = 1218;
            this.match(ScalaParser.T__47);
            this.state = 1219;
            this.varDef();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function DefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_def;
    return this;
}

DefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DefContext.prototype.constructor = DefContext;

DefContext.prototype.patVarDef = function() {
    return this.getTypedRuleContext(PatVarDefContext,0);
};

DefContext.prototype.funDef = function() {
    return this.getTypedRuleContext(FunDefContext,0);
};

DefContext.prototype.typeDef = function() {
    return this.getTypedRuleContext(TypeDefContext,0);
};

DefContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


DefContext.prototype.tmplDef = function() {
    return this.getTypedRuleContext(TmplDefContext,0);
};

DefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterDef(this);
	}
};

DefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitDef(this);
	}
};




ScalaParser.DefContext = DefContext;

ScalaParser.prototype.def = function() {

    var localctx = new DefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 154, ScalaParser.RULE_def);
    var _la = 0; // Token type
    try {
        this.state = 1234;
        switch(this._input.LA(1)) {
        case ScalaParser.T__15:
        case ScalaParser.T__47:
            this.enterOuterAlt(localctx, 1);
            this.state = 1222;
            this.patVarDef();
            break;
        case ScalaParser.T__55:
            this.enterOuterAlt(localctx, 2);
            this.state = 1223;
            this.match(ScalaParser.T__55);
            this.state = 1224;
            this.funDef();
            break;
        case ScalaParser.T__14:
            this.enterOuterAlt(localctx, 3);
            this.state = 1225;
            this.match(ScalaParser.T__14);
            this.state = 1229;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Nl) {
                this.state = 1226;
                this.match(ScalaParser.Nl);
                this.state = 1231;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1232;
            this.typeDef();
            break;
        case ScalaParser.T__41:
        case ScalaParser.T__56:
        case ScalaParser.T__58:
            this.enterOuterAlt(localctx, 4);
            this.state = 1233;
            this.tmplDef();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PatDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_patDef;
    return this;
}

PatDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PatDefContext.prototype.constructor = PatDefContext;

PatDefContext.prototype.pattern2 = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(Pattern2Context);
    } else {
        return this.getTypedRuleContext(Pattern2Context,i);
    }
};

PatDefContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

PatDefContext.prototype.type = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TypeContext);
    } else {
        return this.getTypedRuleContext(TypeContext,i);
    }
};

PatDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPatDef(this);
	}
};

PatDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPatDef(this);
	}
};




ScalaParser.PatDefContext = PatDefContext;

ScalaParser.prototype.patDef = function() {

    var localctx = new PatDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 156, ScalaParser.RULE_patDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1236;
        this.pattern2();
        this.state = 1241;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__3) {
            this.state = 1237;
            this.match(ScalaParser.T__3);
            this.state = 1238;
            this.pattern2();
            this.state = 1243;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1248;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__18) {
            this.state = 1244;
            this.match(ScalaParser.T__18);
            this.state = 1245;
            this.type();
            this.state = 1250;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1251;
        this.match(ScalaParser.T__34);
        this.state = 1252;
        this.expr();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function VarDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_varDef;
    return this;
}

VarDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VarDefContext.prototype.constructor = VarDefContext;

VarDefContext.prototype.patDef = function() {
    return this.getTypedRuleContext(PatDefContext,0);
};

VarDefContext.prototype.ids = function() {
    return this.getTypedRuleContext(IdsContext,0);
};

VarDefContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

VarDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterVarDef(this);
	}
};

VarDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitVarDef(this);
	}
};




ScalaParser.VarDefContext = VarDefContext;

ScalaParser.prototype.varDef = function() {

    var localctx = new VarDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 158, ScalaParser.RULE_varDef);
    try {
        this.state = 1261;
        var la_ = this._interp.adaptivePredict(this._input,170,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1254;
            this.patDef();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1255;
            this.ids();
            this.state = 1256;
            this.match(ScalaParser.T__18);
            this.state = 1257;
            this.type();
            this.state = 1258;
            this.match(ScalaParser.T__34);
            this.state = 1259;
            this.match(ScalaParser.T__19);
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function FunDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_funDef;
    return this;
}

FunDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunDefContext.prototype.constructor = FunDefContext;

FunDefContext.prototype.funSig = function() {
    return this.getTypedRuleContext(FunSigContext,0);
};

FunDefContext.prototype.expr = function() {
    return this.getTypedRuleContext(ExprContext,0);
};

FunDefContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

FunDefContext.prototype.block = function() {
    return this.getTypedRuleContext(BlockContext,0);
};

FunDefContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

FunDefContext.prototype.paramClause = function() {
    return this.getTypedRuleContext(ParamClauseContext,0);
};

FunDefContext.prototype.paramClauses = function() {
    return this.getTypedRuleContext(ParamClausesContext,0);
};

FunDefContext.prototype.constrExpr = function() {
    return this.getTypedRuleContext(ConstrExprContext,0);
};

FunDefContext.prototype.constrBlock = function() {
    return this.getTypedRuleContext(ConstrBlockContext,0);
};

FunDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterFunDef(this);
	}
};

FunDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitFunDef(this);
	}
};




ScalaParser.FunDefContext = FunDefContext;

ScalaParser.prototype.funDef = function() {

    var localctx = new FunDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 160, ScalaParser.RULE_funDef);
    var _la = 0; // Token type
    try {
        this.state = 1288;
        var la_ = this._interp.adaptivePredict(this._input,174,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1263;
            this.funSig();
            this.state = 1266;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__18) {
                this.state = 1264;
                this.match(ScalaParser.T__18);
                this.state = 1265;
                this.type();
            }

            this.state = 1268;
            this.match(ScalaParser.T__34);
            this.state = 1269;
            this.expr();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1271;
            this.funSig();
            this.state = 1273;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 1272;
                this.match(ScalaParser.Nl);
            }

            this.state = 1275;
            this.match(ScalaParser.T__12);
            this.state = 1276;
            this.block();
            this.state = 1277;
            this.match(ScalaParser.T__13);
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1279;
            this.match(ScalaParser.T__4);
            this.state = 1280;
            this.paramClause();
            this.state = 1281;
            this.paramClauses();
            this.state = 1286;
            switch(this._input.LA(1)) {
            case ScalaParser.T__34:
                this.state = 1282;
                this.match(ScalaParser.T__34);
                this.state = 1283;
                this.constrExpr();
                break;
            case ScalaParser.Nl:
                this.state = 1284;
                this.match(ScalaParser.Nl);
                this.state = 1285;
                this.constrBlock();
                break;
            default:
                throw new antlr4.error.NoViableAltException(this);
            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TypeDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_typeDef;
    return this;
}

TypeDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TypeDefContext.prototype.constructor = TypeDefContext;

TypeDefContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

TypeDefContext.prototype.type = function() {
    return this.getTypedRuleContext(TypeContext,0);
};

TypeDefContext.prototype.typeParamClause = function() {
    return this.getTypedRuleContext(TypeParamClauseContext,0);
};

TypeDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTypeDef(this);
	}
};

TypeDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTypeDef(this);
	}
};




ScalaParser.TypeDefContext = TypeDefContext;

ScalaParser.prototype.typeDef = function() {

    var localctx = new TypeDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 162, ScalaParser.RULE_typeDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1290;
        this.match(ScalaParser.Id);
        this.state = 1292;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1291;
            this.typeParamClause();
        }

        this.state = 1294;
        this.match(ScalaParser.T__34);
        this.state = 1295;
        this.type();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TmplDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_tmplDef;
    return this;
}

TmplDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TmplDefContext.prototype.constructor = TmplDefContext;

TmplDefContext.prototype.classDef = function() {
    return this.getTypedRuleContext(ClassDefContext,0);
};

TmplDefContext.prototype.objectDef = function() {
    return this.getTypedRuleContext(ObjectDefContext,0);
};

TmplDefContext.prototype.traitDef = function() {
    return this.getTypedRuleContext(TraitDefContext,0);
};

TmplDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTmplDef(this);
	}
};

TmplDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTmplDef(this);
	}
};




ScalaParser.TmplDefContext = TmplDefContext;

ScalaParser.prototype.tmplDef = function() {

    var localctx = new TmplDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 164, ScalaParser.RULE_tmplDef);
    var _la = 0; // Token type
    try {
        this.state = 1307;
        var la_ = this._interp.adaptivePredict(this._input,177,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1298;
            _la = this._input.LA(1);
            if(_la===ScalaParser.T__41) {
                this.state = 1297;
                this.match(ScalaParser.T__41);
            }

            this.state = 1300;
            this.match(ScalaParser.T__56);
            this.state = 1301;
            this.classDef();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1302;
            this.match(ScalaParser.T__41);
            this.state = 1303;
            this.match(ScalaParser.T__57);
            this.state = 1304;
            this.objectDef();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1305;
            this.match(ScalaParser.T__58);
            this.state = 1306;
            this.traitDef();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classDef;
    return this;
}

ClassDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassDefContext.prototype.constructor = ClassDefContext;

ClassDefContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ClassDefContext.prototype.classParamClauses = function() {
    return this.getTypedRuleContext(ClassParamClausesContext,0);
};

ClassDefContext.prototype.classTemplateOpt = function() {
    return this.getTypedRuleContext(ClassTemplateOptContext,0);
};

ClassDefContext.prototype.typeParamClause = function() {
    return this.getTypedRuleContext(TypeParamClauseContext,0);
};

ClassDefContext.prototype.constrAnnotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ConstrAnnotationContext);
    } else {
        return this.getTypedRuleContext(ConstrAnnotationContext,i);
    }
};

ClassDefContext.prototype.accessModifier = function() {
    return this.getTypedRuleContext(AccessModifierContext,0);
};

ClassDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassDef(this);
	}
};

ClassDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassDef(this);
	}
};




ScalaParser.ClassDefContext = ClassDefContext;

ScalaParser.prototype.classDef = function() {

    var localctx = new ClassDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 166, ScalaParser.RULE_classDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1309;
        this.match(ScalaParser.Id);
        this.state = 1311;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1310;
            this.typeParamClause();
        }

        this.state = 1316;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__43) {
            this.state = 1313;
            this.constrAnnotation();
            this.state = 1318;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1320;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__52 || _la===ScalaParser.T__53) {
            this.state = 1319;
            this.accessModifier();
        }

        this.state = 1322;
        this.classParamClauses();
        this.state = 1323;
        this.classTemplateOpt();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TraitDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_traitDef;
    return this;
}

TraitDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TraitDefContext.prototype.constructor = TraitDefContext;

TraitDefContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

TraitDefContext.prototype.traitTemplateOpt = function() {
    return this.getTypedRuleContext(TraitTemplateOptContext,0);
};

TraitDefContext.prototype.typeParamClause = function() {
    return this.getTypedRuleContext(TypeParamClauseContext,0);
};

TraitDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTraitDef(this);
	}
};

TraitDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTraitDef(this);
	}
};




ScalaParser.TraitDefContext = TraitDefContext;

ScalaParser.prototype.traitDef = function() {

    var localctx = new TraitDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 168, ScalaParser.RULE_traitDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1325;
        this.match(ScalaParser.Id);
        this.state = 1327;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__6) {
            this.state = 1326;
            this.typeParamClause();
        }

        this.state = 1329;
        this.traitTemplateOpt();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ObjectDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_objectDef;
    return this;
}

ObjectDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ObjectDefContext.prototype.constructor = ObjectDefContext;

ObjectDefContext.prototype.Id = function() {
    return this.getToken(ScalaParser.Id, 0);
};

ObjectDefContext.prototype.classTemplateOpt = function() {
    return this.getTypedRuleContext(ClassTemplateOptContext,0);
};

ObjectDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterObjectDef(this);
	}
};

ObjectDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitObjectDef(this);
	}
};




ScalaParser.ObjectDefContext = ObjectDefContext;

ScalaParser.prototype.objectDef = function() {

    var localctx = new ObjectDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 170, ScalaParser.RULE_objectDef);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1331;
        this.match(ScalaParser.Id);
        this.state = 1332;
        this.classTemplateOpt();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassTemplateOptContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classTemplateOpt;
    return this;
}

ClassTemplateOptContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassTemplateOptContext.prototype.constructor = ClassTemplateOptContext;

ClassTemplateOptContext.prototype.classTemplate = function() {
    return this.getTypedRuleContext(ClassTemplateContext,0);
};

ClassTemplateOptContext.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

ClassTemplateOptContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassTemplateOpt(this);
	}
};

ClassTemplateOptContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassTemplateOpt(this);
	}
};




ScalaParser.ClassTemplateOptContext = ClassTemplateOptContext;

ScalaParser.prototype.classTemplateOpt = function() {

    var localctx = new ClassTemplateOptContext(this, this._ctx, this.state);
    this.enterRule(localctx, 172, ScalaParser.RULE_classTemplateOpt);
    var _la = 0; // Token type
    try {
        this.state = 1342;
        var la_ = this._interp.adaptivePredict(this._input,184,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1334;
            this.match(ScalaParser.T__59);
            this.state = 1335;
            this.classTemplate();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1340;
            var la_ = this._interp.adaptivePredict(this._input,183,this._ctx);
            if(la_===1) {
                this.state = 1337;
                _la = this._input.LA(1);
                if(_la===ScalaParser.T__59) {
                    this.state = 1336;
                    this.match(ScalaParser.T__59);
                }

                this.state = 1339;
                this.templateBody();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TraitTemplateOptContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_traitTemplateOpt;
    return this;
}

TraitTemplateOptContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TraitTemplateOptContext.prototype.constructor = TraitTemplateOptContext;

TraitTemplateOptContext.prototype.traitTemplate = function() {
    return this.getTypedRuleContext(TraitTemplateContext,0);
};

TraitTemplateOptContext.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

TraitTemplateOptContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTraitTemplateOpt(this);
	}
};

TraitTemplateOptContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTraitTemplateOpt(this);
	}
};




ScalaParser.TraitTemplateOptContext = TraitTemplateOptContext;

ScalaParser.prototype.traitTemplateOpt = function() {

    var localctx = new TraitTemplateOptContext(this, this._ctx, this.state);
    this.enterRule(localctx, 174, ScalaParser.RULE_traitTemplateOpt);
    var _la = 0; // Token type
    try {
        this.state = 1352;
        var la_ = this._interp.adaptivePredict(this._input,187,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1344;
            this.match(ScalaParser.T__59);
            this.state = 1345;
            this.traitTemplate();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1350;
            var la_ = this._interp.adaptivePredict(this._input,186,this._ctx);
            if(la_===1) {
                this.state = 1347;
                _la = this._input.LA(1);
                if(_la===ScalaParser.T__59) {
                    this.state = 1346;
                    this.match(ScalaParser.T__59);
                }

                this.state = 1349;
                this.templateBody();

            }
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassTemplateContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classTemplate;
    return this;
}

ClassTemplateContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassTemplateContext.prototype.constructor = ClassTemplateContext;

ClassTemplateContext.prototype.classParents = function() {
    return this.getTypedRuleContext(ClassParentsContext,0);
};

ClassTemplateContext.prototype.earlyDefs = function() {
    return this.getTypedRuleContext(EarlyDefsContext,0);
};

ClassTemplateContext.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

ClassTemplateContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassTemplate(this);
	}
};

ClassTemplateContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassTemplate(this);
	}
};




ScalaParser.ClassTemplateContext = ClassTemplateContext;

ScalaParser.prototype.classTemplate = function() {

    var localctx = new ClassTemplateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 176, ScalaParser.RULE_classTemplate);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1355;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__12) {
            this.state = 1354;
            this.earlyDefs();
        }

        this.state = 1357;
        this.classParents();
        this.state = 1359;
        var la_ = this._interp.adaptivePredict(this._input,189,this._ctx);
        if(la_===1) {
            this.state = 1358;
            this.templateBody();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TraitTemplateContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_traitTemplate;
    return this;
}

TraitTemplateContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TraitTemplateContext.prototype.constructor = TraitTemplateContext;

TraitTemplateContext.prototype.traitParents = function() {
    return this.getTypedRuleContext(TraitParentsContext,0);
};

TraitTemplateContext.prototype.earlyDefs = function() {
    return this.getTypedRuleContext(EarlyDefsContext,0);
};

TraitTemplateContext.prototype.templateBody = function() {
    return this.getTypedRuleContext(TemplateBodyContext,0);
};

TraitTemplateContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTraitTemplate(this);
	}
};

TraitTemplateContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTraitTemplate(this);
	}
};




ScalaParser.TraitTemplateContext = TraitTemplateContext;

ScalaParser.prototype.traitTemplate = function() {

    var localctx = new TraitTemplateContext(this, this._ctx, this.state);
    this.enterRule(localctx, 178, ScalaParser.RULE_traitTemplate);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1362;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__12) {
            this.state = 1361;
            this.earlyDefs();
        }

        this.state = 1364;
        this.traitParents();
        this.state = 1366;
        var la_ = this._interp.adaptivePredict(this._input,191,this._ctx);
        if(la_===1) {
            this.state = 1365;
            this.templateBody();

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ClassParentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_classParents;
    return this;
}

ClassParentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ClassParentsContext.prototype.constructor = ClassParentsContext;

ClassParentsContext.prototype.constr = function() {
    return this.getTypedRuleContext(ConstrContext,0);
};

ClassParentsContext.prototype.annotType = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotTypeContext);
    } else {
        return this.getTypedRuleContext(AnnotTypeContext,i);
    }
};

ClassParentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterClassParents(this);
	}
};

ClassParentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitClassParents(this);
	}
};




ScalaParser.ClassParentsContext = ClassParentsContext;

ScalaParser.prototype.classParents = function() {

    var localctx = new ClassParentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 180, ScalaParser.RULE_classParents);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1368;
        this.constr();
        this.state = 1373;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,192,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1369;
                this.match(ScalaParser.T__16);
                this.state = 1370;
                this.annotType(); 
            }
            this.state = 1375;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,192,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TraitParentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_traitParents;
    return this;
}

TraitParentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TraitParentsContext.prototype.constructor = TraitParentsContext;

TraitParentsContext.prototype.annotType = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotTypeContext);
    } else {
        return this.getTypedRuleContext(AnnotTypeContext,i);
    }
};

TraitParentsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTraitParents(this);
	}
};

TraitParentsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTraitParents(this);
	}
};




ScalaParser.TraitParentsContext = TraitParentsContext;

ScalaParser.prototype.traitParents = function() {

    var localctx = new TraitParentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 182, ScalaParser.RULE_traitParents);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1376;
        this.annotType();
        this.state = 1381;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__16) {
            this.state = 1377;
            this.match(ScalaParser.T__16);
            this.state = 1378;
            this.annotType();
            this.state = 1383;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstrContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_constr;
    return this;
}

ConstrContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstrContext.prototype.constructor = ConstrContext;

ConstrContext.prototype.annotType = function() {
    return this.getTypedRuleContext(AnnotTypeContext,0);
};

ConstrContext.prototype.argumentExprs = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ArgumentExprsContext);
    } else {
        return this.getTypedRuleContext(ArgumentExprsContext,i);
    }
};

ConstrContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterConstr(this);
	}
};

ConstrContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitConstr(this);
	}
};




ScalaParser.ConstrContext = ConstrContext;

ScalaParser.prototype.constr = function() {

    var localctx = new ConstrContext(this, this._ctx, this.state);
    this.enterRule(localctx, 184, ScalaParser.RULE_constr);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1384;
        this.annotType();
        this.state = 1388;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,194,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1385;
                this.argumentExprs(); 
            }
            this.state = 1390;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,194,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EarlyDefsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_earlyDefs;
    return this;
}

EarlyDefsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EarlyDefsContext.prototype.constructor = EarlyDefsContext;

EarlyDefsContext.prototype.earlyDef = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(EarlyDefContext);
    } else {
        return this.getTypedRuleContext(EarlyDefContext,i);
    }
};

EarlyDefsContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


EarlyDefsContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterEarlyDefs(this);
	}
};

EarlyDefsContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitEarlyDefs(this);
	}
};




ScalaParser.EarlyDefsContext = EarlyDefsContext;

ScalaParser.prototype.earlyDefs = function() {

    var localctx = new EarlyDefsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 186, ScalaParser.RULE_earlyDefs);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1391;
        this.match(ScalaParser.T__12);
        this.state = 1400;
        _la = this._input.LA(1);
        if(_la===ScalaParser.T__15 || _la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__43 - 40)) | (1 << (ScalaParser.T__47 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
            this.state = 1392;
            this.earlyDef();
            this.state = 1397;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.Semi) {
                this.state = 1393;
                this.match(ScalaParser.Semi);
                this.state = 1394;
                this.earlyDef();
                this.state = 1399;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
        }

        this.state = 1402;
        this.match(ScalaParser.T__13);
        this.state = 1403;
        this.match(ScalaParser.T__16);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function EarlyDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_earlyDef;
    return this;
}

EarlyDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EarlyDefContext.prototype.constructor = EarlyDefContext;

EarlyDefContext.prototype.patVarDef = function() {
    return this.getTypedRuleContext(PatVarDefContext,0);
};

EarlyDefContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

EarlyDefContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

EarlyDefContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


EarlyDefContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterEarlyDef(this);
	}
};

EarlyDefContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitEarlyDef(this);
	}
};




ScalaParser.EarlyDefContext = EarlyDefContext;

ScalaParser.prototype.earlyDef = function() {

    var localctx = new EarlyDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 188, ScalaParser.RULE_earlyDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1411;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__43) {
            this.state = 1405;
            this.annotation();
            this.state = 1407;
            _la = this._input.LA(1);
            if(_la===ScalaParser.Nl) {
                this.state = 1406;
                this.match(ScalaParser.Nl);
            }

            this.state = 1413;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1417;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
            this.state = 1414;
            this.modifier();
            this.state = 1419;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1420;
        this.patVarDef();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstrExprContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_constrExpr;
    return this;
}

ConstrExprContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstrExprContext.prototype.constructor = ConstrExprContext;

ConstrExprContext.prototype.selfInvocation = function() {
    return this.getTypedRuleContext(SelfInvocationContext,0);
};

ConstrExprContext.prototype.constrBlock = function() {
    return this.getTypedRuleContext(ConstrBlockContext,0);
};

ConstrExprContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterConstrExpr(this);
	}
};

ConstrExprContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitConstrExpr(this);
	}
};




ScalaParser.ConstrExprContext = ConstrExprContext;

ScalaParser.prototype.constrExpr = function() {

    var localctx = new ConstrExprContext(this, this._ctx, this.state);
    this.enterRule(localctx, 190, ScalaParser.RULE_constrExpr);
    try {
        this.state = 1424;
        switch(this._input.LA(1)) {
        case ScalaParser.T__4:
            this.enterOuterAlt(localctx, 1);
            this.state = 1422;
            this.selfInvocation();
            break;
        case ScalaParser.T__12:
            this.enterOuterAlt(localctx, 2);
            this.state = 1423;
            this.constrBlock();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function ConstrBlockContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_constrBlock;
    return this;
}

ConstrBlockContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstrBlockContext.prototype.constructor = ConstrBlockContext;

ConstrBlockContext.prototype.selfInvocation = function() {
    return this.getTypedRuleContext(SelfInvocationContext,0);
};

ConstrBlockContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


ConstrBlockContext.prototype.blockStat = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BlockStatContext);
    } else {
        return this.getTypedRuleContext(BlockStatContext,i);
    }
};

ConstrBlockContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterConstrBlock(this);
	}
};

ConstrBlockContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitConstrBlock(this);
	}
};




ScalaParser.ConstrBlockContext = ConstrBlockContext;

ScalaParser.prototype.constrBlock = function() {

    var localctx = new ConstrBlockContext(this, this._ctx, this.state);
    this.enterRule(localctx, 192, ScalaParser.RULE_constrBlock);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1426;
        this.match(ScalaParser.T__12);
        this.state = 1427;
        this.selfInvocation();
        this.state = 1432;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 1428;
            this.match(ScalaParser.Semi);
            this.state = 1429;
            this.blockStat();
            this.state = 1434;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 1435;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function SelfInvocationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_selfInvocation;
    return this;
}

SelfInvocationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SelfInvocationContext.prototype.constructor = SelfInvocationContext;

SelfInvocationContext.prototype.argumentExprs = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ArgumentExprsContext);
    } else {
        return this.getTypedRuleContext(ArgumentExprsContext,i);
    }
};

SelfInvocationContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterSelfInvocation(this);
	}
};

SelfInvocationContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitSelfInvocation(this);
	}
};




ScalaParser.SelfInvocationContext = SelfInvocationContext;

ScalaParser.prototype.selfInvocation = function() {

    var localctx = new SelfInvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 194, ScalaParser.RULE_selfInvocation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1437;
        this.match(ScalaParser.T__4);
        this.state = 1439; 
        this._errHandler.sync(this);
        var _alt = 1;
        do {
        	switch (_alt) {
        	case 1:
        		this.state = 1438;
        		this.argumentExprs();
        		break;
        	default:
        		throw new antlr4.error.NoViableAltException(this);
        	}
        	this.state = 1441; 
        	this._errHandler.sync(this);
        	_alt = this._interp.adaptivePredict(this._input,202, this._ctx);
        } while ( _alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER );
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TopStatSeqContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_topStatSeq;
    return this;
}

TopStatSeqContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TopStatSeqContext.prototype.constructor = TopStatSeqContext;

TopStatSeqContext.prototype.topStat = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(TopStatContext);
    } else {
        return this.getTypedRuleContext(TopStatContext,i);
    }
};

TopStatSeqContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


TopStatSeqContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTopStatSeq(this);
	}
};

TopStatSeqContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTopStatSeq(this);
	}
};




ScalaParser.TopStatSeqContext = TopStatSeqContext;

ScalaParser.prototype.topStatSeq = function() {

    var localctx = new TopStatSeqContext(this, this._ctx, this.state);
    this.enterRule(localctx, 196, ScalaParser.RULE_topStatSeq);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1443;
        this.topStat();
        this.state = 1448;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===ScalaParser.Semi) {
            this.state = 1444;
            this.match(ScalaParser.Semi);
            this.state = 1445;
            this.topStat();
            this.state = 1450;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function TopStatContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_topStat;
    return this;
}

TopStatContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
TopStatContext.prototype.constructor = TopStatContext;

TopStatContext.prototype.tmplDef = function() {
    return this.getTypedRuleContext(TmplDefContext,0);
};

TopStatContext.prototype.annotation = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(AnnotationContext);
    } else {
        return this.getTypedRuleContext(AnnotationContext,i);
    }
};

TopStatContext.prototype.modifier = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ModifierContext);
    } else {
        return this.getTypedRuleContext(ModifierContext,i);
    }
};

TopStatContext.prototype.Nl = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Nl);
    } else {
        return this.getToken(ScalaParser.Nl, i);
    }
};


TopStatContext.prototype.import_ = function() {
    return this.getTypedRuleContext(Import_Context,0);
};

TopStatContext.prototype.packaging = function() {
    return this.getTypedRuleContext(PackagingContext,0);
};

TopStatContext.prototype.packageObject = function() {
    return this.getTypedRuleContext(PackageObjectContext,0);
};

TopStatContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterTopStat(this);
	}
};

TopStatContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitTopStat(this);
	}
};




ScalaParser.TopStatContext = TopStatContext;

ScalaParser.prototype.topStat = function() {

    var localctx = new TopStatContext(this, this._ctx, this.state);
    this.enterRule(localctx, 198, ScalaParser.RULE_topStat);
    var _la = 0; // Token type
    try {
        this.state = 1471;
        var la_ = this._interp.adaptivePredict(this._input,207,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 1457;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__43) {
                this.state = 1451;
                this.annotation();
                this.state = 1453;
                _la = this._input.LA(1);
                if(_la===ScalaParser.Nl) {
                    this.state = 1452;
                    this.match(ScalaParser.Nl);
                }

                this.state = 1459;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1463;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===ScalaParser.T__21 || ((((_la - 40)) & ~0x1f) == 0 && ((1 << (_la - 40)) & ((1 << (ScalaParser.T__39 - 40)) | (1 << (ScalaParser.T__48 - 40)) | (1 << (ScalaParser.T__49 - 40)) | (1 << (ScalaParser.T__50 - 40)) | (1 << (ScalaParser.T__51 - 40)) | (1 << (ScalaParser.T__52 - 40)) | (1 << (ScalaParser.T__53 - 40)))) !== 0)) {
                this.state = 1460;
                this.modifier();
                this.state = 1465;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            this.state = 1466;
            this.tmplDef();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 1467;
            this.import_();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 1468;
            this.packaging();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 1469;
            this.packageObject();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);

            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PackagingContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_packaging;
    return this;
}

PackagingContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PackagingContext.prototype.constructor = PackagingContext;

PackagingContext.prototype.qualId = function() {
    return this.getTypedRuleContext(QualIdContext,0);
};

PackagingContext.prototype.topStatSeq = function() {
    return this.getTypedRuleContext(TopStatSeqContext,0);
};

PackagingContext.prototype.Nl = function() {
    return this.getToken(ScalaParser.Nl, 0);
};

PackagingContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPackaging(this);
	}
};

PackagingContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPackaging(this);
	}
};




ScalaParser.PackagingContext = PackagingContext;

ScalaParser.prototype.packaging = function() {

    var localctx = new PackagingContext(this, this._ctx, this.state);
    this.enterRule(localctx, 200, ScalaParser.RULE_packaging);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1473;
        this.match(ScalaParser.T__60);
        this.state = 1474;
        this.qualId();
        this.state = 1476;
        _la = this._input.LA(1);
        if(_la===ScalaParser.Nl) {
            this.state = 1475;
            this.match(ScalaParser.Nl);
        }

        this.state = 1478;
        this.match(ScalaParser.T__12);
        this.state = 1479;
        this.topStatSeq();
        this.state = 1480;
        this.match(ScalaParser.T__13);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function PackageObjectContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_packageObject;
    return this;
}

PackageObjectContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
PackageObjectContext.prototype.constructor = PackageObjectContext;

PackageObjectContext.prototype.objectDef = function() {
    return this.getTypedRuleContext(ObjectDefContext,0);
};

PackageObjectContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterPackageObject(this);
	}
};

PackageObjectContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitPackageObject(this);
	}
};




ScalaParser.PackageObjectContext = PackageObjectContext;

ScalaParser.prototype.packageObject = function() {

    var localctx = new PackageObjectContext(this, this._ctx, this.state);
    this.enterRule(localctx, 202, ScalaParser.RULE_packageObject);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1482;
        this.match(ScalaParser.T__60);
        this.state = 1483;
        this.match(ScalaParser.T__57);
        this.state = 1484;
        this.objectDef();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};

function CompilationUnitContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = ScalaParser.RULE_compilationUnit;
    return this;
}

CompilationUnitContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
CompilationUnitContext.prototype.constructor = CompilationUnitContext;

CompilationUnitContext.prototype.topStatSeq = function() {
    return this.getTypedRuleContext(TopStatSeqContext,0);
};

CompilationUnitContext.prototype.qualId = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(QualIdContext);
    } else {
        return this.getTypedRuleContext(QualIdContext,i);
    }
};

CompilationUnitContext.prototype.Semi = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(ScalaParser.Semi);
    } else {
        return this.getToken(ScalaParser.Semi, i);
    }
};


CompilationUnitContext.prototype.enterRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.enterCompilationUnit(this);
	}
};

CompilationUnitContext.prototype.exitRule = function(listener) {
    if(listener instanceof ScalaListener ) {
        listener.exitCompilationUnit(this);
	}
};




ScalaParser.CompilationUnitContext = CompilationUnitContext;

ScalaParser.prototype.compilationUnit = function() {

    var localctx = new CompilationUnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 204, ScalaParser.RULE_compilationUnit);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 1492;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,209,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 1486;
                this.match(ScalaParser.T__60);
                this.state = 1487;
                this.qualId();
                this.state = 1488;
                this.match(ScalaParser.Semi); 
            }
            this.state = 1494;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,209,this._ctx);
        }

        this.state = 1495;
        this.topStatSeq();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


ScalaParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 12:
			return this.simpleType_sempred(localctx, predIndex);
	case 22:
			return this.infixExpr_sempred(localctx, predIndex);
	case 24:
			return this.simpleExpr1_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

ScalaParser.prototype.simpleType_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 5);
		case 1:
			return this.precpred(this._ctx, 4);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ScalaParser.prototype.infixExpr_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 2:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

ScalaParser.prototype.simpleExpr1_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 3:
			return this.precpred(this._ctx, 1);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.ScalaParser = ScalaParser;

},{"./ScalaListener":11,"antlr4/index":54}],13:[function(require,module,exports){
module.exports = {
  antlr4: require('antlr4'),
  JavaLexer: require('./JavaLexer'),
  JavaParser: require('./JavaParser'),
  CLexer: require('./CLexer'),
  CParser: require('./CParser'),
  ObjCLexer: require('./ObjCLexer'),
  ObjCParser: require('./ObjCParser'),
  ScalaLexer: require('./ScalaLexer'),
  ScalaParser: require('./ScalaParser')
}

},{"./CLexer":1,"./CParser":3,"./JavaLexer":4,"./JavaParser":6,"./ObjCLexer":7,"./ObjCParser":9,"./ScalaLexer":10,"./ScalaParser":12,"antlr4":54}],14:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This implementation of {@link TokenStream} loads tokens from a
// {@link TokenSource} on-demand, and places the tokens in a buffer to provide
// access to any previous token by index.
//
// <p>
// This token stream ignores the value of {@link Token//getChannel}. If your
// parser requires the token stream filter tokens to only those on a particular
// channel, such as {@link Token//DEFAULT_CHANNEL} or
// {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
// {@link CommonTokenStream}.</p>

var Token = require('./Token').Token;
var Lexer = require('./Lexer').Lexer;
var Interval = require('./IntervalSet').Interval;

// this is just to keep meaningful parameter types to Parser
function TokenStream() {
	return this;
}

function BufferedTokenStream(tokenSource) {

	TokenStream.call(this);
	// The {@link TokenSource} from which tokens for this stream are fetched.
	this.tokenSource = tokenSource;

	// A collection of all tokens fetched from the token source. The list is
	// considered a complete view of the input once {@link //fetchedEOF} is set
	// to {@code true}.
	this.tokens = [];

	// The index into {@link //tokens} of the current token (next token to
	// {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
	// be
	// {@link //LT LT(1)}.
	//
	// <p>This field is set to -1 when the stream is first constructed or when
	// {@link //setTokenSource} is called, indicating that the first token has
	// not yet been fetched from the token source. For additional information,
	// see the documentation of {@link IntStream} for a description of
	// Initializing Methods.</p>
	this.index = -1;

	// Indicates whether the {@link Token//EOF} token has been fetched from
	// {@link //tokenSource} and added to {@link //tokens}. This field improves
	// performance for the following cases:
	//
	// <ul>
	// <li>{@link //consume}: The lookahead check in {@link //consume} to
	// prevent
	// consuming the EOF symbol is optimized by checking the values of
	// {@link //fetchedEOF} and {@link //p} instead of calling {@link
	// //LA}.</li>
	// <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
	// into
	// {@link //tokens} is trivial with this field.</li>
	// <ul>
	this.fetchedEOF = false;
	return this;
}

BufferedTokenStream.prototype = Object.create(TokenStream.prototype);
BufferedTokenStream.prototype.constructor = BufferedTokenStream;

BufferedTokenStream.prototype.mark = function() {
	return 0;
};

BufferedTokenStream.prototype.release = function(marker) {
	// no resources to release
};

BufferedTokenStream.prototype.reset = function() {
	this.seek(0);
};

BufferedTokenStream.prototype.seek = function(index) {
	this.lazyInit();
	this.index = this.adjustSeekIndex(index);
};

BufferedTokenStream.prototype.get = function(index) {
	this.lazyInit();
	return this.tokens[index];
};

BufferedTokenStream.prototype.consume = function() {
	var skipEofCheck = false;
	if (this.index >= 0) {
		if (this.fetchedEOF) {
			// the last token in tokens is EOF. skip check if p indexes any
			// fetched token except the last.
			skipEofCheck = this.index < this.tokens.length - 1;
		} else {
			// no EOF token in tokens. skip check if p indexes a fetched token.
			skipEofCheck = this.index < this.tokens.length;
		}
	} else {
		// not yet initialized
		skipEofCheck = false;
	}
	if (!skipEofCheck && this.LA(1) === Token.EOF) {
		throw "cannot consume EOF";
	}
	if (this.sync(this.index + 1)) {
		this.index = this.adjustSeekIndex(this.index + 1);
	}
};

// Make sure index {@code i} in tokens has a token.
//
// @return {@code true} if a token is located at index {@code i}, otherwise
// {@code false}.
// @see //get(int i)
// /
BufferedTokenStream.prototype.sync = function(i) {
	var n = i - this.tokens.length + 1; // how many more elements we need?
	if (n > 0) {
		var fetched = this.fetch(n);
		return fetched >= n;
	}
	return true;
};

// Add {@code n} elements to buffer.
//
// @return The actual number of elements added to the buffer.
// /
BufferedTokenStream.prototype.fetch = function(n) {
	if (this.fetchedEOF) {
		return 0;
	}
	for (var i = 0; i < n; i++) {
		var t = this.tokenSource.nextToken();
		t.tokenIndex = this.tokens.length;
		this.tokens.push(t);
		if (t.type === Token.EOF) {
			this.fetchedEOF = true;
			return i + 1;
		}
	}
	return n;
};

// Get all tokens from start..stop inclusively///
BufferedTokenStream.prototype.getTokens = function(start, stop, types) {
	if (types === undefined) {
		types = null;
	}
	if (start < 0 || stop < 0) {
		return null;
	}
	this.lazyInit();
	var subset = [];
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	for (var i = start; i < stop; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		if (types === null || types.contains(t.type)) {
			subset.push(t);
		}
	}
	return subset;
};

BufferedTokenStream.prototype.LA = function(i) {
	return this.LT(i).type;
};

BufferedTokenStream.prototype.LB = function(k) {
	if (this.index - k < 0) {
		return null;
	}
	return this.tokens[this.index - k];
};

BufferedTokenStream.prototype.LT = function(k) {
	this.lazyInit();
	if (k === 0) {
		return null;
	}
	if (k < 0) {
		return this.LB(-k);
	}
	var i = this.index + k - 1;
	this.sync(i);
	if (i >= this.tokens.length) { // return EOF token
		// EOF must be last token
		return this.tokens[this.tokens.length - 1];
	}
	return this.tokens[i];
};

// Allowed derived classes to modify the behavior of operations which change
// the current stream position by adjusting the target token index of a seek
// operation. The default implementation simply returns {@code i}. If an
// exception is thrown in this method, the current stream index should not be
// changed.
//
// <p>For example, {@link CommonTokenStream} overrides this method to ensure
// that
// the seek target is always an on-channel token.</p>
//
// @param i The target token index.
// @return The adjusted target token index.

BufferedTokenStream.prototype.adjustSeekIndex = function(i) {
	return i;
};

BufferedTokenStream.prototype.lazyInit = function() {
	if (this.index === -1) {
		this.setup();
	}
};

BufferedTokenStream.prototype.setup = function() {
	this.sync(0);
	this.index = this.adjustSeekIndex(0);
};

// Reset this token stream by setting its token source.///
BufferedTokenStream.prototype.setTokenSource = function(tokenSource) {
	this.tokenSource = tokenSource;
	this.tokens = [];
	this.index = -1;
};

// Given a starting index, return the index of the next token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and EOF.
// /
BufferedTokenStream.prototype.nextTokenOnChannel = function(i, channel) {
	this.sync(i);
	if (i >= this.tokens.length) {
		return -1;
	}
	var token = this.tokens[i];
	while (token.channel !== this.channel) {
		if (token.type === Token.EOF) {
			return -1;
		}
		i += 1;
		this.sync(i);
		token = this.tokens[i];
	}
	return i;
};

// Given a starting index, return the index of the previous token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and 0.
BufferedTokenStream.prototype.previousTokenOnChannel = function(i, channel) {
	while (i >= 0 && this.tokens[i].channel !== channel) {
		i -= 1;
	}
	return i;
};

// Collect all tokens on specified channel to the right of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
// EOF. If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToRight = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (this.tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1,
			Lexer.DEFAULT_TOKEN_CHANNEL);
	var from_ = tokenIndex + 1;
	// if none onchannel to right, nextOnChannel=-1 so set to = last token
	var to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
	return this.filterForChannel(from_, to, channel);
};

// Collect all tokens on specified channel to the left of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
// If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToLeft = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1,
			Lexer.DEFAULT_TOKEN_CHANNEL);
	if (prevOnChannel === tokenIndex - 1) {
		return null;
	}
	// if none on channel to left, prevOnChannel=-1 then from=0
	var from_ = prevOnChannel + 1;
	var to = tokenIndex - 1;
	return this.filterForChannel(from_, to, channel);
};

BufferedTokenStream.prototype.filterForChannel = function(left, right, channel) {
	var hidden = [];
	for (var i = left; i < right + 1; i++) {
		var t = this.tokens[i];
		if (channel === -1) {
			if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
				hidden.push(t);
			}
		} else if (t.channel === channel) {
			hidden.push(t);
		}
	}
	if (hidden.length === 0) {
		return null;
	}
	return hidden;
};

BufferedTokenStream.prototype.getSourceName = function() {
	return this.tokenSource.getSourceName();
};

// Get the text of all tokens in this buffer.///
BufferedTokenStream.prototype.getText = function(interval) {
	this.lazyInit();
	this.fill();
	if (interval === undefined || interval === null) {
		interval = new Interval(0, this.tokens.length - 1);
	}
	var start = interval.start;
	if (start instanceof Token) {
		start = start.tokenIndex;
	}
	var stop = interval.stop;
	if (stop instanceof Token) {
		stop = stop.tokenIndex;
	}
	if (start === null || stop === null || start < 0 || stop < 0) {
		return "";
	}
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	var s = "";
	for (var i = start; i < stop + 1; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		s = s + t.text;
	}
	return s;
};

// Get all tokens from lexer until EOF///
BufferedTokenStream.prototype.fill = function() {
	this.lazyInit();
	while (this.fetch(1000) === 1000) {
		continue;
	}
};

exports.BufferedTokenStream = BufferedTokenStream;

},{"./IntervalSet":19,"./Lexer":21,"./Token":27}],15:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

//
// This default implementation of {@link TokenFactory} creates
// {@link CommonToken} objects.
//

var CommonToken = require('./Token').CommonToken;

function TokenFactory() {
	return this;
}

function CommonTokenFactory(copyText) {
	TokenFactory.call(this);
    // Indicates whether {@link CommonToken//setText} should be called after
    // constructing tokens to explicitly set the text. This is useful for cases
    // where the input stream might not be able to provide arbitrary substrings
    // of text from the input after the lexer creates a token (e.g. the
    // implementation of {@link CharStream//getText} in
    // {@link UnbufferedCharStream} throws an
    // {@link UnsupportedOperationException}). Explicitly setting the token text
    // allows {@link Token//getText} to be called at any time regardless of the
    // input stream implementation.
    //
    // <p>
    // The default value is {@code false} to avoid the performance and memory
    // overhead of copying text for every token unless explicitly requested.</p>
    //
    this.copyText = copyText===undefined ? false : copyText;
	return this;
}

CommonTokenFactory.prototype = Object.create(TokenFactory.prototype);
CommonTokenFactory.prototype.constructor = CommonTokenFactory;

//
// The default {@link CommonTokenFactory} instance.
//
// <p>
// This token factory does not explicitly copy token text when constructing
// tokens.</p>
//
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

CommonTokenFactory.prototype.create = function(source, type, text, channel, start, stop, line, column) {
    var t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !==null) {
        t.text = text;
    } else if (this.copyText && source[1] !==null) {
        t.text = source[1].getText(start,stop);
    }
    return t;
};

CommonTokenFactory.prototype.createThin = function(type, text) {
    var t = new CommonToken(null, type);
    t.text = text;
    return t;
};

exports.CommonTokenFactory = CommonTokenFactory;

},{"./Token":27}],16:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

//
// This class extends {@link BufferedTokenStream} with functionality to filter
// token streams to tokens on a particular channel (tokens where
// {@link Token//getChannel} returns a particular value).
//
// <p>
// This token stream provides access to all tokens by index or when calling
// methods like {@link //getText}. The channel filtering is only used for code
// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
// {@link //LB}.</p>
//
// <p>
// By default, tokens are placed on the default channel
// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
// call {@link Lexer//setChannel}.
// </p>
//
// <p>
// Note: lexer rules which use the {@code ->skip} lexer command or call
// {@link Lexer//skip} do not produce tokens at all, so input text matched by
// such a rule will not be available as part of the token stream, regardless of
// channel.</p>
///

var Token = require('./Token').Token;
var BufferedTokenStream = require('./BufferedTokenStream').BufferedTokenStream;

function CommonTokenStream(lexer, channel) {
	BufferedTokenStream.call(this, lexer);
    this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;
    return this;
}

CommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);
CommonTokenStream.prototype.constructor = CommonTokenStream;

CommonTokenStream.prototype.adjustSeekIndex = function(i) {
    return this.nextTokenOnChannel(i, this.channel);
};

CommonTokenStream.prototype.LB = function(k) {
    if (k===0 || this.index-k<0) {
        return null;
    }
    var i = this.index;
    var n = 1;
    // find k good tokens looking backwards
    while (n <= k) {
        // skip off-channel tokens
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n += 1;
    }
    if (i < 0) {
        return null;
    }
    return this.tokens[i];
};

CommonTokenStream.prototype.LT = function(k) {
    this.lazyInit();
    if (k === 0) {
        return null;
    }
    if (k < 0) {
        return this.LB(-k);
    }
    var i = this.index;
    var n = 1; // we know tokens[pos] is a good one
    // find k good tokens
    while (n < k) {
        // skip off-channel tokens, but make sure to not look past EOF
        if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n += 1;
    }
    return this.tokens[i];
};

// Count EOF just once.///
CommonTokenStream.prototype.getNumberOfOnChannelTokens = function() {
    var n = 0;
    this.fill();
    for (var i =0; i< this.tokens.length;i++) {
        var t = this.tokens[i];
        if( t.channel===this.channel) {
            n += 1;
        }
        if( t.type===Token.EOF) {
            break;
        }
    }
    return n;
};

exports.CommonTokenStream = CommonTokenStream;
},{"./BufferedTokenStream":14,"./Token":27}],17:[function(require,module,exports){
//
//  [The "BSD license"]
//   Copyright (c) 2012 Terence Parr
//   Copyright (c) 2012 Sam Harwell
//   Copyright (c) 2014 Eric Vergnaud
//   All rights reserved.
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//   3. The name of the author may not be used to endorse or promote products
//      derived from this software without specific prior written permission.
// 
//   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

//
//  This is an InputStream that is loaded from a file all at once
//  when you construct the object.
// 
var InputStream = require('./InputStream').InputStream;
try {
	var fs = require("fs");
} catch(ex) {
	// probably running from browser, no "Node.js/fs" makes sense 
}
	
function FileStream(fileName) {
	var data = fs.readFileSync(fileName, "utf8");
	InputStream.call(this, data);
	this.fileName = fileName;
	return this;
}

FileStream.prototype = Object.create(InputStream.prototype);
FileStream.prototype.constructor = FileStream;

exports.FileStream = FileStream;

},{"./InputStream":18,"fs":58}],18:[function(require,module,exports){
// 
//  [The "BSD license"]
//   Copyright (c) 2012 Terence Parr
//   Copyright (c) 2012 Sam Harwell
//   Copyright (c) 2014 Eric Vergnaud
//   All rights reserved.
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//   3. The name of the author may not be used to endorse or promote products
//      derived from this software without specific prior written permission.
// 
//   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

var Token = require('./Token').Token;

// Vacuum all input from a string and then treat it like a buffer.

function _loadString(stream) {
	stream._index = 0;
	stream.data = [];
	for (var i = 0; i < stream.strdata.length; i++) {
		stream.data.push(stream.strdata.charCodeAt(i));
	}
	stream._size = stream.data.length;
}

function InputStream(data) {
	this.name = "<empty>";
	this.strdata = data;
	_loadString(this);
	return this;
}

Object.defineProperty(InputStream.prototype, "index", {
	get : function() {
		return this._index;
	}
});

Object.defineProperty(InputStream.prototype, "size", {
	get : function() {
		return this._size;
	}
});

// Reset the stream so that it's in the same state it was
// when the object was created *except* the data array is not
// touched.
//
InputStream.prototype.reset = function() {
	this._index = 0;
};

InputStream.prototype.consume = function() {
	if (this._index >= this._size) {
		// assert this.LA(1) == Token.EOF
		throw ("cannot consume EOF");
	}
	this._index += 1;
};

InputStream.prototype.LA = function(offset) {
	if (offset === 0) {
		return 0; // undefined
	}
	if (offset < 0) {
		offset += 1; // e.g., translate LA(-1) to use offset=0
	}
	var pos = this._index + offset - 1;
	if (pos < 0 || pos >= this._size) { // invalid
		return Token.EOF;
	}
	return this.data[pos];
};

InputStream.prototype.LT = function(offset) {
	return this.LA(offset);
};

// mark/release do nothing; we have entire buffer
InputStream.prototype.mark = function() {
	return -1;
};

InputStream.prototype.release = function(marker) {
};

// consume() ahead until p==_index; can't just set p=_index as we must
// update line and column. If we seek backwards, just set p
//
InputStream.prototype.seek = function(_index) {
	if (_index <= this._index) {
		this._index = _index; // just jump; don't update stream state (line,
								// ...)
		return;
	}
	// seek forward
	this._index = Math.min(_index, this._size);
};

InputStream.prototype.getText = function(start, stop) {
	if (stop >= this._size) {
		stop = this._size - 1;
	}
	if (start >= this._size) {
		return "";
	} else {
		return this.strdata.slice(start, stop + 1);
	}
};

InputStream.prototype.toString = function() {
	return this.strdata;
};

exports.InputStream = InputStream;

},{"./Token":27}],19:[function(require,module,exports){
/*jslint smarttabs:true */

var Token = require('./Token').Token;

/* stop is not included! */
function Interval(start, stop) {
	this.start = start;
	this.stop = stop;
	return this;
}

Interval.prototype.contains = function(item) {
	return item >= this.start && item < this.stop;
};

Interval.prototype.toString = function() {
	if(this.start===this.stop-1) {
		return this.start.toString();
	} else {
		return this.start.toString() + ".." + (this.stop-1).toString();
	}
};


Object.defineProperty(Interval.prototype, "length", {
	get : function() {
		return this.stop - this.start;
	}
});

function IntervalSet() {
	this.intervals = null;
	this.readOnly = false;
}

IntervalSet.prototype.first = function(v) {
	if (this.intervals === null || this.intervals.length===0) {
		return Token.INVALID_TYPE;
	} else {
		return this.intervals[0].start;
	}
};

IntervalSet.prototype.addOne = function(v) {
	this.addInterval(new Interval(v, v + 1));
};

IntervalSet.prototype.addRange = function(l, h) {
	this.addInterval(new Interval(l, h + 1));
};

IntervalSet.prototype.addInterval = function(v) {
	if (this.intervals === null) {
		this.intervals = [];
		this.intervals.push(v);
	} else {
		// find insert pos
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// distinct range -> insert
			if (v.stop < i.start) {
				this.intervals.splice(k, 0, v);
				return;
			}
			// contiguous range -> adjust
			else if (v.stop === i.start) {
				this.intervals[k].start = v.start;
				return;
			}
			// overlapping range -> adjust and reduce
			else if (v.start <= i.stop) {
				this.intervals[k] = new Interval(Math.min(i.start, v.start), Math.max(i.stop, v.stop));
				this.reduce(k);
				return;
			}
		}
		// greater than any existing
		this.intervals.push(v);
	}
};

IntervalSet.prototype.addSet = function(other) {
	if (other.intervals !== null) {
		for (var k = 0; k < other.intervals.length; k++) {
			var i = other.intervals[k];
			this.addInterval(new Interval(i.start, i.stop));
		}
	}
	return this;
};

IntervalSet.prototype.reduce = function(k) {
	// only need to reduce if k is not the last
	if (k < this.intervalslength - 1) {
		var l = this.intervals[k];
		var r = this.intervals[k + 1];
		// if r contained in l
		if (l.stop >= r.stop) {
			this.intervals.pop(k + 1);
			this.reduce(k);
		} else if (l.stop >= r.start) {
			this.intervals[k] = new Interval(l.start, r.stop);
			this.intervals.pop(k + 1);
		}
	}
};

IntervalSet.prototype.complement = function(start, stop) {
    var result = new IntervalSet();
    result.addInterval(new Interval(start,stop+1));
    for(var i=0; i<this.intervals.length; i++) {
        result.removeRange(this.intervals[i]);
    }
    return result;
};

IntervalSet.prototype.contains = function(item) {
	if (this.intervals === null) {
		return false;
	} else {
		for (var k = 0; k < this.intervals.length; k++) {
			if(this.intervals[k].contains(item)) {
				return true;
			}
		}
		return false;
	}
};

Object.defineProperty(IntervalSet.prototype, "length", {
	get : function() {
		var len = 0;
		this.intervals.map(function(i) {len += i.length;});
		return len;
	}
});

IntervalSet.prototype.removeRange = function(v) {
    if(v.start===v.stop-1) {
        this.removeOne(v.start);
    } else if (this.intervals!==null) {
        var k = 0;
        for(var n=0; n<this.intervals.length; n++) {
            var i = this.intervals[k];
            // intervals are ordered
            if (v.stop<=i.start) {
                return;
            }
            // check for including range, split it
            else if(v.start>i.start && v.stop<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
                var x = new Interval(v.stop, i.stop);
                this.intervals.splice(k, 0, x);
                return;
            }
            // check for included range, remove it
            else if(v.start<=i.start && v.stop>=i.stop) {
                this.intervals.splice(k, 1);
                k = k - 1; // need another pass
            }
            // check for lower boundary
            else if(v.start<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
            }
            // check for upper boundary
            else if(v.stop<i.stop) {
                this.intervals[k] = new Interval(v.stop, i.stop);
            }
            k += 1;
        }
    }
};

IntervalSet.prototype.removeOne = function(v) {
	if (this.intervals !== null) {
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// intervals is ordered
			if (v < i.start) {
				return;
			}
			// check for single value range
			else if (v === i.start && v === i.stop - 1) {
				this.intervals.splice(k, 1);
				return;
			}
			// check for lower boundary
			else if (v === i.start) {
				this.intervals[k] = new Interval(i.start + 1, i.stop);
				return;
			}
			// check for upper boundary
			else if (v === i.stop - 1) {
				this.intervals[k] = new Interval(i.start, i.stop - 1);
				return;
			}
			// split existing range
			else if (v < i.stop - 1) {
				var x = new Interval(i.start, v);
				i.start = v + 1;
				this.intervals.splice(k, 0, x);
				return;
			}
		}
	}
};

IntervalSet.prototype.toString = function(literalNames, symbolicNames, elemsAreChar) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	elemsAreChar = elemsAreChar || false;
	if (this.intervals === null) {
		return "{}";
	} else if(literalNames!==null || symbolicNames!==null) {
		return this.toTokenString(literalNames, symbolicNames);
	} else if(elemsAreChar) {
		return this.toCharString();
	} else {
		return this.toIndexString();
	}
};

IntervalSet.prototype.toCharString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push("'" + String.fromCharCode(v.start) + "'");
			}
		} else {
			names.push("'" + String.fromCharCode(v.start) + "'..'" + String.fromCharCode(v.stop-1) + "'");
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toIndexString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push(v.start.toString());
			}
		} else {
			names.push(v.start.toString() + ".." + (v.stop-1).toString());
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toTokenString = function(literalNames, symbolicNames) {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		for (var j = v.start; j < v.stop; j++) {
			names.push(this.elementName(literalNames, symbolicNames, j));
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};

IntervalSet.prototype.elementName = function(literalNames, symbolicNames, a) {
	if (a === Token.EOF) {
		return "<EOF>";
	} else if (a === Token.EPSILON) {
		return "<EPSILON>";
	} else {
		return literalNames[a] || symbolicNames[a];
	}
};

exports.Interval = Interval;
exports.IntervalSet = IntervalSet;

},{"./Token":27}],20:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

var Set = require('./Utils').Set;
var BitSet = require('./Utils').BitSet;
var Token = require('./Token').Token;
var ATNConfig = require('./atn/ATNConfig').ATNConfig;
var Interval = require('./IntervalSet').Interval;
var IntervalSet = require('./IntervalSet').IntervalSet;
var RuleStopState = require('./atn/ATNState').RuleStopState;
var RuleTransition = require('./atn/Transition').RuleTransition;
var NotSetTransition = require('./atn/Transition').NotSetTransition;
var WildcardTransition = require('./atn/Transition').WildcardTransition;
var AbstractPredicateTransition = require('./atn/Transition').AbstractPredicateTransition;

var pc = require('./PredictionContext');
var predictionContextFromRuleContext = pc.predictionContextFromRuleContext;
var PredictionContext = pc.PredictionContext;
var SingletonPredictionContext = pc.SingletonPredictionContext;

function LL1Analyzer (atn) {
    this.atn = atn;
}

//* Special value added to the lookahead sets to indicate that we hit
//  a predicate during analysis if {@code seeThruPreds==false}.
///
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;


//*
// Calculates the SLL(1) expected lookahead set for each outgoing transition
// of an {@link ATNState}. The returned array has one element for each
// outgoing transition in {@code s}. If the closure from transition
// <em>i</em> leads to a semantic predicate before matching a symbol, the
// element at index <em>i</em> of the result will be {@code null}.
//
// @param s the ATN state
// @return the expected symbols for each outgoing transition of {@code s}.
///
LL1Analyzer.prototype.getDecisionLookahead = function(s) {
    if (s === null) {
        return null;
    }
    var count = s.transitions.length;
    var look = [];
    for(var alt=0; alt< count; alt++) {
        look[alt] = new IntervalSet();
        var lookBusy = new Set();
        var seeThruPreds = false; // fail to get lookahead upon pred
        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
              look[alt], lookBusy, new BitSet(), seeThruPreds, false);
        // Wipe out lookahead for this alternative if we found nothing
        // or we had a predicate when we !seeThruPreds
        if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
            look[alt] = null;
        }
    }
    return look;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and the end of the rule containing
// {@code s} is reached, {@link Token//EPSILON} is added to the result set.
// If {@code ctx} is not {@code null} and the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx the complete parser context, or {@code null} if the context
// should be ignored
//
// @return The set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
///
LL1Analyzer.prototype.LOOK = function(s, stopState, ctx) {
    var r = new IntervalSet();
    var seeThruPreds = true; // ignore preds; get all lookahead
	ctx = ctx || null;
    var lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);
    return r;
};
    
//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
// rule containing {@code s} is reached, {@link Token//EPSILON} is added to
// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
// {@code true} and {@code stopState} or the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state.
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx The outer context, or {@code null} if the outer context should
// not be used.
// @param look The result lookahead set.
// @param lookBusy A set used for preventing epsilon closures in the ATN
// from causing a stack overflow. Outside code should pass
// {@code new Set<ATNConfig>} for this argument.
// @param calledRuleStack A set used for preventing left recursion in the
// ATN from causing a stack overflow. Outside code should pass
// {@code new BitSet()} for this argument.
// @param seeThruPreds {@code true} to true semantic predicates as
// implicitly {@code true} and "see through them", otherwise {@code false}
// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
// result if one is encountered.
// @param addEOF Add {@link Token//EOF} to the result if the end of the
// outermost context is reached. This parameter has no effect if {@code ctx}
// is {@code null}.
///
LL1Analyzer.prototype._LOOK = function(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    var c = new ATNConfig({state:s, alt:0}, ctx);
    if (lookBusy.contains(c)) {
        return;
    }
    lookBusy.add(c);
    if (s === stopState) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
    }
    if (s instanceof RuleStopState ) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
        if (ctx !== PredictionContext.EMPTY) {
            // run thru all possible stack tops in ctx
            for(var i=0; i<ctx.length; i++) {
                var returnState = this.atn.states[ctx.getReturnState(i)];
                var removed = calledRuleStack.contains(returnState.ruleIndex);
                try {
                    calledRuleStack.remove(returnState.ruleIndex);
                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } finally {
                    if (removed) {
                        calledRuleStack.add(returnState.ruleIndex);
                    }
                }
            }
            return;
        }
    }
    for(var j=0; j<s.transitions.length; j++) {
        var t = s.transitions[j];
        if (t.constructor === RuleTransition) {
            if (calledRuleStack.contains(t.target.ruleIndex)) {
                continue;
            }
            var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
            try {
                calledRuleStack.add(t.target.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
                calledRuleStack.remove(t.target.ruleIndex);
            }
        } else if (t instanceof AbstractPredicateTransition ) {
            if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
                look.addOne(LL1Analyzer.HIT_PRED);
            }
        } else if( t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t.constructor === WildcardTransition) {
            look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );
        } else {
            var set = t.label;
            if (set !== null) {
                if (t instanceof NotSetTransition) {
                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                }
                look.addSet(set);
            }
        }
    }
};

exports.LL1Analyzer = LL1Analyzer;


},{"./IntervalSet":19,"./PredictionContext":24,"./Token":27,"./Utils":28,"./atn/ATNConfig":30,"./atn/ATNState":35,"./atn/Transition":43}],21:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  this SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  this SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// A lexer is recognizer that draws input symbols from a character stream.
//  lexer grammars result in a subclass of this object. A Lexer object
//  uses simplified match() and error recovery mechanisms in the interest
//  of speed.
///

var Token = require('./Token').Token;
var Recognizer = require('./Recognizer').Recognizer;
var CommonTokenFactory = require('./CommonTokenFactory').CommonTokenFactory;
var LexerNoViableAltException = require('./error/Errors').LexerNoViableAltException;

function TokenSource() {
	return this;
}

function Lexer(input) {
	Recognizer.call(this);
	this._input = input;
	this._factory = CommonTokenFactory.DEFAULT;
	this._tokenFactorySourcePair = [ this, input ];

	this._interp = null; // child classes must populate this

	// The goal of all lexer rules/methods is to create a token object.
	// this is an instance variable as multiple rules may collaborate to
	// create a single token. nextToken will return this object after
	// matching lexer rule(s). If you subclass to allow multiple token
	// emissions, then set this to the last token to be matched or
	// something nonnull so that the auto token emit mechanism will not
	// emit another token.
	this._token = null;

	// What character index in the stream did the current token start at?
	// Needed, for example, to get the text for current token. Set at
	// the start of nextToken.
	this._tokenStartCharIndex = -1;

	// The line on which the first character of the token resides///
	this._tokenStartLine = -1;

	// The character position of first character within the line///
	this._tokenStartColumn = -1;

	// Once we see EOF on char stream, next token will be EOF.
	// If you have DONE : EOF ; then you see DONE EOF.
	this._hitEOF = false;

	// The channel number for the current token///
	this._channel = Token.DEFAULT_CHANNEL;

	// The token type for the current token///
	this._type = Token.INVALID_TYPE;

	this._modeStack = [];
	this._mode = Lexer.DEFAULT_MODE;

	// You can set the text for the current token to override what is in
	// the input char buffer. Use setText() or can set this instance var.
	// /
	this._text = null;

	return this;
}

Lexer.prototype = Object.create(Recognizer.prototype);
Lexer.prototype.constructor = Lexer;

Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;

Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = '\u0000';
Lexer.MAX_CHAR_VALUE = '\uFFFE';

Lexer.prototype.reset = function() {
	// wack Lexer state variables
	if (this._input !== null) {
		this._input.seek(0); // rewind the input
	}
	this._token = null;
	this._type = Token.INVALID_TYPE;
	this._channel = Token.DEFAULT_CHANNEL;
	this._tokenStartCharIndex = -1;
	this._tokenStartColumn = -1;
	this._tokenStartLine = -1;
	this._text = null;

	this._hitEOF = false;
	this._mode = Lexer.DEFAULT_MODE;
	this._modeStack = [];

	this._interp.reset();
};

// Return a token from this source; i.e., match a token on the char stream.
Lexer.prototype.nextToken = function() {
	if (this._input === null) {
		throw "nextToken requires a non-null input stream.";
	}

	// Mark start location in char stream so unbuffered streams are
	// guaranteed at least have text of current token
	var tokenStartMarker = this._input.mark();
	try {
		while (true) {
			if (this._hitEOF) {
				this.emitEOF();
				return this._token;
			}
			this._token = null;
			this._channel = Token.DEFAULT_CHANNEL;
			this._tokenStartCharIndex = this._input.index;
			this._tokenStartColumn = this._interp.column;
			this._tokenStartLine = this._interp.line;
			this._text = null;
			var continueOuter = false;
			while (true) {
				this._type = Token.INVALID_TYPE;
				var ttype = Lexer.SKIP;
				try {
					ttype = this._interp.match(this._input, this._mode);
				} catch (e) {
					this.notifyListeners(e); // report error
					this.recover(e);
				}
				if (this._input.LA(1) === Token.EOF) {
					this._hitEOF = true;
				}
				if (this._type === Token.INVALID_TYPE) {
					this._type = ttype;
				}
				if (this._type === Lexer.SKIP) {
					continueOuter = true;
					break;
				}
				if (this._type !== Lexer.MORE) {
					break;
				}
			}
			if (continueOuter) {
				continue;
			}
			if (this._token === null) {
				this.emit();
			}
			return this._token;
		}
	} finally {
		// make sure we release marker after match or
		// unbuffered char stream will keep buffering
		this._input.release(tokenStartMarker);
	}
};

// Instruct the lexer to skip creating a token for current lexer rule
// and look for another token. nextToken() knows to keep looking when
// a lexer rule finishes with token set to SKIP_TOKEN. Recall that
// if token==null at end of any token rule, it creates one for you
// and emits it.
// /
Lexer.prototype.skip = function() {
	this._type = Lexer.SKIP;
};

Lexer.prototype.more = function() {
	this._type = Lexer.MORE;
};

Lexer.prototype.mode = function(m) {
	this._mode = m;
};

Lexer.prototype.pushMode = function(m) {
	if (this._interp.debug) {
		console.log("pushMode " + m);
	}
	this._modeStack.push(this._mode);
	this.mode(m);
};

Lexer.prototype.popMode = function() {
	if (this._modeStack.length === 0) {
		throw "Empty Stack";
	}
	if (this._interp.debug) {
		console.log("popMode back to " + this._modeStack.slice(0, -1));
	}
	this.mode(this._modeStack.pop());
	return this._mode;
};

// Set the char stream and reset the lexer
Object.defineProperty(Lexer.prototype, "inputStream", {
	get : function() {
		return this._input;
	},
	set : function(input) {
		this._input = null;
		this._tokenFactorySourcePair = [ this, this._input ];
		this.reset();
		this._input = input;
		this._tokenFactorySourcePair = [ this, this._input ];
	}
});

Object.defineProperty(Lexer.prototype, "sourceName", {
	get : function sourceName() {
		return this._input.sourceName;
	}
});

// By default does not support multiple emits per nextToken invocation
// for efficiency reasons. Subclass and override this method, nextToken,
// and getToken (to push tokens into a list and pull from that list
// rather than a single variable as this implementation does).
// /
Lexer.prototype.emitToken = function(token) {
	this._token = token;
};

// The standard method called to automatically emit a token at the
// outermost lexical rule. The token object should point into the
// char buffer start..stop. If there is a text override in 'text',
// use that to set the token's text. Override this method to emit
// custom Token objects or provide a new factory.
// /
Lexer.prototype.emit = function() {
	var t = this._factory.create(this._tokenFactorySourcePair, this._type,
			this._text, this._channel, this._tokenStartCharIndex, this
					.getCharIndex() - 1, this._tokenStartLine,
			this._tokenStartColumn);
	this.emitToken(t);
	return t;
};

Lexer.prototype.emitEOF = function() {
	var cpos = this.column;
	var lpos = this.line;
	var eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,
			null, Token.DEFAULT_CHANNEL, this._input.index,
			this._input.index - 1, lpos, cpos);
	this.emitToken(eof);
	return eof;
};

Object.defineProperty(Lexer.prototype, "type", {
	get : function() {
		return this.type;
	},
	set : function(type) {
		this._type = type;
	}
});

Object.defineProperty(Lexer.prototype, "line", {
	get : function() {
		return this._interp.line;
	},
	set : function(line) {
		this._interp.line = line;
	}
});

Object.defineProperty(Lexer.prototype, "column", {
	get : function() {
		return this._interp.column;
	},
	set : function(column) {
		this._interp.column = column;
	}
});


// What is the index of the current character of lookahead?///
Lexer.prototype.getCharIndex = function() {
	return this._input.index;
};

// Return the text matched so far for the current token or any text override.
//Set the complete text of this token; it wipes any previous changes to the text.
Object.defineProperty(Lexer.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		} else {
			return this._interp.getText(this._input);
		}
	},
	set : function(text) {
		this._text = text;
	}
});
// Return a list of all Token objects in input char stream.
// Forces load of all tokens. Does not include EOF token.
// /
Lexer.prototype.getAllTokens = function() {
	var tokens = [];
	var t = this.nextToken();
	while (t.type !== Token.EOF) {
		tokens.push(t);
		t = this.nextToken();
	}
	return tokens;
};

Lexer.prototype.notifyListeners = function(e) {
	var start = this._tokenStartCharIndex;
	var stop = this._input.index;
	var text = this._input.getText(start, stop);
	var msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
  msg += e.stack;
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, null, this._tokenStartLine,
			this._tokenStartColumn, msg, e);
};

Lexer.prototype.getErrorDisplay = function(s) {
	var d = [];
	for (var i = 0; i < s.length; i++) {
		d.push(s[i]);
	}
	return d.join('');
};

Lexer.prototype.getErrorDisplayForChar = function(c) {
	if (c.charCodeAt(0) === Token.EOF) {
		return "<EOF>";
	} else if (c === '\n') {
		return "\\n";
	} else if (c === '\t') {
		return "\\t";
	} else if (c === '\r') {
		return "\\r";
	} else {
		return c;
	}
};

Lexer.prototype.getCharErrorDisplay = function(c) {
	return "'" + this.getErrorDisplayForChar(c) + "'";
};

// Lexers can normally match any char in it's vocabulary after matching
// a token, so do the easy thing and just kill a character and hope
// it all works out. You can instead use the rule invocation stack
// to do sophisticated error recovery if you are in a fragment rule.
// /
Lexer.prototype.recover = function(re) {
	if (this._input.LA(1) !== Token.EOF) {
		if (re instanceof LexerNoViableAltException) {
			// skip a char and try again
			this._interp.consume(this._input);
		} else {
			// TODO: Do we lose character or line position information?
			this._input.consume();
		}
	}
};

exports.Lexer = Lexer;

},{"./CommonTokenFactory":15,"./Recognizer":25,"./Token":27,"./error/Errors":52}],22:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  this SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  this SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var Token = require('./Token').Token;
var ParseTreeListener = require('./tree/Tree').ParseTreeListener;
var Recognizer = require('./Recognizer').Recognizer;
var DefaultErrorStrategy = require('./error/ErrorStrategy').DefaultErrorStrategy;
var ATNDeserializer = require('./atn/ATNDeserializer').ATNDeserializer;
var ATNDeserializationOptions = require('./atn/ATNDeserializationOptions').ATNDeserializationOptions;

function TraceListener(parser) {
	ParseTreeListener.call(this);
    this.parser = parser;
	return this;
}

TraceListener.prototype = Object.create(ParseTreeListener);
TraceListener.prototype.constructor = TraceListener;

TraceListener.prototype.enterEveryRule = function(ctx) {
	console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

TraceListener.prototype.visitTerminal = function( node) {
	console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
};

TraceListener.prototype.exitEveryRule = function(ctx) {
	console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

// this is all the parsing support code essentially; most of it is error
// recovery stuff.//
function Parser(input) {
	Recognizer.call(this);
	// The input stream.
	this._input = null;
	// The error handling strategy for the parser. The default value is a new
	// instance of {@link DefaultErrorStrategy}.
	this._errHandler = new DefaultErrorStrategy();
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	// The {@link ParserRuleContext} object for the currently executing rule.
	// this is always non-null during the parsing process.
	this._ctx = null;
	// Specifies whether or not the parser should construct a parse tree during
	// the parsing process. The default value is {@code true}.
	this.buildParseTrees = true;
	// When {@link //setTrace}{@code (true)} is called, a reference to the
	// {@link TraceListener} is stored here so it can be easily removed in a
	// later call to {@link //setTrace}{@code (false)}. The listener itself is
	// implemented as a parser listener so this field is not directly used by
	// other parser methods.
	this._tracer = null;
	// The list of {@link ParseTreeListener} listeners registered to receive
	// events during the parse.
	this._parseListeners = null;
	// The number of syntax errors reported during parsing. this value is
	// incremented each time {@link //notifyErrorListeners} is called.
	this._syntaxErrors = 0;
	this.setInputStream(input);
	return this;
}

Parser.prototype = Object.create(Recognizer.prototype);
Parser.prototype.contructor = Parser;

// this field maps from the serialized ATN string to the deserialized {@link
// ATN} with
// bypass alternatives.
//
// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
//
Parser.bypassAltsAtnCache = {};

// reset the parser's state//
Parser.prototype.reset = function() {
	if (this._input !== null) {
		this._input.seek(0);
	}
	this._errHandler.reset(this);
	this._ctx = null;
	this._syntaxErrors = 0;
	this.setTrace(false);
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	if (this._interp !== null) {
		this._interp.reset();
	}
};

// Match current input symbol against {@code ttype}. If the symbol type
// matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
// called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @param ttype the token type to match
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// {@code ttype} and the error strategy could not recover from the
// mismatched symbol

Parser.prototype.match = function(ttype) {
	var t = this.getCurrentToken();
	if (t.type === ttype) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this.buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};
// Match current input symbol as a wildcard. If the symbol type matches
// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
// and {@link //consume} are called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// a wildcard and the error strategy could not recover from the mismatched
// symbol

Parser.prototype.matchWildcard = function() {
	var t = this.getCurrentToken();
	if (t.type > 0) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this._buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};

Parser.prototype.getParseListeners = function() {
	return this._parseListeners || [];
};

// Registers {@code listener} to receive events during the parsing process.
//
// <p>To support output-preserving grammar transformations (including but not
// limited to left-recursion removal, automated left-factoring, and
// optimized code generation), calls to listener methods during the parse
// may differ substantially from calls made by
// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
// particular, rule entry and exit events may occur in a different order
// during the parse than after the parser. In addition, calls to certain
// rule entry methods may be omitted.</p>
//
// <p>With the following specific exceptions, calls to listener events are
// <em>deterministic</em>, i.e. for identical input the calls to listener
// methods will be the same.</p>
//
// <ul>
// <li>Alterations to the grammar used to generate code may change the
// behavior of the listener calls.</li>
// <li>Alterations to the command line options passed to ANTLR 4 when
// generating the parser may change the behavior of the listener calls.</li>
// <li>Changing the version of the ANTLR Tool used to generate the parser
// may change the behavior of the listener calls.</li>
// </ul>
//
// @param listener the listener to add
//
// @throws NullPointerException if {@code} listener is {@code null}
//
Parser.prototype.addParseListener = function(listener) {
	if (listener === null) {
		throw "listener";
	}
	if (this._parseListeners === null) {
		this._parseListeners = [];
	}
	this._parseListeners.push(listener);
};

//
// Remove {@code listener} from the list of parse listeners.
//
// <p>If {@code listener} is {@code null} or has not been added as a parse
// listener, this method does nothing.</p>
// @param listener the listener to remove
//
Parser.prototype.removeParseListener = function(listener) {
	if (this._parseListeners !== null) {
		var idx = this._parseListeners.indexOf(listener);
		if (idx >= 0) {
			this._parseListeners.splice(idx, 1);
		}
		if (this._parseListeners.length === 0) {
			this._parseListeners = null;
		}
	}
};

// Remove all parse listeners.
Parser.prototype.removeParseListeners = function() {
	this._parseListeners = null;
};

// Notify any parse listeners of an enter rule event.
Parser.prototype.triggerEnterRuleEvent = function() {
	if (this._parseListeners !== null) {
        var ctx = this._ctx;
		this._parseListeners.map(function(listener) {
			listener.enterEveryRule(ctx);
			ctx.enterRule(listener);
		});
	}
};

//
// Notify any parse listeners of an exit rule event.
//
// @see //addParseListener
//
Parser.prototype.triggerExitRuleEvent = function() {
	if (this._parseListeners !== null) {
		// reverse order walk of listeners
        var ctx = this._ctx;
		this._parseListeners.slice(0).reverse().map(function(listener) {
			ctx.exitRule(listener);
			listener.exitEveryRule(ctx);
		});
	}
};

Parser.prototype.getTokenFactory = function() {
	return this._input.tokenSource._factory;
};

// Tell our token source and error strategy about a new way to create tokens.//
Parser.prototype.setTokenFactory = function(factory) {
	this._input.tokenSource._factory = factory;
};

// The ATN with bypass alternatives is expensive to create so we create it
// lazily.
//
// @throws UnsupportedOperationException if the current parser does not
// implement the {@link //getSerializedATN()} method.
//
Parser.prototype.getATNWithBypassAlts = function() {
	var serializedAtn = this.getSerializedATN();
	if (serializedAtn === null) {
		throw "The current parser does not support an ATN with bypass alternatives.";
	}
	var result = this.bypassAltsAtnCache[serializedAtn];
	if (result === null) {
		var deserializationOptions = new ATNDeserializationOptions();
		deserializationOptions.generateRuleBypassTransitions = true;
		result = new ATNDeserializer(deserializationOptions)
				.deserialize(serializedAtn);
		this.bypassAltsAtnCache[serializedAtn] = result;
	}
	return result;
};

// The preferred method of getting a tree pattern. For example, here's a
// sample use:
//
// <pre>
// ParseTree t = parser.expr();
// ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
// MyParser.RULE_expr);
// ParseTreeMatch m = p.match(t);
// String id = m.get("ID");
// </pre>

var Lexer = require('./Lexer').Lexer;

Parser.prototype.compileParseTreePattern = function(pattern, patternRuleIndex, lexer) {
	lexer = lexer || null;
	if (lexer === null) {
		if (this.getTokenStream() !== null) {
			var tokenSource = this.getTokenStream().getTokenSource();
			if (tokenSource instanceof Lexer) {
				lexer = tokenSource;
			}
		}
	}
	if (lexer === null) {
		throw "Parser can't discover a lexer to use";
	}
	var m = new ParseTreePatternMatcher(lexer, this);
	return m.compile(pattern, patternRuleIndex);
};

Parser.prototype.getInputStream = function() {
	return this.getTokenStream();
};

Parser.prototype.setInputStream = function(input) {
	this.setTokenStream(input);
};

Parser.prototype.getTokenStream = function() {
	return this._input;
};

// Set the token stream and reset the parser.//
Parser.prototype.setTokenStream = function(input) {
	this._input = null;
	this.reset();
	this._input = input;
};

// Match needs to return the current input symbol, which gets put
// into the label for the associated token ref; e.g., x=ID.
//
Parser.prototype.getCurrentToken = function() {
	return this._input.LT(1);
};

Parser.prototype.notifyErrorListeners = function(msg, offendingToken, err) {
	offendingToken = offendingToken || null;
	err = err || null;
	if (offendingToken === null) {
		offendingToken = this.getCurrentToken();
	}
	this._syntaxErrors += 1;
	var line = offendingToken.line;
	var column = offendingToken.column;
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, offendingToken, line, column, msg, err);
};

//
// Consume and return the {@linkplain //getCurrentToken current symbol}.
//
// <p>E.g., given the following input with {@code A} being the current
// lookahead symbol, this function moves the cursor to {@code B} and returns
// {@code A}.</p>
//
// <pre>
// A B
// ^
// </pre>
//
// If the parser is not in error recovery mode, the consumed symbol is added
// to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
// {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
// If the parser <em>is</em> in error recovery mode, the consumed symbol is
// added to the parse tree using
// {@link ParserRuleContext//addErrorNode(Token)}, and
// {@link ParseTreeListener//visitErrorNode} is called on any parse
// listeners.
//
Parser.prototype.consume = function() {
	var o = this.getCurrentToken();
	if (o.type !== Token.EOF) {
		this.getInputStream().consume();
	}
	var hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
	if (this.buildParseTrees || hasListener) {
		var node;
		if (this._errHandler.inErrorRecoveryMode(this)) {
			node = this._ctx.addErrorNode(o);
		} else {
			node = this._ctx.addTokenNode(o);
		}
		if (hasListener) {
			this._parseListeners.map(function(listener) {
				listener.visitTerminal(node);
			});
		}
	}
	return o;
};

Parser.prototype.addContextToParseTree = function() {
	// add current context to parent if we have a parent
	if (this._ctx.parentCtx !== null) {
		this._ctx.parentCtx.addChild(this._ctx);
	}
};

// Always called by generated parsers upon entry to a rule. Access field
// {@link //_ctx} get the current context.

Parser.prototype.enterRule = function(localctx, state, ruleIndex) {
	this.state = state;
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this.buildParseTrees) {
		this.addContextToParseTree();
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent();
	}
};

Parser.prototype.exitRule = function() {
	this._ctx.stop = this._input.LT(-1);
	// trigger event on _ctx, before it reverts to parent
	if (this._parseListeners !== null) {
		this.triggerExitRuleEvent();
	}
	this.state = this._ctx.invokingState;
	this._ctx = this._ctx.parentCtx;
};

Parser.prototype.enterOuterAlt = function(localctx, altNum) {
	// if we have new localctx, make sure we replace existing ctx
	// that is previous child of parse tree
	if (this.buildParseTrees && this._ctx !== localctx) {
		if (this._ctx.parentCtx !== null) {
			this._ctx.parentCtx.removeLastChild();
			this._ctx.parentCtx.addChild(localctx);
		}
	}
	this._ctx = localctx;
};

// Get the precedence level for the top-most precedence rule.
//
// @return The precedence level for the top-most precedence rule, or -1 if
// the parser context is not nested within a precedence rule.

Parser.prototype.getPrecedence = function() {
	if (this._precedenceStack.length === 0) {
		return -1;
	} else {
		return this._precedenceStack[this._precedenceStack.length-1];
	}
};

Parser.prototype.enterRecursionRule = function(localctx, state, ruleIndex,
		precedence) {
	this.state = state;
	this._precedenceStack.push(precedence);
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

//
// Like {@link //enterRule} but for recursive rules.

Parser.prototype.pushNewRecursionContext = function(localctx, state, ruleIndex) {
	var previous = this._ctx;
	previous.parentCtx = localctx;
	previous.invokingState = state;
	previous.stop = this._input.LT(-1);

	this._ctx = localctx;
	this._ctx.start = previous.start;
	if (this.buildParseTrees) {
		this._ctx.addChild(previous);
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

Parser.prototype.unrollRecursionContexts = function(parentCtx) {
	this._precedenceStack.pop();
	this._ctx.stop = this._input.LT(-1);
	var retCtx = this._ctx; // save current ctx (return value)
	// unroll so _ctx is as it was before call to recursive method
	if (this._parseListeners !== null) {
		while (this._ctx !== parentCtx) {
			this.triggerExitRuleEvent();
			this._ctx = this._ctx.parentCtx;
		}
	} else {
		this._ctx = parentCtx;
	}
	// hook into tree
	retCtx.parentCtx = parentCtx;
	if (this.buildParseTrees && parentCtx !== null) {
		// add return ctx into invoking rule's tree
		parentCtx.addChild(retCtx);
	}
};

Parser.prototype.getInvokingContext = function(ruleIndex) {
	var ctx = this._ctx;
	while (ctx !== null) {
		if (ctx.ruleIndex === ruleIndex) {
			return ctx;
		}
		ctx = ctx.parentCtx;
	}
	return null;
};

Parser.prototype.precpred = function(localctx, precedence) {
	return precedence >= this._precedenceStack[this._precedenceStack.length-1];
};

Parser.prototype.inContext = function(context) {
	// TODO: useful in parser?
	return false;
};

//
// Checks whether or not {@code symbol} can follow the current state in the
// ATN. The behavior of this method is equivalent to the following, but is
// implemented such that the complete context-sensitive follow set does not
// need to be explicitly constructed.
//
// <pre>
// return getExpectedTokens().contains(symbol);
// </pre>
//
// @param symbol the symbol type to check
// @return {@code true} if {@code symbol} can follow the current state in
// the ATN, otherwise {@code false}.

Parser.prototype.isExpectedToken = function(symbol) {
	var atn = this._interp.atn;
	var ctx = this._ctx;
	var s = atn.states[this.state];
	var following = atn.nextTokens(s);
	if (following.contains(symbol)) {
		return true;
	}
	if (!following.contains(Token.EPSILON)) {
		return false;
	}
	while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
		var invokingState = atn.states[ctx.invokingState];
		var rt = invokingState.transitions[0];
		following = atn.nextTokens(rt.followState);
		if (following.contains(symbol)) {
			return true;
		}
		ctx = ctx.parentCtx;
	}
	if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
		return true;
	} else {
		return false;
	}
};

// Computes the set of input symbols which could follow the current parser
// state and context, as given by {@link //getState} and {@link //getContext},
// respectively.
//
// @see ATN//getExpectedTokens(int, RuleContext)
//
Parser.prototype.getExpectedTokens = function() {
	return this._interp.atn.getExpectedTokens(this.state, this._ctx);
};

Parser.prototype.getExpectedTokensWithinCurrentRule = function() {
	var atn = this._interp.atn;
	var s = atn.states[this.state];
	return atn.nextTokens(s);
};

// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.//
Parser.prototype.getRuleIndex = function(ruleName) {
	var ruleIndex = this.getRuleIndexMap()[ruleName];
	if (ruleIndex !== null) {
		return ruleIndex;
	} else {
		return -1;
	}
};

// Return List&lt;String&gt; of the rule names in your parser instance
// leading up to a call to the current rule. You could override if
// you want more details such as the file/line info of where
// in the ATN a rule is invoked.
//
// this is very useful for error messages.
//
Parser.prototype.getRuleInvocationStack = function(p) {
	p = p || null;
	if (p === null) {
		p = this._ctx;
	}
	var stack = [];
	while (p !== null) {
		// compute what follows who invoked us
		var ruleIndex = p.ruleIndex;
		if (ruleIndex < 0) {
			stack.push("n/a");
		} else {
			stack.push(this.ruleNames[ruleIndex]);
		}
		p = p.parentCtx;
	}
	return stack;
};

// For debugging and other purposes.//
Parser.prototype.getDFAStrings = function() {
	return this._interp.decisionToDFA.toString();
};
// For debugging and other purposes.//
Parser.prototype.dumpDFA = function() {
	var seenOne = false;
	for (var i = 0; i < this._interp.decisionToDFA.length; i++) {
		var dfa = this._interp.decisionToDFA[i];
		if (dfa.states.length > 0) {
			if (seenOne) {
				console.log();
			}
			this.printer.println("Decision " + dfa.decision + ":");
			this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
			seenOne = true;
		}
	}
};

/*
"			printer = function() {\r\n" +
"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
"			};\r\n" +
*/

Parser.prototype.getSourceName = function() {
	return this._input.sourceName;
};

// During a parse is sometimes useful to listen in on the rule entry and exit
// events as well as token matches. this is for quick and dirty debugging.
//
Parser.prototype.setTrace = function(trace) {
	if (!trace) {
		this.removeParseListener(this._tracer);
		this._tracer = null;
	} else {
		if (this._tracer !== null) {
			this.removeParseListener(this._tracer);
		}
		this._tracer = new TraceListener(this);
		this.addParseListener(this._tracer);
	}
};

exports.Parser = Parser;
},{"./Lexer":21,"./Recognizer":25,"./Token":27,"./atn/ATNDeserializationOptions":32,"./atn/ATNDeserializer":33,"./error/ErrorStrategy":51,"./tree/Tree":55}],23:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//* A rule invocation record for parsing.
//
//  Contains all of the information about the current rule not stored in the
//  RuleContext. It handles parse tree children list, Any ATN state
//  tracing, and the default values available for rule indications:
//  start, stop, rule index, current alt number, current
//  ATN state.
//
//  Subclasses made for each rule and grammar track the parameters,
//  return values, locals, and labels specific to that rule. These
//  are the objects that are returned from rules.
//
//  Note text is not an actual field of a rule return value; it is computed
//  from start and stop using the input stream's toString() method.  I
//  could add a ctor to this so that we can pass in and store the input
//  stream, but I'm not sure we want to do that.  It would seem to be undefined
//  to get the .text property anyway if the rule matches tokens from multiple
//  input streams.
//
//  I do not use getters for fields of objects that are used simply to
//  group values such as this aggregate.  The getters/setters are there to
//  satisfy the superclass interface.

var RuleContext = require('./RuleContext').RuleContext;
var Tree = require('./tree/Tree');
var INVALID_INTERVAL = Tree.INVALID_INTERVAL;
var TerminalNode = Tree.TerminalNode;
var TerminalNodeImpl = Tree.TerminalNodeImpl;
var ErrorNodeImpl = Tree.ErrorNodeImpl;
var Interval = require("./IntervalSet").Interval;

function ParserRuleContext(parent, invokingStateNumber) {
	parent = parent || null;
	invokingStateNumber = invokingStateNumber || null;
	RuleContext.call(this, parent, invokingStateNumber);
	this.ruleIndex = -1;
    // * If we are debugging or building a parse tree for a visitor,
    // we need to track all of the tokens and rule invocations associated
    // with this rule's context. This is empty for parsing w/o tree constr.
    // operation because we don't the need to track the details about
    // how we parse this rule.
    // /
    this.children = null;
    this.start = null;
    this.stop = null;
    // The exception that forced this rule to return. If the rule successfully
    // completed, this is {@code null}.
    this.exception = null;
}

ParserRuleContext.prototype = Object.create(RuleContext.prototype);
ParserRuleContext.prototype.constructor = ParserRuleContext;

// * COPY a ctx (I'm deliberately not using copy constructor)///
ParserRuleContext.prototype.copyFrom = function(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
};

// Double dispatch methods for listeners
ParserRuleContext.prototype.enterRule = function(listener) {
};

ParserRuleContext.prototype.exitRule = function(listener) {
};

// * Does not set parent link; other add methods do that///
ParserRuleContext.prototype.addChild = function(child) {
    if (this.children === null) {
        this.children = [];
    }
    this.children.push(child);
    return child;
};

// * Used by enterOuterAlt to toss out a RuleContext previously added as
// we entered a rule. If we have // label, we will need to remove
// generic ruleContext object.
// /
ParserRuleContext.prototype.removeLastChild = function() {
    if (this.children !== null) {
        this.children.pop();
    }
};

ParserRuleContext.prototype.addTokenNode = function(token) {
    var node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.addErrorNode = function(badToken) {
    var node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.getChild = function(i, type) {
	type = type || null;
	if (type === null) {
		return this.children.length>=i ? this.children[i] : null;
	} else {
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if(child instanceof type) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
		}
		return null;
    }
};


ParserRuleContext.prototype.getToken = function(ttype, i) {
	for(var j=0; j<this.children.length; j++) {
		var child = this.children[j];
		if (child instanceof TerminalNode) {
			if (child.symbol.type === ttype) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
        }
	}
    return null;
};

ParserRuleContext.prototype.getTokens = function(ttype ) {
    if (this.children=== null) {
        return [];
    } else {
		var tokens = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof TerminalNode) {
				if (child.symbol.type === ttype) {
					tokens.push(child);
				}
			}
		}
		return tokens;
    }
};

ParserRuleContext.prototype.getTypedRuleContext = function(ctxType, i) {
    return this.getChild(i, ctxType);
};

ParserRuleContext.prototype.getTypedRuleContexts = function(ctxType) {
    if (this.children=== null) {
        return [];
    } else {
		var contexts = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof ctxType) {
				contexts.push(child);
			}
		}
		return contexts;
	}
};

ParserRuleContext.prototype.getChildCount = function() {
	if (this.children=== null) {
		return 0;
	} else {
		return this.children.length;
	}
};

ParserRuleContext.prototype.getSourceInterval = function() {
    if( this.start === null || this.stop === null) {
        return INVALID_INTERVAL;
    } else {
        return Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
};

RuleContext.EMPTY = new ParserRuleContext();

function InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
	ParserRuleContext.call(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
    return this;
}

InterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);
InterpreterRuleContext.prototype.constructor = InterpreterRuleContext;

exports.ParserRuleContext = ParserRuleContext;
},{"./IntervalSet":19,"./RuleContext":26,"./tree/Tree":55}],24:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

var RuleContext = require('./RuleContext').RuleContext;

function PredictionContext(cachedHashString) {
	this.cachedHashString = cachedHashString;
}

// Represents {@code $} in local context prediction, which means wildcard.
// {@code//+x =//}.
// /
PredictionContext.EMPTY = null;

// Represents {@code $} in an array in full context mode, when {@code $}
// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
// {@code $} = {@link //EMPTY_RETURN_STATE}.
// /
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;

PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// Stores the computed hash code of this {@link PredictionContext}. The hash
// code is computed in parts to match the following reference algorithm.
//
// <pre>
// private int referenceHashCode() {
// int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
// //INITIAL_HASH});
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
// getParent}(i));
// }
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
// //getReturnState getReturnState}(i));
// }
//
// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
// //size()});
// return hash;
// }
// </pre>
// /

// This means only the {@link //EMPTY} context is in set.
PredictionContext.prototype.isEmpty = function() {
	return this === PredictionContext.EMPTY;
};

PredictionContext.prototype.hasEmptyPath = function() {
	return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
};

PredictionContext.prototype.hashString = function() {
	return this.cachedHashString;
};

function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}

function calculateEmptyHashString() {
	return "";
}

// Used to cache {@link PredictionContext} objects. Its used for the shared
// context cash associated with contexts in DFA states. This cache
// can be used for both lexers and parsers.

function PredictionContextCache() {
	this.cache = {};
	return this;
}

// Add a context to the cache and return it. If the context already exists,
// return that one instead and do not add a new context to the cache.
// Protect shared cache from unsafe thread access.
//
PredictionContextCache.prototype.add = function(ctx) {
	if (ctx === PredictionContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	var existing = this.cache[ctx];
	if (existing !== null) {
		return existing;
	}
	this.cache[ctx] = ctx;
	return ctx;
};

PredictionContextCache.prototype.get = function(ctx) {
	return this.cache[ctx] || null;
};

Object.defineProperty(PredictionContextCache.prototype, "length", {
	get : function() {
		return this.cache.length;
	}
});

function SingletonPredictionContext(parent, returnState) {
	var hashString = parent !== null ? calculateHashString(parent, returnState)
			: calculateEmptyHashString();
	PredictionContext.call(this, hashString);
	this.parentCtx = parent;
	this.returnState = returnState;
}

SingletonPredictionContext.prototype = Object.create(PredictionContext.prototype);
SingletonPredictionContext.prototype.contructor = SingletonPredictionContext;

SingletonPredictionContext.create = function(parent, returnState) {
	if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
		// someone can pass in the bits of an array ctx that mean $
		return PredictionContext.EMPTY;
	} else {
		return new SingletonPredictionContext(parent, returnState);
	}
};

Object.defineProperty(SingletonPredictionContext.prototype, "length", {
	get : function() {
		return 1;
	}
});

SingletonPredictionContext.prototype.getParent = function(index) {
	return this.parentCtx;
};

SingletonPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

SingletonPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof SingletonPredictionContext)) {
		return false;
	} else if (this.hashString() !== other.hashString()) {
		return false; // can't be same if hash is different
	} else {
		if(this.returnState !== other.returnState)
            return false;
        else if(this.parentCtx==null)
            return other.parentCtx==null
		else
            return this.parentCtx.equals(other.parentCtx);
	}
};

SingletonPredictionContext.prototype.hashString = function() {
	return this.cachedHashString;
};

SingletonPredictionContext.prototype.toString = function() {
	var up = this.parentCtx === null ? "" : this.parentCtx.toString();
	if (up.length === 0) {
		if (this.returnState === this.EMPTY_RETURN_STATE) {
			return "$";
		} else {
			return "" + this.returnState;
		}
	} else {
		return "" + this.returnState + " " + up;
	}
};

function EmptyPredictionContext() {
	SingletonPredictionContext.call(this, null, PredictionContext.EMPTY_RETURN_STATE);
	return this;
}

EmptyPredictionContext.prototype = Object.create(SingletonPredictionContext.prototype);
EmptyPredictionContext.prototype.constructor = EmptyPredictionContext;

EmptyPredictionContext.prototype.isEmpty = function() {
	return true;
};

EmptyPredictionContext.prototype.getParent = function(index) {
	return null;
};

EmptyPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

EmptyPredictionContext.prototype.equals = function(other) {
	return this === other;
};

EmptyPredictionContext.prototype.toString = function() {
	return "$";
};

PredictionContext.EMPTY = new EmptyPredictionContext();

function ArrayPredictionContext(parents, returnStates) {
	// Parent can be null only if full ctx mode and we make an array
	// from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
	// null parent and
	// returnState == {@link //EMPTY_RETURN_STATE}.
	var hash = calculateHashString(parents, returnStates);
	PredictionContext.call(this, hash);
	this.parents = parents;
	this.returnStates = returnStates;
	return this;
}

ArrayPredictionContext.prototype = Object.create(PredictionContext.prototype);
ArrayPredictionContext.prototype.constructor = ArrayPredictionContext;

ArrayPredictionContext.prototype.isEmpty = function() {
	// since EMPTY_RETURN_STATE can only appear in the last position, we
	// don't need to verify that size==1
	return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
};

Object.defineProperty(ArrayPredictionContext.prototype, "length", {
	get : function() {
		return this.returnStates.length;
	}
});

ArrayPredictionContext.prototype.getParent = function(index) {
	return this.parents[index];
};

ArrayPredictionContext.prototype.getReturnState = function(index) {
	return this.returnStates[index];
};

ArrayPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof ArrayPredictionContext)) {
		return false;
	} else if (this.hashString !== other.hashString()) {
		return false; // can't be same if hash is different
	} else {
		return this.returnStates === other.returnStates &&
				this.parents === other.parents;
	}
};

ArrayPredictionContext.prototype.toString = function() {
	if (this.isEmpty()) {
		return "[]";
	} else {
		var s = "[";
		for (var i = 0; i < this.returnStates.length; i++) {
			if (i > 0) {
				s = s + ", ";
			}
			if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
				s = s + "$";
				continue;
			}
			s = s + this.returnStates[i];
			if (this.parents[i] !== null) {
				s = s + " " + this.parents[i];
			} else {
				s = s + "null";
			}
		}
		return s + "]";
	}
};

// Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
// Return {@link //EMPTY} if {@code outerContext} is empty or null.
// /
function predictionContextFromRuleContext(atn, outerContext) {
	if (outerContext === undefined || outerContext === null) {
		outerContext = RuleContext.EMPTY;
	}
	// if we are in RuleContext of start rule, s, then PredictionContext
	// is EMPTY. Nobody called us. (if we are empty, return empty)
	if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	// If we have a parent, convert it to a PredictionContext graph
	var parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
	var state = atn.states[outerContext.invokingState];
	var transition = state.transitions[0];
	return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}

function calculateListsHashString(parents, returnStates) {
	var s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}

function merge(a, b, rootIsWildcard, mergeCache) {
	// share same graph if both same
	if (a === b) {
		return a;
	}
	if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
		return mergeSingletons(a, b, rootIsWildcard, mergeCache);
	}
	// At least one of a or b is array
	// If one is $ and rootIsWildcard, return $ as// wildcard
	if (rootIsWildcard) {
		if (a instanceof EmptyPredictionContext) {
			return a;
		}
		if (b instanceof EmptyPredictionContext) {
			return b;
		}
	}
	// convert singleton so both are arrays to normalize
	if (a instanceof SingletonPredictionContext) {
		a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
	}
	if (b instanceof SingletonPredictionContext) {
		b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
	}
	return mergeArrays(a, b, rootIsWildcard, mergeCache);
}

//
// Merge two {@link SingletonPredictionContext} instances.
//
// <p>Stack tops equal, parents merge is same; return left graph.<br>
// <embed src="images/SingletonMerge_SameRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Same stack top, parents differ; merge parents giving array node, then
// remainders of those graphs. A new root node is created to point to the
// merged parents.<br>
// <embed src="images/SingletonMerge_SameRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to same parent. Make array node for the
// root where both element in the root point to the same (original)
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to different parents. Make array node for
// the root where each element points to the corresponding original
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// @param mergeCache
// /
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}

	var rootMerge = mergeRoot(a, b, rootIsWildcard);
	if (rootMerge !== null) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, rootMerge);
		}
		return rootMerge;
	}
	if (a.returnState === b.returnState) {
		var parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
		// if parent is same as existing a or b parent or reduced to a parent,
		// return it
		if (parent === a.parentCtx) {
			return a; // ax + bx = ax, if a=b
		}
		if (parent === b.parentCtx) {
			return b; // ax + bx = bx, if a=b
		}
		// else: ax + ay = a'[x,y]
		// merge parents x and y, giving array node with x,y then remainders
		// of those graphs. dup a, a' points at merged array
		// new joined parent so create new singleton pointing to it, a'
		var spc = SingletonPredictionContext.create(parent, a.returnState);
		if (mergeCache !== null) {
			mergeCache.set(a, b, spc);
		}
		return spc;
	} else { // a != b payloads differ
		// see if we can collapse parents due to $+x parents if local ctx
		var singleParent = null;
		if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
																				// bx =
																				// [a,b]x
			singleParent = a.parentCtx;
		}
		if (singleParent !== null) { // parents are same
			// sort payloads and use same parent
			var payloads = [ a.returnState, b.returnState ];
			if (a.returnState > b.returnState) {
				payloads[0] = b.returnState;
				payloads[1] = a.returnState;
			}
			var parents = [ singleParent, singleParent ];
			var apc = new ArrayPredictionContext(parents, payloads);
			if (mergeCache !== null) {
				mergeCache.set(a, b, apc);
			}
			return apc;
		}
		// parents differ and can't merge them. Just pack together
		// into array; can't merge.
		// ax + by = [ax,by]
		var payloads = [ a.returnState, b.returnState ];
		var parents = [ a.parentCtx, b.parentCtx ];
		if (a.returnState > b.returnState) { // sort by payload
			payloads[0] = b.returnState;
			payloads[1] = a.returnState;
			parents = [ b.parentCtx, a.parentCtx ];
		}
		var a_ = new ArrayPredictionContext(parents, payloads);
		if (mergeCache !== null) {
			mergeCache.set(a, b, a_);
		}
		return a_;
	}
}

//
// Handle case where at least one of {@code a} or {@code b} is
// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
// to represent {@link //EMPTY}.
//
// <h2>Local-Context Merges</h2>
//
// <p>These local-context merge operations are used when {@code rootIsWildcard}
// is true.</p>
//
// <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
// <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
// {@code //EMPTY}; return left graph.<br>
// <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
//
// <p>Special case of last merge if local context.<br>
// <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
//
// <h2>Full-Context Merges</h2>
//
// <p>These full-context merge operations are used when {@code rootIsWildcard}
// is false.</p>
//
// <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
//
// <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
// null parent).<br>
// <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// /
function mergeRoot(a, b, rootIsWildcard) {
	if (rootIsWildcard) {
		if (a === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // // + b =//
		}
		if (b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // a +// =//
		}
	} else {
		if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // $ + $ = $
		} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]
			var payloads = [ b.returnState,
					PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ b.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)
			var payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ a.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		}
	}
	return null;
}

//
// Merge two {@link ArrayPredictionContext} instances.
//
// <p>Different tops, different parents.<br>
// <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, same parents.<br>
// <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, different parents.<br>
// <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, all shared parents.<br>
// <embed src="images/ArrayMerge_ShareTopSharePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Equal tops, merge parents and reduce top to
// {@link SingletonPredictionContext}.<br>
// <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
// /
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}
	// merge sorted payloads a + b => M
	var i = 0; // walks a
	var j = 0; // walks b
	var k = 0; // walks target M array

	var mergedReturnStates = [];
	var mergedParents = [];
	// walk and merge to yield mergedParents, mergedReturnStates
	while (i < a.returnStates.length && j < b.returnStates.length) {
		var a_parent = a.parents[i];
		var b_parent = b.parents[j];
		if (a.returnStates[i] === b.returnStates[j]) {
			// same payload (stack tops are equal), must yield merged singleton
			var payload = a.returnStates[i];
			// $+$ = $
			var bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&
					a_parent === null && b_parent === null;
			var ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
																							// ->
																							// ax
			if (bothDollars || ax_ax) {
				mergedParents[k] = a_parent; // choose left
				mergedReturnStates[k] = payload;
			} else { // ax+ay -> a'[x,y]
				var mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
				mergedParents[k] = mergedParent;
				mergedReturnStates[k] = payload;
			}
			i += 1; // hop over left one as usual
			j += 1; // but also skip one in right side since we merge
		} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
			mergedParents[k] = a_parent;
			mergedReturnStates[k] = a.returnStates[i];
			i += 1;
		} else { // b > a, copy b[j] to M
			mergedParents[k] = b_parent;
			mergedReturnStates[k] = b.returnStates[j];
			j += 1;
		}
		k += 1;
	}
	// copy over any payloads remaining in either array
	if (i < a.returnStates.length) {
		for (var p = i; p < a.returnStates.length; p++) {
			mergedParents[k] = a.parents[p];
			mergedReturnStates[k] = a.returnStates[p];
			k += 1;
		}
	} else {
		for (var p = j; p < b.returnStates.length; p++) {
			mergedParents[k] = b.parents[p];
			mergedReturnStates[k] = b.returnStates[p];
			k += 1;
		}
	}
	// trim merged if we combined a few that had same stack tops
	if (k < mergedParents.length) { // write index < last position; trim
		if (k === 1) { // for just one merged element, return singleton top
			var a_ = SingletonPredictionContext.create(mergedParents[0],
					mergedReturnStates[0]);
			if (mergeCache !== null) {
				mergeCache.set(a, b, a_);
			}
			return a_;
		}
		mergedParents = mergedParents.slice(0, k);
		mergedReturnStates = mergedReturnStates.slice(0, k);
	}

	var M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

	// if we created same array as a or b, return that instead
	// TODO: track whether this is possible above during merge sort for speed
	if (M === a) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, a);
		}
		return a;
	}
	if (M === b) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, b);
		}
		return b;
	}
	combineCommonParents(mergedParents);

	if (mergeCache !== null) {
		mergeCache.set(a, b, M);
	}
	return M;
}

//
// Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
// ones.
// /
function combineCommonParents(parents) {
	var uniqueParents = {};

	for (var p = 0; p < parents.length; p++) {
		var parent = parents[p];
		if (!(parent in uniqueParents)) {
			uniqueParents[parent] = parent;
		}
	}
	for (var q = 0; q < parents.length; q++) {
		parents[q] = uniqueParents[parents[q]];
	}
}

function getCachedPredictionContext(context, contextCache, visited) {
	if (context.isEmpty()) {
		return context;
	}
	var existing = visited[context] || null;
	if (existing !== null) {
		return existing;
	}
	existing = contextCache.get(context);
	if (existing !== null) {
		visited[context] = existing;
		return existing;
	}
	var changed = false;
	var parents = [];
	for (var i = 0; i < parents.length; i++) {
		var parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
		if (changed || parent !== context.getParent(i)) {
			if (!changed) {
				parents = [];
				for (var j = 0; j < context.length; j++) {
					parents[j] = context.getParent(j);
				}
				changed = true;
			}
			parents[i] = parent;
		}
	}
	if (!changed) {
		contextCache.add(context);
		visited[context] = context;
		return context;
	}
	var updated = null;
	if (parents.length === 0) {
		updated = PredictionContext.EMPTY;
	} else if (parents.length === 1) {
		updated = SingletonPredictionContext.create(parents[0], context
				.getReturnState(0));
	} else {
		updated = new ArrayPredictionContext(parents, context.returnStates);
	}
	contextCache.add(updated);
	visited[updated] = updated;
	visited[context] = updated;

	return updated;
}

// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
	if (nodes === null) {
		nodes = [];
		return getAllContextNodes(context, nodes, visited);
	} else if (visited === null) {
		visited = {};
		return getAllContextNodes(context, nodes, visited);
	} else {
		if (context === null || visited[context] !== null) {
			return nodes;
		}
		visited[context] = context;
		nodes.push(context);
		for (var i = 0; i < context.length; i++) {
			getAllContextNodes(context.getParent(i), nodes, visited);
		}
		return nodes;
	}
}

exports.merge = merge;
exports.PredictionContext = PredictionContext;
exports.PredictionContextCache = PredictionContextCache;
exports.SingletonPredictionContext = SingletonPredictionContext;
exports.predictionContextFromRuleContext = predictionContextFromRuleContext;
exports.getCachedPredictionContext = getCachedPredictionContext;

},{"./RuleContext":26}],25:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

var Token = require('./Token').Token;
var ConsoleErrorListener = require('./error/ErrorListener').ConsoleErrorListener;
var ProxyErrorListener = require('./error/ErrorListener').ProxyErrorListener;

function Recognizer() {
    this._listeners = [ ConsoleErrorListener.INSTANCE ];
    this._interp = null;
    this._stateNumber = -1;
    return this;
}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};


Recognizer.prototype.checkVersion = function(toolVersion) {
    var runtimeVersion = "4.5";
    if (runtimeVersion!==toolVersion) {
        console.log("ANTLR runtime and generated code versions disagree: "+runtimeVersion+"!="+toolVersion);
    }
};

Recognizer.prototype.addErrorListener = function(listener) {
    this._listeners.push(listener);
};

Recognizer.prototype.removeErrorListeners = function() {
    this._listeners = [];
};

Recognizer.prototype.getTokenTypeMap = function() {
    var tokenNames = this.getTokenNames();
    if (tokenNames===null) {
        throw("The current recognizer does not provide a list of token names.");
    }
    var result = this.tokenTypeMapCache[tokenNames];
    if(result===undefined) {
        result = tokenNames.reduce(function(o, k, i) { o[k] = i; });
        result.EOF = Token.EOF;
        this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
};

// Get a map from rule names to rule indexes.
//
// <p>Used for XPath and tree pattern compilation.</p>
//
Recognizer.prototype.getRuleIndexMap = function() {
    var ruleNames = this.getRuleNames();
    if (ruleNames===null) {
        throw("The current recognizer does not provide a list of rule names.");
    }
    var result = this.ruleIndexMapCache[ruleNames];
    if(result===undefined) {
        result = ruleNames.reduce(function(o, k, i) { o[k] = i; });
        this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
};

Recognizer.prototype.getTokenType = function(tokenName) {
    var ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !==undefined) {
        return ttype;
    } else {
        return Token.INVALID_TYPE;
    }
};


// What is the error header, normally line/character position information?//
Recognizer.prototype.getErrorHeader = function(e) {
    var line = e.getOffendingToken().line;
    var column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
};


// How should a token be displayed in an error message? The default
//  is to display just the text, but during development you might
//  want to have a lot of information spit out.  Override in that case
//  to use t.toString() (which, for CommonToken, dumps everything about
//  the token). This is better than forcing you to override a method in
//  your token objects because you don't have to go modify your lexer
//  so that it creates a new Java type.
//
// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
// implementations of {@link ANTLRErrorStrategy} may provide a similar
// feature when necessary. For example, see
// {@link DefaultErrorStrategy//getTokenErrorDisplay}.
//
Recognizer.prototype.getTokenErrorDisplay = function(t) {
    if (t===null) {
        return "<no token>";
    }
    var s = t.text;
    if (s===null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    s = s.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t");
    return "'" + s + "'";
};

Recognizer.prototype.getErrorListenerDispatch = function() {
    return new ProxyErrorListener(this._listeners);
};

// subclass needs to override these if there are sempreds or actions
// that the ATN interp needs to execute
Recognizer.prototype.sempred = function(localctx, ruleIndex, actionIndex) {
    return true;
};

Recognizer.prototype.precpred = function(localctx , precedence) {
    return true;
};

//Indicate that the recognizer has changed internal state that is
//consistent with the ATN state passed in.  This way we always know
//where we are in the ATN as the parser goes along. The rule
//context objects form a stack that lets us see the stack of
//invoking rules. Combine this and we have complete ATN
//configuration information.

Object.defineProperty(Recognizer.prototype, "state", {
	get : function() {
		return this._stateNumber;
	},
	set : function(state) {
		this._stateNumber = state;
	}
});


exports.Recognizer = Recognizer;

},{"./Token":27,"./error/ErrorListener":50}],26:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

//  A rule context is a record of a single rule invocation. It knows
//  which context invoked it, if any. If there is no parent context, then
//  naturally the invoking state is not valid.  The parent link
//  provides a chain upwards from the current rule invocation to the root
//  of the invocation tree, forming a stack. We actually carry no
//  information about the rule associated with this context (except
//  when parsing). We keep only the state number of the invoking state from
//  the ATN submachine that invoked this. Contrast this with the s
//  pointer inside ParserRuleContext that tracks the current state
//  being "executed" for the current rule.
//
//  The parent contexts are useful for computing lookahead sets and
//  getting error information.
//
//  These objects are used during parsing and prediction.
//  For the special case of parsers, we use the subclass
//  ParserRuleContext.
//
//  @see ParserRuleContext
///

var RuleNode = require('./tree/Tree').RuleNode;
var INVALID_INTERVAL = require('./tree/Tree').INVALID_INTERVAL;

function RuleContext(parent, invokingState) {
	RuleNode.call(this);
	// What context invoked this rule?
	this.parentCtx = parent || null;
	// What state invoked the rule associated with this context?
	// The "return address" is the followState of invokingState
	// If parent is null, this should be -1.
	this.invokingState = invokingState || -1;
	return this;
}

RuleContext.prototype = Object.create(RuleNode.prototype);
RuleContext.prototype.constructor = RuleContext;

RuleContext.prototype.depth = function() {
	var n = 0;
	var p = this;
	while (p !== null) {
		p = p.parentCtx;
		n += 1;
	}
	return n;
};

// A context is empty if there is no invoking state; meaning nobody call
// current context.
RuleContext.prototype.isEmpty = function() {
	return this.invokingState === -1;
};

// satisfy the ParseTree / SyntaxTree interface

RuleContext.prototype.getSourceInterval = function() {
	return INVALID_INTERVAL;
};

RuleContext.prototype.getRuleContext = function() {
	return this;
};

RuleContext.prototype.getPayload = function() {
	return this;
};

// Return the combined text of all child nodes. This method only considers
// tokens which have been added to the parse tree.
// <p>
// Since tokens on hidden channels (e.g. whitespace or comments) are not
// added to the parse trees, they will not appear in the output of this
// method.
// /
RuleContext.prototype.getText = function() {
	if (this.getChildCount() === 0) {
		return "";
	} else {
		return this.children.map(function(child) {
			return child.getText();
		}).join("");
	}
};

RuleContext.prototype.getChild = function(i) {
	return null;
};

RuleContext.prototype.getChildCount = function() {
	return 0;
};

RuleContext.prototype.accept = function(visitor) {
	return visitor.visitChildren(this);
};

//need to manage circular dependencies, so export now
exports.RuleContext = RuleContext;
var Trees = require('./tree/Trees').Trees;


// Print out a whole tree, not just a node, in LISP format
// (root child1 .. childN). Print just a node if this is a leaf.
//

RuleContext.prototype.toStringTree = function(ruleNames, recog) {
	return Trees.toStringTree(this, ruleNames, recog);
};

RuleContext.prototype.toString = function(ruleNames, stop) {
	ruleNames = ruleNames || null;
	stop = stop || null;
	var p = this;
	var s = "[";
	while (p !== null && p !== stop) {
		if (ruleNames === null) {
			if (!p.isEmpty()) {
				s += p.invokingState;
			}
		} else {
			var ri = p.ruleIndex;
			var ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
					: "" + ri;
			s += ruleName;
		}
		if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
			s += " ";
		}
		p = p.parentCtx;
	}
	s += "]";
	return s;
};


},{"./tree/Tree":55,"./tree/Trees":56}],27:[function(require,module,exports){
//[The "BSD license"]
// Copyright (c) 2012 Terence Parr
// Copyright (c) 2012 Sam Harwell
// Copyright (c) 2014 Eric Vergnaud
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// A token has properties: text, type, line, character position in the line
// (so we can ignore tabs), token channel, index, and source from which
// we obtained this token.

function Token() {
	this.source = null;
	this.type = null; // token type of the token
	this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
	this.start = null; // optional; return -1 if not implemented.
	this.stop = null; // optional; return -1 if not implemented.
	this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
	this.line = null; // line=1..n of the 1st character
	this.column = null; // beginning of the line at which it occurs, 0..n-1
	this._text = null; // text of the token.
	return this;
}

Token.INVALID_TYPE = 0;

// During lookahead operations, this "token" signifies we hit rule end ATN state
// and did not follow it despite needing to.
Token.EPSILON = -2;

Token.MIN_USER_TOKEN_TYPE = 1;

Token.EOF = -1;

// All tokens go to the parser (unless skip() is called in that rule)
// on a particular "channel". The parser tunes to a particular channel
// so that whitespace etc... can go to the parser on a "hidden" channel.

Token.DEFAULT_CHANNEL = 0;

// Anything on different channel than DEFAULT_CHANNEL is not parsed
// by parser.

Token.HIDDEN_CHANNEL = 1;

// Explicitly set the text for this token. If {code text} is not
// {@code null}, then {@link //getText} will return this value rather than
// extracting the text from the input.
//
// @param text The explicit text of the token, or {@code null} if the text
// should be obtained from the input along with the start and stop indexes
// of the token.

Object.defineProperty(Token.prototype, "text", {
	get : function() {
		return this._text;
	},
	set : function(text) {
		this._text = text;
	}
});

Token.prototype.getTokenSource = function() {
	return this.source[0];
};

Token.prototype.getInputStream = function() {
	return this.source[1];
};

function CommonToken(source, type, channel, start, stop) {
	Token.call(this);
	this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
	this.type = type !== undefined ? type : null;
	this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
	this.start = start !== undefined ? start : -1;
	this.stop = stop !== undefined ? stop : -1;
	this.tokenIndex = -1;
	if (this.source[0] !== null) {
		this.line = source[0].line;
		this.column = source[0].column;
	} else {
		this.column = -1;
	}
	return this;
}

CommonToken.prototype = Object.create(Token.prototype);
CommonToken.prototype.constructor = CommonToken;

// An empty {@link Pair} which is used as the default value of
// {@link //source} for tokens that do not have a source.
CommonToken.EMPTY_SOURCE = [ null, null ];

// Constructs a new {@link CommonToken} as a copy of another {@link Token}.
//
// <p>
// If {@code oldToken} is also a {@link CommonToken} instance, the newly
// constructed token will share a reference to the {@link //text} field and
// the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
// be assigned the result of calling {@link //getText}, and {@link //source}
// will be constructed from the result of {@link Token//getTokenSource} and
// {@link Token//getInputStream}.</p>
//
// @param oldToken The token to copy.
//
CommonToken.prototype.clone = function() {
	var t = new CommonToken(this.source, this.type, this.channel, this.start,
			this.stop);
	t.tokenIndex = this.tokenIndex;
	t.line = this.line;
	t.column = this.column;
	t.text = this.text;
	return t;
};

Object.defineProperty(CommonToken.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		}
		var input = this.getInputStream();
		if (input === null) {
			return null;
		}
		var n = input.size;
		if (this.start < n && this.stop < n) {
			return input.getText(this.start, this.stop);
		} else {
			return "<EOF>";
		}
	},
	set : function(text) {
		this._text = text;
	}
});

CommonToken.prototype.toString = function() {
	var txt = this.text;
	if (txt !== null) {
		txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	} else {
		txt = "<no text>";
	}
	return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
			txt + "',<" + this.type + ">" +
			(this.channel > 0 ? ",channel=" + this.channel : "") + "," +
			this.line + ":" + this.column + "]";
};

exports.Token = Token;
exports.CommonToken = CommonToken;

},{}],28:[function(require,module,exports){
function arrayToString(a) {
	return "[" + a.join(", ") + "]";
}

String.prototype.hashCode = function(s) {
	var hash = 0;
	if (this.length === 0) {
		return hash;
	}
	for (var i = 0; i < this.length; i++) {
		var character = this.charCodeAt(i);
		hash = ((hash << 5) - hash) + character;
		hash = hash & hash; // Convert to 32bit integer
	}
	return hash;
};

function standardEqualsFunction(a,b) {
	return a.equals(b);
}

function standardHashFunction(a) {
	return a.hashString();
}

function Set(hashFunction, equalsFunction) {
	this.data = {};
	this.hashFunction = hashFunction || standardHashFunction;
	this.equalsFunction = equalsFunction || standardEqualsFunction;
	return this;
}

Object.defineProperty(Set.prototype, "length", {
	get : function() {
		return this.values().length;
	}
});

Set.prototype.add = function(value) {
	var hash = this.hashFunction(value);
	var key = "hash_" + hash.hashCode();
	if(key in this.data) {
		var i;
		var values = this.data[key];
		for(i=0;i<values.length; i++) {
			if(this.equalsFunction(value, values[i])) {
				return values[i];
			}
		}
		values.push(value);
		return value;
	} else {
		this.data[key] = [ value ];
		return value;
	}
};

Set.prototype.contains = function(value) {
	var hash = this.hashFunction(value);
	var key = hash.hashCode();
	if(key in this.data) {
		var i;
		var values = this.data[key];
		for(i=0;i<values.length; i++) {
			if(this.equalsFunction(value, values[i])) {
				return true;
			}
		}
	}
	return false;
};

Set.prototype.values = function() {
	var l = [];
	for(var key in this.data) {
		if(key.indexOf("hash_")===0) {
			l = l.concat(this.data[key]);
		}
	}
	return l;
};

Set.prototype.toString = function() {
	return arrayToString(this.values());
};

function BitSet() {
	this.data = [];
	return this;
}

BitSet.prototype.add = function(value) {
	this.data[value] = true;
};

BitSet.prototype.or = function(set) {
	var bits = this;
	Object.keys(set.data).map( function(alt) { bits.add(alt); });
};

BitSet.prototype.remove = function(value) {
	delete this.data[value];
};

BitSet.prototype.contains = function(value) {
	return this.data[value] === true;
};

BitSet.prototype.values = function() {
	return Object.keys(this.data);
};

BitSet.prototype.minValue = function() {
	return Math.min.apply(null, this.values());
};

BitSet.prototype.hashString = function() {
	return this.values().toString();
};

BitSet.prototype.equals = function(other) {
	if(!(other instanceof BitSet)) {
		return false;
	}
	return this.hashString()===other.hashString();
};

Object.defineProperty(BitSet.prototype, "length", {
	get : function() {
		return this.values().length;
	}
});

BitSet.prototype.toString = function() {
	return "{" + this.values().join(", ") + "}";
};

function AltDict() {
	this.data = {};
	return this;
}

AltDict.prototype.get = function(key) {
	key = "k-" + key;
	if(key in this.data){
		return this.data[key];
	} else {
		return null;
	}
};

AltDict.prototype.put = function(key, value) {
	key = "k-" + key;
	this.data[key] = value;
};

AltDict.prototype.values = function() {
	var data = this.data;
	var keys = Object.keys(this.data);
	return keys.map(function(key) {
		return data[key];
	});
};

function DoubleDict() {
	return this;
}

DoubleDict.prototype.get = function(a, b) {
	var d = this[a] || null;
	return d===null ? null : (d[b] || null);
};

DoubleDict.prototype.set = function(a, b, o) {
	var d = this[a] || null;
	if(d===null) {
		d = {};
		this[a] = d;
	}
	d[b] = o;
};


function escapeWhitespace(s, escapeSpaces) {
	s = s.replace("\t","\\t");
	s = s.replace("\n","\\n");
	s = s.replace("\r","\\r");
	if(escapeSpaces) {
		s = s.replace(" ","\u00B7");
	}
	return s;
}


exports.Set = Set;
exports.BitSet = BitSet;
exports.AltDict = AltDict;
exports.DoubleDict = DoubleDict;
exports.escapeWhitespace = escapeWhitespace;
exports.arrayToString = arrayToString;

},{}],29:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var LL1Analyzer = require('./../LL1Analyzer').LL1Analyzer;
var IntervalSet = require('./../IntervalSet').IntervalSet;

function ATN(grammarType , maxTokenType) {

    // Used for runtime deserialization of ATNs from strings///
    // The type of the ATN.
    this.grammarType = grammarType;
    // The maximum value for any symbol recognized by a transition in the ATN.
    this.maxTokenType = maxTokenType;
    this.states = [];
    // Each subrule/rule is a decision point and we must track them so we
    //  can go back later and build DFA predictors for them.  This includes
    //  all the rules, subrules, optional blocks, ()+, ()* etc...
    this.decisionToState = [];
    // Maps from rule index to starting state number.
    this.ruleToStartState = [];
    // Maps from rule index to stop state number.
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    // For lexer ATNs, this maps the rule index to the resulting token type.
    // For parser ATNs, this maps the rule index to the generated bypass token
    // type if the
    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
    // deserialization option was specified; otherwise, this is {@code null}.
    this.ruleToTokenType = null;
    // For lexer ATNs, this is an array of {@link LexerAction} objects which may
    // be referenced by action transitions in the ATN.
    this.lexerActions = null;
    this.modeToStartState = [];

    return this;
}
	
// Compute the set of valid tokens that can occur starting in state {@code s}.
//  If {@code ctx} is null, the set of tokens will not include what can follow
//  the rule surrounding {@code s}. In other words, the set will be
//  restricted to tokens reachable staying within {@code s}'s rule.
ATN.prototype.nextTokensInContext = function(s, ctx) {
    var anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
};

// Compute the set of valid tokens that can occur starting in {@code s} and
// staying in same rule. {@link Token//EPSILON} is in set if we reach end of
// rule.
ATN.prototype.nextTokensNoContext = function(s) {
    if (s.nextTokenWithinRule !== null ) {
        return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readonly = true;
    return s.nextTokenWithinRule;
};

ATN.prototype.nextTokens = function(s, ctx) {
    if ( ctx===undefined ) {
        return this.nextTokensNoContext(s);
    } else {
        return this.nextTokensInContext(s, ctx);
    }
};

ATN.prototype.addState = function( state) {
    if ( state !== null ) {
        state.atn = this;
        state.stateNumber = this.states.length;
    }
    this.states.push(state);
};

ATN.prototype.removeState = function( state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
};

ATN.prototype.defineDecisionState = function( s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length-1;
    return s.decision;
};

ATN.prototype.getDecisionState = function( decision) {
    if (this.decisionToState.length===0) {
        return null;
    } else {
        return this.decisionToState[decision];
    }
};

// Computes the set of input symbols which could follow ATN state number
// {@code stateNumber} in the specified full {@code context}. This method
// considers the complete parser context, but does not evaluate semantic
// predicates (i.e. all predicates encountered during the calculation are
// assumed true). If a path in the ATN exists from the starting state to the
// {@link RuleStopState} of the outermost context without matching any
// symbols, {@link Token//EOF} is added to the returned set.
//
// <p>If {@code context} is {@code null}, it is treated as
// {@link ParserRuleContext//EMPTY}.</p>
//
// @param stateNumber the ATN state number
// @param context the full parse context
// @return The set of potentially valid input symbols which could follow the
// specified state in the specified context.
// @throws IllegalArgumentException if the ATN does not contain a state with
// number {@code stateNumber}
var Token = require('./../Token').Token;

ATN.prototype.getExpectedTokens = function( stateNumber, ctx ) {
    if ( stateNumber < 0 || stateNumber >= this.states.length ) {
        throw("Invalid state number.");
    }
    var s = this.states[stateNumber];
    var following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
        return following;
    }
    var expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        var invokingState = this.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
        expected.addOne(Token.EOF);
    }
    return expected;
};

ATN.INVALID_ALT_NUMBER = 0;

exports.ATN = ATN;
},{"./../IntervalSet":19,"./../LL1Analyzer":20,"./../Token":27}],30:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// A tuple: (ATN state, predicted alt, syntactic, semantic context).
//  The syntactic context is a graph-structured stack node whose
//  path(s) to the root is the rule invocation(s)
//  chain used to arrive at the state.  The semantic context is
//  the tree of semantic predicates encountered before reaching
//  an ATN state.
///

var DecisionState = require('./ATNState').DecisionState;
var SemanticContext = require('./SemanticContext').SemanticContext;

function checkParams(params, isCfg) {
	if(params===null) {
		var result = { state:null, alt:null, context:null, semanticContext:null };
		if(isCfg) {
			result.reachesIntoOuterContext = 0;
		}
		return result;
	} else {
		var props = {};
		props.state = params.state || null;
		props.alt = params.alt || null;
		props.context = params.context || null;
		props.semanticContext = params.semanticContext || null;
		if(isCfg) {
			props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
			props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
		}
		return props;
	}
}

function ATNConfig(params, config) {
	this.checkContext(params, config);
	params = checkParams(params);
	config = checkParams(config, true);
    // The ATN state associated with this configuration///
    this.state = params.state!==null ? params.state : config.state;
    // What alt (or lexer rule) is predicted by this configuration///
    this.alt = params.alt!==null ? params.alt : config.alt;
    // The stack of invoking states leading to the rule/states associated
    //  with this config.  We track only those contexts pushed during
    //  execution of the ATN simulator.
    this.context = params.context!==null ? params.context : config.context;
    this.semanticContext = params.semanticContext!==null ? params.semanticContext :
        (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);
    // We cannot execute predicates dependent upon local context unless
    // we know for sure we are in the correct context. Because there is
    // no way to do this efficiently, we simply cannot evaluate
    // dependent predicates unless we are in the rule that initially
    // invokes the ATN simulator.
    //
    // closure() tracks the depth of how far we dip into the
    // outer context: depth &gt; 0.  Note that it may not be totally
    // accurate depth since I don't ever decrement. TODO: make it a boolean then
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    return this;
}

ATNConfig.prototype.checkContext = function(params, config) {
	if((params.context===null || params.context===undefined) &&
			(config===null || config.context===null || config.context===undefined)) {
		this.context = null;
	}
};

// An ATN configuration is equal to another if both have
//  the same state, they predict the same alternative, and
//  syntactic/semantic contexts are the same.
///
ATNConfig.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            (this.context===null ? other.context===null : this.context.equals(other.context)) &&
            this.semanticContext.equals(other.semanticContext) &&
            this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;
    }
};

ATNConfig.prototype.shortHashString = function() {
    return "" + this.state.stateNumber + "/" + this.alt + "/" + this.semanticContext;
};

ATNConfig.prototype.hashString = function() {
    return "" + this.state.stateNumber + "/" + this.alt + "/" +
             (this.context===null ? "" : this.context.hashString()) +
             "/" + this.semanticContext.hashString();
};

ATNConfig.prototype.toString = function() {
    return "(" + this.state + "," + this.alt +
        (this.context!==null ? ",[" + this.context.toString() + "]" : "") +
        (this.semanticContext !== SemanticContext.NONE ?
                ("," + this.semanticContext.toString())
                : "") +
        (this.reachesIntoOuterContext>0 ?
                (",up=" + this.reachesIntoOuterContext)
                : "") + ")";
};


function LexerATNConfig(params, config) {
	ATNConfig.call(this, params, config);
    
    // This is the backing field for {@link //getLexerActionExecutor}.
	var lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;
    return this;
}

LexerATNConfig.prototype = Object.create(ATNConfig.prototype);
LexerATNConfig.prototype.constructor = LexerATNConfig;

LexerATNConfig.prototype.hashString = function() {
    return "" + this.state.stateNumber + this.alt + this.context +
            this.semanticContext + (this.passedThroughNonGreedyDecision ? 1 : 0) +
            this.lexerActionExecutor;
};

LexerATNConfig.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (!(other instanceof LexerATNConfig)) {
        return false;
    } else if (this.passedThroughNonGreedyDecision !== other.passedThroughNonGreedyDecision) {
        return false;
    } else if (this.lexerActionExecutor !== other.lexerActionExecutor) {
        return false;
    } else {
        return ATNConfig.prototype.equals.call(this, other);
    }
};

LexerATNConfig.prototype.checkNonGreedyDecision = function(source, target) {
    return source.passedThroughNonGreedyDecision ||
        (target instanceof DecisionState) && target.nonGreedy;
};

exports.ATNConfig = ATNConfig;
exports.LexerATNConfig = LexerATNConfig;
},{"./ATNState":35,"./SemanticContext":42}],31:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//
// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
// info about the set, with support for combining similar configurations using a
// graph-structured stack.
///

var ATN = require('./ATN').ATN;
var Utils = require('./../Utils');
var Set = Utils.Set;
var SemanticContext = require('./SemanticContext').SemanticContext;
var merge = require('./../PredictionContext').merge;

function hashATNConfig(c) {
	return c.shortHashString();
}

function equalATNConfigs(a, b) {
	if ( a===b ) {
		return true;
	}
	if ( a===null || b===null ) {
		return false;
	}
	return a.state.stateNumber===b.state.stateNumber &&
		a.alt===b.alt && a.semanticContext.equals(b.semanticContext);
}


function ATNConfigSet(fullCtx) {
	//
	// The reason that we need this is because we don't want the hash map to use
	// the standard hash code and equals. We need all configurations with the
	// same
	// {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
	// doubles
	// the number of objects associated with ATNConfigs. The other solution is
	// to
	// use a hash table that lets us specify the equals/hashcode operation.
	// All configs but hashed by (s, i, _, pi) not including context. Wiped out
	// when we go readonly as this set becomes a DFA state.
	this.configLookup = new Set(hashATNConfig, equalATNConfigs);
	// Indicates that this configuration set is part of a full context
	// LL prediction. It will be used to determine how to merge $. With SLL
	// it's a wildcard whereas it is not for LL context merge.
	this.fullCtx = fullCtx === undefined ? true : fullCtx;
	// Indicates that the set of configurations is read-only. Do not
	// allow any code to manipulate the set; DFA states will point at
	// the sets and they must not change. This does not protect the other
	// fields; in particular, conflictingAlts is set after
	// we've made this readonly.
	this.readonly = false;
	// Track the elements as they are added to the set; supports get(i)///
	this.configs = [];

	// TODO: these fields make me pretty uncomfortable but nice to pack up info
	// together, saves recomputation
	// TODO: can we track conflicts as they are added to save scanning configs
	// later?
	this.uniqueAlt = 0;
	this.conflictingAlts = null;

	// Used in parser and lexer. In lexer, it indicates we hit a pred
	// while computing a closure operation. Don't make a DFA state from this.
	this.hasSemanticContext = false;
	this.dipsIntoOuterContext = false;

	this.cachedHashString = "-1";

	return this;
}

// Adding a new config means merging contexts with existing configs for
// {@code (s, i, pi, _)}, where {@code s} is the
// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
// {@code pi} is the {@link ATNConfig//semanticContext}. We use
// {@code (s,i,pi)} as key.
//
// <p>This method updates {@link //dipsIntoOuterContext} and
// {@link //hasSemanticContext} when necessary.</p>
// /
ATNConfigSet.prototype.add = function(config, mergeCache) {
	if (mergeCache === undefined) {
		mergeCache = null;
	}
	if (this.readonly) {
		throw "This set is readonly";
	}
	if (config.semanticContext !== SemanticContext.NONE) {
		this.hasSemanticContext = true;
	}
	if (config.reachesIntoOuterContext > 0) {
		this.dipsIntoOuterContext = true;
	}
	var existing = this.configLookup.add(config);
	if (existing === config) {
		this.cachedHashString = "-1";
		this.configs.push(config); // track order here
		return true;
	}
	// a previous (s,i,pi,_), merge with it and save result
	var rootIsWildcard = !this.fullCtx;
	var merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
	// no need to check for existing.context, config.context in cache
	// since only way to create new graphs is "call rule" and here. We
	// cache at both places.
	existing.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
	// make sure to preserve the precedence filter suppression during the merge
	if (config.precedenceFilterSuppressed) {
		existing.precedenceFilterSuppressed = true;
	}
	existing.context = merged; // replace context; no need to alt mapping
	return true;
};

ATNConfigSet.prototype.getStates = function() {
	var states = new Set();
	for (var i = 0; i < this.configs.length; i++) {
		states.add(this.configs[i].state);
	}
	return states;
};

ATNConfigSet.prototype.getPredicates = function() {
	var preds = [];
	for (var i = 0; i < this.configs.length; i++) {
		var c = this.configs[i].semanticContext;
		if (c !== SemanticContext.NONE) {
			preds.push(c.semanticContext);
		}
	}
	return preds;
};

Object.defineProperty(ATNConfigSet.prototype, "items", {
	get : function() {
		return this.configs;
	}
});

ATNConfigSet.prototype.optimizeConfigs = function(interpreter) {
	if (this.readonly) {
		throw "This set is readonly";
	}
	if (this.configLookup.length === 0) {
		return;
	}
	for (var i = 0; i < this.configs.length; i++) {
		var config = this.configs[i];
		config.context = interpreter.getCachedContext(config.context);
	}
};

ATNConfigSet.prototype.addAll = function(coll) {
	for (var i = 0; i < coll.length; i++) {
		this.add(coll[i]);
	}
	return false;
};

ATNConfigSet.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof ATNConfigSet)) {
		return false;
	}
	return this.configs !== null && this.configs.equals(other.configs) &&
			this.fullCtx === other.fullCtx &&
			this.uniqueAlt === other.uniqueAlt &&
			this.conflictingAlts === other.conflictingAlts &&
			this.hasSemanticContext === other.hasSemanticContext &&
			this.dipsIntoOuterContext === other.dipsIntoOuterContext;
};

ATNConfigSet.prototype.hashString = function() {
	if (this.readonly) {
		if (this.cachedHashString === "-1") {
			this.cachedHashString = this.hashConfigs();
		}
		return this.cachedHashString;
	} else {
		return this.hashConfigs();
	}
};

ATNConfigSet.prototype.hashConfigs = function() {
	var s = "";
	this.configs.map(function(c) {
		s += c.toString();
	});
	return s;
};

Object.defineProperty(ATNConfigSet.prototype, "length", {
	get : function() {
		return this.configs.length;
	}
});

ATNConfigSet.prototype.isEmpty = function() {
	return this.configs.length === 0;
};

ATNConfigSet.prototype.contains = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.contains(item);
};

ATNConfigSet.prototype.containsFast = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.containsFast(item);
};

ATNConfigSet.prototype.clear = function() {
	if (this.readonly) {
		throw "This set is readonly";
	}
	this.configs = [];
	this.cachedHashString = "-1";
	this.configLookup = new Set();
};

ATNConfigSet.prototype.setReadonly = function(readonly) {
	this.readonly = readonly;
	if (readonly) {
		this.configLookup = null; // can't mod, no need for lookup cache
	}
};

ATNConfigSet.prototype.toString = function() {
	return Utils.arrayToString(this.configs) +
		(this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
		(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
		(this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
		(this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
};

function OrderedATNConfigSet() {
	ATNConfigSet.call(this);
	this.configLookup = new Set();
	return this;
}

OrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);
OrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;

exports.ATNConfigSet = ATNConfigSet;
exports.OrderedATNConfigSet = OrderedATNConfigSet;

},{"./../PredictionContext":24,"./../Utils":28,"./ATN":29,"./SemanticContext":42}],32:[function(require,module,exports){
//[The "BSD license"]
// Copyright (c) 2013 Terence Parr
// Copyright (c) 2013 Sam Harwell
// Copyright (c) 2014 Eric Vergnaud
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function ATNDeserializationOptions(copyFrom) {
	if(copyFrom===undefined) {
		copyFrom = null;
	}
	this.readOnly = false;
    this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;

    return this;
}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

//    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

exports.ATNDeserializationOptions = ATNDeserializationOptions;

},{}],33:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var Token = require('./../Token').Token;
var ATN = require('./ATN').ATN;
var ATNType = require('./ATNType').ATNType;
var ATNStates = require('./ATNState');
var ATNState = ATNStates.ATNState;
var BasicState = ATNStates.BasicState;
var DecisionState = ATNStates.DecisionState;
var BlockStartState = ATNStates.BlockStartState;
var BlockEndState = ATNStates.BlockEndState;
var LoopEndState = ATNStates.LoopEndState;
var RuleStartState = ATNStates.RuleStartState;
var RuleStopState = ATNStates.RuleStopState;
var TokensStartState = ATNStates.TokensStartState;
var PlusLoopbackState = ATNStates.PlusLoopbackState;
var StarLoopbackState = ATNStates.StarLoopbackState;
var StarLoopEntryState = ATNStates.StarLoopEntryState;
var PlusBlockStartState = ATNStates.PlusBlockStartState;
var StarBlockStartState = ATNStates.StarBlockStartState;
var BasicBlockStartState = ATNStates.BasicBlockStartState;
var Transitions = require('./Transition');
var Transition = Transitions.Transition;
var AtomTransition = Transitions.AtomTransition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var RangeTransition = Transitions.RangeTransition;
var ActionTransition = Transitions.ActionTransition;
var EpsilonTransition = Transitions.EpsilonTransition;
var WildcardTransition = Transitions.WildcardTransition;
var PredicateTransition = Transitions.PredicateTransition;
var PrecedencePredicateTransition = Transitions.PrecedencePredicateTransition;
var IntervalSet = require('./../IntervalSet').IntervalSet;
var Interval = require('./../IntervalSet').Interval;
var ATNDeserializationOptions = require('./ATNDeserializationOptions').ATNDeserializationOptions;
var LexerActions = require('./LexerAction');
var LexerActionType = LexerActions.LexerActionType;
var LexerSkipAction = LexerActions.LexerSkipAction;
var LexerChannelAction = LexerActions.LexerChannelAction;
var LexerCustomAction = LexerActions.LexerCustomAction;
var LexerMoreAction = LexerActions.LexerMoreAction;
var LexerTypeAction = LexerActions.LexerTypeAction;
var LexerPushModeAction = LexerActions.LexerPushModeAction;
var LexerPopModeAction = LexerActions.LexerPopModeAction;
var LexerModeAction = LexerActions.LexerModeAction;
// This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance
var BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";

// This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.
var SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID ];

var SERIALIZED_VERSION = 3;

// This is the current serialized UUID.
var SERIALIZED_UUID = BASE_SERIALIZED_UUID;

function initArray( length, value) {
	var tmp = [];
	tmp[length-1] = value;
	return tmp.map(function(i) {return value;});
}

function ATNDeserializer (options) {
	
    if ( options=== undefined || options === null ) {
        options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;
    
    return this;
}

// Determines if a particular serialized representation of an ATN supports
// a particular feature, identified by the {@link UUID} used for serializing
// the ATN at the time the feature was first introduced.
//
// @param feature The {@link UUID} marking the first time the feature was
// supported in the serialized ATN.
// @param actualUuid The {@link UUID} of the actual serialized ATN which is
// currently being deserialized.
// @return {@code true} if the {@code actualUuid} value represents a
// serialized ATN at or after the feature identified by {@code feature} was
// introduced; otherwise, {@code false}.

ATNDeserializer.prototype.isFeatureSupported = function(feature, actualUuid) {
    var idx1 = SUPPORTED_UUIDS.index(feature);
    if (idx1<0) {
        return false;
    }
    var idx2 = SUPPORTED_UUIDS.index(actualUuid);
    return idx2 >= idx1;
};

ATNDeserializer.prototype.deserialize = function(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    var atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    var sets = this.readSets(atn);
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {
        this.generateRuleBypassTransitions(atn);
        // re-verify after modification
        this.verifyATN(atn);
    }
    return atn;
};

ATNDeserializer.prototype.reset = function(data) {
	var adjust = function(c) {
        var v = c.charCodeAt(0);
        return v>1  ? v-2 : -1;
	};
    var temp = data.split("").map(adjust);
    // don't adjust the first value since that's the version number
    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
};

ATNDeserializer.prototype.checkVersion = function() {
    var version = this.readInt();
    if ( version !== SERIALIZED_VERSION ) {
        throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
    }
};

ATNDeserializer.prototype.checkUUID = function() {
    var uuid = this.readUUID();
    if (SUPPORTED_UUIDS.indexOf(uuid)<0) {
        throw ("Could not deserialize ATN with UUID: " + uuid +
                        " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID);
    }
    this.uuid = uuid;
};

ATNDeserializer.prototype.readATN = function() {
    var grammarType = this.readInt();
    var maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
};

ATNDeserializer.prototype.readStates = function(atn) {
	var j, pair, stateNumber;
    var loopBackStateNumbers = [];
    var endStateNumbers = [];
    var nstates = this.readInt();
    for(var i=0; i<nstates; i++) {
        var stype = this.readInt();
        // ignore bad type of states
        if (stype===ATNState.INVALID_TYPE) {
            atn.addState(null);
            continue;
        }
        var ruleIndex = this.readInt();
        if (ruleIndex === 0xFFFF) {
            ruleIndex = -1;
        }
        var s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNState.LOOP_END) { // special case
            var loopBackStateNumber = this.readInt();
            loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if(s instanceof BlockStartState) {
            var endStateNumber = this.readInt();
            endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
    }
    // delay the assignment of loop back and end states until we know all the
	// state instances have been initialized
    for (j=0; j<loopBackStateNumbers.length; j++) {
        pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]];
    }

    for (j=0; j<endStateNumbers.length; j++) {
        pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
    }
    
    var numNonGreedyStates = this.readInt();
    for (j=0; j<numNonGreedyStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].nonGreedy = true;
    }

    var numPrecedenceStates = this.readInt();
    for (j=0; j<numPrecedenceStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].isPrecedenceRule = true;
    }
};

ATNDeserializer.prototype.readRules = function(atn) {
    var i;
    var nrules = this.readInt();
    if (atn.grammarType === ATNType.LEXER ) {
        atn.ruleToTokenType = initArray(nrules, 0);
    }
    atn.ruleToStartState = initArray(nrules, 0);
    for (i=0; i<nrules; i++) {
        var s = this.readInt();
        var startState = atn.states[s];
        atn.ruleToStartState[i] = startState;
        if ( atn.grammarType === ATNType.LEXER ) {
            var tokenType = this.readInt();
            if (tokenType === 0xFFFF) {
                tokenType = Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
        }
    }
    atn.ruleToStopState = initArray(nrules, 0);
    for (i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
            continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
};

ATNDeserializer.prototype.readModes = function(atn) {
    var nmodes = this.readInt();
    for (var i=0; i<nmodes; i++) {
        var s = this.readInt();
        atn.modeToStartState.push(atn.states[s]);
    }
};

ATNDeserializer.prototype.readSets = function(atn) {
    var sets = [];
    var m = this.readInt();
    for (var i=0; i<m; i++) {
        var iset = new IntervalSet();
        sets.push(iset);
        var n = this.readInt();
        var containsEof = this.readInt();
        if (containsEof!==0) {
            iset.addOne(-1);
        }
        for (var j=0; j<n; j++) {
            var i1 = this.readInt();
            var i2 = this.readInt();
            iset.addRange(i1, i2);
        }
    }
    return sets;
};

ATNDeserializer.prototype.readEdges = function(atn, sets) {
	var i, j, state, trans, target;
    var nedges = this.readInt();
    for (i=0; i<nedges; i++) {
        var src = this.readInt();
        var trg = this.readInt();
        var ttype = this.readInt();
        var arg1 = this.readInt();
        var arg2 = this.readInt();
        var arg3 = this.readInt();
        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        var srcState = atn.states[src];
        srcState.addTransition(trans);
    }
    // edges for rule stop states can be derived, so they aren't serialized
    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for (j=0; j<state.transitions.length; j++) {
            var t = state.transitions[j];
            if (!(t instanceof RuleTransition)) {
                continue;
            }
			var outermostPrecedenceReturn = -1;
			if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
				if (t.precedence === 0) {
					outermostPrecedenceReturn = t.target.ruleIndex;
				}
			}

			trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
    }

    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
            // we need to know the end state to set its start state
            if (state.endState === null) {
                throw ("IllegalState");
            }
            // block end states can only be associated to a single block start
			// state
            if ( state.endState.startState !== null) {
                throw ("IllegalState");
            }
            state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof PlusBlockStartState) {
                    target.loopBackState = state;
                }
            }
        } else if (state instanceof StarLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof StarLoopEntryState) {
                    target.loopBackState = state;
                }
            }
        }
    }
};

ATNDeserializer.prototype.readDecisions = function(atn) {
    var ndecisions = this.readInt();
    for (var i=0; i<ndecisions; i++) {
        var s = this.readInt();
        var decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
    }
};

ATNDeserializer.prototype.readLexerActions = function(atn) {
    if (atn.grammarType === ATNType.LEXER) {
        var count = this.readInt();
        atn.lexerActions = initArray(count, null);
        for (var i=0; i<count; i++) {
            var actionType = this.readInt();
            var data1 = this.readInt();
            if (data1 === 0xFFFF) {
                data1 = -1;
            }
            var data2 = this.readInt();
            if (data2 === 0xFFFF) {
                data2 = -1;
            }
            var lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[i] = lexerAction;
        }
    }
};

ATNDeserializer.prototype.generateRuleBypassTransitions = function(atn) {
	var i;
    var count = atn.ruleToStartState.length;
    for(i=0; i<count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for(i=0; i<count; i++) {
        this.generateRuleBypassTransition(atn, i);
    }
};

ATNDeserializer.prototype.generateRuleBypassTransition = function(atn, idx) {
	var i, state;
    var bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);

    var bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);

    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);

    bypassStop.startState = bypassStart;

    var excludeTransition = null;
    var endState = null;
    
    if (atn.ruleToStartState[idx].isPrecedenceRule) {
        // wrap from the beginning of the rule to the StarLoopEntryState
        endState = null;
        for(i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            if (this.stateIsEndStateFor(state, idx)) {
                endState = state;
                excludeTransition = state.loopBackState.transitions[0];
                break;
            }
        }
        if (excludeTransition === null) {
            throw ("Couldn't identify final state of the precedence rule prefix section.");
        }
    } else {
        endState = atn.ruleToStopState[idx];
    }
    
    // all non-excluded transitions that currently target end state need to
	// target blockEnd instead
    for(i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for(var j=0; j<state.transitions.length; j++) {
            var transition = state.transitions[j];
            if (transition === excludeTransition) {
                continue;
            }
            if (transition.target === endState) {
                transition.target = bypassStop;
            }
        }
    }

    // all transitions leaving the rule start state need to leave blockStart
	// instead
    var ruleToStartState = atn.ruleToStartState[idx];
    var count = ruleToStartState.transitions.length;
    while ( count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count-1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    // link the new states
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));

    var matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
};

ATNDeserializer.prototype.stateIsEndStateFor = function(state, idx) {
    if ( state.ruleIndex !== idx) {
        return null;
    }
    if (!( state instanceof StarLoopEntryState)) {
        return null;
    }
    var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!( maybeLoopEndState instanceof LoopEndState)) {
        return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions &&
        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
        return state;
    } else {
        return null;
    }
};

//
// Analyze the {@link StarLoopEntryState} states in the specified ATN to set
// the {@link StarLoopEntryState//precedenceRuleDecision} field to the
// correct value.
//
// @param atn The ATN.
//
ATNDeserializer.prototype.markPrecedenceDecisions = function(atn) {
	for(var i=0; i<atn.states.length; i++) {
		var state = atn.states[i];
		if (!( state instanceof StarLoopEntryState)) {
            continue;
        }
        // We analyze the ATN to determine if this ATN decision state is the
        // decision for the closure block that determines whether a
        // precedence rule should continue or complete.
        //
        if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
            if (maybeLoopEndState instanceof LoopEndState) {
                if ( maybeLoopEndState.epsilonOnlyTransitions &&
                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
                    state.precedenceRuleDecision = true;
                }
            }
        }
	}
};

ATNDeserializer.prototype.verifyATN = function(atn) {
    if (!this.deserializationOptions.verifyATN) {
        return;
    }
    // verify assumptions
	for(var i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (state === null) {
            continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== null);
        } else  if (state instanceof StarLoopEntryState) {
            this.checkCondition(state.loopBackState !== null);
            this.checkCondition(state.transitions.length === 2);
            if (state.transitions[0].target instanceof StarBlockStartState) {
                this.checkCondition(state.transitions[1].target instanceof LoopEndState);
                this.checkCondition(!state.nonGreedy);
            } else if (state.transitions[0].target instanceof LoopEndState) {
                this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
                this.checkCondition(state.nonGreedy);
            } else {
                throw("IllegalState");
            }
        } else if (state instanceof StarLoopbackState) {
            this.checkCondition(state.transitions.length === 1);
            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
            this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
            this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
            this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
            this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
            this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));
        }
	}
};

ATNDeserializer.prototype.checkCondition = function(condition, message) {
    if (!condition) {
        if (message === undefined || message===null) {
            message = "IllegalState";
        }
        throw (message);
    }
};

ATNDeserializer.prototype.readInt = function() {
    return this.data[this.pos++];
};

ATNDeserializer.prototype.readInt32 = function() {
    var low = this.readInt();
    var high = this.readInt();
    return low | (high << 16);
};

ATNDeserializer.prototype.readLong = function() {
    var low = this.readInt32();
    var high = this.readInt32();
    return (low & 0x00000000FFFFFFFF) | (high << 32);
};

function createByteToHex() {
	var bth = [];
	for (var i = 0; i < 256; i++) {
		bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
	}
	return bth;
}

var byteToHex = createByteToHex();
	
ATNDeserializer.prototype.readUUID = function() {
	var bb = [];
	for(var i=7;i>=0;i--) {
		var int = this.readInt();
		/* jshint bitwise: false */
		bb[(2*i)+1] = int & 0xFF;
		bb[2*i] = (int >> 8) & 0xFF;
	}
    return byteToHex[bb[0]] + byteToHex[bb[1]] +
    byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +
    byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +
    byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +
    byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +
    byteToHex[bb[10]] + byteToHex[bb[11]] +
    byteToHex[bb[12]] + byteToHex[bb[13]] +
    byteToHex[bb[14]] + byteToHex[bb[15]];
};

ATNDeserializer.prototype.edgeFactory = function(atn, type, src, trg, arg1, arg2, arg3, sets) {
    var target = atn.states[trg];
    switch(type) {
    case Transition.EPSILON:
        return new EpsilonTransition(target);
    case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
    case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
    case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
    case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
    case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.SET:
        return new SetTransition(target, sets[arg1]);
    case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
    case Transition.WILDCARD:
        return new WildcardTransition(target);
    default:
        throw "The specified transition type: " + type + " is not valid.";
    }
};

ATNDeserializer.prototype.stateFactory = function(type, ruleIndex) {
    if (this.stateFactories === null) {
        var sf = [];
        sf[ATNState.INVALID_TYPE] = null;
        sf[ATNState.BASIC] = function() { return new BasicState(); };
        sf[ATNState.RULE_START] = function() { return new RuleStartState(); };
        sf[ATNState.BLOCK_START] = function() { return new BasicBlockStartState(); };
        sf[ATNState.PLUS_BLOCK_START] = function() { return new PlusBlockStartState(); };
        sf[ATNState.STAR_BLOCK_START] = function() { return new StarBlockStartState(); };
        sf[ATNState.TOKEN_START] = function() { return new TokensStartState(); };
        sf[ATNState.RULE_STOP] = function() { return new RuleStopState(); };
        sf[ATNState.BLOCK_END] = function() { return new BlockEndState(); };
        sf[ATNState.STAR_LOOP_BACK] = function() { return new StarLoopbackState(); };
        sf[ATNState.STAR_LOOP_ENTRY] = function() { return new StarLoopEntryState(); };
        sf[ATNState.PLUS_LOOP_BACK] = function() { return new PlusLoopbackState(); };
        sf[ATNState.LOOP_END] = function() { return new LoopEndState(); };
        this.stateFactories = sf;
    }
    if (type>this.stateFactories.length || this.stateFactories[type] === null) {
        throw("The specified state type " + type + " is not valid.");
    } else {
        var s = this.stateFactories[type]();
        if (s!==null) {
            s.ruleIndex = ruleIndex;
            return s;
        }
    }
};

ATNDeserializer.prototype.lexerActionFactory = function(type, data1, data2) {
    if (this.actionFactories === null) {
        var af = [];
        af[LexerActionType.CHANNEL] = function(data1, data2) { return new LexerChannelAction(data1); };
        af[LexerActionType.CUSTOM] = function(data1, data2) { return new LexerCustomAction(data1, data2); };
        af[LexerActionType.MODE] = function(data1, data2) { return new LexerModeAction(data1); };
        af[LexerActionType.MORE] = function(data1, data2) { return LexerMoreAction.INSTANCE; };
        af[LexerActionType.POP_MODE] = function(data1, data2) { return LexerPopModeAction.INSTANCE; };
        af[LexerActionType.PUSH_MODE] = function(data1, data2) { return new LexerPushModeAction(data1); };
        af[LexerActionType.SKIP] = function(data1, data2) { return LexerSkipAction.INSTANCE; };
        af[LexerActionType.TYPE] = function(data1, data2) { return new LexerTypeAction(data1); };
        this.actionFactories = af;
    }
    if (type>this.actionFactories.length || this.actionFactories[type] === null) {
        throw("The specified lexer action type " + type + " is not valid.");
    } else {
        return this.actionFactories[type](data1, data2);
    }
};
   

exports.ATNDeserializer = ATNDeserializer;
},{"./../IntervalSet":19,"./../Token":27,"./ATN":29,"./ATNDeserializationOptions":32,"./ATNState":35,"./ATNType":36,"./LexerAction":38,"./Transition":43}],34:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

var DFAState = require('./../dfa/DFAState').DFAState;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var getCachedPredictionContext = require('./../PredictionContext').getCachedPredictionContext;

function ATNSimulator(atn, sharedContextCache) {
	
    // The context cache maps all PredictionContext objects that are ==
    //  to a single cached copy. This cache is shared across all contexts
    //  in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
    //  to use only cached nodes/graphs in addDFAState(). We don't want to
    //  fill this during closure() since there are lots of contexts that
    //  pop up but are not used ever again. It also greatly slows down closure().
    //
    //  <p>This cache makes a huge difference in memory and a little bit in speed.
    //  For the Java grammar on java.*, it dropped the memory requirements
    //  at the end from 25M to 16M. We don't store any of the full context
    //  graphs in the DFA because they are limited to local context only,
    //  but apparently there's a lot of repetition there as well. We optimize
    //  the config contexts before storing the config set in the DFA states
    //  by literally rebuilding them with cached subgraphs only.</p>
    //
    //  <p>I tried a cache for use during closure operations, that was
    //  whacked after each adaptivePredict(). It cost a little bit
    //  more time I think and doesn't save on the overall footprint
    //  so it's not worth the complexity.</p>
    ///
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());


ATNSimulator.prototype.getCachedContext = function(context) {
    if (this.sharedContextCache ===null) {
        return context;
    }
    var visited = {};
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
};

exports.ATNSimulator = ATNSimulator;

},{"./../PredictionContext":24,"./../dfa/DFAState":47,"./ATNConfigSet":31}],35:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// The following images show the relation of states and
// {@link ATNState//transitions} for various grammar constructs.
//
// <ul>
//
// <li>Solid edges marked with an &//0949; indicate a required
// {@link EpsilonTransition}.</li>
//
// <li>Dashed edges indicate locations where any transition derived from
// {@link Transition} might appear.</li>
//
// <li>Dashed nodes are place holders for either a sequence of linked
// {@link BasicState} states or the inclusion of a block representing a nested
// construct in one of the forms below.</li>
//
// <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
// any number of alternatives (one or more). Nodes without the {@code ...} only
// support the exact number of alternatives shown in the diagram.</li>
//
// </ul>
//
// <h2>Basic Blocks</h2>
//
// <h3>Rule</h3>
//
// <embed src="images/Rule.svg" type="image/svg+xml"/>
//
// <h3>Block of 1 or more alternatives</h3>
//
// <embed src="images/Block.svg" type="image/svg+xml"/>
//
// <h2>Greedy Loops</h2>
//
// <h3>Greedy Closure: {@code (...)*}</h3>
//
// <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Positive Closure: {@code (...)+}</h3>
//
// <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Optional: {@code (...)?}</h3>
//
// <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
//
// <h2>Non-Greedy Loops</h2>
//
// <h3>Non-Greedy Closure: {@code (...)*?}</h3>
//
// <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
//
// <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Optional: {@code (...)??}</h3>
//
// <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
//

var INITIAL_NUM_TRANSITIONS = 4;

function ATNState() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    // Track the transitions emanating from this ATN state.
    this.transitions = [];
    // Used to cache lookahead during parsing, not used during construction
    this.nextTokenWithinRule = null;
    return this;
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;

ATNState.serializationNames = [
            "INVALID",
            "BASIC",
            "RULE_START",
            "BLOCK_START",
            "PLUS_BLOCK_START",
            "STAR_BLOCK_START",
            "TOKEN_START",
            "RULE_STOP",
            "BLOCK_END",
            "STAR_LOOP_BACK",
            "STAR_LOOP_ENTRY",
            "PLUS_LOOP_BACK",
            "LOOP_END" ];

ATNState.INVALID_STATE_NUMBER = -1;

ATNState.prototype.toString = function() {
	return this.stateNumber;
};

ATNState.prototype.equals = function(other) {
    if (other instanceof ATNState) {
        return this.stateNumber===other.stateNumber;
    } else {
        return false;
    }
};

ATNState.prototype.isNonGreedyExitState = function() {
    return false;
};


ATNState.prototype.addTransition = function(trans, index) {
	if(index===undefined) {
		index = -1;
	}
    if (this.transitions.length===0) {
        this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {
        this.epsilonOnlyTransitions = false;
    }
    if (index===-1) {
        this.transitions.push(trans);
    } else {
        this.transitions.splice(index, 1, trans);
    }
};

function BasicState() {
	ATNState.call(this);
    this.stateType = ATNState.BASIC;
    return this;
}

BasicState.prototype = Object.create(ATNState.prototype);
BasicState.prototype.constructor = BasicState;


function DecisionState() {
	ATNState.call(this);
    this.decision = -1;
    this.nonGreedy = false;
    return this;
}

DecisionState.prototype = Object.create(ATNState.prototype);
DecisionState.prototype.constructor = DecisionState;


//  The start of a regular {@code (...)} block.
function BlockStartState() {
	DecisionState.call(this);
	this.endState = null;
	return this;
}

BlockStartState.prototype = Object.create(DecisionState.prototype);
BlockStartState.prototype.constructor = BlockStartState;


function BasicBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.BLOCK_START;
	return this;
}

BasicBlockStartState.prototype = Object.create(BlockStartState.prototype);
BasicBlockStartState.prototype.constructor = BasicBlockStartState;


// Terminal node of a simple {@code (a|b|c)} block.
function BlockEndState() {
	ATNState.call(this);
	this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
}

BlockEndState.prototype = Object.create(ATNState.prototype);
BlockEndState.prototype.constructor = BlockEndState;


// The last node in the ATN for a rule, unless that rule is the start symbol.
//  In that case, there is one transition to EOF. Later, we might encode
//  references to all calls to this rule to compute FOLLOW sets for
//  error handling.
//
function RuleStopState() {
	ATNState.call(this);
    this.stateType = ATNState.RULE_STOP;
    return this;
}

RuleStopState.prototype = Object.create(ATNState.prototype);
RuleStopState.prototype.constructor = RuleStopState;

function RuleStartState() {
	ATNState.call(this);
	this.stateType = ATNState.RULE_START;
	this.stopState = null;
	this.isPrecedenceRule = false;
	return this;
}

RuleStartState.prototype = Object.create(ATNState.prototype);
RuleStartState.prototype.constructor = RuleStartState;

// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
//  one to the loop back to start of the block and one to exit.
//
function PlusLoopbackState() {
	DecisionState.call(this);
	this.stateType = ATNState.PLUS_LOOP_BACK;
	return this;
}

PlusLoopbackState.prototype = Object.create(DecisionState.prototype);
PlusLoopbackState.prototype.constructor = PlusLoopbackState;
        

// Start of {@code (A|B|...)+} loop. Technically a decision state, but
//  we don't use for code generation; somebody might need it, so I'm defining
//  it for completeness. In reality, the {@link PlusLoopbackState} node is the
//  real decision-making note for {@code A+}.
//
function PlusBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
}

PlusBlockStartState.prototype = Object.create(BlockStartState.prototype);
PlusBlockStartState.prototype.constructor = PlusBlockStartState;

// The block that begins a closure loop.
function StarBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.STAR_BLOCK_START;
	return this;
}

StarBlockStartState.prototype = Object.create(BlockStartState.prototype);
StarBlockStartState.prototype.constructor = StarBlockStartState;


function StarLoopbackState() {
	ATNState.call(this);
	this.stateType = ATNState.STAR_LOOP_BACK;
	return this;
}

StarLoopbackState.prototype = Object.create(ATNState.prototype);
StarLoopbackState.prototype.constructor = StarLoopbackState;


function StarLoopEntryState() {
	DecisionState.call(this);
	this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
    this.precedenceRuleDecision = null;
    return this;
}

StarLoopEntryState.prototype = Object.create(DecisionState.prototype);
StarLoopEntryState.prototype.constructor = StarLoopEntryState;


// Mark the end of a * or + loop.
function LoopEndState() {
	ATNState.call(this);
	this.stateType = ATNState.LOOP_END;
	this.loopBackState = null;
	return this;
}

LoopEndState.prototype = Object.create(ATNState.prototype);
LoopEndState.prototype.constructor = LoopEndState;


// The Tokens rule start state linking to each lexer rule start state */
function TokensStartState() {
	DecisionState.call(this);
	this.stateType = ATNState.TOKEN_START;
	return this;
}

TokensStartState.prototype = Object.create(DecisionState.prototype);
TokensStartState.prototype.constructor = TokensStartState;

exports.ATNState = ATNState;
exports.BasicState = BasicState;
exports.DecisionState = DecisionState;
exports.BlockStartState = BlockStartState;
exports.BlockEndState = BlockEndState;
exports.LoopEndState = LoopEndState;
exports.RuleStartState = RuleStartState;
exports.RuleStopState = RuleStopState;
exports.TokensStartState = TokensStartState;
exports.PlusLoopbackState = PlusLoopbackState;
exports.StarLoopbackState = StarLoopbackState;
exports.StarLoopEntryState = StarLoopEntryState;
exports.PlusBlockStartState = PlusBlockStartState;
exports.StarBlockStartState = StarBlockStartState;
exports.BasicBlockStartState = BasicBlockStartState;

},{}],36:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// Represents the type of recognizer an ATN applies to.

function ATNType() {
	
}

ATNType.LEXER = 0;
ATNType.PARSER = 1;

exports.ATNType = ATNType;


},{}],37:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// When we hit an accept state in either the DFA or the ATN, we
//  have to notify the character stream to start buffering characters
//  via {@link IntStream//mark} and record the current state. The current sim state
//  includes the current index into the input, the current line,
//  and current character position in that line. Note that the Lexer is
//  tracking the starting line and characterization of the token. These
//  variables track the "state" of the simulator when it hits an accept state.
//
//  <p>We track these variables separately for the DFA and ATN simulation
//  because the DFA simulation often has to fail over to the ATN
//  simulation. If the ATN simulation fails, we need the DFA to fall
//  back to its previously accepted state, if any. If the ATN succeeds,
//  then the ATN does the accept and the DFA simulator that invoked it
//  can simply return the predicted token type.</p>
///

var Token = require('./../Token').Token;
var Lexer = require('./../Lexer').Lexer;
var ATN = require('./ATN').ATN;
var ATNSimulator = require('./ATNSimulator').ATNSimulator;
var DFAState = require('./../dfa/DFAState').DFAState;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var OrderedATNConfigSet = require('./ATNConfigSet').OrderedATNConfigSet;
var PredictionContext = require('./../PredictionContext').PredictionContext;
var SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;
var RuleStopState = require('./ATNState').RuleStopState;
var LexerATNConfig = require('./ATNConfig').LexerATNConfig;
var Transition = require('./Transition').Transition;
var LexerActionExecutor = require('./LexerActionExecutor').LexerActionExecutor;
var LexerNoViableAltException = require('./../error/Errors').LexerNoViableAltException;

function resetSimState(sim) {
	sim.index = -1;
	sim.line = 0;
	sim.column = -1;
	sim.dfaState = null;
}

function SimState() {
	resetSimState(this);
	return this;
}

SimState.prototype.reset = function() {
	resetSimState(this);
};

function LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
	this.decisionToDFA = decisionToDFA;
	this.recog = recog;
	// The current token's starting index into the character stream.
	// Shared across DFA to ATN simulation in case the ATN fails and the
	// DFA did not have a previous accept state. In this case, we use the
	// ATN-generated exception object.
	this.startIndex = -1;
	// line number 1..n within the input///
	this.line = 1;
	// The index of the character relative to the beginning of the line
	// 0..n-1///
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
	// Used during DFA/ATN exec to record the most recent accept configuration
	// info
	this.prevAccept = new SimState();
	// done
	return this;
}

LexerATNSimulator.prototype = Object.create(ATNSimulator.prototype);
LexerATNSimulator.prototype.constructor = LexerATNSimulator;

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;

LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;

LexerATNSimulator.prototype.copyState = function(simulator) {
	this.column = simulator.column;
	this.line = simulator.line;
	this.mode = simulator.mode;
	this.startIndex = simulator.startIndex;
};

LexerATNSimulator.prototype.match = function(input, mode) {
	this.match_calls += 1;
	this.mode = mode;
	var mark = input.mark();
	try {
		this.startIndex = input.index;
		this.prevAccept.reset();
		var dfa = this.decisionToDFA[mode];
		if (dfa.s0 === null) {
			return this.matchATN(input);
		} else {
			return this.execATN(input, dfa.s0);
		}
	} finally {
		input.release(mark);
	}
};

LexerATNSimulator.prototype.reset = function() {
	this.prevAccept.reset();
	this.startIndex = -1;
	this.line = 1;
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
};

LexerATNSimulator.prototype.matchATN = function(input) {
	var startState = this.atn.modeToStartState[this.mode];

	if (this.debug) {
		console.log("matchATN mode " + this.mode + " start: " + startState);
	}
	var old_mode = this.mode;
	var s0_closure = this.computeStartState(input, startState);
	var suppressEdge = s0_closure.hasSemanticContext;
	s0_closure.hasSemanticContext = false;

	var next = this.addDFAState(s0_closure);
	if (!suppressEdge) {
		this.decisionToDFA[this.mode].s0 = next;
	}

	var predict = this.execATN(input, next);

	if (this.debug) {
		console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
	}
	return predict;
};

LexerATNSimulator.prototype.execATN = function(input, ds0) {
	if (this.debug) {
		console.log("start state closure=" + ds0.configs);
	}
	if (ds0.isAcceptState) {
		// allow zero-length tokens
		this.captureSimState(this.prevAccept, input, ds0);
	}
	var t = input.LA(1);
	var s = ds0; // s is current/from DFA state

	while (true) { // while more work
		if (this.debug) {
			console.log("execATN loop starting closure: " + s.configs);
		}

		// As we move src->trg, src->trg, we keep track of the previous trg to
		// avoid looking up the DFA state again, which is expensive.
		// If the previous target was already part of the DFA, we might
		// be able to avoid doing a reach operation upon t. If s!=null,
		// it means that semantic predicates didn't prevent us from
		// creating a DFA state. Once we know s!=null, we check to see if
		// the DFA state has an edge already for t. If so, we can just reuse
		// it's configuration set; there's no point in re-computing it.
		// This is kind of like doing DFA simulation within the ATN
		// simulation because DFA simulation is really just a way to avoid
		// computing reach/closure sets. Technically, once we know that
		// we have a previously added DFA state, we could jump over to
		// the DFA simulator. But, that would mean popping back and forth
		// a lot and making things more complicated algorithmically.
		// This optimization makes a lot of sense for loops within DFA.
		// A character will take us back to an existing DFA state
		// that already has lots of edges out of it. e.g., .* in comments.
		// print("Target for:" + str(s) + " and:" + str(t))
		var target = this.getExistingTargetState(s, t);
		// print("Existing:" + str(target))
		if (target === null) {
			target = this.computeTargetState(input, s, t);
			// print("Computed:" + str(target))
		}
		if (target === ATNSimulator.ERROR) {
			break;
		}
		// If this is a consumable input element, make sure to consume before
		// capturing the accept state so the input index, line, and char
		// position accurately reflect the state of the interpreter at the
		// end of the token.
		if (t !== Token.EOF) {
			this.consume(input);
		}
		if (target.isAcceptState) {
			this.captureSimState(this.prevAccept, input, target);
			if (t === Token.EOF) {
				break;
			}
		}
		t = input.LA(1);
		s = target; // flip; current DFA target becomes new src/from state
	}
	return this.failOrAccept(this.prevAccept, input, s.configs, t);
};

// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param s The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
LexerATNSimulator.prototype.getExistingTargetState = function(s, t) {
	if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
		return null;
	}

	var target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
	if(target===undefined) {
		target = null;
	}
	if (this.debug && target !== null) {
		console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
	}
	return target;
};

// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param input The input stream
// @param s The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
LexerATNSimulator.prototype.computeTargetState = function(input, s, t) {
	var reach = new OrderedATNConfigSet();
	// if we don't find an existing DFA state
	// Fill reach starting from closure, following t transitions
	this.getReachableConfigSet(input, s.configs, reach, t);

	if (reach.items.length === 0) { // we got nowhere on t from s
		if (!reach.hasSemanticContext) {
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			this.addDFAEdge(s, t, ATNSimulator.ERROR);
		}
		// stop when we can't match any more char
		return ATNSimulator.ERROR;
	}
	// Add an edge from s to target DFA found/created for reach
	return this.addDFAEdge(s, t, null, reach);
};

LexerATNSimulator.prototype.failOrAccept = function(prevAccept, input, reach, t) {
	if (this.prevAccept.dfaState !== null) {
		var lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
		this.accept(input, lexerActionExecutor, this.startIndex,
				prevAccept.index, prevAccept.line, prevAccept.column);
		return prevAccept.dfaState.prediction;
	} else {
		// if no accept and EOF is first char, return EOF
		if (t === Token.EOF && input.index === this.startIndex) {
			return Token.EOF;
		}
		throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
	}
};

// Given a starting configuration set, figure out all ATN configurations
// we can reach upon input {@code t}. Parameter {@code reach} is a return
// parameter.
LexerATNSimulator.prototype.getReachableConfigSet = function(input, closure,
		reach, t) {
	// this is used to skip processing for configs which have a lower priority
	// than a config that already reached an accept state for the same rule
	var skipAlt = ATN.INVALID_ALT_NUMBER;
	for (var i = 0; i < closure.items.length; i++) {
		var cfg = closure.items[i];
		var currentAltReachedAcceptState = (cfg.alt === skipAlt);
		if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
			continue;
		}
		if (this.debug) {
			console.log("testing %s at %s\n", this.getTokenName(t), cfg
					.toString(this.recog, true));
		}
		for (var j = 0; j < cfg.state.transitions.length; j++) {
			var trans = cfg.state.transitions[j]; // for each transition
			var target = this.getReachableTarget(trans, t);
			if (target !== null) {
				var lexerActionExecutor = cfg.lexerActionExecutor;
				if (lexerActionExecutor !== null) {
					lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
				}
				var treatEofAsEpsilon = (t === Token.EOF);
				var config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);
				if (this.closure(input, config, reach,
						currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
					// any remaining configs for this alt have a lower priority
					// than the one that just reached an accept state.
					skipAlt = cfg.alt;
				}
			}
		}
	}
};

LexerATNSimulator.prototype.accept = function(input, lexerActionExecutor,
		startIndex, index, line, charPos) {
	if (this.debug) {
		console.log("ACTION %s\n", lexerActionExecutor);
	}
	// seek to after last char in token
	input.seek(index);
	this.line = line;
	this.column = charPos;
	if (lexerActionExecutor !== null && this.recog !== null) {
		lexerActionExecutor.execute(this.recog, input, startIndex);
	}
};

LexerATNSimulator.prototype.getReachableTarget = function(trans, t) {
	if (trans.matches(t, 0, 0xFFFE)) {
		return trans.target;
	} else {
		return null;
	}
};

LexerATNSimulator.prototype.computeStartState = function(input, p) {
	var initialContext = PredictionContext.EMPTY;
	var configs = new OrderedATNConfigSet();
	for (var i = 0; i < p.transitions.length; i++) {
		var target = p.transitions[i].target;
        var cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);
		this.closure(input, cfg, configs, false, false, false);
	}
	return configs;
};

// Since the alternatives within any lexer decision are ordered by
// preference, this method stops pursuing the closure as soon as an accept
// state is reached. After the first accept state is reached by depth-first
// search from {@code config}, all other (potentially reachable) states for
// this rule would have a lower priority.
//
// @return {@code true} if an accept state is reached, otherwise
// {@code false}.
LexerATNSimulator.prototype.closure = function(input, config, configs,
		currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (this.debug) {
		console.log("closure(" + config.toString(this.recog, true) + ")");
	}
	if (config.state instanceof RuleStopState) {
		if (this.debug) {
			if (this.recog !== null) {
				console.log("closure at %s rule stop %s\n", this.recog.getRuleNames()[config.state.ruleIndex], config);
			} else {
				console.log("closure at rule stop %s\n", config);
			}
		}
		if (config.context === null || config.context.hasEmptyPath()) {
			if (config.context === null || config.context.isEmpty()) {
				configs.add(config);
				return true;
			} else {
				configs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));
				currentAltReachedAcceptState = true;
			}
		}
		if (config.context !== null && !config.context.isEmpty()) {
			for (var i = 0; i < config.context.length; i++) {
				if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
					var newContext = config.context.getParent(i); // "pop" return state
					var returnState = this.atn.states[config.context.getReturnState(i)];
					cfg = new LexerATNConfig({ state:returnState, context:newContext }, config);
					currentAltReachedAcceptState = this.closure(input, cfg,
							configs, currentAltReachedAcceptState, speculative,
							treatEofAsEpsilon);
				}
			}
		}
		return currentAltReachedAcceptState;
	}
	// optimization
	if (!config.state.epsilonOnlyTransitions) {
		if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
			configs.add(config);
		}
	}
	for (var j = 0; j < config.state.transitions.length; j++) {
		var trans = config.state.transitions[j];
		cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
		if (cfg !== null) {
			currentAltReachedAcceptState = this.closure(input, cfg, configs,
					currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
		}
	}
	return currentAltReachedAcceptState;
};

// side-effect: can alter configs.hasSemanticContext
LexerATNSimulator.prototype.getEpsilonTarget = function(input, config, trans,
		configs, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (trans.serializationType === Transition.RULE) {
		var newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
		cfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);
	} else if (trans.serializationType === Transition.PRECEDENCE) {
		throw "Precedence predicates are not supported in lexers.";
	} else if (trans.serializationType === Transition.PREDICATE) {
		// Track traversing semantic predicates. If we traverse,
		// we cannot add a DFA state for this "reach" computation
		// because the DFA would not test the predicate again in the
		// future. Rather than creating collections of semantic predicates
		// like v3 and testing them on prediction, v4 will test them on the
		// fly all the time using the ATN not the DFA. This is slower but
		// semantically it's not used that often. One of the key elements to
		// this predicate mechanism is not adding DFA states that see
		// predicates immediately afterwards in the ATN. For example,

		// a : ID {p1}? | ID {p2}? ;

		// should create the start state for rule 'a' (to save start state
		// competition), but should not create target of ID state. The
		// collection of ATN states the following ID references includes
		// states reached by traversing predicates. Since this is when we
		// test them, we cannot cash the DFA state target of ID.

		if (this.debug) {
			console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
		}
		configs.hasSemanticContext = true;
		if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
			cfg = new LexerATNConfig({ state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.ACTION) {
		if (config.context === null || config.context.hasEmptyPath()) {
			// execute actions anywhere in the start rule for a token.
			//
			// TODO: if the entry rule is invoked recursively, some
			// actions may be executed during the recursive call. The
			// problem can appear when hasEmptyPath() is true but
			// isEmpty() is false. In this case, the config needs to be
			// split into two contexts - one with just the empty path
			// and another with everything but the empty path.
			// Unfortunately, the current algorithm does not allow
			// getEpsilonTarget to return two configurations, so
			// additional modifications are needed before we can support
			// the split operation.
			var lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,
					this.atn.lexerActions[trans.actionIndex]);
			cfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);
		} else {
			// ignore actions in referenced rules
			cfg = new LexerATNConfig( { state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.EPSILON) {
		cfg = new LexerATNConfig({ state:trans.target}, config);
	} else if (trans.serializationType === Transition.ATOM ||
				trans.serializationType === Transition.RANGE ||
				trans.serializationType === Transition.SET) {
		if (treatEofAsEpsilon) {
			if (trans.matches(Token.EOF, 0, 0xFFFF)) {
				cfg = new LexerATNConfig( { state:trans.target }, config);
			}
		}
	}
	return cfg;
};

// Evaluate a predicate specified in the lexer.
//
// <p>If {@code speculative} is {@code true}, this method was called before
// {@link //consume} for the matched character. This method should call
// {@link //consume} before evaluating the predicate to ensure position
// sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
// and {@link Lexer//getcolumn}, properly reflect the current
// lexer state. This method should restore {@code input} and the simulator
// to the original state before returning (i.e. undo the actions made by the
// call to {@link //consume}.</p>
//
// @param input The input stream.
// @param ruleIndex The rule containing the predicate.
// @param predIndex The index of the predicate within the rule.
// @param speculative {@code true} if the current index in {@code input} is
// one character before the predicate's location.
//
// @return {@code true} if the specified predicate evaluates to
// {@code true}.
// /
LexerATNSimulator.prototype.evaluatePredicate = function(input, ruleIndex,
		predIndex, speculative) {
	// assume true if no recognizer was provided
	if (this.recog === null) {
		return true;
	}
	if (!speculative) {
		return this.recog.sempred(null, ruleIndex, predIndex);
	}
	var savedcolumn = this.column;
	var savedLine = this.line;
	var index = input.index;
	var marker = input.mark();
	try {
		this.consume(input);
		return this.recog.sempred(null, ruleIndex, predIndex);
	} finally {
		this.column = savedcolumn;
		this.line = savedLine;
		input.seek(index);
		input.release(marker);
	}
};

LexerATNSimulator.prototype.captureSimState = function(settings, input, dfaState) {
	settings.index = input.index;
	settings.line = this.line;
	settings.column = this.column;
	settings.dfaState = dfaState;
};

LexerATNSimulator.prototype.addDFAEdge = function(from_, tk, to, cfgs) {
	if (to === undefined) {
		to = null;
	}
	if (cfgs === undefined) {
		cfgs = null;
	}
	if (to === null && cfgs !== null) {
		// leading to this call, ATNConfigSet.hasSemanticContext is used as a
		// marker indicating dynamic predicate evaluation makes this edge
		// dependent on the specific input sequence, so the static edge in the
		// DFA should be omitted. The target DFAState is still created since
		// execATN has the ability to resynchronize with the DFA state cache
		// following the predicate evaluation step.
		//
		// TJP notes: next time through the DFA, we see a pred again and eval.
		// If that gets us to a previously created (but dangling) DFA
		// state, we can continue in pure DFA mode from there.
		// /
		var suppressEdge = cfgs.hasSemanticContext;
		cfgs.hasSemanticContext = false;

		to = this.addDFAState(cfgs);

		if (suppressEdge) {
			return to;
		}
	}
	// add the edge
	if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
		// Only track edges within the DFA bounds
		return to;
	}
	if (this.debug) {
		console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
	}
	if (from_.edges === null) {
		// make room for tokens 1..n and -1 masquerading as index 0
		from_.edges = [];
	}
	from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

	return to;
};

// Add a new DFA state if there isn't one with this set of
// configurations already. This method also detects the first
// configuration containing an ATN rule stop state. Later, when
// traversing the DFA, we will know which rule to accept.
LexerATNSimulator.prototype.addDFAState = function(configs) {
	var proposed = new DFAState(null, configs);
	var firstConfigWithRuleStopState = null;
	for (var i = 0; i < configs.items.length; i++) {
		var cfg = configs.items[i];
		if (cfg.state instanceof RuleStopState) {
			firstConfigWithRuleStopState = cfg;
			break;
		}
	}
	if (firstConfigWithRuleStopState !== null) {
		proposed.isAcceptState = true;
		proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
		proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
	}
	var hash = proposed.hashString();
	var dfa = this.decisionToDFA[this.mode];
	var existing = dfa.states[hash] || null;
	if (existing!==null) {
		return existing;
	}
	var newState = proposed;
	newState.stateNumber = dfa.states.length;
	configs.setReadonly(true);
	newState.configs = configs;
	dfa.states[hash] = newState;
	return newState;
};

LexerATNSimulator.prototype.getDFA = function(mode) {
	return this.decisionToDFA[mode];
};

// Get the text matched so far for the current token.
LexerATNSimulator.prototype.getText = function(input) {
	// index is first lookahead char, don't include.
	return input.getText(this.startIndex, input.index - 1);
};

LexerATNSimulator.prototype.consume = function(input) {
	var curChar = input.LA(1);
	if (curChar === "\n".charCodeAt(0)) {
		this.line += 1;
		this.column = 0;
	} else {
		this.column += 1;
	}
	input.consume();
};

LexerATNSimulator.prototype.getTokenName = function(tt) {
	if (tt === -1) {
		return "EOF";
	} else {
		return "'" + String.fromCharCode(tt) + "'";
	}
};

exports.LexerATNSimulator = LexerATNSimulator;

},{"./../Lexer":21,"./../PredictionContext":24,"./../Token":27,"./../dfa/DFAState":47,"./../error/Errors":52,"./ATN":29,"./ATNConfig":30,"./ATNConfigSet":31,"./ATNSimulator":34,"./ATNState":35,"./LexerActionExecutor":39,"./Transition":43}],38:[function(require,module,exports){
//
 //[The "BSD license"]
 // Copyright (c) 2013 Terence Parr
 // Copyright (c) 2013 Sam Harwell
 // Copyright (c) 2014 Eric Vergnaud
 // All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions
 // are met:
 //
 // 1. Redistributions of source code must retain the above copyright
 //    notice, this list of conditions and the following disclaimer.
 // 2. Redistributions in binary form must reproduce the above copyright
 //    notice, this list of conditions and the following disclaimer in the
 //    documentation and/or other materials provided with the distribution.
 // 3. The name of the author may not be used to endorse or promote products
 //    derived from this software without specific prior written permission.
 //
 // THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 // OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 // IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 // INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 // NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //

function LexerActionType() {
}

LexerActionType.CHANNEL = 0;     //The type of a {@link LexerChannelAction} action.
LexerActionType.CUSTOM = 1;      //The type of a {@link LexerCustomAction} action.
LexerActionType.MODE = 2;        //The type of a {@link LexerModeAction} action.
LexerActionType.MORE = 3;        //The type of a {@link LexerMoreAction} action.
LexerActionType.POP_MODE = 4;    //The type of a {@link LexerPopModeAction} action.
LexerActionType.PUSH_MODE = 5;   //The type of a {@link LexerPushModeAction} action.
LexerActionType.SKIP = 6;        //The type of a {@link LexerSkipAction} action.
LexerActionType.TYPE = 7;        //The type of a {@link LexerTypeAction} action.

function LexerAction(action) {
    this.actionType = action;
    this.isPositionDependent = false;
    return this;
}

LexerAction.prototype.hashString = function() {
    return "" + this.actionType;
};

LexerAction.prototype.equals = function(other) {
    return this === other;
};



//
// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
//
// <p>The {@code skip} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerSkipAction() {
	LexerAction.call(this, LexerActionType.SKIP);
	return this;
}

LexerSkipAction.prototype = Object.create(LexerAction.prototype);
LexerSkipAction.prototype.constructor = LexerSkipAction;

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

LexerSkipAction.prototype.execute = function(lexer) {
    lexer.skip();
};

LexerSkipAction.prototype.toString = function() {
	return "skip";
};

//  Implements the {@code type} lexer action by calling {@link Lexer//setType}
// with the assigned type.
function LexerTypeAction(type) {
	LexerAction.call(this, LexerActionType.TYPE);
	this.type = type;
	return this;
}

LexerTypeAction.prototype = Object.create(LexerAction.prototype);
LexerTypeAction.prototype.constructor = LexerTypeAction;

LexerTypeAction.prototype.execute = function(lexer) {
    lexer.type = this.type;
};

LexerTypeAction.prototype.hashString = function() {
	return "" + this.actionType + this.type;
};


LexerTypeAction.prototype.equals = function(other) {
    if(this === other) {
        return true;
    } else if (! (other instanceof LexerTypeAction)) {
        return false;
    } else {
        return this.type === other.type;
    }
};

LexerTypeAction.prototype.toString = function() {
    return "type(" + this.type + ")";
};

// Implements the {@code pushMode} lexer action by calling
// {@link Lexer//pushMode} with the assigned mode.
function LexerPushModeAction(mode) {
	LexerAction.call(this, LexerActionType.PUSH_MODE);
    this.mode = mode;
    return this;
}

LexerPushModeAction.prototype = Object.create(LexerAction.prototype);
LexerPushModeAction.prototype.constructor = LexerPushModeAction;

// <p>This action is implemented by calling {@link Lexer//pushMode} with the
// value provided by {@link //getMode}.</p>
LexerPushModeAction.prototype.execute = function(lexer) {
    lexer.pushMode(this.mode);
};

LexerPushModeAction.prototype.hashString = function() {
    return "" + this.actionType + this.mode;
};

LexerPushModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerPushModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerPushModeAction.prototype.toString = function() {
	return "pushMode(" + this.mode + ")";
};


// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
//
// <p>The {@code popMode} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerPopModeAction() {
	LexerAction.call(this,LexerActionType.POP_MODE);
	return this;
}

LexerPopModeAction.prototype = Object.create(LexerAction.prototype);
LexerPopModeAction.prototype.constructor = LexerPopModeAction;

LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerPopModeAction.prototype.execute = function(lexer) {
    lexer.popMode();
};

LexerPopModeAction.prototype.toString = function() {
	return "popMode";
};

// Implements the {@code more} lexer action by calling {@link Lexer//more}.
//
// <p>The {@code more} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerMoreAction() {
	LexerAction.call(this, LexerActionType.MORE);
	return this;
}

LexerMoreAction.prototype = Object.create(LexerAction.prototype);
LexerMoreAction.prototype.constructor = LexerMoreAction;

LexerMoreAction.INSTANCE = new LexerMoreAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerMoreAction.prototype.execute = function(lexer) {
    lexer.more();
};

LexerMoreAction.prototype.toString = function() {
    return "more";
};


// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
// the assigned mode.
function LexerModeAction(mode) {
	LexerAction.call(this, LexerActionType.MODE);
    this.mode = mode;
    return this;
}

LexerModeAction.prototype = Object.create(LexerAction.prototype);
LexerModeAction.prototype.constructor = LexerModeAction;

// <p>This action is implemented by calling {@link Lexer//mode} with the
// value provided by {@link //getMode}.</p>
LexerModeAction.prototype.execute = function(lexer) {
    lexer.mode(this.mode);
};

LexerModeAction.prototype.hashString = function() {
	return "" + this.actionType + this.mode;
};

LexerModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerModeAction.prototype.toString = function() {
    return "mode(" + this.mode + ")";
};

// Executes a custom lexer action by calling {@link Recognizer//action} with the
// rule and action indexes assigned to the custom action. The implementation of
// a custom action is added to the generated code for the lexer in an override
// of {@link Recognizer//action} when the grammar is compiled.
//
// <p>This class may represent embedded actions created with the <code>{...}</code>
// syntax in ANTLR 4, as well as actions created for lexer commands where the
// command argument could not be evaluated when the grammar was compiled.</p>


    // Constructs a custom lexer action with the specified rule and action
    // indexes.
    //
    // @param ruleIndex The rule index to use for calls to
    // {@link Recognizer//action}.
    // @param actionIndex The action index to use for calls to
    // {@link Recognizer//action}.

function LexerCustomAction(ruleIndex, actionIndex) {
	LexerAction.call(this, LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
    return this;
}

LexerCustomAction.prototype = Object.create(LexerAction.prototype);
LexerCustomAction.prototype.constructor = LexerCustomAction;

// <p>Custom actions are implemented by calling {@link Lexer//action} with the
// appropriate rule and action indexes.</p>
LexerCustomAction.prototype.execute = function(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.hashString = function() {
    return "" + this.actionType + this.ruleIndex + this.actionIndex;
};

LexerCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerCustomAction)) {
        return false;
    } else {
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
};

// Implements the {@code channel} lexer action by calling
// {@link Lexer//setChannel} with the assigned channel.
// Constructs a new {@code channel} action with the specified channel value.
// @param channel The channel value to pass to {@link Lexer//setChannel}.
function LexerChannelAction(channel) {
	LexerAction.call(this, LexerActionType.CHANNEL);
    this.channel = channel;
    return this;
}

LexerChannelAction.prototype = Object.create(LexerAction.prototype);
LexerChannelAction.prototype.constructor = LexerChannelAction;

// <p>This action is implemented by calling {@link Lexer//setChannel} with the
// value provided by {@link //getChannel}.</p>
LexerChannelAction.prototype.execute = function(lexer) {
    lexer._channel = this.channel;
};

LexerChannelAction.prototype.hashString = function() {
    return "" + this.actionType + this.channel;
};

LexerChannelAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerChannelAction)) {
        return false;
    } else {
        return this.channel === other.channel;
    }
};

LexerChannelAction.prototype.toString = function() {
    return "channel(" + this.channel + ")";
};

// This implementation of {@link LexerAction} is used for tracking input offsets
// for position-dependent actions within a {@link LexerActionExecutor}.
//
// <p>This action is not serialized as part of the ATN, and is only required for
// position-dependent lexer actions which appear at a location other than the
// end of a rule. For more information about DFA optimizations employed for
// lexer actions, see {@link LexerActionExecutor//append} and
// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>

// Constructs a new indexed custom action by associating a character offset
// with a {@link LexerAction}.
//
// <p>Note: This class is only required for lexer actions for which
// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
//
// @param offset The offset into the input {@link CharStream}, relative to
// the token start index, at which the specified lexer action should be
// executed.
// @param action The lexer action to execute at a particular offset in the
// input {@link CharStream}.
function LexerIndexedCustomAction(offset, action) {
	LexerAction.call(this, action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
    return this;
}

LexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);
LexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction;

// <p>This method calls {@link //execute} on the result of {@link //getAction}
// using the provided {@code lexer}.</p>
LexerIndexedCustomAction.prototype.execute = function(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
};

LexerIndexedCustomAction.prototype.hashString = function() {
    return "" + this.actionType + this.offset + this.action;
};

LexerIndexedCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerIndexedCustomAction)) {
        return false;
    } else {
        return this.offset === other.offset && this.action === other.action;
    }
};


exports.LexerActionType = LexerActionType;
exports.LexerSkipAction = LexerSkipAction;
exports.LexerChannelAction = LexerChannelAction;
exports.LexerCustomAction = LexerCustomAction;
exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
exports.LexerMoreAction = LexerMoreAction;
exports.LexerTypeAction = LexerTypeAction;
exports.LexerPushModeAction = LexerPushModeAction;
exports.LexerPopModeAction = LexerPopModeAction;
exports.LexerModeAction = LexerModeAction;
},{}],39:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2013 Terence Parr
//  Copyright (c) 2013 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// Represents an executor for a sequence of lexer actions which traversed during
// the matching operation of a lexer rule (token).
//
// <p>The executor tracks position information for position-dependent lexer actions
// efficiently, ensuring that actions appearing only at the end of the rule do
// not cause bloating of the {@link DFA} created for the lexer.</p>

var LexerIndexedCustomAction = require('./LexerAction').LexerIndexedCustomAction;

function LexerActionExecutor(lexerActions) {
	this.lexerActions = lexerActions === null ? [] : lexerActions;
	// Caches the result of {@link //hashCode} since the hash code is an element
	// of the performance-critical {@link LexerATNConfig//hashCode} operation.
	this.hashString = lexerActions.toString(); // "".join([str(la) for la in
	// lexerActions]))
	return this;
}

// Creates a {@link LexerActionExecutor} which executes the actions for
// the input {@code lexerActionExecutor} followed by a specified
// {@code lexerAction}.
//
// @param lexerActionExecutor The executor for actions already traversed by
// the lexer while matching a token within a particular
// {@link LexerATNConfig}. If this is {@code null}, the method behaves as
// though it were an empty executor.
// @param lexerAction The lexer action to execute after the actions
// specified in {@code lexerActionExecutor}.
//
// @return A {@link LexerActionExecutor} for executing the combine actions
// of {@code lexerActionExecutor} and {@code lexerAction}.
LexerActionExecutor.append = function(lexerActionExecutor, lexerAction) {
	if (lexerActionExecutor === null) {
		return new LexerActionExecutor([ lexerAction ]);
	}
	var lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);
	return new LexerActionExecutor(lexerActions);
};

// Creates a {@link LexerActionExecutor} which encodes the current offset
// for position-dependent lexer actions.
//
// <p>Normally, when the executor encounters lexer actions where
// {@link LexerAction//isPositionDependent} returns {@code true}, it calls
// {@link IntStream//seek} on the input {@link CharStream} to set the input
// position to the <em>end</em> of the current token. This behavior provides
// for efficient DFA representation of lexer actions which appear at the end
// of a lexer rule, even when the lexer rule matches a variable number of
// characters.</p>
//
// <p>Prior to traversing a match transition in the ATN, the current offset
// from the token start index is assigned to all position-dependent lexer
// actions which have not already been assigned a fixed offset. By storing
// the offsets relative to the token start index, the DFA representation of
// lexer actions which appear in the middle of tokens remains efficient due
// to sharing among tokens of the same length, regardless of their absolute
// position in the input stream.</p>
//
// <p>If the current executor already has offsets assigned to all
// position-dependent lexer actions, the method returns {@code this}.</p>
//
// @param offset The current offset to assign to all position-dependent
// lexer actions which do not already have offsets assigned.
//
// @return A {@link LexerActionExecutor} which stores input stream offsets
// for all position-dependent lexer actions.
// /
LexerActionExecutor.prototype.fixOffsetBeforeMatch = function(offset) {
	var updatedLexerActions = null;
	for (var i = 0; i < this.lexerActions.length; i++) {
		if (this.lexerActions[i].isPositionDependent &&
				!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
			if (updatedLexerActions === null) {
				updatedLexerActions = this.lexerActions.concat([]);
			}
			updatedLexerActions[i] = new LexerIndexedCustomAction(offset,
					this.lexerActions[i]);
		}
	}
	if (updatedLexerActions === null) {
		return this;
	} else {
		return new LexerActionExecutor(updatedLexerActions);
	}
};

// Execute the actions encapsulated by this executor within the context of a
// particular {@link Lexer}.
//
// <p>This method calls {@link IntStream//seek} to set the position of the
// {@code input} {@link CharStream} prior to calling
// {@link LexerAction//execute} on a position-dependent action. Before the
// method returns, the input position will be restored to the same position
// it was in when the method was invoked.</p>
//
// @param lexer The lexer instance.
// @param input The input stream which is the source for the current token.
// When this method is called, the current {@link IntStream//index} for
// {@code input} should be the start of the following token, i.e. 1
// character past the end of the current token.
// @param startIndex The token start index. This value may be passed to
// {@link IntStream//seek} to set the {@code input} position to the beginning
// of the token.
// /
LexerActionExecutor.prototype.execute = function(lexer, input, startIndex) {
	var requiresSeek = false;
	var stopIndex = input.index;
	try {
		for (var i = 0; i < this.lexerActions.length; i++) {
			var lexerAction = this.lexerActions[i];
			if (lexerAction instanceof LexerIndexedCustomAction) {
				var offset = lexerAction.offset;
				input.seek(startIndex + offset);
				lexerAction = lexerAction.action;
				requiresSeek = (startIndex + offset) !== stopIndex;
			} else if (lexerAction.isPositionDependent) {
				input.seek(stopIndex);
				requiresSeek = false;
			}
			lexerAction.execute(lexer);
		}
	} finally {
		if (requiresSeek) {
			input.seek(stopIndex);
		}
	}
};

LexerActionExecutor.prototype.hashString = function() {
	return this.hashString;
};

LexerActionExecutor.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof LexerActionExecutor)) {
		return false;
	} else {
		return this.hashString === other.hashString &&
				this.lexerActions === other.lexerActions;
	}
};

exports.LexerActionExecutor = LexerActionExecutor;

},{"./LexerAction":38}],40:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

//
// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
//
// <p>
// The basic complexity of the adaptive strategy makes it harder to understand.
// We begin with ATN simulation to build paths in a DFA. Subsequent prediction
// requests go through the DFA first. If they reach a state without an edge for
// the current symbol, the algorithm fails over to the ATN simulation to
// complete the DFA path for the current input (until it finds a conflict state
// or uniquely predicting state).</p>
//
// <p>
// All of that is done without using the outer context because we want to create
// a DFA that is not dependent upon the rule invocation stack when we do a
// prediction. One DFA works in all contexts. We avoid using context not
// necessarily because it's slower, although it can be, but because of the DFA
// caching problem. The closure routine only considers the rule invocation stack
// created during prediction beginning in the decision rule. For example, if
// prediction occurs without invoking another rule's ATN, there are no context
// stacks in the configurations. When lack of context leads to a conflict, we
// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
// strategy (versus full LL(*)).</p>
//
// <p>
// When SLL yields a configuration set with conflict, we rewind the input and
// retry the ATN simulation, this time using full outer context without adding
// to the DFA. Configuration context stacks will be the full invocation stacks
// from the start rule. If we get a conflict using full context, then we can
// definitively say we have a true ambiguity for that input sequence. If we
// don't get a conflict, it implies that the decision is sensitive to the outer
// context. (It is not context-sensitive in the sense of context-sensitive
// grammars.)</p>
//
// <p>
// The next time we reach this DFA state with an SLL conflict, through DFA
// simulation, we will again retry the ATN simulation using full context mode.
// This is slow because we can't save the results and have to "interpret" the
// ATN each time we get that input.</p>
//
// <p>
// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
//
// <p>
// We could cache results from full context to predicted alternative easily and
// that saves a lot of time but doesn't work in presence of predicates. The set
// of visible predicates from the ATN start state changes depending on the
// context, because closure can fall off the end of a rule. I tried to cache
// tuples (stack context, semantic context, predicted alt) but it was slower
// than interpreting and much more complicated. Also required a huge amount of
// memory. The goal is not to create the world's fastest parser anyway. I'd like
// to keep this algorithm simple. By launching multiple threads, we can improve
// the speed of parsing across a large number of files.</p>
//
// <p>
// There is no strict ordering between the amount of input used by SLL vs LL,
// which makes it really hard to build a cache for full context. Let's say that
// we have input A B C that leads to an SLL conflict with full context X. That
// implies that using X we might only use A B but we could also use A B C D to
// resolve conflict. Input A B C D could predict alternative 1 in one position
// in the input and A B C E could predict alternative 2 in another position in
// input. The conflicting SLL configurations could still be non-unique in the
// full context prediction, which would lead us to requiring more input than the
// original A B C.	To make a	prediction cache work, we have to track	the exact
// input	used during the previous prediction. That amounts to a cache that maps
// X to a specific DFA for that context.</p>
//
// <p>
// Something should be done for left-recursive expression predictions. They are
// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
// with full LL thing Sam does.</p>
//
// <p>
// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
//
// <p>
// We avoid doing full context retry when the outer context is empty, we did not
// dip into the outer context by falling off the end of the decision state rule,
// or when we force SLL mode.</p>
//
// <p>
// As an example of the not dip into outer context case, consider as super
// constructor calls versus function calls. One grammar might look like
// this:</p>
//
// <pre>
// ctorBody
//   : '{' superCall? stat* '}'
//   ;
// </pre>
//
// <p>
// Or, you might see something like</p>
//
// <pre>
// stat
//   : superCall ';'
//   | expression ';'
//   | ...
//   ;
// </pre>
//
// <p>
// In both cases I believe that no closure operations will dip into the outer
// context. In the first case ctorBody in the worst case will stop at the '}'.
// In the 2nd case it should stop at the ';'. Both cases should stay within the
// entry rule and not dip into the outer context.</p>
//
// <p>
// <strong>PREDICATES</strong></p>
//
// <p>
// Predicates are always evaluated if present in either SLL or LL both. SLL and
// LL simulation deals with predicates differently. SLL collects predicates as
// it performs closure operations like ANTLR v3 did. It delays predicate
// evaluation until it reaches and accept state. This allows us to cache the SLL
// ATN simulation whereas, if we had evaluated predicates on-the-fly during
// closure, the DFA state configuration sets would be different and we couldn't
// build up a suitable DFA.</p>
//
// <p>
// When building a DFA accept state during ATN simulation, we evaluate any
// predicates and return the sole semantically valid alternative. If there is
// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
// we throw an exception. Alternatives without predicates act like they have
// true predicates. The simple way to think about it is to strip away all
// alternatives with false predicates and choose the minimum alternative that
// remains.</p>
//
// <p>
// When we start in the DFA and reach an accept state that's predicated, we test
// those and return the minimum semantically viable alternative. If no
// alternatives are viable, we throw an exception.</p>
//
// <p>
// During full LL ATN simulation, closure always evaluates predicates and
// on-the-fly. This is crucial to reducing the configuration set size during
// closure. It hits a landmine when parsing with the Java grammar, for example,
// without this on-the-fly evaluation.</p>
//
// <p>
// <strong>SHARING DFA</strong></p>
//
// <p>
// All instances of the same parser share the same decision DFAs through a
// static field. Each instance gets its own ATN simulator but they share the
// same {@link //decisionToDFA} field. They also share a
// {@link PredictionContextCache} object that makes sure that all
// {@link PredictionContext} objects are shared among the DFA states. This makes
// a big size difference.</p>
//
// <p>
// <strong>THREAD SAFETY</strong></p>
//
// <p>
// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
// it adds a new DFA object to that array. {@link //addDFAEdge}
// locks on the DFA for the current decision when setting the
// {@link DFAState//edges} field. {@link //addDFAState} locks on
// the DFA for the current decision when looking up a DFA state to see if it
// already exists. We must make sure that all requests to add DFA states that
// are equivalent result in the same shared DFA object. This is because lots of
// threads will be trying to update the DFA at once. The
// {@link //addDFAState} method also locks inside the DFA lock
// but this time on the shared context cache when it rebuilds the
// configurations' {@link PredictionContext} objects using cached
// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
// safe as long as we can guarantee that all threads referencing
// {@code s.edge[t]} get the same physical target {@link DFAState}, or
// {@code null}. Once into the DFA, the DFA simulation does not reference the
// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
// targets. The DFA simulator will either find {@link DFAState//edges} to be
// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
// {@code dfa.edges[t]} to be non-null. The
// {@link //addDFAEdge} method could be racing to set the field
// but in either case the DFA simulator works; if {@code null}, and requests ATN
// simulation. It could also race trying to get {@code dfa.edges[t]}, but either
// way it will work because it's not doing a test and set operation.</p>
//
// <p>
// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
// Parsing)</strong></p>
//
// <p>
// Sam pointed out that if SLL does not give a syntax error, then there is no
// point in doing full LL, which is slower. We only have to try LL if we get a
// syntax error. For maximum speed, Sam starts the parser set to pure SLL
// mode with the {@link BailErrorStrategy}:</p>
//
// <pre>
// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
// </pre>
//
// <p>
// If it does not get a syntax error, then we're done. If it does get a syntax
// error, we need to retry with the combined SLL/LL strategy.</p>
//
// <p>
// The reason this works is as follows. If there are no SLL conflicts, then the
// grammar is SLL (at least for that input set). If there is an SLL conflict,
// the full LL analysis must yield a set of viable alternatives which is a
// subset of the alternatives reported by SLL. If the LL set is a singleton,
// then the grammar is LL but not SLL. If the LL set is the same size as the SLL
// set, the decision is SLL. If the LL set has size &gt; 1, then that decision
// is truly ambiguous on the current input. If the LL set is smaller, then the
// SLL conflict resolution might choose an alternative that the full LL would
// rule out as a possibility based upon better context information. If that's
// the case, then the SLL parse will definitely get an error because the full LL
// analysis says it's not viable. If SLL conflict resolution chooses an
// alternative within the LL set, them both SLL and LL would choose the same
// alternative because they both choose the minimum of multiple conflicting
// alternatives.</p>
//
// <p>
// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
// parsing will get an error because SLL will pursue alternative 1. If
// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
// choose the same alternative because alternative one is the minimum of either
// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
//
// <p>
// Of course, if the input is invalid, then we will get an error for sure in
// both SLL and LL parsing. Erroneous input will therefore require 2 passes over
// the input.</p>
//

var Utils = require('./../Utils');
var Set = Utils.Set;
var BitSet = Utils.BitSet;
var DoubleDict = Utils.DoubleDict;
var ATN = require('./ATN').ATN;
var ATNConfig = require('./ATNConfig').ATNConfig;
var ATNConfigSet = require('./ATNConfigSet').ATNConfigSet;
var Token = require('./../Token').Token;
var DFAState = require('./../dfa/DFAState').DFAState;
var PredPrediction = require('./../dfa/DFAState').PredPrediction;
var ATNSimulator = require('./ATNSimulator').ATNSimulator;
var PredictionMode = require('./PredictionMode').PredictionMode;
var RuleContext = require('./../RuleContext').RuleContext;
var ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;
var SemanticContext = require('./SemanticContext').SemanticContext;
var StarLoopEntryState = require('./ATNState').StarLoopEntryState;
var RuleStopState = require('./ATNState').RuleStopState;
var PredictionContext = require('./../PredictionContext').PredictionContext;
var Interval = require('./../IntervalSet').Interval;
var Transitions = require('./Transition');
var Transition = Transitions.Transition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var ActionTransition = Transitions.ActionTransition;
var NoViableAltException = require('./../error/Errors').NoViableAltException;

var SingletonPredictionContext = require('./../PredictionContext').SingletonPredictionContext;
var predictionContextFromRuleContext = require('./../PredictionContext').predictionContextFromRuleContext;

function ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    // SLL, LL, or LL + exact ambig detection?//
    this.predictionMode = PredictionMode.LL;
    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    // Each prediction operation uses a cache for merge of prediction contexts.
    //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
    //  isn't synchronized but we're ok since two threads shouldn't reuse same
    //  parser/atnsim object because it can only handle one input at a time.
    //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
    //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
    //  also be examined during cache lookup.
    //
    this.mergeCache = null;
    return this;
}

ParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);
ParserATNSimulator.prototype.constructor = ParserATNSimulator;

ParserATNSimulator.prototype.debug = false;
ParserATNSimulator.prototype.debug_list_atn_decisions = false;
ParserATNSimulator.prototype.dfa_debug = false;
ParserATNSimulator.prototype.retry_debug = false;


ParserATNSimulator.prototype.reset = function() {
};

ParserATNSimulator.prototype.adaptivePredict = function(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("adaptivePredict decision " + decision +
                               " exec LA(1)==" + this.getLookaheadName(input) +
                               " line " + input.LT(1).line + ":" +
                               input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;
    
    var dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    var m = input.mark();
    var index = input.index;

    // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?
    try {
        var s0;
        if (dfa.precedenceDfa) {
            // the start state for a precedence DFA depends on the current
            // parser precedence, and is provided by a DFA method.
            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
            // the start state for a "regular" DFA is just s0
            s0 = dfa.s0;
        }
        if (s0===null) {
            if (outerContext===null) {
                outerContext = RuleContext.EMPTY;
            }
            if (this.debug || this.debug_list_atn_decisions) {
                console.log("predictATN decision " + dfa.decision +
                                   " exec LA(1)==" + this.getLookaheadName(input) +
                                   ", outerContext=" + outerContext.toString(this.parser.ruleNames));
            }
            // If this is not a precedence DFA, we check the ATN start state
            // to determine if this ATN start state is the decision for the
            // closure block that determines whether a precedence rule
            // should continue or complete.
            //
            if (!dfa.precedenceDfa && (dfa.atnStartState instanceof StarLoopEntryState)) {
                if (dfa.atnStartState.precedenceRuleDecision) {
                    dfa.setPrecedenceDfa(true);
                }
            }
            var fullCtx = false;
            var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

            if( dfa.precedenceDfa) {
                // If this is a precedence DFA, we use applyPrecedenceFilter
                // to convert the computed start state to a precedence start
                // state. We then use DFA.setPrecedenceStartState to set the
                // appropriate start state for the precedence level rather
                // than simply setting DFA.s0.
                //
                s0_closure = this.applyPrecedenceFilter(s0_closure);
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
            } else {
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.s0 = s0;
            }
        }
        var alt = this.execATN(dfa, s0, input, index, outerContext);
        if (this.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames));
        }
        return alt;
    } finally {
        this._dfa = null;
        this.mergeCache = null; // wack cache after each prediction
        input.seek(index);
        input.release(m);
    }
};
// Performs ATN simulation to compute a predicted alternative based
//  upon the remaining input, but also updates the DFA cache to avoid
//  having to traverse the ATN again for the same input sequence.

// There are some key conditions we're looking for after computing a new
// set of ATN configs (proposed DFA state):
      // if the set is empty, there is no viable alternative for current symbol
      // does the state uniquely predict an alternative?
      // does the state have a conflict that would prevent us from
      //   putting it on the work list?

// We also have some key operations to do:
      // add an edge from previous DFA state to potentially new DFA state, D,
      //   upon current symbol but only if adding to work list, which means in all
      //   cases except no viable alternative (and possibly non-greedy decisions?)
      // collecting predicates and adding semantic context to DFA accept states
      // adding rule context to context-sensitive DFA accept states
      // consuming an input symbol
      // reporting a conflict
      // reporting an ambiguity
      // reporting a context sensitivity
      // reporting insufficient predicates

// cover these cases:
//    dead end
//    single alt
//    single alt + preds
//    conflict
//    conflict + preds
//
ParserATNSimulator.prototype.execATN = function(dfa, s0, input, startIndex, outerContext ) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATN decision " + dfa.decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    var alt;
    var previousD = s0;

    if (this.debug) {
        console.log("s0 = " + s0);
    }
    var t = input.LA(1);
    while(true) { // while more work
        var D = this.getExistingTargetState(previousD, t);
        if(D===null) {
            D = this.computeTargetState(dfa, previousD, t);
        }
        if(D===ATNSimulator.ERROR) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for SLL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
            input.seek(startIndex);
            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
            // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
            var conflictingAlts = null;
            if (D.predicates!==null) {
                if (this.debug) {
                    console.log("DFA state has preds in DFA sim LL failover");
                }
                var conflictIndex = input.index;
                if(conflictIndex !== startIndex) {
                    input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (conflictingAlts.length===1) {
                    if(this.debug) {
                        console.log("Full LL avoided");
                    }
                    return conflictingAlts.minValue();
                }
                if (conflictIndex !== startIndex) {
                    // restore the index so reporting the fallback to full
                    // context occurs with the index at the correct spot
                    input.seek(conflictIndex);
                }
            }
            if (this.dfa_debug) {
                console.log("ctx sensitive state " + outerContext +" in " + D);
            }
            var fullCtx = true;
            var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
            this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
            alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
            return alt;
        }
        if (D.isAcceptState) {
            if (D.predicates===null) {
                return D.prediction;
            }
            var stopIndex = input.index;
            input.seek(startIndex);
            var alts = this.evalSemanticContext(D.predicates, outerContext, true);
            if (alts.length===0) {
                throw this.noViableAlt(input, outerContext, D.configs, startIndex);
            } else if (alts.length===1) {
                return alts.minValue();
            } else {
                // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                return alts.minValue();
            }
        }
        previousD = D;

        if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
};
//
// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param previousD The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
//
ParserATNSimulator.prototype.getExistingTargetState = function(previousD, t) {
    var edges = previousD.edges;
    if (edges===null) {
        return null;
    } else {
        return edges[t + 1] || null;
    }
};
//
// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param dfa The DFA
// @param previousD The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
//
ParserATNSimulator.prototype.computeTargetState = function(dfa, previousD, t) {
   var reach = this.computeReachSet(previousD.configs, t, false);
    if(reach===null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
    }
    // create new target state; we'll add to DFA after it's complete
    var D = new DFAState(null, reach);

    var predictedAlt = this.getUniqueAlt(reach);

    if (this.debug) {
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) +
                    ", previous=" + previousD.configs +
                    ", configs=" + reach +
                    ", predict=" + predictedAlt +
                    ", allSubsetsConflict=" +
                    PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                    this.getConflictingAlts(reach));
    }
    if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {
        // NO CONFLICT, UNIQUELY PREDICTED ALT
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        // MORE THAN ONE VIABLE ALTERNATIVE
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        // in SLL-only mode, we will stop at this state and return the minimum alt
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if( D.predicates!==null) {
            D.prediction = ATN.INVALID_ALT_NUMBER;
        }
    }
    // all adds to dfa are done after we've created full D state
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
};

ParserATNSimulator.prototype.predicateDFAState = function(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    var nalts = decisionState.transitions.length;
    // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts
    var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred!==null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
        // There are preds in configs but they might go away
        // when OR'd together like {p}? || NONE == NONE. If neither
        // alt has preds, resolve to min alt
        dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
};

// comes back with reach.uniqueAlt set to a valid alt
ParserATNSimulator.prototype.execATNWithFullContext = function(dfa, D, // how far we got before failing over
                                     s0,
                                     input,
                                     startIndex,
                                     outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATNWithFullContext "+s0);
    }
    var fullCtx = true;
    var foundExactAmbig = false;
    var reach = null;
    var previous = s0;
    input.seek(startIndex);
    var t = input.LA(1);
    var predictedAlt = -1;
    while (true) { // while more work
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach===null) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for LL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previous, startIndex);
            input.seek(startIndex);
            var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if(this.debug) {
            console.log("LL altSubSets=" + altSubSets + ", predict=" +
                  PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                  PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = this.getUniqueAlt(reach);
        // unique prediction?
        if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {
            predictedAlt = reach.uniqueAlt;
            break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
            if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {
                break;
            }
        } else {
            // In exact ambiguity mode, we never try to terminate early.
            // Just keeps scarfing until we know what the conflict is
            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
                foundExactAmbig = true;
                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
                break;
            }
            // else there are multiple non-conflicting subsets or
            // we're not sure what the ambiguity is yet.
            // So, keep going.
        }
        previous = reach;
        if( t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
    // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
    }
    // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.

    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:

    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.

    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);

    return predictedAlt;
};

ParserATNSimulator.prototype.computeReachSet = function(closure, t, fullCtx) {
    if (this.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
    }
    if( this.mergeCache===null) {
        this.mergeCache = new DoubleDict();
    }
    var intermediate = new ATNConfigSet(fullCtx);

    // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.
    
    var skippedStopStates = null;

    // First figure out where we can reach on input t
    for (var i=0; i<closure.items.length;i++) {
        var c = closure.items[i];
        if(this.debug) {
            console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
            if (fullCtx || t === Token.EOF) {
                if (skippedStopStates===null) {
                    skippedStopStates = [];
                }
                skippedStopStates.push(c);
                if(this.debug) {
                    console.log("added " + c + " to skippedStopStates");
                }
            }
            continue;
        }
        for(var j=0;j<c.state.transitions.length;j++) {
            var trans = c.state.transitions[j];
            var target = this.getReachableTarget(trans, t);
            if (target!==null) {
                var cfg = new ATNConfig({state:target}, c);
                intermediate.add(cfg, this.mergeCache);
                if(this.debug) {
                    console.log("added " + cfg + " to intermediate");
                }
            }
        }
    }
    // Now figure out where the reach operation can take us...
    var reach = null;

    // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //
    if (skippedStopStates===null && t!==Token.EOF) {
        if (intermediate.items.length===1) {
            // Don't pursue the closure if there is just one state.
            // It can only have one alternative; just add to result
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        }
    }
    // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //
    if (reach===null) {
        reach = new ATNConfigSet(fullCtx);
        var closureBusy = new Set();
        var treatEofAsEpsilon = t === Token.EOF;
        for (var k=0; k<intermediate.items.length;k++) {
            this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
    }
    if (t === Token.EOF) {
        // After consuming EOF no additional input is possible, so we are
        // only interested in configurations which reached the end of the
        // decision rule (local context) or end of the start rule (full
        // context). Update reach to contain only these configurations. This
        // handles both explicit EOF transitions in the grammar and implicit
        // EOF transitions following the end of the decision or start rule.
        //
        // When reach==intermediate, no closure operation was performed. In
        // this case, removeAllConfigsNotInRuleStopState needs to check for
        // reachable rule stop states as well as configurations already in
        // a rule stop state.
        //
        // This is handled before the configurations in skippedStopStates,
        // because any configurations potentially added from that list are
        // already guaranteed to meet this condition whether or not it's
        // required.
        //
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //
    if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {
        for (var l=0; l<skippedStopStates.length;l++) {
            reach.add(skippedStopStates[l], this.mergeCache);
        }
    }
    if (reach.items.length===0) {
        return null;
    } else {
        return reach;
    }
};
//
// Return a configuration set containing only the configurations from
// {@code configs} which are in a {@link RuleStopState}. If all
// configurations in {@code configs} are already in a rule stop state, this
// method simply returns {@code configs}.
//
// <p>When {@code lookToEndOfRule} is true, this method uses
// {@link ATN//nextTokens} for each configuration in {@code configs} which is
// not already in a rule stop state to see if a rule stop state is reachable
// from the configuration via epsilon-only transitions.</p>
//
// @param configs the configuration set to update
// @param lookToEndOfRule when true, this method checks for rule stop states
// reachable by epsilon-only transitions from each configuration in
// {@code configs}.
//
// @return {@code configs} if all configurations in {@code configs} are in a
// rule stop state, otherwise return a new configuration set containing only
// the configurations from {@code configs} which are in a rule stop state
//
ParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
    }
    var result = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length;i++) {
        var config = configs.items[i];
        if (config.state instanceof RuleStopState) {
            result.add(config, this.mergeCache);
            continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
            var nextTokens = this.atn.nextTokens(config.state);
            if (nextTokens.contains(Token.EPSILON)) {
                var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);
            }
        }
    }
    return result;
};

ParserATNSimulator.prototype.computeStartState = function(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    var initialContext = predictionContextFromRuleContext(this.atn, ctx);
    var configs = new ATNConfigSet(fullCtx);
    for(var i=0;i<p.transitions.length;i++) {
        var target = p.transitions[i].target;
        var c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);
        var closureBusy = new Set();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
};

//
// This method transforms the start state computed by
// {@link //computeStartState} to the special start state used by a
// precedence DFA for a particular precedence value. The transformation
// process applies the following changes to the start state's configuration
// set.
//
// <ol>
// <li>Evaluate the precedence predicates for each configuration using
// {@link SemanticContext//evalPrecedence}.</li>
// <li>Remove all configurations which predict an alternative greater than
// 1, for which another configuration that predicts alternative 1 is in the
// same ATN state with the same prediction context. This transformation is
// valid for the following reasons:
// <ul>
// <li>The closure block cannot contain any epsilon transitions which bypass
// the body of the closure, so all states reachable via alternative 1 are
// part of the precedence alternatives of the transformed left-recursive
// rule.</li>
// <li>The "primary" portion of a left recursive rule cannot contain an
// epsilon transition, so the only way an alternative other than 1 can exist
// in a state that is also reachable via alternative 1 is by nesting calls
// to the left-recursive rule, with the outer calls not being at the
// preferred precedence level.</li>
// </ul>
// </li>
// </ol>
//
// <p>
// The prediction context must be considered by this filter to address
// situations like the following.
// </p>
// <code>
// <pre>
// grammar TA;
// prog: statement* EOF;
// statement: letterA | statement letterA 'b' ;
// letterA: 'a';
// </pre>
// </code>
// <p>
// If the above grammar, the ATN state immediately before the token
// reference {@code 'a'} in {@code letterA} is reachable from the left edge
// of both the primary and closure blocks of the left-recursive rule
// {@code statement}. The prediction context associated with each of these
// configurations distinguishes between them, and prevents the alternative
// which stepped out to {@code prog} (and then back in to {@code statement}
// from being eliminated by the filter.
// </p>
//
// @param configs The configuration set computed by
// {@link //computeStartState} as the start state for the DFA.
// @return The transformed configuration set representing the start state
// for a precedence DFA at a particular precedence level (determined by
// calling {@link Parser//getPrecedence}).
//
ParserATNSimulator.prototype.applyPrecedenceFilter = function(configs) {
	var config;
	var statesFromAlt1 = [];
    var configSet = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        // handle alt 1 first
        if (config.alt !== 1) {
            continue;
        }
        var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
        if (updatedContext===null) {
            // the configuration was eliminated
            continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
            configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);
        } else {
            configSet.add(config, this.mergeCache);
        }
    }
    for(i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt === 1) {
            // already handled
            continue;
        }
        // In the future, this elimination step could be updated to also
        // filter the prediction context for alternatives predicting alt>1
        // (basically a graph subtraction algorithm).
		if (!config.precedenceFilterSuppressed) {
            var context = statesFromAlt1[config.state.stateNumber] || null;
            if (context!==null && context.equals(config.context)) {
                // eliminated
                continue;
            }
		}
        configSet.add(config, this.mergeCache);
    }
    return configSet;
};

ParserATNSimulator.prototype.getReachableTarget = function(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
    } else {
        return null;
    }
};

ParserATNSimulator.prototype.getPredsForAmbigAlts = function(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    var altToPred = [];
    for(var i=0;i<configs.items.length;i++) {
        var c = configs.items[i];
        if(ambigAlts.contains( c.alt )) {
            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
        }
    }
    var nPredAlts = 0;
    for (i =1;i< nalts+1;i++) {
        var pred = altToPred[i] || null;
        if (pred===null) {
            altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
            nPredAlts += 1;
        }
    }
    // nonambig alts are null in altToPred
    if (nPredAlts===0) {
        altToPred = null;
    }
    if (this.debug) {
        console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }
    return altToPred;
};

ParserATNSimulator.prototype.getPredicatePredictions = function(ambigAlts, altToPred) {
    var pairs = [];
    var containsPredicate = false;
    for (var i=1; i<altToPred.length;i++) {
        var pred = altToPred[i];
        // unpredicated is indicated by SemanticContext.NONE
        if( ambigAlts!==null && ambigAlts.contains( i )) {
            pairs.push(new PredPrediction(pred, i));
        }
        if (pred !== SemanticContext.NONE) {
            containsPredicate = true;
        }
    }
    if (! containsPredicate) {
        return null;
    }
    return pairs;
};

//
// This method is used to improve the localization of error messages by
// choosing an alternative rather than throwing a
// {@link NoViableAltException} in particular prediction scenarios where the
// {@link //ERROR} state was reached during ATN simulation.
//
// <p>
// The default implementation of this method uses the following
// algorithm to identify an ATN configuration which successfully parsed the
// decision entry rule. Choosing such an alternative ensures that the
// {@link ParserRuleContext} returned by the calling rule will be complete
// and valid, and the syntax error will be reported later at a more
// localized location.</p>
//
// <ul>
// <li>If a syntactically valid path or paths reach the end of the decision rule and
// they are semantically valid if predicated, return the min associated alt.</li>
// <li>Else, if a semantically invalid but syntactically valid path exist
// or paths exist, return the minimum associated alt.
// </li>
// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
// </ul>
//
// <p>
// In some scenarios, the algorithm described above could predict an
// alternative which will result in a {@link FailedPredicateException} in
// the parser. Specifically, this could occur if the <em>only</em> configuration
// capable of successfully parsing to the end of the decision rule is
// blocked by a semantic predicate. By choosing this alternative within
// {@link //adaptivePredict} instead of throwing a
// {@link NoViableAltException}, the resulting
// {@link FailedPredicateException} in the parser will identify the specific
// predicate which is preventing the parser from successfully parsing the
// decision rule, which helps developers identify and correct logic errors
// in semantic predicates.
// </p>
//
// @param configs The ATN configurations which were valid immediately before
// the {@link //ERROR} state was reached
// @param outerContext The is the \gamma_0 initial parser context from the paper
// or the parser stack at the instant before prediction commences.
//
// @return The value to return from {@link //adaptivePredict}, or
// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
// identified and {@link //adaptivePredict} should report an error instead.
//
ParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function(configs, outerContext) {
    var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    var semValidConfigs = cfgs[0];
    var semInvalidConfigs = cfgs[1];
    var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
        return alt;
    }
    // Is there a syntactically valid path with a failed pred?
    if (semInvalidConfigs.items.length>0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists
            return alt;
        }
    }
    return ATN.INVALID_ALT_NUMBER;
};
    
ParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function(configs) {
    var alts = [];
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {
            if(alts.indexOf(c.alt)<0) {
                alts.push(c.alt);
            }
        }
    }
    if (alts.length===0) {
        return ATN.INVALID_ALT_NUMBER;
    } else {
        return Math.min.apply(null, alts);
    }
};
// Walk the list of configurations and split them according to
//  those that have preds evaluating to true/false.  If no pred, assume
//  true pred and include in succeeded set.  Returns Pair of sets.
//
//  Create a new set so as not to alter the incoming parameter.
//
//  Assumption: the input stream has been restored to the starting point
//  prediction, which is where predicates need to evaluate.
//
ParserATNSimulator.prototype.splitAccordingToSemanticValidity = function( configs, outerContext) {
    var succeeded = new ATNConfigSet(configs.fullCtx);
    var failed = new ATNConfigSet(configs.fullCtx);
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.semanticContext !== SemanticContext.NONE) {
            var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
            if (predicateEvaluationResult) {
                succeeded.add(c);
            } else {
                failed.add(c);
            }
        } else {
            succeeded.add(c);
        }
    }
    return [succeeded, failed];
};

// Look through a list of predicate/alt pairs, returning alts for the
//  pairs that win. A {@code NONE} predicate indicates an alt containing an
//  unpredicated config which behaves as "always true." If !complete
//  then we stop at the first predicate that evaluates to true. This
//  includes pairs with null predicates.
//
ParserATNSimulator.prototype.evalSemanticContext = function(predPredictions, outerContext, complete) {
    var predictions = new BitSet();
    for(var i=0;i<predPredictions.length;i++) {
    	var pair = predPredictions[i];
        if (pair.pred === SemanticContext.NONE) {
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
            continue;
        }
        var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (this.debug || this.dfa_debug) {
            console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
            if (this.debug || this.dfa_debug) {
                console.log("PREDICT " + pair.alt);
            }
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
        }
    }
    return predictions;
};

// TODO: If we are doing predicates, there is no point in pursuing
//     closure operations if we reach a DFA state that uniquely predicts
//     alternative. We will not be caching that DFA state and it is a
//     waste to pursue the closure. Might have to advance when we do
//     ambig detection thought :(
//

ParserATNSimulator.prototype.closure = function(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    var initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,
                             fullCtx, initialDepth, treatEofAsEpsilon);
};


ParserATNSimulator.prototype.closureCheckingStopState = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug) {
        console.log("closure(" + config.toString(this.parser,true) + ")");
        console.log("configs(" + configs.toString() + ")");
        if(config.reachesIntoOuterContext>50) {
            throw "problem";
        }
    }
    if (config.state instanceof RuleStopState) {
        // We hit rule end. If we have context info, use it
        // run thru all possible stack tops in ctx
        if (! config.context.isEmpty()) {
            for ( var i =0; i<config.context.length; i++) {
                if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                    if (fullCtx) {
                        configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);
                        continue;
                    } else {
                        // we have no context info, just chase follow links (if greedy)
                        if (this.debug) {
                            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                        }
                        this.closure_(config, configs, closureBusy, collectPredicates,
                                 fullCtx, depth, treatEofAsEpsilon);
                    }
                    continue;
                }
                returnState = this.atn.states[config.context.getReturnState(i)];
                newContext = config.context.getParent(i); // "pop" return state
                var parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};
                c = new ATNConfig(parms, null);
                // While we have context to pop back from, we may have
                // gotten that context AFTER having falling off a rule.
                // Make sure we track that we are now out of context.
                c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
            }
            return;
        } else if( fullCtx) {
            // reached end of start rule
            configs.add(config, this.mergeCache);
            return;
        } else {
            // else if we have no context info, just chase follow links (if greedy)
            if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
        }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
};

// Do the actual work of walking epsilon edges//
ParserATNSimulator.prototype.closure_ = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    var p = config.state;
    // optimization
    if (! p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
        // make sure to not return here, because EOF transitions can act as
        // both epsilon transitions and non-epsilon transitions.
    }
    for(var i = 0;i<p.transitions.length; i++) {
        var t = p.transitions[i];
        var continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c!==null) {
			if (!t.isEpsilon && closureBusy.add(c)!==c){
				// avoid infinite recursion for EOF* and EOF+
				continue;
			}
            var newDepth = depth;
            if ( config.state instanceof RuleStopState) {
                // target fell off end of rule; mark resulting c as having dipped into outer context
                // We can't get here if incoming config was rule stop and we had context
                // track how far we dip into outer context.  Might
                // come in handy and we avoid evaluating context dependent
                // preds if this is > 0.

                if (closureBusy.add(c)!==c) {
                    // avoid infinite recursion for right-recursive rules
                    continue;
                }

				if (this._dfa !== null && this._dfa.precedenceDfa) {
					if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
						c.precedenceFilterSuppressed = true;
					}
				}

                c.reachesIntoOuterContext += 1;
                configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                newDepth -= 1;
                if (this.debug) {
                    console.log("dips into outer ctx: " + c);
                }
            } else if (t instanceof RuleTransition) {
                // latch when newDepth goes negative - once we step out of the entry context we can't return
                if (newDepth >= 0) {
                    newDepth += 1;
                }
            }
            this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
        }
    }
};

ParserATNSimulator.prototype.getRuleName = function( index) {
    if (this.parser!==null && index>=0) {
        return this.parser.ruleNames[index];
    } else {
        return "<rule " + index + ">";
    }
};

ParserATNSimulator.prototype.getEpsilonTarget = function(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch(t.serializationType) {
    case Transition.RULE:
        return this.ruleTransition(config, t);
    case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.ACTION:
        return this.actionTransition(config, t);
    case Transition.EPSILON:
        return new ATNConfig({state:t.target}, config);
    case Transition.ATOM:
    case Transition.RANGE:
    case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
            if (t.matches(Token.EOF, 0, 1)) {
                return new ATNConfig({state: t.target}, config);
            }
        }
        return null;
    default:
    	return null;
    }
};

ParserATNSimulator.prototype.actionTransition = function(config, t) {
    if (this.debug) {
        console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
    }
    return new ATNConfig({state:t.target}, config);
};

ParserATNSimulator.prototype.precedenceTransition = function(config, pt,  collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser!==null) {
        	console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && inContext) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.predTransition = function(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser!==null) {
            console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.ruleTransition = function(config, t) {
    if (this.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    var returnState = t.followState;
    var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({state:t.target, context:newContext}, config );
};

ParserATNSimulator.prototype.getConflictingAlts = function(configs) {
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
};

 // Sam pointed out a problem with the previous definition, v3, of
 // ambiguous states. If we have another state associated with conflicting
 // alternatives, we should keep going. For example, the following grammar
 //
 // s : (ID | ID ID?) ';' ;
 //
 // When the ATN simulation reaches the state before ';', it has a DFA
 // state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
 // 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
 // because alternative to has another way to continue, via [6|2|[]].
 // The key is that we have a single state that has config's only associated
 // with a single alternative, 2, and crucially the state transitions
 // among the configurations are all non-epsilon transitions. That means
 // we don't consider any conflicts that include alternative 2. So, we
 // ignore the conflict between alts 1 and 2. We ignore a set of
 // conflicting alts when there is an intersection with an alternative
 // associated with a single alt state in the state&rarr;config-list map.
 //
 // It's also the case that we might have two conflicting configurations but
 // also a 3rd nonconflicting configuration for a different alternative:
 // [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
 //
 // a : A | A | A B ;
 //
 // After matching input A, we reach the stop state for rule A, state 1.
 // State 8 is the state right before B. Clearly alternatives 1 and 2
 // conflict and no amount of further lookahead will separate the two.
 // However, alternative 3 will be able to continue and so we do not
 // stop working on this state. In the previous example, we're concerned
 // with states associated with the conflicting alternatives. Here alt
 // 3 is not associated with the conflicting configs, but since we can continue
 // looking for input reasonably, I don't declare the state done. We
 // ignore a set of conflicting alts when we have an alternative
 // that we still need to pursue.
//

ParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function(configs) {
    var conflictingAlts = null;
    if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.add(configs.uniqueAlt);
    } else {
        conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
};

ParserATNSimulator.prototype.getTokenName = function( t) {
    if (t===Token.EOF) {
        return "EOF";
    }
    if( this.parser!==null && this.parser.literalNames!==null) {
        if (t >= this.parser.literalNames.length) {
            console.log("" + t + " ttype out of range: " + this.parser.literalNames);
            console.log("" + this.parser.getInputStream().getTokens());
        } else {
            return this.parser.literalNames[t] + "<" + t + ">";
        }
    }
    return "" + t;
};

ParserATNSimulator.prototype.getLookaheadName = function(input) {
    return this.getTokenName(input.LA(1));
};

// Used for debugging in adaptivePredict around execATN but I cut
//  it out for clarity now that alg. works well. We can leave this
//  "dead" code for a bit.
//
ParserATNSimulator.prototype.dumpDeadEndConfigs = function(nvae) {
    console.log("dead end configs: ");
    var decs = nvae.getDeadEndConfigs();
    for(var i=0; i<decs.length; i++) {
    	var c = decs[i];
        var trans = "no edges";
        if (c.state.transitions.length>0) {
            var t = c.state.transitions[0];
            if (t instanceof AtomTransition) {
                trans = "Atom "+ this.getTokenName(t.label);
            } else if (t instanceof SetTransition) {
                var neg = (t instanceof NotSetTransition);
                trans = (neg ? "~" : "") + "Set " + t.set;
            }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
    }
};

ParserATNSimulator.prototype.noViableAlt = function(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
};

ParserATNSimulator.prototype.getUniqueAlt = function(configs) {
    var alt = ATN.INVALID_ALT_NUMBER;
    for(var i=0;i<configs.items.length;i++) {
    	var c = configs.items[i];
        if (alt === ATN.INVALID_ALT_NUMBER) {
            alt = c.alt // found first alt
        } else if( c.alt!==alt) {
            return ATN.INVALID_ALT_NUMBER;
        }
    }
    return alt;
};

//
// Add an edge to the DFA, if possible. This method calls
// {@link //addDFAState} to ensure the {@code to} state is present in the
// DFA. If {@code from} is {@code null}, or if {@code t} is outside the
// range of edges that can be represented in the DFA tables, this method
// returns without adding the edge to the DFA.
//
// <p>If {@code to} is {@code null}, this method returns {@code null}.
// Otherwise, this method returns the {@link DFAState} returned by calling
// {@link //addDFAState} for the {@code to} state.</p>
//
// @param dfa The DFA
// @param from The source state for the edge
// @param t The input symbol
// @param to The target state for the edge
//
// @return If {@code to} is {@code null}, this method returns {@code null};
// otherwise this method returns the result of calling {@link //addDFAState}
// on {@code to}
//
ParserATNSimulator.prototype.addDFAEdge = function(dfa, from_, t, to) {
    if( this.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to===null) {
        return null;
    }
    to = this.addDFAState(dfa, to); // used existing if possible not incoming
    if (from_===null || t < -1 || t > this.atn.maxTokenType) {
        return to;
    }
    if (from_.edges===null) {
        from_.edges = [];
    }
    from_.edges[t+1] = to; // connect

    if (this.debug) {
        var names = this.parser===null ? null : this.parser.literalNames;
        console.log("DFA=\n" + dfa.toString(names));
    }
    return to;
};
//
// Add state {@code D} to the DFA if it is not already present, and return
// the actual instance stored in the DFA. If a state equivalent to {@code D}
// is already in the DFA, the existing state is returned. Otherwise this
// method returns {@code D} after adding it to the DFA.
//
// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
// does not change the DFA.</p>
//
// @param dfa The dfa
// @param D The DFA state to add
// @return The state stored in the DFA. This will be either the existing
// state if {@code D} is already in the DFA, or {@code D} itself if the
// state was not already present.
//
ParserATNSimulator.prototype.addDFAState = function(dfa, D) {
    if (D == ATNSimulator.ERROR) {
        return D;
    }
    var hash = D.hashString();
    var existing = dfa.states[hash] || null;
    if(existing!==null) {
        return existing;
    }
    D.stateNumber = dfa.states.length;
    if (! D.configs.readonly) {
        D.configs.optimizeConfigs(this);
        D.configs.setReadonly(true);
    }
    dfa.states[hash] = D;
    if (this.debug) {
        console.log("adding new DFA state: " + D);
    }
    return D;
};

ParserATNSimulator.prototype.reportAttemptingFullContext = function(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
};

ParserATNSimulator.prototype.reportContextSensitivity = function(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
};
    
// If context sensitive parsing, we know it's ambiguity not conflict//
ParserATNSimulator.prototype.reportAmbiguity = function(dfa, D, startIndex, stopIndex,
                               exact, ambigAlts, configs ) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
};
            
exports.ParserATNSimulator = ParserATNSimulator;
},{"./../IntervalSet":19,"./../ParserRuleContext":23,"./../PredictionContext":24,"./../RuleContext":26,"./../Token":27,"./../Utils":28,"./../dfa/DFAState":47,"./../error/Errors":52,"./ATN":29,"./ATNConfig":30,"./ATNConfigSet":31,"./ATNSimulator":34,"./ATNState":35,"./PredictionMode":41,"./SemanticContext":42,"./Transition":43}],41:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//
// This enumeration defines the prediction modes available in ANTLR 4 along with
// utility methods for analyzing configuration sets for conflicts and/or
// ambiguities.

var Set = require('./../Utils').Set;
var BitSet = require('./../Utils').BitSet;
var AltDict = require('./../Utils').AltDict;
var ATN = require('./ATN').ATN;
var RuleStopState = require('./ATNState').RuleStopState;

function PredictionMode() {
	return this;
}

//
// The SLL(*) prediction mode. This prediction mode ignores the current
// parser context when making predictions. This is the fastest prediction
// mode, and provides correct results for many grammars. This prediction
// mode is more powerful than the prediction mode provided by ANTLR 3, but
// may result in syntax errors for grammar and input combinations which are
// not SLL.
//
// <p>
// When using this prediction mode, the parser will either return a correct
// parse tree (i.e. the same parse tree that would be returned with the
// {@link //LL} prediction mode), or it will report a syntax error. If a
// syntax error is encountered when using the {@link //SLL} prediction mode,
// it may be due to either an actual syntax error in the input or indicate
// that the particular combination of grammar and input requires the more
// powerful {@link //LL} prediction abilities to complete successfully.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.SLL = 0;
//
// The LL(*) prediction mode. This prediction mode allows the current parser
// context to be used for resolving SLL conflicts that occur during
// prediction. This is the fastest prediction mode that guarantees correct
// parse results for all combinations of grammars with syntactically correct
// inputs.
//
// <p>
// When using this prediction mode, the parser will make correct decisions
// for all syntactically-correct grammar and input combinations. However, in
// cases where the grammar is truly ambiguous this prediction mode might not
// report a precise answer for <em>exactly which</em> alternatives are
// ambiguous.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL = 1;
//
// The LL(*) prediction mode with exact ambiguity detection. In addition to
// the correctness guarantees provided by the {@link //LL} prediction mode,
// this prediction mode instructs the prediction algorithm to determine the
// complete and exact set of ambiguous alternatives for every ambiguous
// decision encountered while parsing.
//
// <p>
// This prediction mode may be used for diagnosing ambiguities during
// grammar development. Due to the performance overhead of calculating sets
// of ambiguous alternatives, this prediction mode should be avoided when
// the exact results are not necessary.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL_EXACT_AMBIG_DETECTION = 2;


//
// Computes the SLL prediction termination condition.
//
// <p>
// This method computes the SLL prediction termination condition for both of
// the following cases.</p>
//
// <ul>
// <li>The usual SLL+LL fallback upon SLL conflict</li>
// <li>Pure SLL without LL fallback</li>
// </ul>
//
// <p><strong>COMBINED SLL+LL PARSING</strong></p>
//
// <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
// ensured regardless of how the termination condition is computed by this
// method. Due to the substantially higher cost of LL prediction, the
// prediction should only fall back to LL when the additional lookahead
// cannot lead to a unique SLL prediction.</p>
//
// <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
// conflicting subsets should fall back to full LL, even if the
// configuration sets don't resolve to the same alternative (e.g.
// {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
// configuration, SLL could continue with the hopes that more lookahead will
// resolve via one of those non-conflicting configurations.</p>
//
// <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
// stops when it sees only conflicting configuration subsets. In contrast,
// full LL keeps going when there is uncertainty.</p>
//
// <p><strong>HEURISTIC</strong></p>
//
// <p>As a heuristic, we stop prediction when we see any conflicting subset
// unless we see a state that only has one alternative associated with it.
// The single-alt-state thing lets prediction continue upon rules like
// (otherwise, it would admit defeat too soon):</p>
//
// <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
//
// <p>When the ATN simulation reaches the state before {@code ';'}, it has a
// DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
// {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
// processing this node because alternative to has another way to continue,
// via {@code [6|2|[]]}.</p>
//
// <p>It also let's us continue for this rule:</p>
//
// <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
//
// <p>After matching input A, we reach the stop state for rule A, state 1.
// State 8 is the state right before B. Clearly alternatives 1 and 2
// conflict and no amount of further lookahead will separate the two.
// However, alternative 3 will be able to continue and so we do not stop
// working on this state. In the previous example, we're concerned with
// states associated with the conflicting alternatives. Here alt 3 is not
// associated with the conflicting configs, but since we can continue
// looking for input reasonably, don't declare the state done.</p>
//
// <p><strong>PURE SLL PARSING</strong></p>
//
// <p>To handle pure SLL parsing, all we have to do is make sure that we
// combine stack contexts for configurations that differ only by semantic
// predicate. From there, we can do the usual SLL termination heuristic.</p>
//
// <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
//
// <p>SLL decisions don't evaluate predicates until after they reach DFA stop
// states because they need to create the DFA cache that works in all
// semantic situations. In contrast, full LL evaluates predicates collected
// during start state computation so it can ignore predicates thereafter.
// This means that SLL termination detection can totally ignore semantic
// predicates.</p>
//
// <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
// semantic predicate contexts so we might see two configurations like the
// following.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
//
// <p>Before testing these configurations against others, we have to merge
// {@code x} and {@code x'} (without modifying the existing configurations).
// For example, we test {@code (x+x')==x''} when looking for conflicts in
// the following configurations.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
//
// <p>If the configuration set has predicates (as indicated by
// {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
// the configurations to strip out all of the predicates so that a standard
// {@link ATNConfigSet} will merge everything ignoring predicates.</p>
//
PredictionMode.hasSLLConflictTerminatingPrediction = function( mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
    }
    // pure SLL mode parsing
    if (mode === PredictionMode.SLL) {
        // Don't bother with combining configs from different semantic
        // contexts if we can fail over to full LL; costs more time
        // since we'll often fail over anyway.
        if (configs.hasSemanticContext) {
            // dup configs, tossing out semantic predicates
            var dup = new ATNConfigSet();
            for(var i=0;i<configs.items.length;i++) {
            	var c = configs.items[i];
                c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);
                dup.add(c);
            }
            configs = dup;
        }
        // now we have combined contexts for configs with dissimilar preds
    }
    // pure SLL or combined SLL+LL mode parsing
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
};

// Checks if any configuration in {@code configs} is in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if any configuration in {@code configs} is in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.hasConfigInRuleStopState = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (c.state instanceof RuleStopState) {
            return true;
        }
	}
    return false;
};

// Checks if all configurations in {@code configs} are in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if all configurations in {@code configs} are in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.allConfigsInRuleStopStates = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (!(c.state instanceof RuleStopState)) {
            return false;
        }
	}
    return true;
};

//
// Full LL prediction termination.
//
// <p>Can we stop looking ahead during ATN simulation or is there some
// uncertainty as to which alternative we will ultimately pick, after
// consuming more input? Even if there are partial conflicts, we might know
// that everything is going to resolve to the same minimum alternative. That
// means we can stop since no more lookahead will change that fact. On the
// other hand, there might be multiple conflicts that resolve to different
// minimums. That means we need more look ahead to decide which of those
// alternatives we should predict.</p>
//
// <p>The basic idea is to split the set of configurations {@code C}, into
// conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
// non-conflicting configurations. Two configurations conflict if they have
// identical {@link ATNConfig//state} and {@link ATNConfig//context} values
// but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
// and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
//
// <p>Reduce these configuration subsets to the set of possible alternatives.
// You can compute the alternative subsets in one pass as follows:</p>
//
// <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
// {@code C} holding {@code s} and {@code ctx} fixed.</p>
//
// <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>
//
// <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
//
// <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
// {@code s} and {@code ctx}.</p>
//
// <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
// the union of these alternative subsets is a singleton, then no amount of
// more lookahead will help us. We will always pick that alternative. If,
// however, there is more than one alternative, then we are uncertain which
// alternative to predict and must continue looking for resolution. We may
// or may not discover an ambiguity in the future, even if there are no
// conflicting subsets this round.</p>
//
// <p>The biggest sin is to terminate early because it means we've made a
// decision but were uncertain as to the eventual outcome. We haven't used
// enough lookahead. On the other hand, announcing a conflict too late is no
// big deal; you will still have the conflict. It's just inefficient. It
// might even look until the end of file.</p>
//
// <p>No special consideration for semantic predicates is required because
// predicates are evaluated on-the-fly for full LL prediction, ensuring that
// no configuration contains a semantic context during the termination
// check.</p>
//
// <p><strong>CONFLICTING CONFIGS</strong></p>
//
// <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
// when {@code i!=j} but {@code x=x'}. Because we merge all
// {@code (s, i, _)} configurations together, that means that there are at
// most {@code n} configurations associated with state {@code s} for
// {@code n} possible alternatives in the decision. The merged stacks
// complicate the comparison of configuration contexts {@code x} and
// {@code x'}. Sam checks to see if one is a subset of the other by calling
// merge and checking to see if the merged result is either {@code x} or
// {@code x'}. If the {@code x} associated with lowest alternative {@code i}
// is the superset, then {@code i} is the only possible prediction since the
// others resolve to {@code min(i)} as well. However, if {@code x} is
// associated with {@code j>i} then at least one stack configuration for
// {@code j} is not in conflict with alternative {@code i}. The algorithm
// should keep going, looking for more lookahead due to the uncertainty.</p>
//
// <p>For simplicity, I'm doing a equality check between {@code x} and
// {@code x'} that lets the algorithm continue to consume lookahead longer
// than necessary. The reason I like the equality is of course the
// simplicity but also because that is the test you need to detect the
// alternatives that are actually in conflict.</p>
//
// <p><strong>CONTINUE/STOP RULE</strong></p>
//
// <p>Continue if union of resolved alternative sets from non-conflicting and
// conflicting alternative subsets has more than one alternative. We are
// uncertain about which alternative to predict.</p>
//
// <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
// alternatives are still in the running for the amount of input we've
// consumed at this point. The conflicting sets let us to strip away
// configurations that won't lead to more states because we resolve
// conflicts to the configuration with a minimum alternate for the
// conflicting set.</p>
//
// <p><strong>CASES</strong></p>
//
// <ul>
//
// <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
//
// <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
// {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
// {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1,3}} =&gt; continue
// </li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
// {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1}} =&gt; stop and predict 1</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
// ambiguity {@code {1,2}}</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
// {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {2}} = {@code {1,2}} =&gt; continue</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
// {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {3}} = {@code {1,3}} =&gt; continue</li>
//
// </ul>
//
// <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
//
// <p>If all states report the same conflicting set of alternatives, then we
// know we have the exact ambiguity set.</p>
//
// <p><code>|A_<em>i</em>|&gt;1</code> and
// <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
//
// <p>In other words, we continue examining lookahead until all {@code A_i}
// have more than one alternative and all {@code A_i} are the same. If
// {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
// because the resolved set is {@code {1}}. To determine what the real
// ambiguity is, we have to know whether the ambiguity is between one and
// two or one and three so we keep going. We can only stop prediction when
// we need exact ambiguity detection when the sets look like
// {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
//
PredictionMode.resolvesToJustOneViableAlt = function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
};

//
// Determines if every alternative subset in {@code altsets} contains more
// than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every {@link BitSet} in {@code altsets} has
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.allSubsetsConflict = function(altsets) {
    return ! PredictionMode.hasNonConflictingAltSet(altsets);
};
//
// Determines if any single alternative subset in {@code altsets} contains
// exactly one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
//
PredictionMode.hasNonConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length===1) {
            return true;
        }
	}
    return false;
};

//
// Determines if any single alternative subset in {@code altsets} contains
// more than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.hasConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length>1) {
            return true;
        }
	}
    return false;
};

//
// Determines if every alternative subset in {@code altsets} is equivalent.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every member of {@code altsets} is equal to the
// others, otherwise {@code false}
//
PredictionMode.allSubsetsEqual = function(altsets) {
    var first = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (first === null) {
            first = alts;
        } else if (alts!==first) {
            return false;
        }
	}
    return true;
};

//
// Returns the unique alternative predicted by all alternative subsets in
// {@code altsets}. If no such alternative exists, this method returns
// {@link ATN//INVALID_ALT_NUMBER}.
//
// @param altsets a collection of alternative subsets
//
PredictionMode.getUniqueAlt = function(altsets) {
    var all = PredictionMode.getAlts(altsets);
    if (all.length===1) {
        return all.minValue();
    } else {
        return ATN.INVALID_ALT_NUMBER;
    }
};

// Gets the complete set of represented alternatives for a collection of
// alternative subsets. This method returns the union of each {@link BitSet}
// in {@code altsets}.
//
// @param altsets a collection of alternative subsets
// @return the set of represented alternatives in {@code altsets}
//
PredictionMode.getAlts = function(altsets) {
    var all = new BitSet();
    altsets.map( function(alts) { all.or(alts); });
    return all;
};

//
// This function gets the conflicting alt subsets from a configuration set.
// For each configuration {@code c} in {@code configs}:
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>
//
PredictionMode.getConflictingAltSubsets = function(configs) {
    var configToAlts = {};
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        var key = "key_" + c.state.stateNumber + "/" + c.context;
        var alts = configToAlts[key] || null;
        if (alts === null) {
            alts = new BitSet();
            configToAlts[key] = alts;
        }
        alts.add(c.alt);
	}
	var values = [];
	for(var k in configToAlts) {
		if(k.indexOf("key_")!==0) {
			continue;
		}
		values.push(configToAlts[k]);
	}
    return values;
};

//
// Get a map from state to alt subset from a configuration set. For each
// configuration {@code c} in {@code configs}:
//
// <pre>
// map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
// </pre>
//
PredictionMode.getStateToAltMap = function(configs) {
    var m = new AltDict();
    configs.items.map(function(c) {
        var alts = m.get(c.state);
        if (alts === null) {
            alts = new BitSet();
            m.put(c.state, alts);
        }
        alts.add(c.alt);
    });
    return m;
};

PredictionMode.hasStateAssociatedWithOneAlt = function(configs) {
    var values = PredictionMode.getStateToAltMap(configs).values();
    for(var i=0;i<values.length;i++) {
        if (values[i].length===1) {
            return true;
        }
    }
    return false;
};

PredictionMode.getSingleViableAlt = function(altsets) {
    var result = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        var minAlt = alts.minValue();
        if(result===null) {
            result = minAlt;
        } else if(result!==minAlt) { // more than 1 viable alt
            return ATN.INVALID_ALT_NUMBER;
        }
	}
    return result;
};

exports.PredictionMode = PredictionMode;
},{"./../Utils":28,"./ATN":29,"./ATNState":35}],42:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

// A tree structure used to record the semantic context in which
//  an ATN configuration is valid.  It's either a single predicate,
//  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
//
//  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
//  {@link SemanticContext} within the scope of this outer class.</p>
//

var Set = require('./../Utils').Set;

function SemanticContext() {
	return this;
}

// For context independent predicates, we evaluate them without a local
// context (i.e., null context). That way, we can evaluate them without
// having to create proper rule-specific context during prediction (as
// opposed to the parser, which creates them naturally). In a practical
// sense, this avoids a cast exception from RuleContext to myruleContext.
//
// <p>For context dependent predicates, we must pass in a local context so that
// references such as $arg evaluate properly as _localctx.arg. We only
// capture context dependent predicates in the context in which we begin
// prediction, so we passed in the outer context here in case of context
// dependent predicate evaluation.</p>
//
SemanticContext.prototype.evaluate = function(parser, outerContext) {
};

//
// Evaluate the precedence predicates for the context and reduce the result.
//
// @param parser The parser instance.
// @param outerContext The current parser context object.
// @return The simplified semantic context after precedence predicates are
// evaluated, which will be one of the following values.
// <ul>
// <li>{@link //NONE}: if the predicate simplifies to {@code true} after
// precedence predicates are evaluated.</li>
// <li>{@code null}: if the predicate simplifies to {@code false} after
// precedence predicates are evaluated.</li>
// <li>{@code this}: if the semantic context is not changed as a result of
// precedence predicate evaluation.</li>
// <li>A non-{@code null} {@link SemanticContext}: the new simplified
// semantic context after precedence predicates are evaluated.</li>
// </ul>
//
SemanticContext.prototype.evalPrecedence = function(parser, outerContext) {
	return this;
};

SemanticContext.andContext = function(a, b) {
	if (a === null || a === SemanticContext.NONE) {
		return b;
	}
	if (b === null || b === SemanticContext.NONE) {
		return a;
	}
	var result = new AND(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

SemanticContext.orContext = function(a, b) {
	if (a === null) {
		return b;
	}
	if (b === null) {
		return a;
	}
	if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
		return SemanticContext.NONE;
	}
	var result = new OR(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

function Predicate(ruleIndex, predIndex, isCtxDependent) {
	SemanticContext.call(this);
	this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
	this.predIndex = predIndex === undefined ? -1 : predIndex;
	this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
	return this;
}

Predicate.prototype = Object.create(SemanticContext.prototype);
Predicate.prototype.constructor = Predicate;

//The default {@link SemanticContext}, which is semantically equivalent to
//a predicate of the form {@code {true}?}.
//
SemanticContext.NONE = new Predicate();


Predicate.prototype.evaluate = function(parser, outerContext) {
	var localctx = this.isCtxDependent ? outerContext : null;
	return parser.sempred(localctx, this.ruleIndex, this.predIndex);
};

Predicate.prototype.hashString = function() {
	return "" + this.ruleIndex + "/" + this.predIndex + "/" + this.isCtxDependent;
};

Predicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof Predicate)) {
		return false;
	} else {
		return this.ruleIndex === other.ruleIndex &&
				this.predIndex === other.predIndex &&
				this.isCtxDependent === other.isCtxDependent;
	}
};

Predicate.prototype.toString = function() {
	return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
};

function PrecedencePredicate(precedence) {
	SemanticContext.call(this);
	this.precedence = precedence === undefined ? 0 : precedence;
}

PrecedencePredicate.prototype = Object.create(SemanticContext.prototype);
PrecedencePredicate.prototype.constructor = PrecedencePredicate;

PrecedencePredicate.prototype.evaluate = function(parser, outerContext) {
	return parser.precpred(outerContext, this.precedence);
};

PrecedencePredicate.prototype.evalPrecedence = function(parser, outerContext) {
	if (parser.precpred(outerContext, this.precedence)) {
		return SemanticContext.NONE;
	} else {
		return null;
	}
};

PrecedencePredicate.prototype.compareTo = function(other) {
	return this.precedence - other.precedence;
};

PrecedencePredicate.prototype.hashString = function() {
	return "31";
};

PrecedencePredicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof PrecedencePredicate)) {
		return false;
	} else {
		return this.precedence === other.precedence;
	}
};

PrecedencePredicate.prototype.toString = function() {
	return "{"+this.precedence+">=prec}?";
};



PrecedencePredicate.filterPrecedencePredicates = function(set) {
	var result = [];
	set.values().map( function(context) {
		if (context instanceof PrecedencePredicate) {
			result.push(context);
		}
	});
	return result;
};


// A semantic context which is true whenever none of the contained contexts
// is false.
//
function AND(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof AND) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof AND) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}
	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the lowest precedence
		var reduced = null;
		precedencePredicates.map( function(p) {
			if(reduced===null || p.precedence<reduced.precedence) {
				reduced = p;
			}
		});
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

AND.prototype = Object.create(SemanticContext.prototype);
AND.prototype.constructor = AND;

AND.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof AND)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

AND.prototype.hashString = function() {
	return "" + this.opnds + "/AND";
};
//
// {@inheritDoc}
//
// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
AND.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (!this.opnds[i].evaluate(parser, outerContext)) {
			return false;
		}
	}
	return true;
};

AND.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === null) {
			// The AND context is false if any element is false
			return null;
		} else if (evaluated !== SemanticContext.NONE) {
			// Reduce the result by skipping true elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were true, so the AND context is true
		return SemanticContext.NONE;
	}
	var result = null;
	operands.map(function(o) {
		result = result === null ? o : SemanticPredicate.andContext(result, o);
	});
	return result;
};

AND.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "&& " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

//
// A semantic context which is true whenever at least one of the contained
// contexts is true.
//
function OR(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof OR) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof OR) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}

	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the highest precedence
		var s = precedencePredicates.sort(function(a, b) {
			return a.compareTo(b);
		});
		var reduced = s[s.length-1];
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

OR.prototype = Object.create(SemanticContext.prototype);
OR.prototype.constructor = OR;

OR.prototype.constructor = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof OR)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

OR.prototype.hashString = function() {
	return "" + this.opnds + "/OR"; 
};

// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
OR.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (this.opnds[i].evaluate(parser, outerContext)) {
			return true;
		}
	}
	return false;
};

OR.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === SemanticContext.NONE) {
			// The OR context is true if any element is true
			return SemanticContext.NONE;
		} else if (evaluated !== null) {
			// Reduce the result by skipping false elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were false, so the OR context is false
		return null;
	}
	var result = null;
	operands.map(function(o) {
		return result === null ? o : SemanticContext.orContext(result, o);
	});
	return result;
};

AND.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "|| " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

exports.SemanticContext = SemanticContext;
exports.PrecedencePredicate = PrecedencePredicate;
exports.Predicate = Predicate;

},{"./../Utils":28}],43:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

//  An ATN transition between any two ATN states.  Subclasses define
//  atom, set, epsilon, action, predicate, rule transitions.
//
//  <p>This is a one way link.  It emanates from a state (usually via a list of
//  transitions) and has a target state.</p>
//
//  <p>Since we never have to change the ATN transitions once we construct it,
//  we can fix these transitions as specific classes. The DFA transitions
//  on the other hand need to update the labels as it adds transitions to
//  the states. We'll use the term Edge for the DFA to distinguish them from
//  ATN transitions.</p>

var Token = require('./../Token').Token;
var Interval = require('./../IntervalSet').Interval;
var IntervalSet = require('./../IntervalSet').IntervalSet;
var Predicate = require('./SemanticContext').Predicate;
var PrecedencePredicate = require('./SemanticContext').PrecedencePredicate;

function Transition (target) {
    // The target of this transition.
    if (target===undefined || target===null) {
        throw "target cannot be null.";
    }
    this.target = target;
    // Are we epsilon, action, sempred?
    this.isEpsilon = false;
    this.label = null;
    return this;
}
    // constants for serialization
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4; // e.g., {isType(input.LT(1))}?
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7; // ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;

Transition.serializationNames = [
            "INVALID",
            "EPSILON",
            "RANGE",
            "RULE",
            "PREDICATE",
            "ATOM",
            "ACTION",
            "SET",
            "NOT_SET",
            "WILDCARD",
            "PRECEDENCE"
        ];

Transition.serializationTypes = {
        EpsilonTransition: Transition.EPSILON,
        RangeTransition: Transition.RANGE,
        RuleTransition: Transition.RULE,
        PredicateTransition: Transition.PREDICATE,
        AtomTransition: Transition.ATOM,
        ActionTransition: Transition.ACTION,
        SetTransition: Transition.SET,
        NotSetTransition: Transition.NOT_SET,
        WildcardTransition: Transition.WILDCARD,
        PrecedencePredicateTransition: Transition.PRECEDENCE
    };


// TODO: make all transitions sets? no, should remove set edges
function AtomTransition(target, label) {
	Transition.call(this, target);
	this.label_ = label; // The token type or character value; or, signifies special label.
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
    return this;
}

AtomTransition.prototype = Object.create(Transition.prototype);
AtomTransition.prototype.constructor = AtomTransition;

AtomTransition.prototype.makeLabel = function() {
	var s = new IntervalSet();
    s.addOne(this.label_);
    return s;
};

AtomTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
    return this.label_ === symbol;
};

AtomTransition.prototype.toString = function() {
	return this.label_;
};

function RuleTransition(ruleStart, ruleIndex, precedence, followState) {
	Transition.call(this, ruleStart);
    this.ruleIndex = ruleIndex; // ptr to the rule definition object for this rule ref
    this.precedence = precedence;
    this.followState = followState; // what node to begin computations following ref to rule
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
    return this;
}

RuleTransition.prototype = Object.create(Transition.prototype);
RuleTransition.prototype.constructor = RuleTransition;

RuleTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};


function EpsilonTransition(target, outermostPrecedenceReturn) {
	Transition.call(this, target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    return this;
}

EpsilonTransition.prototype = Object.create(Transition.prototype);
EpsilonTransition.prototype.constructor = EpsilonTransition;

EpsilonTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

EpsilonTransition.prototype.toString = function() {
	return "epsilon";
};

function RangeTransition(target, start, stop) {
	Transition.call(this, target);
	this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
    return this;
}

RangeTransition.prototype = Object.create(Transition.prototype);
RangeTransition.prototype.constructor = RangeTransition;

RangeTransition.prototype.makeLabel = function() {
    var s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
};

RangeTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= this.start && symbol <= this.stop;
};

RangeTransition.prototype.toString = function() {
	return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
};

function AbstractPredicateTransition(target) {
	Transition.call(this, target);
	return this;
}

AbstractPredicateTransition.prototype = Object.create(Transition.prototype);
AbstractPredicateTransition.prototype.constructor = AbstractPredicateTransition;

function PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

PredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PredicateTransition.prototype.constructor = PredicateTransition;

PredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PredicateTransition.prototype.getPredicate = function() {
	return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

PredicateTransition.prototype.toString = function() {
	return "pred_" + this.ruleIndex + ":" + this.predIndex;
};

function ActionTransition(target, ruleIndex, actionIndex, isCtxDependent) {
	Transition.call(this, target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex===undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

ActionTransition.prototype = Object.create(Transition.prototype);
ActionTransition.prototype.constructor = ActionTransition;


ActionTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

ActionTransition.prototype.toString = function() {
	return "action_" + this.ruleIndex + ":" + this.actionIndex;
};
        

// A transition containing a set of values.
function SetTransition(target, set) {
	Transition.call(this, target);
	this.serializationType = Transition.SET;
    if (set !==undefined && set !==null) {
        this.label = set;
    } else {
        this.label = new IntervalSet();
        this.label.addOne(Token.INVALID_TYPE);
    }
    return this;
}

SetTransition.prototype = Object.create(Transition.prototype);
SetTransition.prototype.constructor = SetTransition;

SetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return this.label.contains(symbol);
};
        

SetTransition.prototype.toString = function() {
	return this.label.toString();
};

function NotSetTransition(target, set) {
	SetTransition.call(this, target, set);
	this.serializationType = Transition.NOT_SET;
	return this;
}

NotSetTransition.prototype = Object.create(SetTransition.prototype);
NotSetTransition.prototype.constructor = NotSetTransition;

NotSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
			!SetTransition.prototype.matches.call(this, symbol, minVocabSymbol, maxVocabSymbol);
};

NotSetTransition.prototype.toString = function() {
	return '~' + SetTransition.prototype.toString.call(this);
};

function WildcardTransition(target) {
	Transition.call(this, target);
	this.serializationType = Transition.WILDCARD;
	return this;
}

WildcardTransition.prototype = Object.create(Transition.prototype);
WildcardTransition.prototype.constructor = WildcardTransition;


WildcardTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
};

WildcardTransition.prototype.toString = function() {
	return ".";
};

function PrecedencePredicateTransition(target, precedence) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
    return this;
}

PrecedencePredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PrecedencePredicateTransition.prototype.constructor = PrecedencePredicateTransition;

PrecedencePredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PrecedencePredicateTransition.prototype.getPredicate = function() {
	return new PrecedencePredicate(this.precedence);
};

PrecedencePredicateTransition.prototype.toString = function() {
	return this.precedence + " >= _p";
};
        
exports.Transition = Transition;
exports.AtomTransition = AtomTransition;
exports.SetTransition = SetTransition;
exports.NotSetTransition = NotSetTransition;
exports.RuleTransition = RuleTransition;
exports.ActionTransition = ActionTransition;
exports.EpsilonTransition = EpsilonTransition;
exports.RangeTransition = RangeTransition;
exports.WildcardTransition = WildcardTransition;
exports.PredicateTransition = PredicateTransition;
exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
exports.AbstractPredicateTransition = AbstractPredicateTransition;
},{"./../IntervalSet":19,"./../Token":27,"./SemanticContext":42}],44:[function(require,module,exports){
exports.ATN = require('./ATN').ATN;
exports.ATNDeserializer = require('./ATNDeserializer').ATNDeserializer;
exports.LexerATNSimulator = require('./LexerATNSimulator').LexerATNSimulator;
exports.ParserATNSimulator = require('./ParserATNSimulator').ParserATNSimulator;
exports.PredictionMode = require('./PredictionMode').PredictionMode;
},{"./ATN":29,"./ATNDeserializer":33,"./LexerATNSimulator":37,"./ParserATNSimulator":40,"./PredictionMode":41}],45:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var DFAState = require('./DFAState').DFAState;
var ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;
var DFASerializer = require('./DFASerializer').DFASerializer;
var LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;

function DFAStatesSet() {
	return this;
}

Object.defineProperty(DFAStatesSet.prototype, "length", {
	get : function() {
		return Object.keys(this).length;
	}
});

function DFA(atnStartState, decision) {
	if (decision === undefined) {
		decision = 0;
	}
	// From which ATN state did we create this DFA?
	this.atnStartState = atnStartState;
	this.decision = decision;
	// A set of all DFA states. Use {@link Map} so we can get old state back
	// ({@link Set} only allows you to see if it's there).
	this._states = new DFAStatesSet();
	this.s0 = null;
	// {@code true} if this DFA is for a precedence decision; otherwise,
	// {@code false}. This is the backing field for {@link //isPrecedenceDfa},
	// {@link //setPrecedenceDfa}.
	this.precedenceDfa = false;
	return this;
}

// Get the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @return The start state corresponding to the specified precedence, or
// {@code null} if no start state exists for the specified precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()

DFA.prototype.getPrecedenceStartState = function(precedence) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	// s0.edges is never null for a precedence DFA
	if (precedence < 0 || precedence >= this.s0.edges.length) {
		return null;
	}
	return this.s0.edges[precedence] || null;
};

// Set the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @param startState The start state corresponding to the specified
// precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()
//
DFA.prototype.setPrecedenceStartState = function(precedence, startState) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	if (precedence < 0) {
		return;
	}

	// synchronization on s0 here is ok. when the DFA is turned into a
	// precedence DFA, s0 will be initialized once and not updated again
	// s0.edges is never null for a precedence DFA
	this.s0.edges[precedence] = startState;
};

//
// Sets whether this is a precedence DFA. If the specified value differs
// from the current DFA configuration, the following actions are taken;
// otherwise no changes are made to the current DFA.
//
// <ul>
// <li>The {@link //states} map is cleared</li>
// <li>If {@code precedenceDfa} is {@code false}, the initial state
// {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
// {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
// store the start states for individual precedence values.</li>
// <li>The {@link //precedenceDfa} field is updated</li>
// </ul>
//
// @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
// {@code false}

DFA.prototype.setPrecedenceDfa = function(precedenceDfa) {
	if (this.precedenceDfa!==precedenceDfa) {
		this._states = new DFAStatesSet();
		if (precedenceDfa) {
			var precedenceState = new DFAState(new ATNConfigSet());
			precedenceState.edges = [];
			precedenceState.isAcceptState = false;
			precedenceState.requiresFullContext = false;
			this.s0 = precedenceState;
		} else {
			this.s0 = null;
		}
		this.precedenceDfa = precedenceDfa;
	}
};

Object.defineProperty(DFA.prototype, "states", {
	get : function() {
		return this._states;
	}
});

// Return a list of all states in this DFA, ordered by state number.
DFA.prototype.sortedStates = function() {
	// states_ is a map of state/state, where key=value
	var keys = Object.keys(this._states);
	var list = [];
	for(var i=0;i<keys.length;i++) {
		list.push(this._states[keys[i]]);
	}
	return list.sort(function(a, b) {
		return a.stateNumber - b.stateNumber;
	});
};

DFA.prototype.toString = function(literalNames, symbolicNames) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	if (this.s0 === null) {
		return "";
	}
	var serializer = new DFASerializer(this, literalNames, symbolicNames);
	return serializer.toString();
};

DFA.prototype.toLexerString = function() {
	if (this.s0 === null) {
		return "";
	}
	var serializer = new LexerDFASerializer(this);
	return serializer.toString();
};

exports.DFA = DFA;

},{"./../atn/ATNConfigSet":31,"./DFASerializer":46,"./DFAState":47}],46:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.

//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:

//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// A DFA walker that knows how to dump them to serialized strings.#/


function DFASerializer(dfa, literalNames, symbolicNames) {
	this.dfa = dfa;
	this.literalNames = literalNames || [];
	this.symbolicNames = symbolicNames || [];
	return this;
}

DFASerializer.prototype.toString = function() {
   if(this.dfa.s0 === null) {
       return null;
   }
   var buf = "";
   var states = this.dfa.sortedStates();
   for(var i=0;i<states.length;i++) {
       var s = states[i];
       if(s.edges!==null) {
            var n = s.edges.length;
            for(var j=0;j<n;j++) {
                var t = s.edges[j] || null;
                if(t!==null && t.stateNumber !== 0x7FFFFFFF) {
                    buf = buf.concat(this.getStateString(s));
                    buf = buf.concat("-");
                    buf = buf.concat(this.getEdgeLabel(j));
                    buf = buf.concat("->");
                    buf = buf.concat(this.getStateString(t));
                    buf = buf.concat('\n');
                }
            }
       }
   }
   return buf.length===0 ? null : buf;
};

DFASerializer.prototype.getEdgeLabel = function(i) {
    if (i===0) {
        return "EOF";
    } else if(this.literalNames !==null || this.symbolicNames!==null) {
        return this.literalNames[i-1] || this.symbolicNames[i-1];
    } else {
        return String.fromCharCode(i-1);
    }
};

DFASerializer.prototype.getStateString = function(s) {
    var baseStateStr = ( s.isAcceptState ? ":" : "") + "s" + s.stateNumber + ( s.requiresFullContext ? "^" : "");
    if(s.isAcceptState) {
        if (s.predicates !== null) {
            return baseStateStr + "=>" + s.predicates.toString();
        } else {
            return baseStateStr + "=>" + s.prediction.toString();
        }
    } else {
        return baseStateStr;
    }
};

function LexerDFASerializer(dfa) {
	DFASerializer.call(this, dfa, null);
	return this;
}

LexerDFASerializer.prototype = Object.create(DFASerializer.prototype);
LexerDFASerializer.prototype.constructor = LexerDFASerializer;

LexerDFASerializer.prototype.getEdgeLabel = function(i) {
	return "'" + String.fromCharCode(i) + "'";
};

exports.DFASerializer = DFASerializer;
exports.LexerDFASerializer = LexerDFASerializer;


},{}],47:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

var ATNConfigSet = require('./../atn/ATNConfigSet').ATNConfigSet;

// Map a predicate to a predicted alternative.///

function PredPrediction(pred, alt) {
	this.alt = alt;
	this.pred = pred;
	return this;
}

PredPrediction.prototype.toString = function() {
	return "(" + this.pred + ", " + this.alt + ")";
};

// A DFA state represents a set of possible ATN configurations.
// As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
// to keep track of all possible states the ATN can be in after
// reading each input symbol. That is to say, after reading
// input a1a2..an, the DFA is in a state that represents the
// subset T of the states of the ATN that are reachable from the
// ATN's start state along some path labeled a1a2..an."
// In conventional NFA&rarr;DFA conversion, therefore, the subset T
// would be a bitset representing the set of states the
// ATN could be in. We need to track the alt predicted by each
// state as well, however. More importantly, we need to maintain
// a stack of states, tracking the closure operations as they
// jump from rule to rule, emulating rule invocations (method calls).
// I have to add a stack to simulate the proper lookahead sequences for
// the underlying LL grammar from which the ATN was derived.
//
// <p>I use a set of ATNConfig objects not simple states. An ATNConfig
// is both a state (ala normal conversion) and a RuleContext describing
// the chain of rules (if any) followed to arrive at that state.</p>
//
// <p>A DFA state may have multiple references to a particular state,
// but with different ATN contexts (with same or different alts)
// meaning that state was reached via a different set of rule invocations.</p>
// /

function DFAState(stateNumber, configs) {
	if (stateNumber === null) {
		stateNumber = -1;
	}
	if (configs === null) {
		configs = new ATNConfigSet();
	}
	this.stateNumber = stateNumber;
	this.configs = configs;
	// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
	// {@link Token//EOF} maps to {@code edges[0]}.
	this.edges = null;
	this.isAcceptState = false;
	// if accept state, what ttype do we match or alt do we predict?
	// This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link
	// //predicates}{@code !=null} or
	// {@link //requiresFullContext}.
	this.prediction = 0;
	this.lexerActionExecutor = null;
	// Indicates that this state was created during SLL prediction that
	// discovered a conflict between the configurations in the state. Future
	// {@link ParserATNSimulator//execATN} invocations immediately jumped doing
	// full context prediction if this field is true.
	this.requiresFullContext = false;
	// During SLL parsing, this is a list of predicates associated with the
	// ATN configurations of the DFA state. When we have predicates,
	// {@link //requiresFullContext} is {@code false} since full context
	// prediction evaluates predicates
	// on-the-fly. If this is not null, then {@link //prediction} is
	// {@link ATN//INVALID_ALT_NUMBER}.
	//
	// <p>We only use these for non-{@link //requiresFullContext} but
	// conflicting states. That
	// means we know from the context (it's $ or we don't dip into outer
	// context) that it's an ambiguity not a conflict.</p>
	//
	// <p>This list is computed by {@link
	// ParserATNSimulator//predicateDFAState}.</p>
	this.predicates = null;
	return this;
}

// Get the set of all alts mentioned by all ATN configurations in this
// DFA state.
DFAState.prototype.getAltSet = function() {
	var alts = new Set();
	if (this.configs !== null) {
		for (var i = 0; i < this.configs.length; i++) {
			var c = this.configs[i];
			alts.add(c.alt);
		}
	}
	if (alts.length === 0) {
		return null;
	} else {
		return alts;
	}
};

// Two {@link DFAState} instances are equal if their ATN configuration sets
// are the same. This method is used to see if a state already exists.
//
// <p>Because the number of alternatives and number of ATN configurations are
// finite, there is a finite number of DFA states that can be processed.
// This is necessary to show that the algorithm terminates.</p>
//
// <p>Cannot test the DFA state numbers here because in
// {@link ParserATNSimulator//addDFAState} we need to know if any other state
// exists that has this exact set of ATN configurations. The
// {@link //stateNumber} is irrelevant.</p>
DFAState.prototype.equals = function(other) {
	// compare set of ATN configurations in this set with other
	if (this === other) {
		return true;
	} else if (!(other instanceof DFAState)) {
		return false;
	} else {
		return this.configs.equals(other.configs);
	}
};

DFAState.prototype.toString = function() {
	return "" + this.stateNumber + ":" + this.hashString();
};

DFAState.prototype.hashString = function() {
	return "" +  this.configs +
			(this.isAcceptState ?
					"=>" + (this.predicates !== null ?
								this.predicates :
								this.prediction) :
					"");
};

exports.DFAState = DFAState;
exports.PredPrediction = PredPrediction;
},{"./../atn/ATNConfigSet":31}],48:[function(require,module,exports){
exports.DFA = require('./DFA').DFA;
exports.DFASerializer = require('./DFASerializer').DFASerializer;
exports.LexerDFASerializer = require('./DFASerializer').LexerDFASerializer;
exports.PredPrediction = require('./DFAState').PredPrediction;

},{"./DFA":45,"./DFASerializer":46,"./DFAState":47}],49:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

//
// This implementation of {@link ANTLRErrorListener} can be used to identify
// certain potential correctness and performance problems in grammars. "Reports"
// are made by calling {@link Parser//notifyErrorListeners} with the appropriate
// message.
//
// <ul>
// <li><b>Ambiguities</b>: These are cases where more than one path through the
// grammar can match the input.</li>
// <li><b>Weak context sensitivity</b>: These are cases where full-context
// prediction resolved an SLL conflict to a unique alternative which equaled the
// minimum alternative of the SLL conflict.</li>
// <li><b>Strong (forced) context sensitivity</b>: These are cases where the
// full-context prediction resolved an SLL conflict to a unique alternative,
// <em>and</em> the minimum alternative of the SLL conflict was found to not be
// a truly viable alternative. Two-stage parsing cannot be used for inputs where
// this situation occurs.</li>
// </ul>

var BitSet = require('./../Utils').BitSet;
var ErrorListener = require('./ErrorListener').ErrorListener;
var Interval = require('./../IntervalSet').Interval;

function DiagnosticErrorListener(exactOnly) {
	ErrorListener.call(this);
	exactOnly = exactOnly || true;
	// whether all ambiguities or only exact ambiguities are reported.
	this.exactOnly = exactOnly;
	return this;
}

DiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);
DiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;

DiagnosticErrorListener.prototype.reportAmbiguity = function(recognizer, dfa,
		startIndex, stopIndex, exact, ambigAlts, configs) {
	if (this.exactOnly && !exact) {
		return;
	}
	var msg = "reportAmbiguity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			": ambigAlts=" +
			this.getConflictingAlts(ambigAlts, configs) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportAttemptingFullContext = function(
		recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	var msg = "reportAttemptingFullContext d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportContextSensitivity = function(
		recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	var msg = "reportContextSensitivity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.getDecisionDescription = function(recognizer, dfa) {
	var decision = dfa.decision;
	var ruleIndex = dfa.atnStartState.ruleIndex;

	var ruleNames = recognizer.ruleNames;
	if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
		return "" + decision;
	}
	var ruleName = ruleNames[ruleIndex] || null;
	if (ruleName === null || ruleName.length === 0) {
		return "" + decision;
	}
	return "" + decision + " (" + ruleName + ")";
};

//
// Computes the set of conflicting or ambiguous alternatives from a
// configuration set, if that information was not already provided by the
// parser.
//
// @param reportedAlts The set of conflicting or ambiguous alternatives, as
// reported by the parser.
// @param configs The conflicting or ambiguous configuration set.
// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
// returns the set of alternatives represented in {@code configs}.
//
DiagnosticErrorListener.prototype.getConflictingAlts = function(reportedAlts, configs) {
	if (reportedAlts !== null) {
		return reportedAlts;
	}
	var result = new BitSet();
	for (var i = 0; i < configs.items.length; i++) {
		result.add(configs.items[i].alt);
	}
	return "{" + result.values().join(", ") + "}";
};

exports.DiagnosticErrorListener = DiagnosticErrorListener;
},{"./../IntervalSet":19,"./../Utils":28,"./ErrorListener":50}],50:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Provides an empty default implementation of {@link ANTLRErrorListener}. The
// default implementation of each method does nothing, but can be overridden as
// necessary.

function ErrorListener() {
	return this;
}

ErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
};

ErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
};

ErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
};

ErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
};

function ConsoleErrorListener() {
	ErrorListener.call(this);
	return this;
}

ConsoleErrorListener.prototype = Object.create(ErrorListener.prototype);
ConsoleErrorListener.prototype.constructor = ConsoleErrorListener;

//
// Provides a default instance of {@link ConsoleErrorListener}.
//
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

//
// {@inheritDoc}
//
// <p>
// This implementation prints messages to {@link System//err} containing the
// values of {@code line}, {@code charPositionInLine}, and {@code msg} using
// the following format.</p>
//
// <pre>
// line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
// </pre>
//
ConsoleErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
};

function ProxyErrorListener(delegates) {
	ErrorListener.call(this);
    if (delegates===null) {
        throw "delegates";
    }
    this.delegates = delegates;
	return this;
}

ProxyErrorListener.prototype = Object.create(ErrorListener.prototype);
ProxyErrorListener.prototype.constructor = ProxyErrorListener;

ProxyErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(function(d) { d.syntaxError(recognizer, offendingSymbol, line, column, msg, e); });
};

ProxyErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(function(d) { d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs); });
};

ProxyErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	this.delegates.map(function(d) { d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs); });
};

ProxyErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	this.delegates.map(function(d) { d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs); });
};

exports.ErrorListener = ErrorListener;
exports.ConsoleErrorListener = ConsoleErrorListener;
exports.ProxyErrorListener = ProxyErrorListener;


},{}],51:[function(require,module,exports){
//
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//

var Token = require('./../Token').Token;
var Errors = require('./Errors');
var NoViableAltException = Errors.NoViableAltException;
var InputMismatchException = Errors.InputMismatchException;
var FailedPredicateException = Errors.FailedPredicateException;
var ParseCancellationException = Errors.ParseCancellationException;
var ATNState = require('./../atn/ATNState').ATNState;
var Interval = require('./../IntervalSet').Interval;
var IntervalSet = require('./../IntervalSet').IntervalSet;

function ErrorStrategy() {
	
}

ErrorStrategy.prototype.reset = function(recognizer){
};

ErrorStrategy.prototype.recoverInline = function(recognizer){
};

ErrorStrategy.prototype.recover = function(recognizer, e){
};

ErrorStrategy.prototype.sync = function(recognizer){
};

ErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer){
};

ErrorStrategy.prototype.reportError = function(recognizer){
};



// This is the default implementation of {@link ANTLRErrorStrategy} used for
// error reporting and recovery in ANTLR parsers.
//
function DefaultErrorStrategy() {
	ErrorStrategy.call(this);
    // Indicates whether the error strategy is currently "recovering from an
    // error". This is used to suppress reporting multiple error messages while
    // attempting to recover from a detected syntax error.
    //
    // @see //inErrorRecoveryMode
    //
    this.errorRecoveryMode = false;

    // The index into the input stream where the last error occurred.
    // This is used to prevent infinite loops where an error is found
    // but no token is consumed during recovery...another error is found,
    // ad nauseum. This is a failsafe mechanism to guarantee that at least
    // one token/tree node is consumed for two errors.
    //
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    return this;
}

DefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);
DefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy;

// <p>The default implementation simply calls {@link //endErrorCondition} to
// ensure that the handler is not in error recovery mode.</p>
DefaultErrorStrategy.prototype.reset = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// This method is called to enter error recovery mode when a recognition
// exception is reported.
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.beginErrorCondition = function(recognizer) {
    this.errorRecoveryMode = true;
};

DefaultErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer) {
    return this.errorRecoveryMode;
};

//
// This method is called to leave error recovery mode after recovering from
// a recognition exception.
//
// @param recognizer
//
DefaultErrorStrategy.prototype.endErrorCondition = function(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
};

//
// {@inheritDoc}
//
// <p>The default implementation simply calls {@link //endErrorCondition}.</p>
//
DefaultErrorStrategy.prototype.reportMatch = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// {@inheritDoc}
//
// <p>The default implementation returns immediately if the handler is already
// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
// and dispatches the reporting task based on the runtime type of {@code e}
// according to the following table.</p>
//
// <ul>
// <li>{@link NoViableAltException}: Dispatches the call to
// {@link //reportNoViableAlternative}</li>
// <li>{@link InputMismatchException}: Dispatches the call to
// {@link //reportInputMismatch}</li>
// <li>{@link FailedPredicateException}: Dispatches the call to
// {@link //reportFailedPredicate}</li>
// <li>All other types: calls {@link Parser//notifyErrorListeners} to report
// the exception</li>
// </ul>
//
DefaultErrorStrategy.prototype.reportError = function(recognizer, e) {
   // if we've already reported an error and have not matched a token
   // yet successfully, don't report any errors.
    if(this.inErrorRecoveryMode(recognizer)) {
        return; // don't report spurious errors
    }
    this.beginErrorCondition(recognizer);
    if ( e instanceof NoViableAltException ) {
        this.reportNoViableAlternative(recognizer, e);
    } else if ( e instanceof InputMismatchException ) {
        this.reportInputMismatch(recognizer, e);
    } else if ( e instanceof FailedPredicateException ) {
        this.reportFailedPredicate(recognizer, e);
    } else {
        console.log("unknown recognition error type: " + e.constructor.name);
        console.log(e.stack);
        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
};
//
// {@inheritDoc}
//
// <p>The default implementation resynchronizes the parser by consuming tokens
// until we find one in the resynchronization set--loosely the set of tokens
// that can follow the current rule.</p>
//
DefaultErrorStrategy.prototype.recover = function(recognizer, e) {
    if (this.lastErrorIndex===recognizer.getInputStream().index &&
        this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {
		// uh oh, another error at same token index and previously-visited
		// state in ATN; must be a case where LT(1) is in the recovery
		// token set so nothing got consumed. Consume a single token
		// at least to prevent an infinite loop; this is a failsafe.
		recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
        this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    var followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
};

// The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
// that the current lookahead symbol is consistent with what were expecting
// at this point in the ATN. You can call this anytime but ANTLR only
// generates code to check before subrules/loops and each iteration.
//
// <p>Implements Jim Idle's magic sync mechanism in closures and optional
// subrules. E.g.,</p>
//
// <pre>
// a : sync ( stuff sync )* ;
// sync : {consume to what can follow sync} ;
// </pre>
//
// At the start of a sub rule upon error, {@link //sync} performs single
// token deletion, if possible. If it can't do that, it bails on the current
// rule and uses the default error recovery, which consumes until the
// resynchronization set of the current rule.
//
// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
// with an empty alternative), then the expected set includes what follows
// the subrule.</p>
//
// <p>During loop iteration, it consumes until it sees a token that can start a
// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
// stay in the loop as long as possible.</p>
//
// <p><strong>ORIGINS</strong></p>
//
// <p>Previous versions of ANTLR did a poor job of their recovery within loops.
// A single mismatch token or missing token would force the parser to bail
// out of the entire rules surrounding the loop. So, for rule</p>
//
// <pre>
// classDef : 'class' ID '{' member* '}'
// </pre>
//
// input with an extra token between members would force the parser to
// consume until it found the next class definition rather than the next
// member definition of the current class.
//
// <p>This functionality cost a little bit of effort because the parser has to
// compare token set at the start of the loop and at each iteration. If for
// some reason speed is suffering for you, you can turn off this
// functionality by simply overriding this method as a blank { }.</p>
//
DefaultErrorStrategy.prototype.sync = function(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    var s = recognizer._interp.atn.states[recognizer.state];
    var la = recognizer.getTokenStream().LA(1);
    // try cheaper subset first; might get lucky. seems to shave a wee bit off
    if (la===Token.EOF || recognizer.atn.nextTokens(s).contains(la)) {
        return;
    }
    // Return but don't end recovery. only do that upon valid token match
    if(recognizer.isExpectedToken(la)) {
        return;
    }
    switch (s.stateType) {
    case ATNState.BLOCK_START:
    case ATNState.STAR_BLOCK_START:
    case ATNState.PLUS_BLOCK_START:
    case ATNState.STAR_LOOP_ENTRY:
       // report error and recover if possible
        if( this.singleTokenDeletion(recognizer) !== null) {
            return;
        } else {
            throw new InputMismatchException(recognizer);
        }
        break;
    case ATNState.PLUS_LOOP_BACK:
    case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        var expecting = recognizer.getExpectedTokens();
        var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
    default:
        // do nothing if we can't identify the exact kind of ATN state
    }
};

// This is called by {@link //reportError} when the exception is a
// {@link NoViableAltException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportNoViableAlternative = function(recognizer, e) {
    var tokens = recognizer.getTokenStream();
    var input;
    if(tokens !== null) {
        if (e.startToken.type===Token.EOF) {
            input = "<EOF>";
        } else {
            input = tokens.getText(new Interval(e.startToken, e.offendingToken));
        }
    } else {
        input = "<unknown input>";
    }
    var msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is an
// {@link InputMismatchException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportInputMismatch = function(recognizer, e) {
    var msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
          " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is a
// {@link FailedPredicateException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportFailedPredicate = function(recognizer, e) {
    var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    var msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

// This method is called to report a syntax error which requires the removal
// of a token from the input stream. At the time this method is called, the
// erroneous symbol is current {@code LT(1)} symbol and has not yet been
// removed from the input stream. When this method returns,
// {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenDeletion} identifies
// single-token deletion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportUnwantedToken = function(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var tokenName = this.getTokenErrorDisplay(t);
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "extraneous input " + tokenName + " expecting " +
        expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
};
// This method is called to report a syntax error which requires the
// insertion of a missing token into the input stream. At the time this
// method is called, the missing token has not yet been inserted. When this
// method returns, {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenInsertion} identifies
// single-token insertion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportMissingToken = function(recognizer) {
    if ( this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
          " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
};

// <p>The default implementation attempts to recover from the mismatched input
// by using single token insertion and deletion as described below. If the
// recovery attempt fails, this method throws an
// {@link InputMismatchException}.</p>
//
// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
//
// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
// right token, however, then assume {@code LA(1)} is some extra spurious
// token and delete it. Then consume and return the next token (which was
// the {@code LA(2)} token) as the successful result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenDeletion}.</p>
//
// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
//
// <p>If current token (at {@code LA(1)}) is consistent with what could come
// after the expected {@code LA(1)} token, then assume the token is missing
// and use the parser's {@link TokenFactory} to create it on the fly. The
// "insertion" is performed by returning the created token as the successful
// result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenInsertion}.</p>
//
// <p><strong>EXAMPLE</strong></p>
//
// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
// the parser returns from the nested call to {@code expr}, it will have
// call chain:</p>
//
// <pre>
// stat &rarr; expr &rarr; atom
// </pre>
//
// and it will be trying to match the {@code ')'} at this point in the
// derivation:
//
// <pre>
// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
// ^
// </pre>
//
// The attempt to match {@code ')'} will fail when it sees {@code ';'} and
// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
// is in the set of tokens that can follow the {@code ')'} token reference
// in rule {@code atom}. It can assume that you forgot the {@code ')'}.
//
DefaultErrorStrategy.prototype.recoverInline = function(recognizer) {
    // SINGLE TOKEN DELETION
    var matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
        // we have deleted the extra token.
        // now, move past ttype token as if all were ok
        recognizer.consume();
        return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
};

//
// This method implements the single-token insertion inline error recovery
// strategy. It is called by {@link //recoverInline} if the single-token
// deletion strategy fails to recover from the mismatched input. If this
// method returns {@code true}, {@code recognizer} will be in error recovery
// mode.
//
// <p>This method determines whether or not single-token insertion is viable by
// checking if the {@code LA(1)} input symbol could be successfully matched
// if it were instead the {@code LA(2)} symbol. If this method returns
// {@code true}, the caller is responsible for creating and inserting a
// token with the correct type to produce this behavior.</p>
//
// @param recognizer the parser instance
// @return {@code true} if single-token insertion is a viable recovery
// strategy for the current mismatched input, otherwise {@code false}
//
DefaultErrorStrategy.prototype.singleTokenInsertion = function(recognizer) {
    var currentSymbolType = recognizer.getTokenStream().LA(1);
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    var atn = recognizer._interp.atn;
    var currentState = atn.states[recognizer.state];
    var next = currentState.transitions[0].target;
    var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType) ){
        this.reportMissingToken(recognizer);
        return true;
    } else {
        return false;
    }
};

// This method implements the single-token deletion inline error recovery
// strategy. It is called by {@link //recoverInline} to attempt to recover
// from mismatched input. If this method returns null, the parser and error
// handler state will not have changed. If this method returns non-null,
// {@code recognizer} will <em>not</em> be in error recovery mode since the
// returned token was a successful match.
//
// <p>If the single-token deletion is successful, this method calls
// {@link //reportUnwantedToken} to report the error, followed by
// {@link Parser//consume} to actually "delete" the extraneous token. Then,
// before returning {@link //reportMatch} is called to signal a successful
// match.</p>
//
// @param recognizer the parser instance
// @return the successfully matched {@link Token} instance if single-token
// deletion successfully recovers from the mismatched input, otherwise
// {@code null}
//
DefaultErrorStrategy.prototype.singleTokenDeletion = function(recognizer) {
    var nextTokenType = recognizer.getTokenStream().LA(2);
    var expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        // print("recoverFromMismatchedToken deleting " \
        // + str(recognizer.getTokenStream().LT(1)) \
        // + " since " + str(recognizer.getTokenStream().LT(2)) \
        // + " is what we want", file=sys.stderr)
        recognizer.consume(); // simply delete extra token
        // we want to return the token we're actually matching
        var matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer); // we know current token is correct
        return matchedSymbol;
    } else {
        return null;
    }
};

// Conjure up a missing token during error recovery.
//
// The recognizer attempts to recover from single missing
// symbols. But, actions might refer to that missing symbol.
// For example, x=ID {f($x);}. The action clearly assumes
// that there has been an identifier matched previously and that
// $x points at that token. If that token is missing, but
// the next token in the stream is what we want we assume that
// this token is missing and we keep going. Because we
// have to return some token to replace the missing token,
// we have to conjure one up. This method gives the user control
// over the tokens returned for missing tokens. Mostly,
// you will want to create something special for identifier
// tokens. For literals such as '{' and ',', the default
// action in the parser or tree parser works. It simply creates
// a CommonToken of the appropriate type. The text will be the token.
// If you change what tokens must be created by the lexer,
// override this method to create the appropriate tokens.
//
DefaultErrorStrategy.prototype.getMissingSymbol = function(recognizer) {
    var currentSymbol = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var expectedTokenType = expecting.first(); // get any element
    var tokenText;
    if (expectedTokenType===Token.EOF) {
        tokenText = "<missing EOF>";
    } else {
        tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    var current = currentSymbol;
    var lookback = recognizer.getTokenStream().LT(-1);
    if (current.type===Token.EOF && lookback !== null) {
        current = lookback;
    }
    return recognizer.getTokenFactory().create(current.source,
        expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,
        -1, -1, current.line, current.column);
};

DefaultErrorStrategy.prototype.getExpectedTokens = function(recognizer) {
    return recognizer.getExpectedTokens();
};

// How should a token be displayed in an error message? The default
// is to display just the text, but during development you might
// want to have a lot of information spit out. Override in that case
// to use t.toString() (which, for CommonToken, dumps everything about
// the token). This is better than forcing you to override a method in
// your token objects because you don't have to go modify your lexer
// so that it creates a new Java type.
//
DefaultErrorStrategy.prototype.getTokenErrorDisplay = function(t) {
    if (t === null) {
        return "<no token>";
    }
    var s = t.text;
    if (s === null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    return this.escapeWSAndQuote(s);
};

DefaultErrorStrategy.prototype.escapeWSAndQuote = function(s) {
    s = s.replace(/\n/g,"\\n");
    s = s.replace(/\r/g,"\\r");
    s = s.replace(/\t/g,"\\t");
    return "'" + s + "'";
};

// Compute the error recovery set for the current rule. During
// rule invocation, the parser pushes the set of tokens that can
// follow that rule reference on the stack; this amounts to
// computing FIRST of what follows the rule reference in the
// enclosing rule. See LinearApproximator.FIRST().
// This local follow set only includes tokens
// from within the rule; i.e., the FIRST computation done by
// ANTLR stops at the end of a rule.
//
// EXAMPLE
//
// When you find a "no viable alt exception", the input is not
// consistent with any of the alternatives for rule r. The best
// thing to do is to consume tokens until you see something that
// can legally follow a call to r//or* any rule that called r.
// You don't want the exact set of viable next tokens because the
// input might just be missing a token--you might consume the
// rest of the input looking for one of the missing tokens.
//
// Consider grammar:
//
// a : '[' b ']'
// | '(' b ')'
// ;
// b : c '^' INT ;
// c : ID
// | INT
// ;
//
// At each rule invocation, the set of tokens that could follow
// that rule is pushed on a stack. Here are the various
// context-sensitive follow sets:
//
// FOLLOW(b1_in_a) = FIRST(']') = ']'
// FOLLOW(b2_in_a) = FIRST(')') = ')'
// FOLLOW(c_in_b) = FIRST('^') = '^'
//
// Upon erroneous input "[]", the call chain is
//
// a -> b -> c
//
// and, hence, the follow context stack is:
//
// depth follow set start of rule execution
// 0 <EOF> a (from main())
// 1 ']' b
// 2 '^' c
//
// Notice that ')' is not included, because b would have to have
// been called from a different context in rule a for ')' to be
// included.
//
// For error recovery, we cannot consider FOLLOW(c)
// (context-sensitive or otherwise). We need the combined set of
// all context-sensitive FOLLOW sets--the set of all tokens that
// could follow any reference in the call chain. We need to
// resync to one of those tokens. Note that FOLLOW(c)='^' and if
// we resync'd to that token, we'd consume until EOF. We need to
// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
// In this case, for input "[]", LA(1) is ']' and in the set, so we would
// not consume anything. After printing an error, rule c would
// return normally. Rule b would not find the required '^' though.
// At this point, it gets a mismatched token error and throws an
// exception (since LA(1) is not in the viable following token
// set). The rule exception handler tries to recover, but finds
// the same recovery set and doesn't consume anything. Rule b
// exits normally returning to rule a. Now it finds the ']' (and
// with the successful match exits errorRecovery mode).
//
// So, you can see that the parser walks up the call chain looking
// for the token that was a member of the recovery set.
//
// Errors are not generated in errorRecovery mode.
//
// ANTLR's error recovery mechanism is based upon original ideas:
//
// "Algorithms + Data Structures = Programs" by Niklaus Wirth
//
// and
//
// "A note on error recovery in recursive descent parsers":
// http://portal.acm.org/citation.cfm?id=947902.947905
//
// Later, Josef Grosch had some good ideas:
//
// "Efficient and Comfortable Error Recovery in Recursive Descent
// Parsers":
// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
//
// Like Grosch I implement context-sensitive FOLLOW sets that are combined
// at run-time upon error to avoid overhead during parsing.
//
DefaultErrorStrategy.prototype.getErrorRecoverySet = function(recognizer) {
    var atn = recognizer._interp.atn;
    var ctx = recognizer._ctx;
    var recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState>=0) {
        // compute what follows who invoked us
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        var follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
};

// Consume tokens until one matches the given token set.//
DefaultErrorStrategy.prototype.consumeUntil = function(recognizer, set) {
    var ttype = recognizer.getTokenStream().LA(1);
    while( ttype !== Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.getTokenStream().LA(1);
    }
};

//
// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
// by immediately canceling the parse operation with a
// {@link ParseCancellationException}. The implementation ensures that the
// {@link ParserRuleContext//exception} field is set for all parse tree nodes
// that were not completed prior to encountering the error.
//
// <p>
// This error strategy is useful in the following scenarios.</p>
//
// <ul>
// <li><strong>Two-stage parsing:</strong> This error strategy allows the first
// stage of two-stage parsing to immediately terminate if an error is
// encountered, and immediately fall back to the second stage. In addition to
// avoiding wasted work by attempting to recover from errors here, the empty
// implementation of {@link BailErrorStrategy//sync} improves the performance of
// the first stage.</li>
// <li><strong>Silent validation:</strong> When syntax errors are not being
// reported or logged, and the parse result is simply ignored if errors occur,
// the {@link BailErrorStrategy} avoids wasting work on recovering from errors
// when the result will be ignored either way.</li>
// </ul>
//
// <p>
// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
//
// @see Parser//setErrorHandler(ANTLRErrorStrategy)
//
function BailErrorStrategy() {
	DefaultErrorStrategy.call(this);
	return this;
}

BailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);
BailErrorStrategy.prototype.constructor = BailErrorStrategy;

// Instead of recovering from exception {@code e}, re-throw it wrapped
// in a {@link ParseCancellationException} so it is not caught by the
// rule function catches. Use {@link Exception//getCause()} to get the
// original {@link RecognitionException}.
//
BailErrorStrategy.prototype.recover = function(recognizer, e) {
    var context = recognizer._ctx;
    while (context !== null) {
        context.exception = e;
        context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
};
    
// Make sure we don't attempt to recover inline; if the parser
// successfully recovers, it won't throw an exception.
//
BailErrorStrategy.prototype.recoverInline = function(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
};

// Make sure we don't attempt to recover from problems in subrules.//
BailErrorStrategy.prototype.sync = function(recognizer) {
    // pass
};

exports.BailErrorStrategy = BailErrorStrategy;
exports.DefaultErrorStrategy = DefaultErrorStrategy;
},{"./../IntervalSet":19,"./../Token":27,"./../atn/ATNState":35,"./Errors":52}],52:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
//  3 kinds of errors: prediction errors, failed predicate errors, and
//  mismatched input errors. In each case, the parser knows where it is
//  in the input, where it is in the ATN, the rule invocation stack,
//  and what kind of problem occurred.

var PredicateTransition = require('./../atn/Transition').PredicateTransition;

function RecognitionException(params) {
	Error.call(this);
	if (!!Error.captureStackTrace) {
        Error.captureStackTrace(this, RecognitionException);
	} else {
		var stack = new Error().stack;
	}
	this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    // The current {@link Token} when an error occurred. Since not all streams
    // support accessing symbols by index, we have to track the {@link Token}
    // instance itself.
    this.offendingToken = null;
    // Get the ATN state number the parser was in at the time the error
    // occurred. For {@link NoViableAltException} and
    // {@link LexerNoViableAltException} exceptions, this is the
    // {@link DecisionState} number. For others, it is the state whose outgoing
    // edge we couldn't match.
    this.offendingState = -1;
    if (this.recognizer!==null) {
        this.offendingState = this.recognizer.state;
    }
    return this;
}

RecognitionException.prototype = Object.create(Error.prototype);
RecognitionException.prototype.constructor = RecognitionException;

// <p>If the state number is not known, this method returns -1.</p>

//
// Gets the set of input symbols which could potentially follow the
// previously matched symbol at the time this exception was thrown.
//
// <p>If the set of expected tokens is not known and could not be computed,
// this method returns {@code null}.</p>
//
// @return The set of token types that could potentially follow the current
// state in the ATN, or {@code null} if the information is not available.
// /
RecognitionException.prototype.getExpectedTokens = function() {
    if (this.recognizer!==null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
        return null;
    }
};

RecognitionException.prototype.toString = function() {
    return this.message;
};

function LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {
	RecognitionException.call(this, {message:"", recognizer:lexer, input:input, ctx:null});
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
    return this;
}

LexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);
LexerNoViableAltException.prototype.constructor = LexerNoViableAltException;

LexerNoViableAltException.prototype.toString = function() {
    var symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getText((this.startIndex,this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
};

// Indicates that the parser could not decide which of two or more paths
// to take based upon the remaining input. It tracks the starting token
// of the offending input and also knows where the parser was
// in the various paths when the error. Reported by reportNoViableAlternative()
//
function NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
	ctx = ctx || recognizer._ctx;
	offendingToken = offendingToken || recognizer.getCurrentToken();
	startToken = startToken || recognizer.getCurrentToken();
	input = input || recognizer.getInputStream();
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:input, ctx:ctx});
    // Which configurations did we try at input.index() that couldn't match
	// input.LT(1)?//
    this.deadEndConfigs = deadEndConfigs;
    // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)
    this.startToken = startToken;
    this.offendingToken = offendingToken;
}

NoViableAltException.prototype = Object.create(RecognitionException.prototype);
NoViableAltException.prototype.constructor = NoViableAltException;

// This signifies any kind of mismatched input exceptions such as
// when the current input does not match the expected token.
//
function InputMismatchException(recognizer) {
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:recognizer.getInputStream(), ctx:recognizer._ctx});
    this.offendingToken = recognizer.getCurrentToken();
}

InputMismatchException.prototype = Object.create(RecognitionException.prototype);
InputMismatchException.prototype.constructor = InputMismatchException;

// A semantic predicate failed during validation. Validation of predicates
// occurs when normally parsing the alternative just like matching a token.
// Disambiguating predicate evaluation occurs when we test a predicate during
// prediction.

function FailedPredicateException(recognizer, predicate, message) {
	RecognitionException.call(this, {message:this.formatMessage(predicate,message || null), recognizer:recognizer,
                         input:recognizer.getInputStream(), ctx:recognizer._ctx});
    var s = recognizer._interp.atn.states[recognizer.state];
    var trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
    } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
    return this;
}

FailedPredicateException.prototype = Object.create(RecognitionException.prototype);
FailedPredicateException.prototype.constructor = FailedPredicateException;

FailedPredicateException.prototype.formatMessage = function(predicate, message) {
    if (message !==null) {
        return message;
    } else {
        return "failed predicate: {" + predicate + "}?";
    }
};

function ParseCancellationException() {
	Error.call(this);
	Error.captureStackTrace(this, ParseCancellationException);
	return this;
}

ParseCancellationException.prototype = Object.create(Error.prototype);
ParseCancellationException.prototype.constructor = ParseCancellationException;

exports.RecognitionException = RecognitionException;
exports.NoViableAltException = NoViableAltException;
exports.LexerNoViableAltException = LexerNoViableAltException;
exports.InputMismatchException = InputMismatchException;
exports.FailedPredicateException = FailedPredicateException;

},{"./../atn/Transition":43}],53:[function(require,module,exports){
exports.RecognitionException = require('./Errors').RecognitionException;
exports.NoViableAltException = require('./Errors').NoViableAltException;
exports.LexerNoViableAltException = require('./Errors').LexerNoViableAltException;
exports.InputMismatchException = require('./Errors').InputMismatchException;
exports.FailedPredicateException = require('./Errors').FailedPredicateException;
exports.DiagnosticErrorListener = require('./DiagnosticErrorListener').DiagnosticErrorListener;
exports.BailErrorStrategy = require('./ErrorStrategy').BailErrorStrategy;
exports.ErrorListener = require('./ErrorListener').ErrorListener;
},{"./DiagnosticErrorListener":49,"./ErrorListener":50,"./ErrorStrategy":51,"./Errors":52}],54:[function(require,module,exports){
exports.atn = require('./atn/index');
exports.dfa = require('./dfa/index');
exports.tree = require('./tree/index');
exports.error = require('./error/index');
exports.Token = require('./Token').Token;
exports.CommonToken = require('./Token').CommonToken;
exports.InputStream = require('./InputStream').InputStream;
exports.FileStream = require('./FileStream').FileStream;
exports.CommonTokenStream = require('./CommonTokenStream').CommonTokenStream;
exports.Lexer = require('./Lexer').Lexer;
exports.Parser = require('./Parser').Parser;
var pc = require('./PredictionContext');
exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = require('./ParserRuleContext').ParserRuleContext;
exports.Interval = require('./IntervalSet').Interval;
exports.Utils = require('./Utils');

},{"./CommonTokenStream":16,"./FileStream":17,"./InputStream":18,"./IntervalSet":19,"./Lexer":21,"./Parser":22,"./ParserRuleContext":23,"./PredictionContext":24,"./Token":27,"./Utils":28,"./atn/index":44,"./dfa/index":48,"./error/index":53,"./tree/index":57}],55:[function(require,module,exports){
// [The "BSD license"]
//  Copyright (c) 2012 Terence Parr
//  Copyright (c) 2012 Sam Harwell
//  Copyright (c) 2014 Eric Vergnaud
//  All rights reserved.
//
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions
//  are met:
//
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
//  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
//  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
//  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
///

// The basic notion of a tree has a parent, a payload, and a list of children.
//  It is the most abstract interface for all the trees used by ANTLR.
///

var Token = require('./../Token').Token;
var Interval = require('./../IntervalSet').Interval;
var INVALID_INTERVAL = new Interval(-1, -2);

function Tree() {
	return this;
}

function SyntaxTree() {
	Tree.call(this);
	return this;
}

SyntaxTree.prototype = Object.create(Tree.prototype);
SyntaxTree.prototype.constructor = SyntaxTree;

function ParseTree() {
	SyntaxTree.call(this);
	return this;
}

ParseTree.prototype = Object.create(SyntaxTree.prototype);
ParseTree.prototype.constructor = ParseTree;

function RuleNode() {
	ParseTree.call(this);
	return this;
}

RuleNode.prototype = Object.create(ParseTree.prototype);
RuleNode.prototype.constructor = RuleNode;

function TerminalNode() {
	ParseTree.call(this);
	return this;
}

TerminalNode.prototype = Object.create(ParseTree.prototype);
TerminalNode.prototype.constructor = TerminalNode;

function ErrorNode() {
	TerminalNode.call(this);
	return this;
}

ErrorNode.prototype = Object.create(TerminalNode.prototype);
ErrorNode.prototype.constructor = ErrorNode;

function ParseTreeVisitor() {
	return this;
}

function ParseTreeListener() {
	return this;
}

ParseTreeListener.prototype.visitTerminal = function(node) {
};

ParseTreeListener.prototype.visitErrorNode = function(node) {
};

ParseTreeListener.prototype.enterEveryRule = function(node) {
};

ParseTreeListener.prototype.exitEveryRule = function(node) {
};

function TerminalNodeImpl(symbol) {
	TerminalNode.call(this);
	this.parentCtx = null;
	this.symbol = symbol;
	return this;
}

TerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);
TerminalNodeImpl.prototype.constructor = TerminalNodeImpl;

TerminalNodeImpl.prototype.getChild = function(i) {
	return null;
};

TerminalNodeImpl.prototype.getSymbol = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getParent = function() {
	return this.parentCtx;
};

TerminalNodeImpl.prototype.getPayload = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getSourceInterval = function() {
	if (this.symbol === null) {
		return INVALID_INTERVAL;
	}
	var tokenIndex = this.symbol.tokenIndex;
	return new Interval(tokenIndex, tokenIndex);
};

TerminalNodeImpl.prototype.getChildCount = function() {
	return 0;
};

TerminalNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitTerminal(this);
};

TerminalNodeImpl.prototype.getText = function() {
	return this.symbol.text;
};

TerminalNodeImpl.prototype.toString = function() {
	if (this.symbol.type === Token.EOF) {
		return "<EOF>";
	} else {
		return this.symbol.text;
	}
};

// Represents a token that was consumed during resynchronization
// rather than during a valid match operation. For example,
// we will create this kind of a node during single token insertion
// and deletion as well as during "consume until error recovery set"
// upon no viable alternative exceptions.

function ErrorNodeImpl(token) {
	TerminalNodeImpl.call(this, token);
	return this;
}

ErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);
ErrorNodeImpl.prototype.constructor = ErrorNodeImpl;

ErrorNodeImpl.prototype.isErrorNode = function() {
	return true;
};

ErrorNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitErrorNode(this);
};

function ParseTreeWalker() {
	return this;
}

ParseTreeWalker.prototype.walk = function(listener, t) {
	var errorNode = t instanceof ErrorNode ||
			(t.isErrorNode !== undefined && t.isErrorNode());
	if (errorNode) {
		listener.visitErrorNode(t);
	} else if (t instanceof TerminalNode) {
		listener.visitTerminal(t);
	} else {
		this.enterRule(listener, t);
		for (var i = 0; i < t.getChildCount(); i++) {
			var child = t.getChild(i);
			this.walk(listener, child);
		}
		this.exitRule(listener, t);
	}
};
//
// The discovery of a rule node, involves sending two events: the generic
// {@link ParseTreeListener//enterEveryRule} and a
// {@link RuleContext}-specific event. First we trigger the generic and then
// the rule specific. We to them in reverse order upon finishing the node.
//
ParseTreeWalker.prototype.enterRule = function(listener, r) {
	var ctx = r.getRuleContext();
	listener.enterEveryRule(ctx);
	ctx.enterRule(listener);
};

ParseTreeWalker.prototype.exitRule = function(listener, r) {
	var ctx = r.getRuleContext();
	ctx.exitRule(listener);
	listener.exitEveryRule(ctx);
};

ParseTreeWalker.DEFAULT = new ParseTreeWalker();

exports.RuleNode = RuleNode;
exports.ErrorNode = ErrorNode;
exports.TerminalNode = TerminalNode;
exports.ErrorNodeImpl = ErrorNodeImpl;
exports.TerminalNodeImpl = TerminalNodeImpl;
exports.ParseTreeListener = ParseTreeListener;
exports.ParseTreeVisitor = ParseTreeVisitor;
exports.ParseTreeWalker = ParseTreeWalker;
exports.INVALID_INTERVAL = INVALID_INTERVAL;
},{"./../IntervalSet":19,"./../Token":27}],56:[function(require,module,exports){
/*
 * [The "BSD license"]
 *  Copyright (c) 2012 Terence Parr
 *  Copyright (c) 2012 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var Utils = require('./../Utils');
var Token = require('./../Token').Token;
var RuleNode = require('./Tree').RuleNode;
var ErrorNode = require('./Tree').ErrorNode;
var TerminalNode = require('./Tree').TerminalNode;
var ParserRuleContext = require('./../ParserRuleContext').ParserRuleContext;


/** A set of utility routines useful for all kinds of ANTLR trees. */
function Trees() {
}

// Print out a whole tree in LISP form. {@link //getNodeText} is used on the
//  node payloads to get the text for the nodes.  Detect
//  parse trees and extract data appropriately.
Trees.toStringTree = function(tree, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
       ruleNames = recog.ruleNames;
    }
    var s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    var c = tree.getChildCount();
    if(c===0) {
        return s;
    }
    var res = "(" + s + ' ';
    if(c>0) {
        s = Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
    }
    for(var i=1;i<c;i++) {
        s = Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(' ' + s);
    }
    res = res.concat(")");
    return res;
};

Trees.getNodeText = function(t, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
        ruleNames = recog.ruleNames;
    }
    if(ruleNames!==null) {
       if (t instanceof RuleNode) {
           return ruleNames[t.getRuleContext().ruleIndex];
       } else if ( t instanceof ErrorNode) {
           return t.toString();
       } else if(t instanceof TerminalNode) {
           if(t.symbol!==null) {
               return t.symbol.text;
           }
       }
    }
    // no recog for rule names
    var payload = t.getPayload();
    if (payload instanceof Token ) {
       return payload.text;
    }
    return t.getPayload().toString();
};


// Return ordered list of all children of this node
Trees.getChildren = function(t) {
	var list = [];
	for(var i=0;i<t.getChildCount();i++) {
		list.push(t.getChild(i));
	}
	return list;
};

// Return a list of all ancestors of this node.  The first node of
//  list is the root and the last is the parent of this node.
//
Trees.getAncestors = function(t) {
    var ancestors = [];
    t = t.getParent();
    while(t!==null) {
        ancestors = [t].concat(ancestors);
        t = t.getParent();
    }
    return ancestors;
};
   
Trees.findAllTokenNodes = function(t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
};

Trees.findAllRuleNodes = function(t, ruleIndex) {
	return Trees.findAllNodes(t, ruleIndex, false);
};

Trees.findAllNodes = function(t, index, findTokens) {
	var nodes = [];
	Trees._findAllNodes(t, index, findTokens, nodes);
	return nodes;
};

Trees._findAllNodes = function(t, index, findTokens, nodes) {
	// check this node (the root) first
	if(findTokens && (t instanceof TerminalNode)) {
		if(t.symbol.type===index) {
			nodes.push(t);
		}
	} else if(!findTokens && (t instanceof ParserRuleContext)) {
		if(t.ruleIndex===index) {
			nodes.push(t);
		}
	}
	// check children
	for(var i=0;i<t.getChildCount();i++) {
		Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
	}
};

Trees.descendants = function(t) {
	var nodes = [t];
    for(var i=0;i<t.getChildCount();i++) {
        nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
};


exports.Trees = Trees;
},{"./../ParserRuleContext":23,"./../Token":27,"./../Utils":28,"./Tree":55}],57:[function(require,module,exports){
var Tree = require('./Tree');
exports.Trees = require('./Tree').Trees;
exports.RuleNode = Tree.RuleNode;
exports.ParseTreeListener = Tree.ParseTreeListener;
exports.ParseTreeVisitor = Tree.ParseTreeVisitor;
exports.ParseTreeWalker = Tree.ParseTreeWalker;
},{"./Tree":55}],58:[function(require,module,exports){

},{}]},{},[13])(13)
});